[
    {
        "db_id": "department_management",
        "gold": "SELECT creation FROM department GROUP BY creation ORDER BY count(*) DESC LIMIT 1",
        "question": "In which year were most departments established?",
        "fields": "Table department, columns = [*,Department_ID,Name,Creation,Ranking,Budget_in_Billions,Num_Employees]\nTable head, columns = [*,head_ID,name,born_state,age]\nTable management, columns = [*,department_ID,head_ID,temporary_acting]\n",
        "foreign_keys": "Foreign_keys = [management.head_ID = head.head_ID,management.department_ID = department.Department_ID]\n",
        "reasoning": "<1> Operation: The query requires the year in which the most departments were established, so we should apply the 'count' operation to the 'Department_ID' column in the 'department' table and find the year with the highest count. Since the unit to which the departments being counted in the query belong is the year, we should apply the 'group by' operation to the 'Creation' column in the 'department' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['department'].\n\n<3> SQL Generation: The query requires the year in which the most departments were established, so we should select the 'Creation' column in the 'department' table.\n\nSQL query: SELECT Creation FROM department GROUP BY Creation ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Creation FROM department GROUP BY Creation ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "farm",
        "gold": "SELECT T1.Status FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID GROUP BY T2.Host_city_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the status of the city that has hosted the greatest number of competitions.",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n",
        "reasoning": "<1> Operation: The query requires the status of the city that has hosted the greatest number of competitions, so we should apply the 'count' operation to the 'Competition_ID' column in the 'farm_competition' table, and sort it in descending order. Since the unit to which the competitions being counted in the query belong is the city and only table 'city' has the column 'Status', so we should apply the 'group by' operation to the 'Host_city_ID' column in the 'farm_competition' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Due to the direct foreign key connection between table 'city' and 'farm_competition', we need to use tables ['city', 'farm_competition'].\n\n<3> SQL generation: The query requires the status of the city that has hosted the greatest number of competitions, so we should select the 'Status' column in the 'city' table. The query does not require the count of most competitions, so it is only used for filtering and not selected. \n\nSQL query: SELECT T1.Status FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID GROUP BY T2.Host_city_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Status FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID GROUP BY T2.Host_city_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "farm",
        "gold": "SELECT T1.Status FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID GROUP BY T2.Host_city_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the status of the city that has hosted the most competitions?",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n",
        "reasoning": "<1> Operation: The query requires the status of the city that has hosted the most competitions, so we should apply the 'count' operation to the 'Competition_ID' column in the 'farm_competition' table, and find the city with the highest count. Since the unit to which the competitions being counted in the query belong is the city, we should apply the 'group by' operation to the 'Host_city_ID' column in the 'farm_competition' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['city', 'farm_competition'].\n\n<3> SQL Generation: The query requires the status of the city that has hosted the most competitions, so we should select the 'Status' column in the 'city' table.\n\nSQL query: SELECT Status FROM city WHERE City_ID = (SELECT Host_city_ID FROM farm_competition GROUP BY Host_city_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Status FROM city WHERE City_ID = (SELECT Host_city_ID FROM farm_competition GROUP BY Host_city_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "farm",
        "gold": "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) ASC",
        "question": "Return the different statuses of cities, ascending by frequency.",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n",
        "reasoning": "<1> Operation: The query requires the different statuses of cities, so we should apply the 'count' operation to the 'Status' column in the 'city' table, and sort it in ascending order. Since the unit to which the statuses being counted in the query belong is the city, we should apply the 'group by' operation to the 'Status' column in the 'city' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['city'].\n\n<3> SQL Generation: The query requires the different statuses of cities, so we should select the 'Status' column in the 'city' table.\n\nSQL query: SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) ASC",
        "predict": "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) ASC",
        "hardness": "medium"
    },
    {
        "db_id": "farm",
        "gold": "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "List the most common type of Status across cities.",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common type of Status across cities, so we should apply the 'count' operation to the 'Status' column in the 'city' table and find the status with the highest count. Since the unit to which the statuses being counted in the query belong is the city, we should apply the 'group by' operation to the 'Status' column in the 'city' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'city'.\n\n<3> SQL Generation: The query requires the most common type of Status across cities, so we should select the 'Status' column in the 'city' table.\n\nSQL query: SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "farm",
        "gold": "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the most common status across all cities?",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common status across all cities, so we should apply the 'count' operation to the 'Status' column in the 'city' table and find the status with the highest count. Since the unit to which the statuses being counted in the query belong is the city, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'city'.\n\n<3> SQL Generation: The query requires the most common status across all cities, so we should select the 'Status' column in the 'city' table.\n\nSQL query: SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Status FROM city GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the course with the most registered students?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the course with the most registered students, so we should apply the 'count' operation to the 'course_id' column in the 'Student_Course_Registrations' table, and find the course with the highest count. Since the unit to which the registered students being counted in the query belong is the course, we should apply the 'group by' operation to the 'course_id' column in the 'Student_Course_Registrations' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student_Course_Registrations', 'Courses'].\n\n<3> SQL Generation: The query requires the name of the course with the most registered students, so we should select the 'course_name' column in the 'Courses' table and the 'course_id' column in the 'Student_Course_Registrations' table.\n\nSQL query: SELECT course_name FROM Courses WHERE course_id = (SELECT course_id FROM Student_Course_Registrations GROUP BY course_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT course_name FROM Courses WHERE course_id = (SELECT course_id FROM Student_Course_Registrations GROUP BY course_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is detail of the student who registered the most number of courses?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Operation: The query requires the detail of the student who registered the most number of courses, so we should apply the 'count' operation to the 'course_id' column in the 'Student_Course_Registrations' table, and find the student with the highest count. Since the unit to which the courses being counted in the query belong is the student, we should apply the 'group by' operation to the 'student_id' column in the 'Student_Course_Registrations' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Students' and 'Student_Course_Registrations', we need to use tables ['Students', 'Student_Course_Registrations'].\n\n<3> SQL Generation: The query requires the detail of the student who registered the most number of courses, so we should select the 'student_details' column in the 'Students' table.\n\nSQL query: SELECT student_details FROM Students WHERE student_id = (SELECT student_id FROM Student_Course_Registrations GROUP BY student_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT student_details FROM Students WHERE student_id = (SELECT student_id FROM Student_Course_Registrations GROUP BY student_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE \"8/%\" GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What are the start station's name and id for the one that had the most start trips in August?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Operation: The query requires the start station's name and id for the one that had the most start trips in August, so we should apply the 'count' operation to the 'start_station_id' column in the 'trip' table, and find the start station with the highest count. Since the unit to which the start stations being counted in the query belong is the start station, we should apply the 'group by' operation to the 'start_station_id' column in the 'trip' table. We also need to filter the trips that occurred in August in the 'trip' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['trip'].\n\n<3> SQL Generation: The query requires the start station's name and id for the one that had the most start trips in August, so we should select the 'start_station_name' column and the 'start_station_id' column in the 'trip' table. We also need to filter the trips that occurred in August.\n\nSQL query: SELECT start_station_name, start_station_id FROM trip WHERE start_date LIKE '2019-08%' GROUP BY start_station_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT start_station_name, start_station_id FROM trip WHERE start_date LIKE '2019-08%' GROUP BY start_station_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which bike traveled the most often in zip code 94002?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Operation: The query requires the bike that traveled the most often in zip code 94002, so we should apply the 'count' operation to the 'bike_id' column in the 'trip' table, and find the bike with the highest count. Since the unit to which the trips being counted in the query belong is the bike, we should apply the 'group by' operation to the 'bike_id' column in the 'trip' table. We also need to filter the trips with zip code 94002.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['trip'].\n\n<3> SQL Generation: The query requires the bike that traveled the most often in zip code 94002, so we should select the 'bike_id' column in the 'trip' table.\n\nSQL query: SELECT bike_id FROM trip WHERE zip_code = '94002' GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT bike_id FROM trip WHERE zip_code = '94002' GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3",
        "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Operation: The query requires the 3 most common cloud cover rates in the region of zip code 94107, so we should apply the 'count' operation to the 'cloud_cover' column in the 'weather' table, and find the top 3 cloud cover rates. Since the unit to which the cloud cover rates being counted in the query belong is the zip code, we should apply the 'group by' operation to the 'zip_code' column in the 'weather' table. We also need to filter the region of zip code 94107.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['weather'].\n\n<3> SQL Generation: The query requires the 3 most common cloud cover rates in the region of zip code 94107, so we should select the 'cloud_cover' column in the 'weather' table and filter the 'zip_code' column to be equal to 94107. We also need to group by the 'cloud_cover' column and order by the count in descending order, and limit the result to 3.\n\nSQL query: SELECT cloud_cover FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY COUNT(*) DESC LIMIT 3",
        "predict": "SELECT cloud_cover FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY COUNT(*) DESC LIMIT 3",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3",
        "question": "What are the 3 most common cloud covers in the zip code of 94107?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Operation: The query requires the 3 most common cloud covers in the zip code of 94107, so we should apply the 'count' operation to the 'cloud_cover' column in the 'weather' table, and find the top 3 cloud covers. Since the unit to which the cloud covers being counted in the query belong is the zip code, we should apply the 'group by' operation to the 'zip_code' column in the 'weather' table. We also need to filter the zip code to be 94107.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['weather'].\n\n<3> SQL Generation: The query requires the 3 most common cloud covers in the zip code of 94107, so we should select the 'cloud_cover' column in the 'weather' table.\n\nSQL query: SELECT cloud_cover FROM weather WHERE zip_code = '94107' GROUP BY cloud_cover ORDER BY COUNT(*) DESC LIMIT 3",
        "predict": "SELECT cloud_cover FROM weather WHERE zip_code = '94107' GROUP BY cloud_cover ORDER BY COUNT(*) DESC LIMIT 3",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT zip_code FROM weather GROUP BY zip_code ORDER BY avg(mean_sea_level_pressure_inches) LIMIT 1",
        "question": "What is the zip code in which the average mean sea level pressure is the lowest?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Operation: The query requires the zip code in which the average mean sea level pressure is the lowest, so we should apply the 'average' operation to the 'mean_sea_level_pressure_inches' column in the 'weather' table and find the zip code with the lowest average. Since the unit to which the average mean sea level pressure being calculated in the query belongs is the zip code, we should apply the 'group by' operation to the 'zip_code' column in the 'weather' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['weather'].\n\n<3> SQL Generation: The query requires the zip code in which the average mean sea level pressure is the lowest, so we should select the 'zip_code' column in the 'weather' table and calculate the average of the 'mean_sea_level_pressure_inches' column in the 'weather' table.\n\nSQL query: SELECT zip_code FROM weather GROUP BY zip_code ORDER BY AVG(mean_sea_level_pressure_inches) ASC LIMIT 1",
        "predict": "SELECT zip_code FROM weather GROUP BY zip_code ORDER BY AVG(mean_sea_level_pressure_inches) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT zip_code FROM weather GROUP BY zip_code ORDER BY avg(mean_sea_level_pressure_inches) LIMIT 1",
        "question": "What is the zip code that has the lowest average mean sea level pressure?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Operation: The query requires the zip code that has the lowest average mean sea level pressure, so we should apply the 'average' operation to the 'mean_sea_level_pressure_inches' column in the 'weather' table and find the zip code with the lowest average. Since the unit to which the average mean sea level pressure being calculated in the query belongs is the zip code, we should apply the 'group by' operation to the 'zip_code' column in the 'weather' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['weather'].\n\n<3> SQL Generation: The query requires the zip code that has the lowest average mean sea level pressure, so we should select the 'zip_code' column in the 'weather' table and the average of the 'mean_sea_level_pressure_inches' column in the 'weather' table.\n\nSQL query: SELECT zip_code FROM weather GROUP BY zip_code ORDER BY AVG(mean_sea_level_pressure_inches) ASC LIMIT 1",
        "predict": "SELECT zip_code FROM weather GROUP BY zip_code ORDER BY AVG(mean_sea_level_pressure_inches) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC",
        "question": "List all the cities in a decreasing order of each city's stations' highest latitude.",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Operation: The query requires the cities in a decreasing order of each city's stations' highest latitude, so we should apply the 'max' operation to the 'lat' column in the 'station' table, and sort it in descending order. Since the unit to which the highest latitude being calculated in the query belongs is the city and only table 'station' has the column 'city', we should apply the 'group by' operation to the 'city' column in the 'station' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['station'].\n\n<3> SQL Generation: The query requires the cities in a decreasing order of each city's stations' highest latitude, so we should select the 'city' column in the 'station' table and the maximum of the 'lat' column in the 'station' table.\n\nSQL query: SELECT city FROM station GROUP BY city ORDER BY MAX(lat) DESC",
        "predict": "SELECT city FROM station GROUP BY city ORDER BY MAX(lat) DESC",
        "hardness": "medium"
    },
    {
        "db_id": "book_2",
        "gold": "SELECT Publication_Date FROM publication GROUP BY Publication_Date ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Please show the most common publication date.",
        "fields": "Table book, columns = [*,Book_ID,Title,Issues,Writer]\nTable publication, columns = [*,Publication_ID,Book_ID,Publisher,Publication_Date,Price]\n",
        "foreign_keys": "Foreign_keys = [publication.Book_ID = book.Book_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common publication date, so we should apply the 'count' operation to the 'Publication_Date' column in the 'publication' table, and find the publication date with the highest count. Since the unit to which the publication dates being counted in the query belong is the publication, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'publication'.\n\n<3> SQL Generation: The query requires the most common publication date, so we should select the 'Publication_Date' column in the 'publication' table.\n\nSQL query: SELECT Publication_Date FROM publication GROUP BY Publication_Date ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Publication_Date FROM publication GROUP BY Publication_Date ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "musical",
        "gold": "SELECT Nominee FROM musical GROUP BY Nominee ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Please show the nominee who has been nominated the greatest number of times.",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Operation: The query requires the nominee who has been nominated the greatest number of times, so we should apply the 'count' operation to the 'Nominee' column in the 'musical' table and sort it in descending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'musical'.\n\n<3> SQL Generation: The query requires the nominee who has been nominated the greatest number of times, so we should select the 'Nominee' column in the 'musical' table.\n\nSQL query: SELECT Nominee FROM musical GROUP BY Nominee ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Nominee FROM musical GROUP BY Nominee ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "musical",
        "gold": "SELECT RESULT FROM musical GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "List the most common result of the musicals.",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common result of the musicals, so we should apply the 'count' operation to the 'Result' column in the 'musical' table and find the result with the highest count. Since the unit to which the results being counted in the query belong is the musical, we should apply the 'group by' operation to the 'Result' column in the 'musical' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['musical'].\n\n<3> SQL Generation: The query requires the most common result of the musicals, so we should select the 'Result' column in the 'musical' table.\n\nSQL query: SELECT Result FROM musical GROUP BY Result ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Result FROM musical GROUP BY Result ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "musical",
        "gold": "SELECT RESULT FROM musical GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Return the most frequent result across all musicals.",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Operation: The query requires the most frequent result across all musicals, so we should apply the 'count' operation to the 'Result' column in the 'musical' table and find the result with the highest count. Since the unit to which the results being counted in the query belong is the musical, we should apply the 'group by' operation to the 'Result' column in the 'musical' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['musical'].\n\n<3> SQL Generation: The query requires the most frequent result across all musicals, so we should select the 'Result' column in the 'musical' table.\n\nSQL query: SELECT Result FROM musical GROUP BY Result ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Result FROM musical GROUP BY Result ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "product_catalog",
        "gold": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1",
        "question": "Which catalog publisher has published the most catalogs?",
        "fields": "Table Attribute_Definitions, columns = [*,attribute_id,attribute_name,attribute_data_type]\nTable Catalog_Contents, columns = [*,catalog_entry_id,catalog_level_number,parent_entry_id,previous_entry_id,next_entry_id,catalog_entry_name,product_stock_number,price_in_dollars,price_in_euros,price_in_pounds,capacity,length,height,width]\nTable Catalog_Contents_Additional_Attributes, columns = [*,catalog_entry_id,catalog_level_number,attribute_id,attribute_value]\nTable Catalog_Structure, columns = [*,catalog_level_number,catalog_id,catalog_level_name]\nTable Catalogs, columns = [*,catalog_id,catalog_name,catalog_publisher,date_of_publication,date_of_latest_revision]\n",
        "foreign_keys": "Foreign_keys = [Catalog_Structure.catalog_id = Catalogs.catalog_id,Catalog_Contents.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_entry_id = Catalog_Contents.catalog_entry_id]\n",
        "reasoning": "<1> Operation: The query requires the catalog publisher that has published the most catalogs, so we should apply the 'count' operation to the 'catalog_id' column in the 'Catalogs' table, and find the catalog publisher with the highest count. Since the unit to which the catalogs being counted in the query belong is the catalog publisher, we should apply the 'group by' operation to the 'catalog_publisher' column in the 'Catalogs' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Catalogs'].\n\n<3> SQL Generation: The query requires the catalog publisher that has published the most catalogs, so we should select the 'catalog_publisher' column in the 'Catalogs' table.\n\nSQL query: SELECT catalog_publisher FROM Catalogs GROUP BY catalog_publisher ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT catalog_publisher FROM Catalogs GROUP BY catalog_publisher ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "product_catalog",
        "gold": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the catalog publisher that has the most catalogs.",
        "fields": "Table Attribute_Definitions, columns = [*,attribute_id,attribute_name,attribute_data_type]\nTable Catalog_Contents, columns = [*,catalog_entry_id,catalog_level_number,parent_entry_id,previous_entry_id,next_entry_id,catalog_entry_name,product_stock_number,price_in_dollars,price_in_euros,price_in_pounds,capacity,length,height,width]\nTable Catalog_Contents_Additional_Attributes, columns = [*,catalog_entry_id,catalog_level_number,attribute_id,attribute_value]\nTable Catalog_Structure, columns = [*,catalog_level_number,catalog_id,catalog_level_name]\nTable Catalogs, columns = [*,catalog_id,catalog_name,catalog_publisher,date_of_publication,date_of_latest_revision]\n",
        "foreign_keys": "Foreign_keys = [Catalog_Structure.catalog_id = Catalogs.catalog_id,Catalog_Contents.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_entry_id = Catalog_Contents.catalog_entry_id]\n",
        "reasoning": "<1> Operation: The query requires the catalog publisher that has the most catalogs, so we should apply the 'count' operation to the 'catalog_id' column in the 'Catalogs' table, and find the catalog publisher with the highest count. Since the unit to which the catalogs being counted in the query belong is the catalog publisher, we should apply the 'group by' operation to the 'catalog_publisher' column in the 'Catalogs' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Catalogs'].\n\n<3> SQL Generation: The query requires the catalog publisher that has the most catalogs, so we should select the 'catalog_publisher' column in the 'Catalogs' table.\n\nSQL query: SELECT catalog_publisher FROM Catalogs GROUP BY catalog_publisher ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT catalog_publisher FROM Catalogs GROUP BY catalog_publisher ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1",
        "question": "Which origin has most number of flights?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Operation: The query requires the origin with the most number of flights, so we should apply the 'count' operation to the 'flight' table for the 'origin' column, and find the origin with the highest count. Since the unit to which the flights being counted in the query belong is the origin, we should apply the 'group by' operation to the 'origin' column in the 'flight' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'flight'.\n\n<3> SQL Generation: The query requires the origin with the most number of flights, so we should select the 'origin' column in the 'flight' table.\n\nSQL query: SELECT origin FROM flight GROUP BY origin ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT origin FROM flight GROUP BY origin ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1",
        "question": "What place has the most flights coming from there?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Operation: The query requires the place that has the most flights coming from there, so we should apply the 'count' operation to the 'flight' table for the 'origin' column, and find the place with the highest count. Since the unit to which the flights being counted in the query belong is the place, we should apply the 'group by' operation to the 'origin' column in the 'flight' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'flight'.\n\n<3> SQL Generation: The query requires the place that has the most flights coming from there, so we should select the 'origin' column in the 'flight' table.\n\nSQL query: SELECT origin FROM flight GROUP BY origin ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT origin FROM flight GROUP BY origin ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT destination FROM Flight GROUP BY destination ORDER BY count(*) LIMIT 1",
        "question": "Which destination has least number of flights?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Operation: The query requires the destination with the least number of flights, so we should apply the 'count' operation to the 'destination' column in the 'flight' table, and sort it in ascending order. Since the unit to which the flights being counted in the query belong is the destination, we should apply the 'group by' operation to the 'destination' column in the 'flight' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'flight'.\n\n<3> SQL Generation: The query requires the destination with the least number of flights, so we should select the 'destination' column in the 'flight' table.\n\nSQL query: SELECT destination FROM flight GROUP BY destination ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT destination FROM flight GROUP BY destination ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT T1.name ,  T1.salary FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1",
        "question": "what is the salary and name of the employee who has the most number of aircraft certificates?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Operation: The query requires the salary and name of the employee who has the most number of aircraft certificates, so we should apply the 'count' operation to the 'certificate' table for the 'eid' column, and find the employee with the highest count. Since the unit to which the certificates being counted in the query belong is the employee, we should apply the 'group by' operation to the 'eid' column in the 'certificate' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'employee' and 'certificate', we need to use tables ['employee', 'certificate'].\n\n<3> SQL Generation: The query requires the salary and name of the employee who has the most number of aircraft certificates, so we should select the 'name' and 'salary' columns in the 'employee' table and the 'eid' column in the 'certificate' table.\n\nSQL query: SELECT T1.name, T1.salary FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid GROUP BY T1.eid ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.name, T1.salary FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid GROUP BY T1.eid ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT T1.name ,  T1.salary FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the salaray and name of the employee that is certified to fly the most planes?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Operation: The query requires the salary and name of the employee that is certified to fly the most planes, so we should apply the 'count' operation to the 'certificate' table for the 'eid' column, and find the employee with the highest count. Since the unit to which the certificates being counted in the query belong is the employee, we should apply the 'group by' operation to the 'eid' column in the 'certificate' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'employee' and 'certificate', we need to use tables ['employee', 'certificate'].\n\n<3> SQL Generation: The query requires the salary and name of the employee that is certified to fly the most planes, so we should select the 'name' and 'salary' columns in the 'employee' table and the 'eid' column in the 'certificate' table.\n\nSQL query: SELECT T1.name, T1.salary FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid GROUP BY T1.eid ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.name, T1.salary FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid GROUP BY T1.eid ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1",
        "question": "Which allergy type is most common?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the most common allergy type, so we should apply the 'count' operation to the 'AllergyType' column in the 'Allergy_Type' table and find the allergy type with the highest count. Since the unit to which the allergy types being counted in the query belong is the allergy type, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Allergy_Type'].\n\n<3> SQL Generation: The query requires the most common allergy type, so we should select the 'AllergyType' column in the 'Allergy_Type' table.\n\nSQL query: SELECT AllergyType FROM Allergy_Type GROUP BY AllergyType ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT AllergyType FROM Allergy_Type GROUP BY AllergyType ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1",
        "question": "Which allergy type is the least common?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the least common allergy type, so we should apply the 'count' operation to the 'AllergyType' column in the 'Allergy_Type' table and find the allergy type with the lowest count. Since the unit to which the allergy types being counted in the query belong is the allergy type, we should apply the 'group by' operation to the 'AllergyType' column in the 'Allergy_Type' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Allergy_Type'].\n\n<3> SQL Generation: The query requires the least common allergy type, so we should select the 'AllergyType' column in the 'Allergy_Type' table.\n\nSQL query: SELECT AllergyType FROM Allergy_Type GROUP BY AllergyType ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT AllergyType FROM Allergy_Type GROUP BY AllergyType ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1",
        "question": "Which major has most number of students?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the major with the most number of students, so we should apply the 'count' operation to the 'StuID' column in the 'Student' table and find the major with the highest count. Since the unit to which the students being counted in the query belong is the major, we should apply the 'group by' operation to the 'Major' column in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the major with the most number of students, so we should select the 'Major' column in the 'Student' table.\n\nSQL query: SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the largest major?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the largest major, so we should apply the 'count' operation to the 'Major' column in the 'Student' table and find the major with the highest count. Since the unit to which the majors being counted in the query belong is the major itself, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Student'.\n\n<3> SQL Generation: The query requires the largest major, so we should select the 'Major' column in the 'Student' table.\n\nSQL query: SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1",
        "question": "Which advisor has most number of students?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the advisor with the most number of students, so we should apply the 'count' operation to the 'StuID' column in the 'Student' table and find the advisor with the highest count. Since the unit to which the students being counted in the query belong is the advisor, we should apply the 'group by' operation to the 'Advisor' column in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Student'.\n\n<3> SQL Generation: The query requires the advisor with the most number of students, so we should select the 'Advisor' column in the 'Student' table.\n\nSQL query: SELECT Advisor FROM Student GROUP BY Advisor ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Advisor FROM Student GROUP BY Advisor ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1",
        "question": "Give the advisor with the most students.",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the advisor with the most students, so we should apply the 'count' operation to the 'StuID' column in the 'Student' table, and find the advisor with the highest count. Since the unit to which the students being counted in the query belong is the advisor, we should apply the 'group by' operation to the 'Advisor' column in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the advisor with the most students, so we should select the 'Advisor' column in the 'Student' table.\n\nSQL query: SELECT Advisor FROM Student GROUP BY Advisor ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Advisor FROM Student GROUP BY Advisor ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1",
        "question": "Which allergy has most number of students affected?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the allergy that has the most number of students affected, so we should apply the 'count' operation to the 'StuID' column in the 'Has_Allergy' table, and find the allergy with the highest count. Since the unit to which the students being counted in the query belong is the allergy, we should apply the 'group by' operation to the 'Allergy' column in the 'Has_Allergy' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Has_Allergy' and 'Allergy_Type', we need to use tables ['Has_Allergy', 'Allergy_Type'].\n\n<3> SQL Generation: The query requires the allergy that has the most number of students affected, so we should select the 'Allergy' column in the 'Has_Allergy' table.\n\nSQL query: SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1",
        "question": "Which allergy is the most common?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the most common allergy, so we should apply the 'count' operation to the 'Allergy' column in the 'Has_Allergy' table and find the allergy with the highest count. Since the unit to which the allergies being counted in the query belong is the allergy, we should apply the 'group by' operation to the 'Allergy' column in the 'Has_Allergy' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Has_Allergy'].\n\n<3> SQL Generation: The query requires the most common allergy, so we should select the 'Allergy' column in the 'Has_Allergy' table.\n\nSQL query: SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT billing_country ,  COUNT(*) FROM invoices GROUP BY billing_country ORDER BY count(*) DESC LIMIT 5;",
        "question": "A list of the top 5 countries by number of invoices. List country name and number of invoices.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the top 5 countries by number of invoices, so we should apply the 'count' operation to the 'invoices' table for the 'customer_id' column, and sort it in descending order. Since the unit to which the invoices being counted in the query belong is the country and only table 'customers' has the column 'country', so we should apply the 'group by' operation to the 'country' column in the 'customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'invoices' and 'customers', we need to use tables ['invoices', 'customers'].\n\n<3> SQL Generation: The query requires the top 5 countries by number of invoices, so we should select the 'country' column in the 'customers' table and count the 'customer_id' column in the 'invoices' table.\n\nSQL query: SELECT T1.country, COUNT(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.country ORDER BY COUNT(*) DESC LIMIT 5",
        "predict": "SELECT T1.country, COUNT(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.country ORDER BY COUNT(*) DESC LIMIT 5",
        "hardness": "hard"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT billing_country ,  COUNT(*) FROM invoices GROUP BY billing_country ORDER BY count(*) DESC LIMIT 5;",
        "question": "What are the top 5 countries by number of invoices and how many do they have?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the top 5 countries by the number of invoices, so we should apply the 'count' operation to the 'invoices' table for the 'customer_id' column, and sort it in descending order. Since the unit to which the invoices being counted in the query belong is the country and only table 'customers' has the column 'country', so we should apply the 'group by' operation to the 'country' column in the 'customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'invoices' and 'customers', we need to use tables ['invoices', 'customers'].\n\n<3> SQL Generation: The query requires the top 5 countries by the number of invoices, so we should select the 'country' column in the 'customers' table and count the 'customer_id' column in the 'invoices' table.\n\nSQL query: SELECT T1.country, COUNT(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.country ORDER BY COUNT(*) DESC LIMIT 5",
        "predict": "SELECT T1.country, COUNT(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.country ORDER BY COUNT(*) DESC LIMIT 5",
        "hardness": "hard"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT billing_country ,  SUM(total) FROM invoices GROUP BY billing_country ORDER BY SUM(total) DESC LIMIT 8;",
        "question": "A list of the top 8 countries by gross/total invoice size. List country name and gross invoice size.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the top 8 countries by gross/total invoice size, so we should apply the 'sum' operation to the 'total' column in the 'invoices' table and sort it in descending order. Since the unit to which the total invoice size being calculated in the query belongs is the country and only table 'customers' has the column 'country', we should apply the 'group by' operation to the 'country' column in the 'customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'invoices' and 'customers', we need to use tables ['invoices', 'customers'].\n\n<3> SQL Generation: The query requires the top 8 countries by gross/total invoice size, so we should select the 'country' column in the 'customers' table and the sum of the 'total' column in the 'invoices' table.\n\nSQL query: SELECT T1.country, SUM(T2.total) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.country ORDER BY SUM(T2.total) DESC LIMIT 8",
        "predict": "SELECT T1.country, SUM(T2.total) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.country ORDER BY SUM(T2.total) DESC LIMIT 8",
        "hardness": "hard"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT billing_country ,  SUM(total) FROM invoices GROUP BY billing_country ORDER BY SUM(total) DESC LIMIT 8;",
        "question": "What are the names of the top 8 countries by total invoice size and what are those sizes?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the names of the top 8 countries by total invoice size and their corresponding sizes, so we should apply the 'sum' operation to the 'total' column in the 'invoices' table and sort it in descending order. Since the unit to which the total invoice size being calculated in the query belongs is the country and only table 'customers' has the column 'country', we should apply the 'group by' operation to the 'country' column in the 'customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'invoices' and 'customers', we need to use tables ['invoices', 'customers'].\n\n<3> SQL Generation: The query requires the names of the top 8 countries by total invoice size and their corresponding sizes, so we should select the 'country' column in the 'customers' table and the sum of the 'total' column in the 'invoices' table.\n\nSQL query: SELECT T1.country, SUM(T2.total) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.country ORDER BY SUM(T2.total) DESC LIMIT 8",
        "predict": "SELECT T1.country, SUM(T2.total) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.country ORDER BY SUM(T2.total) DESC LIMIT 8",
        "hardness": "hard"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.first_name ,  T1.last_name ,  COUNT(*) FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id GROUP BY T1.id ORDER BY COUNT(*) DESC LIMIT 10;",
        "question": "Find out the top 10 customers by total number of orders. List customers' first and last name and the number of total orders.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the top 10 customers by the total number of orders, so we should apply the 'count' operation to the 'customer_id' column in the 'invoices' table and sort it in descending order. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'invoices' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'invoices' and 'customers', we need to use tables ['invoices', 'customers'].\n\n<3> SQL Generation: The query requires the top 10 customers by the total number of orders, so we should select the 'first_name' and 'last_name' columns in the 'customers' table and count the 'customer_id' column in the 'invoices' table.\n\nSQL query: SELECT T1.first_name, T1.last_name, COUNT(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T2.customer_id ORDER BY COUNT(*) DESC LIMIT 10",
        "predict": "SELECT T1.first_name, T1.last_name, COUNT(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T2.customer_id ORDER BY COUNT(*) DESC LIMIT 10",
        "hardness": "extra"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.first_name ,  T1.last_name ,  COUNT(*) FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id GROUP BY T1.id ORDER BY COUNT(*) DESC LIMIT 10;",
        "question": "What are the top 10 customers' first and last names by total number of orders and how many orders did they make?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the top 10 customers' first and last names by the total number of orders, so we should apply the 'count' operation to the 'customer_id' column in the 'invoices' table and sort it in descending order. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'invoices' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'invoices' and 'customers', we need to use tables ['invoices', 'customers'].\n\n<3> SQL Generation: The query requires the top 10 customers' first and last names by the total number of orders, so we should select the 'first_name' and 'last_name' columns in the 'customers' table and the count of the 'customer_id' column in the 'invoices' table.\n\nSQL query: SELECT T1.first_name, T1.last_name, COUNT(*) AS order_count FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.id ORDER BY order_count DESC LIMIT 10",
        "predict": "SELECT T1.first_name, T1.last_name, COUNT(*) AS order_count FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.id ORDER BY order_count DESC LIMIT 10",
        "hardness": "extra"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.first_name ,  T1.last_name ,  SUM(T2.total) FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id GROUP BY T1.id ORDER BY SUM(T2.total) DESC LIMIT 10;",
        "question": "List the top 10 customers by total gross sales. List customers' first and last name and total gross sales.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the top 10 customers by total gross sales, so we should apply the 'sum' operation to the 'total' column in the 'invoices' table and sort it in descending order. Since the unit to which the total gross sales being calculated in the query belongs is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'invoices' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'invoices' and 'customers', we need to use tables ['invoices', 'customers'].\n\n<3> SQL Generation: The query requires the top 10 customers by total gross sales, so we should select the 'first_name' and 'last_name' columns in the 'customers' table and the sum of the 'total' column in the 'invoices' table.\n\nSQL query: SELECT T1.first_name, T1.last_name, SUM(T2.total) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.id ORDER BY SUM(T2.total) DESC LIMIT 10",
        "predict": "SELECT T1.first_name, T1.last_name, SUM(T2.total) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.id ORDER BY SUM(T2.total) DESC LIMIT 10",
        "hardness": "extra"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.first_name ,  T1.last_name ,  SUM(T2.total) FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id GROUP BY T1.id ORDER BY SUM(T2.total) DESC LIMIT 10;",
        "question": "What are the top 10 customers' first and last names with the highest gross sales, and also what are the sales?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the top 10 customers' first and last names with the highest gross sales, so we should apply the 'sum' operation to the 'total' column in the 'invoices' table and sort it in descending order. Since the unit to which the gross sales being calculated in the query belongs is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'invoices' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'invoices' and 'customers', we need to use tables ['invoices', 'customers'].\n\n<3> SQL Generation: The query requires the top 10 customers' first and last names with the highest gross sales, so we should select the 'first_name' and 'last_name' columns in the 'customers' table and the sum of the 'total' column in the 'invoices' table.\n\nSQL query: SELECT T1.first_name, T1.last_name, SUM(T2.total) AS sales FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.id ORDER BY sales DESC LIMIT 10",
        "predict": "SELECT T1.first_name, T1.last_name, SUM(T2.total) AS sales FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id GROUP BY T1.id ORDER BY sales DESC LIMIT 10",
        "hardness": "extra"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.name ,  COUNT(*) FROM genres AS T1 JOIN tracks AS T2 ON T2.genre_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 5;",
        "question": "List the top 5 genres by number of tracks. List genres name and total tracks.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the top 5 genres by number of tracks, so we should apply the 'count' operation to the 'tracks' table for the 'genre_id' column, and sort it in descending order. Since the unit to which the tracks being counted in the query belong is the genre, we should apply the 'group by' operation to the 'genre_id' column in the 'tracks' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['tracks', 'genres'].\n\n<3> SQL Generation: The query requires the top 5 genres by number of tracks, so we should select the 'name' column in the 'genres' table and the count of the 'genre_id' column in the 'tracks' table.\n\nSQL query: SELECT T2.name, COUNT(*) FROM tracks AS T1 JOIN genres AS T2 ON T1.genre_id = T2.id GROUP BY T1.genre_id ORDER BY COUNT(*) DESC LIMIT 5",
        "predict": "SELECT T2.name, COUNT(*) FROM tracks AS T1 JOIN genres AS T2 ON T1.genre_id = T2.id GROUP BY T1.genre_id ORDER BY COUNT(*) DESC LIMIT 5",
        "hardness": "extra"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.name ,  COUNT(*) FROM genres AS T1 JOIN tracks AS T2 ON T2.genre_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 5;",
        "question": "How many tracks does each genre have and what are the names of the top 5?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the number of tracks for each genre, so we should apply the 'count' operation to the 'tracks' table for the 'genre_id' column, and it does not need sorting. Since the unit to which the tracks being counted in the query belong is the genre, only the 'genres' table has the 'genre_id' column, so we should apply the 'group by' operation to the 'genre_id' column in the 'tracks' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['tracks', 'genres'].\n\n<3> SQL Generation: The query requires the number of tracks for each genre, so we should select the 'name' column in the 'genres' table and count the 'genre_id' column in the 'tracks' table.\n\nSQL query: SELECT T1.name, COUNT(*) FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id GROUP BY T1.name\n\nTo find the names of the top 5 genres, we can modify the SQL query to include sorting and limit the results to 5.\n\nSQL query: SELECT T1.name, COUNT(*) FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id GROUP BY T1.name ORDER BY COUNT(*) DESC LIMIT 5",
        "predict": "SELECT T1.name, COUNT(*) FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id GROUP BY T1.name ORDER BY COUNT(*) DESC LIMIT 5",
        "hardness": "extra"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the full name of employee who supported the most number of customers.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the full name of the employee who supported the most number of customers, so we should apply the 'count' operation to the 'customers' table for the 'support_rep_id' column, and find the employee with the highest count. Since the unit to which the customers being counted in the query belong is the employee, we should apply the 'group by' operation to the 'support_rep_id' column in the 'customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'customers' and 'employees', we need to use tables ['customers', 'employees'].\n\n<3> SQL Generation: The query requires the full name of the employee who supported the most number of customers, so we should select the 'first_name' and 'last_name' columns in the 'employees' table.\n\nSQL query: SELECT first_name, last_name FROM employees WHERE id = (SELECT support_rep_id FROM customers GROUP BY support_rep_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT first_name, last_name FROM employees WHERE id = (SELECT support_rep_id FROM customers GROUP BY support_rep_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the full name of the employee who has the most customers?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Operation: The query requires the full name of the employee who has the most customers, so we should apply the 'count' operation to the 'customers' table for the 'support_rep_id' column, and find the employee with the highest count. Since the unit to which the customers being counted in the query belong is the employee, we should apply the 'group by' operation to the 'support_rep_id' column in the 'customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'customers' and 'employees', we need to use tables ['customers', 'employees'].\n\n<3> SQL Generation: The query requires the full name of the employee who has the most customers, so we should select the 'first_name' and 'last_name' columns in the 'employees' table.\n\nSQL query: SELECT first_name, last_name FROM employees WHERE id = (SELECT support_rep_id FROM customers GROUP BY support_rep_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT first_name, last_name FROM employees WHERE id = (SELECT support_rep_id FROM customers GROUP BY support_rep_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "journal_committee",
        "gold": "SELECT Age FROM editor GROUP BY Age ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Please show the most common age of editors.",
        "fields": "Table editor, columns = [*,Editor_ID,Name,Age]\nTable journal, columns = [*,Journal_ID,Date,Theme,Sales]\nTable journal_committee, columns = [*,Editor_ID,Journal_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [journal_committee.Journal_ID = journal.Journal_ID,journal_committee.Editor_ID = editor.Editor_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common age of editors, so we should apply the 'count' operation to the 'Age' column in the 'editor' table and find the age with the highest count. Since the unit to which the ages being counted in the query belong is the editor, we should apply the 'group by' operation to the 'Age' column in the 'editor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['editor'].\n\n<3> SQL Generation: The query requires the most common age of editors, so we should select the 'Age' column in the 'editor' table.\n\nSQL query: SELECT Age FROM editor GROUP BY Age ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Age FROM editor GROUP BY Age ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the customer id and number of accounts with most accounts.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Operation: The query requires the customer id and number of accounts with the most accounts, so we should apply the 'count' operation to the 'account_id' column in the 'Accounts' table, and find the customer with the highest count. Since the unit to which the accounts being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Accounts' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Accounts'].\n\n<3> SQL Generation: The query requires the customer id and number of accounts with the most accounts, so we should select the 'customer_id' column in the 'Accounts' table and the count of the 'account_id' column in the 'Accounts' table.\n\nSQL query: SELECT customer_id, COUNT(account_id) FROM Accounts GROUP BY customer_id ORDER BY COUNT(account_id) DESC LIMIT 1",
        "predict": "SELECT customer_id, COUNT(account_id) FROM Accounts GROUP BY customer_id ORDER BY COUNT(account_id) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the customer id of the customer with the most accounts, and how many accounts does this person have?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Operation: The query requires the customer id of the customer with the most accounts and the number of accounts they have, so we should apply the 'count' operation to the 'account_id' column in the 'Accounts' table and find the customer with the highest count. Since the unit to which the accounts being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Accounts' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Accounts'].\n\n<3> SQL Generation: The query requires the customer id of the customer with the most accounts and the number of accounts they have, so we should select the 'customer_id' column in the 'Accounts' table and count the 'account_id' column in the 'Accounts' table.\n\nSQL query: SELECT customer_id, COUNT(*) FROM Accounts GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT customer_id, COUNT(*) FROM Accounts GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1",
        "question": "What is the customer first, last name and id with least number of accounts.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Operation: The query requires the customer with the least number of accounts, so we should apply the 'count' operation to the 'Accounts' table for the 'customer_id' column, and find the customer with the lowest count. Since the unit to which the accounts being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Accounts' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers'].\n\n<3> SQL Generation: The query requires the customer first name, last name, and id with the least number of accounts, so we should select the 'customer_first_name', 'customer_last_name', and 'customer_id' columns in the 'Customers' table.\n\nSQL query: SELECT customer_first_name, customer_last_name, customer_id FROM Customers WHERE customer_id = (SELECT customer_id FROM Accounts GROUP BY customer_id ORDER BY COUNT(*) ASC LIMIT 1)",
        "predict": "SELECT customer_first_name, customer_last_name, customer_id FROM Customers WHERE customer_id = (SELECT customer_id FROM Accounts GROUP BY customer_id ORDER BY COUNT(*) ASC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1",
        "question": "Give the full name and customer id of the customer with the fewest accounts.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Operation: The query requires the full name and customer id of the customer with the fewest accounts, so we should apply the 'count' operation to the 'Accounts' table for the 'customer_id' column, and find the customer with the lowest count. Since the unit to which the accounts being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Accounts' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers'].\n\n<3> SQL Generation: The query requires the full name and customer id of the customer with the fewest accounts, so we should select the 'customer_first_name', 'customer_last_name', and 'customer_id' columns in the 'Customers' table.\n\nSQL query: SELECT customer_first_name, customer_last_name, customer_id FROM Customers WHERE customer_id = (SELECT customer_id FROM Accounts GROUP BY customer_id ORDER BY COUNT(*) ASC LIMIT 1)",
        "predict": "SELECT customer_first_name, customer_last_name, customer_id FROM Customers WHERE customer_id = (SELECT customer_id FROM Accounts GROUP BY customer_id ORDER BY COUNT(*) ASC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_id ,  count(*) FROM Customers_cards GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the customer id with most number of cards, and how many does he have?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Operation: The query requires the customer id with the most number of cards, so we should apply the 'count' operation to the 'card_id' column in the 'Customers_Cards' table, and find the customer with the highest count. Since the unit to which the cards being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Customers_Cards' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers_Cards'].\n\n<3> SQL Generation: The query requires the customer id with the most number of cards, so we should select the 'customer_id' column in the 'Customers_Cards' table and count the 'card_id' column in the 'Customers_Cards' table.\n\nSQL query: SELECT customer_id, COUNT(*) FROM Customers_Cards GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT customer_id, COUNT(*) FROM Customers_Cards GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_id ,  count(*) FROM Customers_cards GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the id of the customer who has the most cards, as well as the number of cards.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Operation: The query requires the id of the customer who has the most cards, so we should apply the 'count' operation to the 'card_id' column in the 'Customers_Cards' table, and find the customer with the highest count. Since the unit to which the cards being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Customers_Cards' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers_Cards'].\n\n<3> SQL Generation: The query requires the id of the customer who has the most cards, so we should select the 'customer_id' column in the 'Customers_Cards' table and the count of the 'card_id' column in the 'Customers_Cards' table.\n\nSQL query: SELECT customer_id, COUNT(card_id) FROM Customers_Cards GROUP BY customer_id ORDER BY COUNT(card_id) DESC LIMIT 1",
        "predict": "SELECT customer_id, COUNT(card_id) FROM Customers_Cards GROUP BY customer_id ORDER BY COUNT(card_id) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the card type code with most number of cards?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Operation: The query requires the card type code with the most number of cards, so we should apply the 'count' operation to the 'card_type_code' column in the 'Customers_Cards' table, and find the card type code with the highest count. Since the unit to which the card type codes being counted in the query belong is the card, we should apply the 'group by' operation to the 'card_type_code' column in the 'Customers_Cards' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers_Cards'].\n\n<3> SQL Generation: The query requires the card type code with the most number of cards, so we should select the 'card_type_code' column in the 'Customers_Cards' table.\n\nSQL query: SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the code of the card type that is most common.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Operation: The query requires the code of the card type that is most common, so we should apply the 'count' operation to the 'card_type_code' column in the 'Customers_Cards' table, and find the card type with the highest count. Since the unit to which the card types being counted in the query belong is the card, we should apply the 'group by' operation to the 'card_type_code' column in the 'Customers_Cards' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers_Cards'].\n\n<3> SQL Generation: The query requires the code of the card type that is most common, so we should select the 'card_type_code' column in the 'Customers_Cards' table.\n\nSQL query: SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1",
        "question": "What is the transaction type that has processed the greatest total amount in transactions?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Operation: The query requires the transaction type that has processed the greatest total amount in transactions, so we should apply the 'sum' operation to the 'transaction_amount' column in the 'Financial_Transactions' table and find the transaction type with the highest sum. Since the unit to which the transaction amounts being summed in the query belong is the transaction type, we should apply the 'group by' operation to the 'transaction_type' column in the 'Financial_Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Financial_Transactions'].\n\n<3> SQL Generation: The query requires the transaction type that has processed the greatest total amount in transactions, so we should select the 'transaction_type' column in the 'Financial_Transactions' table and the sum of the 'transaction_amount' column in the 'Financial_Transactions' table.\n\nSQL query: SELECT transaction_type FROM Financial_Transactions GROUP BY transaction_type ORDER BY SUM(transaction_amount) DESC LIMIT 1",
        "predict": "SELECT transaction_type FROM Financial_Transactions GROUP BY transaction_type ORDER BY SUM(transaction_amount) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1",
        "question": "Return the type of transaction with the highest total amount.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Operation: The query requires the type of transaction with the highest total amount, so we should apply the 'sum' operation to the 'transaction_amount' column in the 'Financial_Transactions' table and find the transaction type with the highest sum. Since the unit to which the transaction amounts being summed in the query belong is the transaction type, we should apply the 'group by' operation to the 'transaction_type' column in the 'Financial_Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Financial_Transactions'].\n\n<3> SQL Generation: The query requires the type of transaction with the highest total amount, so we should select the 'transaction_type' column in the 'Financial_Transactions' table and the sum of the 'transaction_amount' column in the 'Financial_Transactions' table.\n\nSQL query: SELECT transaction_type FROM Financial_Transactions GROUP BY transaction_type ORDER BY SUM(transaction_amount) DESC LIMIT 1",
        "predict": "SELECT transaction_type FROM Financial_Transactions GROUP BY transaction_type ORDER BY SUM(transaction_amount) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT CLASS FROM race GROUP BY CLASS ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the race class with most number of races.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Operation: The query requires the race class with the most number of races, so we should apply the 'count' operation to the 'Race_ID' column in the 'race' table, and find the race class with the highest count. Since the unit to which the races being counted in the query belong is the race class, we should apply the 'group by' operation to the 'Class' column in the 'race' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['race'].\n\n<3> SQL Generation: The query requires the race class with the most number of races, so we should select the 'Class' column in the 'race' table.\n\nSQL query: SELECT Class FROM race GROUP BY Class ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Class FROM race GROUP BY Class ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT CLASS FROM race GROUP BY CLASS ORDER BY count(*) DESC LIMIT 1",
        "question": "Give the class of races that is most common.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Operation: The query requires the class of races that is most common, so we should apply the 'count' operation to the 'Class' column in the 'race' table and find the class with the highest count. Since the unit to which the classes being counted in the query belong is the race, we should apply the 'group by' operation to the 'Class' column in the 'race' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['race'].\n\n<3> SQL Generation: The query requires the class of races that is most common, so we should select the 'Class' column in the 'race' table.\n\nSQL query: SELECT Class FROM race GROUP BY Class ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Class FROM race GROUP BY Class ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT T2.name FROM race AS T1 JOIN track AS T2 ON T1.track_id  =  T2.track_id GROUP BY T1.track_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the name of track with most number of races.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the track with the most number of races, so we should apply the 'count' operation to the 'Race_ID' column in the 'race' table and find the track with the highest count. Since the unit to which the races being counted in the query belong is the track, we should apply the 'group by' operation to the 'Track_ID' column in the 'race' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['race', 'track'].\n\n<3> SQL Generation: The query requires the name of the track with the most number of races, so we should select the 'Name' column in the 'track' table.\n\nSQL query: SELECT T2.Name FROM race AS T1 JOIN track AS T2 ON T1.Track_ID = T2.Track_ID GROUP BY T1.Track_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.Name FROM race AS T1 JOIN track AS T2 ON T1.Track_ID = T2.Track_ID GROUP BY T1.Track_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT T2.name FROM race AS T1 JOIN track AS T2 ON T1.track_id  =  T2.track_id GROUP BY T1.track_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the track that has had the greatest number of races?",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the track that has had the greatest number of races, so we should apply the 'count' operation to the 'Race_ID' column in the 'race' table and sort it in descending order. Since the unit to which the races being counted in the query belong is the track and only table 'track' has the column 'Track_ID', so we should apply the 'group by' operation to the 'Track_ID' column in table 'race'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'race' and 'track', we need to use tables ['race', 'track'].\n\n<3> SQL Generation: The query requires the name of the track that has had the greatest number of races, so we should select the 'Name' column in the 'track' table. The query does not require the count of most races, so it is only used for filtering and not selected.\n\nSQL query: SELECT T2.Name FROM race AS T1 JOIN track AS T2 ON T1.Track_ID = T2.Track_ID GROUP BY T1.Track_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.Name FROM race AS T1 JOIN track AS T2 ON T1.Track_ID = T2.Track_ID GROUP BY T1.Track_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "coffee_shop",
        "gold": "SELECT shop_id ,  count(*) FROM happy_hour GROUP BY shop_id ORDER BY count(*) DESC LIMIT 1",
        "question": "which shop has happy hour most frequently? List its id and number of happy hours.",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Operation: The query requires the shop that has the most frequent happy hour, so we should apply the 'count' operation to the 'HH_ID' column in the 'happy_hour' table and find the shop with the highest count. Since the unit to which the happy hours being counted in the query belong is the shop, we should apply the 'group by' operation to the 'Shop_ID' column in the 'happy_hour' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['happy_hour', 'shop'].\n\n<3> SQL Generation: The query requires the shop that has the most frequent happy hour, so we should select the 'Shop_ID' column in the 'happy_hour' table and the count of the 'HH_ID' column in the 'happy_hour' table.\n\nSQL query: SELECT Shop_ID, COUNT(HH_ID) FROM happy_hour GROUP BY Shop_ID ORDER BY COUNT(HH_ID) DESC LIMIT 1",
        "predict": "SELECT Shop_ID, COUNT(HH_ID) FROM happy_hour GROUP BY Shop_ID ORDER BY COUNT(HH_ID) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "coffee_shop",
        "gold": "SELECT MONTH FROM happy_hour GROUP BY MONTH ORDER BY count(*) DESC LIMIT 1",
        "question": "Which month has the most happy hours?",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Operation: The query requires the month with the most happy hours, so we should apply the 'count' operation to the 'HH_ID' column in the 'happy_hour' table, and find the month with the highest count. Since the unit to which the happy hours being counted in the query belong is the month, we should apply the 'group by' operation to the 'Month' column in the 'happy_hour' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['happy_hour'].\n\n<3> SQL Generation: The query requires the month with the most happy hours, so we should select the 'Month' column in the 'happy_hour' table.\n\nSQL query: SELECT Month FROM happy_hour GROUP BY Month ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Month FROM happy_hour GROUP BY Month ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT T2.Name FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId GROUP BY T2.Name ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which artist has the most albums?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Operation: The query requires the artist with the most albums, so we should apply the 'count' operation to the 'Album' table for the 'ArtistId' column, and find the artist with the highest count. Since the unit to which the albums being counted in the query belong is the artist, we should apply the 'group by' operation to the 'ArtistId' column in the 'Album' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Artist', 'Album'].\n\n<3> SQL Generation: The query requires the artist with the most albums, so we should select the 'Name' column in the 'Artist' table and the count of the 'AlbumId' column in the 'Album' table.\n\nSQL query: SELECT T1.Name FROM Artist AS T1 JOIN Album AS T2 ON T1.ArtistId = T2.ArtistId GROUP BY T1.ArtistId ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Name FROM Artist AS T1 JOIN Album AS T2 ON T1.ArtistId = T2.ArtistId GROUP BY T1.ArtistId ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT T2.Name FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId GROUP BY T2.Name ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the name of the artist with the greatest number of albums?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Operation: The query requires the name of the artist with the greatest number of albums, so we should apply the 'count' operation to the 'Album' table for the 'ArtistId' column, and find the artist with the highest count. Since the unit to which the albums being counted in the query belong is the artist, we should apply the 'group by' operation to the 'ArtistId' column in the 'Album' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Artist'].\n\n<3> SQL Generation: The query requires the name of the artist with the greatest number of albums, so we should select the 'Name' column in the 'Artist' table.\n\nSQL query: SELECT Name FROM Artist WHERE ArtistId = (SELECT ArtistId FROM Album GROUP BY ArtistId ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Name FROM Artist WHERE ArtistId = (SELECT ArtistId FROM Album GROUP BY ArtistId ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT T1.Name FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId GROUP BY T2.GenreId ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Find the name of the genre that is most frequent across all tracks.",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Operation: The query requires the name of the genre that is most frequent across all tracks, so we should apply the 'count' operation to the 'GenreId' column in the 'Track' table, and find the genre with the highest count. Since the unit to which the genres being counted in the query belong is the genre, we should apply the 'group by' operation to the 'GenreId' column in the 'Track' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Track'].\n\n<3> SQL Generation: The query requires the name of the genre that is most frequent across all tracks, so we should select the 'Name' column in the 'Genre' table and the 'GenreId' column in the 'Track' table.\n\nSQL query: SELECT Name FROM Genre WHERE GenreId = (SELECT GenreId FROM Track GROUP BY GenreId ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Name FROM Genre WHERE GenreId = (SELECT GenreId FROM Track GROUP BY GenreId ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT T1.Name FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId GROUP BY T2.MediaTypeId ORDER BY COUNT(*) ASC LIMIT 1",
        "question": "What is the name of the media type that is least common across all tracks?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Operation: The query requires the name of the media type that is least common across all tracks, so we should apply the 'count' operation to the 'MediaType' column in the 'Track' table, and find the media type with the lowest count. Since the unit to which the media types being counted in the query belong is the track, we should apply the 'group by' operation to the 'MediaType' column in the 'Track' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Track'].\n\n<3> SQL Generation: The query requires the name of the media type that is least common across all tracks, so we should select the 'Name' column in the 'MediaType' table and the 'MediaType' column in the 'Track' table.\n\nSQL query: SELECT T1.Name FROM MediaType AS T1 JOIN Track AS T2 ON T1.MediaTypeId = T2.MediaTypeId GROUP BY T2.MediaTypeId ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT T1.Name FROM MediaType AS T1 JOIN Track AS T2 ON T1.MediaTypeId = T2.MediaTypeId GROUP BY T2.MediaTypeId ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT T2.Name ,  T1.ArtistId FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistID GROUP BY T1.ArtistId HAVING COUNT(*)  >=  3 ORDER BY T2.Name",
        "question": "Please list the name and id of all artists that have at least 3 albums in alphabetical order.",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Operation: The query requires the name and id of all artists that have at least 3 albums, so we should apply the 'count' operation to the 'Album' table for the 'ArtistId' column, and filter the count to be greater than or equal to 3. Since the unit to which the albums being counted in the query belong is the artist, we should apply the 'group by' operation to the 'ArtistId' column in the 'Album' table. We also need to sort the result in alphabetical order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Artist'].\n\n<3> SQL Generation: The query requires the name and id of all artists that have at least 3 albums, so we should select the 'Name' and 'ArtistId' columns in the 'Artist' table. We also need to filter the result based on the count of albums.\n\nSQL query: SELECT Name, ArtistId FROM Artist WHERE ArtistId IN (SELECT ArtistId FROM Album GROUP BY ArtistId HAVING COUNT(*) >= 3) ORDER BY Name",
        "predict": "SELECT Name, ArtistId FROM Artist WHERE ArtistId IN (SELECT ArtistId FROM Album GROUP BY ArtistId HAVING COUNT(*) >= 3) ORDER BY Name",
        "hardness": "hard"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT T2.Name ,  T1.ArtistId FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistID GROUP BY T1.ArtistId HAVING COUNT(*)  >=  3 ORDER BY T2.Name",
        "question": "What are the names and ids of artists with 3 or more albums, listed in alphabetical order?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Operation: The query requires the names and ids of artists with 3 or more albums, so we should apply the 'count' operation to the 'Album' table for the 'ArtistId' column, and filter the count to be greater than or equal to 3. Since the unit to which the albums being counted in the query belong is the artist, we should apply the 'group by' operation to the 'ArtistId' column in the 'Album' table. We also need to sort the result in alphabetical order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Artist'].\n\n<3> SQL Generation: The query requires the names and ids of artists with 3 or more albums, so we should select the 'Name' and 'ArtistId' columns in the 'Artist' table. We also need to filter the result to only include artists with a count greater than or equal to 3 and sort the result in alphabetical order.\n\nSQL query: SELECT Name, ArtistId FROM Artist WHERE ArtistId IN (SELECT ArtistId FROM Album GROUP BY ArtistId HAVING COUNT(*) >= 3) ORDER BY Name ASC",
        "predict": "SELECT Name, ArtistId FROM Artist WHERE ArtistId IN (SELECT ArtistId FROM Album GROUP BY ArtistId HAVING COUNT(*) >= 3) ORDER BY Name ASC",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Which policy type appears most frequently in the available policies?",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Operation: The query requires the policy type that appears most frequently in the available policies, so we should apply the 'count' operation to the 'policy_type_code' column in the 'Available_Policies' table and find the policy type with the highest count. Since the unit to which the policy types being counted in the query belong is the policy, we should apply the 'group by' operation to the 'policy_type_code' column in the 'Available_Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Available_Policies'].\n\n<3> SQL Generation: The query requires the policy type that appears most frequently in the available policies, so we should select the 'policy_type_code' column in the 'Available_Policies' table.\n\nSQL query: SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)",
        "question": "Find the phone numbers of customers using the most common policy type among the available policies.",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Operation: The query requires the phone numbers of customers using the most common policy type among the available policies, so we should apply the 'count' operation to the 'policy_type_code' column in the 'Available_Policies' table, and find the policy type with the highest count. Since the unit to which the policy types being counted in the query belong is the customer, we should apply the 'group by' operation to the 'policy_type_code' column in the 'Available_Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Customers_Policies' and 'Available_Policies', we need to use tables ['Customers_Policies', 'Available_Policies'].\n\n<3> SQL Generation: The query requires the phone numbers of customers using the most common policy type among the available policies, so we should select the 'Customer_Phone' column in the 'Available_Policies' table.\n\nSQL query: SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = (SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = (SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT t1.Effective_Date FROM claims AS t1 JOIN settlements AS t2 ON t1.claim_id  =  t2.claim_id GROUP BY t1.claim_id ORDER BY sum(t2.settlement_amount) DESC LIMIT 1",
        "question": "What is the effective date of the claim that has the largest amount of total settlement?",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Operation: The query requires the effective date of the claim that has the largest amount of total settlement, so we should apply the 'sum' operation to the 'Settlement_Amount' column in the 'Settlements' table and find the claim with the highest sum. Since the unit to which the settlement amounts being summed in the query belong is the claim, we should apply the 'group by' operation to the 'Claim_ID' column in the 'Settlements' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Settlements' and 'Claims', we need to use tables ['Settlements', 'Claims'].\n\n<3> SQL Generation: The query requires the effective date of the claim that has the largest amount of total settlement, so we should select the 'Effective_Date' column in the 'Claims' table.\n\nSQL query: SELECT Effective_Date FROM Claims WHERE Claim_ID = (SELECT Claim_ID FROM Settlements GROUP BY Claim_ID ORDER BY SUM(Settlement_Amount) DESC LIMIT 1)",
        "predict": "SELECT Effective_Date FROM Claims WHERE Claim_ID = (SELECT Claim_ID FROM Settlements GROUP BY Claim_ID ORDER BY SUM(Settlement_Amount) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT t1.customer_name FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_name ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the customer who has the most policies listed?",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the customer who has the most policies listed, so we should apply the 'count' operation to the 'Customers_Policies' table for the 'Policy_ID' column, and find the customer with the highest count. Since the unit to which the policies being counted in the query belong is the customer, we should apply the 'group by' operation to the 'Customer_ID' column in the 'Customers_Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Customers', 'Customers_Policies'].\n\n<3> SQL Generation: The query requires the name of the customer who has the most policies listed, so we should select the 'Customer_name' column in the 'Customers' table and the 'Policy_ID' column in the 'Customers_Policies' table.\n\nSQL query: SELECT Customer_name FROM Customers WHERE Customer_ID = (SELECT Customer_ID FROM Customers_Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Customer_name FROM Customers WHERE Customer_ID = (SELECT Customer_ID FROM Customers_Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT t1.customer_name FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_name ORDER BY count(*) DESC LIMIT 1",
        "question": "Which customer uses the most policies? Give me the customer name.",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Operation: The query requires the customer who uses the most policies, so we should apply the 'count' operation to the 'Customers_Policies' table for the 'Customer_ID' column, and find the customer with the highest count. Since the unit to which the policies being counted in the query belong is the customer, we should apply the 'group by' operation to the 'Customer_ID' column in the 'Customers_Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers_Policies', 'Customers'].\n\n<3> SQL Generation: The query requires the customer who uses the most policies, so we should select the 'Customer_name' column in the 'Customers' table and the 'Customer_ID' column in the 'Customers_Policies' table.\n\nSQL query: SELECT Customer_name FROM Customers WHERE Customer_ID = (SELECT Customer_ID FROM Customers_Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Customer_name FROM Customers WHERE Customer_ID = (SELECT Customer_ID FROM Customers_Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT DISTINCT t3.policy_type_code FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id JOIN available_policies AS t3 ON t2.policy_id  =  t3.policy_id WHERE t1.customer_name  =  (SELECT t1.customer_name FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_name ORDER BY count(*) DESC LIMIT 1)",
        "question": "What are all the policy types of the customer that has the most policies listed?",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Operation: The query requires the policy types of the customer with the most policies listed, so we should apply the 'count' operation to the 'Customers_Policies' table for the 'Policy_ID' column, and find the customer with the highest count. Since the unit to which the policies being counted in the query belong is the customer, we should apply the 'group by' operation to the 'Customer_ID' column in the 'Customers_Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Customers_Policies' and 'Available_Policies', we need to use tables ['Customers_Policies', 'Available_Policies'].\n\n<3> SQL Generation: The query requires the policy types of the customer with the most policies listed, so we should select the 'policy_type_code' column in the 'Available_Policies' table.\n\nSQL query: SELECT policy_type_code FROM Available_Policies WHERE Policy_ID IN (SELECT Policy_ID FROM Customers_Policies WHERE Customer_ID = (SELECT Customer_ID FROM Customers_Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1))",
        "predict": "SELECT policy_type_code FROM Available_Policies WHERE Policy_ID IN (SELECT Policy_ID FROM Customers_Policies WHERE Customer_ID = (SELECT Customer_ID FROM Customers_Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1))",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT DISTINCT t3.policy_type_code FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id JOIN available_policies AS t3 ON t2.policy_id  =  t3.policy_id WHERE t1.customer_name  =  (SELECT t1.customer_name FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_name ORDER BY count(*) DESC LIMIT 1)",
        "question": "List all the policy types used by the customer enrolled in the most policies.",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Operation: The query requires the policy types used by the customer enrolled in the most policies, so we should apply the 'count' operation to the 'Customers_Policies' table for the 'Policy_ID' column, and find the customer with the highest count. Since the unit to which the policies being counted in the query belong is the customer, we should apply the 'group by' operation to the 'Customer_ID' column in the 'Customers_Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Customers_Policies' and 'Available_Policies', we need to use tables ['Customers_Policies', 'Available_Policies'].\n\n<3> SQL Generation: The query requires the policy types used by the customer enrolled in the most policies, so we should select the 'policy_type_code' column in the 'Available_Policies' table.\n\nSQL query: SELECT policy_type_code FROM Available_Policies WHERE Policy_ID IN (SELECT Policy_ID FROM Customers_Policies WHERE Customer_ID = (SELECT Customer_ID FROM Customers_Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1))",
        "predict": "SELECT policy_type_code FROM Available_Policies WHERE Policy_ID IN (SELECT Policy_ID FROM Customers_Policies WHERE Customer_ID = (SELECT Customer_ID FROM Customers_Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1))",
        "hardness": "extra"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC",
        "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Operation: The query requires the ids, names, and FDA approval status of medicines in descending order of the number of enzymes that it can interact with, so we should apply the 'count' operation to the 'enzyme_id' column in the 'medicine_enzyme_interaction' table, and sort it in descending order. Since the unit to which the enzymes being counted in the query belong is the medicine, we should apply the 'group by' operation to the 'medicine_id' column in the 'medicine_enzyme_interaction' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['medicine', 'medicine_enzyme_interaction'].\n\n<3> SQL Generation: The query requires the ids, names, and FDA approval status of medicines in descending order of the number of enzymes that it can interact with, so we should select the 'id', 'name', and 'FDA_approved' columns in the 'medicine' table and count the 'enzyme_id' column in the 'medicine_enzyme_interaction' table.\n\nSQL query: SELECT T1.id, T1.name, T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.medicine_id GROUP BY T2.medicine_id ORDER BY COUNT(*) DESC",
        "predict": "SELECT T1.id, T1.name, T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.medicine_id GROUP BY T2.medicine_id ORDER BY COUNT(*) DESC",
        "hardness": "hard"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Operation: The query requires the id and name of the enzyme with the most number of medicines that can interact as 'activator', so we should apply the 'count' operation to the 'medicine_enzyme_interaction' table for the 'enzyme_id' column, and find the enzyme with the highest count. Since the unit to which the interactions being counted in the query belong is the enzyme, we should apply the 'group by' operation to the 'enzyme_id' column in the 'medicine_enzyme_interaction' table. We also need to filter the interactions with the type 'activator' in the 'medicine_enzyme_interaction' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'enzyme' and 'medicine_enzyme_interaction', we need to use tables ['enzyme', 'medicine_enzyme_interaction'].\n\n<3> SQL Generation: The query requires the id and name of the enzyme with the most number of medicines that can interact as 'activator', so we should select the 'id' and 'name' columns in the 'enzyme' table and the 'enzyme_id' column in the 'medicine_enzyme_interaction' table.\n\nSQL query: SELECT T1.id, T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id WHERE T2.interaction_type = 'activator' GROUP BY T2.enzyme_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.id, T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id WHERE T2.interaction_type = 'activator' GROUP BY T2.enzyme_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id and name of the enzyme that can interact with the most medicines as an activator?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Operation: The query requires the id and name of the enzyme that can interact with the most medicines as an activator, so we should apply the 'count' operation to the 'medicine_enzyme_interaction' table for the 'enzyme_id' column, and find the enzyme with the highest count. Since the unit to which the interactions being counted in the query belong is the enzyme, we should apply the 'group by' operation to the 'enzyme_id' column in the 'medicine_enzyme_interaction' table. We also need to filter the interactions where the 'interaction_type' is 'activator'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['enzyme', 'medicine_enzyme_interaction'].\n\n<3> SQL Generation: The query requires the id and name of the enzyme that can interact with the most medicines as an activator, so we should select the 'id' and 'name' columns in the 'enzyme' table and the 'enzyme_id' column in the 'medicine_enzyme_interaction' table. We also need to filter the interactions where the 'interaction_type' is 'activator'.\n\nSQL query: SELECT T1.id, T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id WHERE T2.interaction_type = 'activator' GROUP BY T2.enzyme_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.id, T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id WHERE T2.interaction_type = 'activator' GROUP BY T2.enzyme_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "phone_1",
        "gold": "SELECT Company_name ,  count(*) FROM phone GROUP BY Company_name ORDER BY count(*) ASC LIMIT 1;",
        "question": "Find the name of the company that has the least number of phone models. List the company name and the number of phone model produced by that company.",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n",
        "reasoning": "<1> Operation: The query requires the name of the company that has the least number of phone models, so we should apply the 'count' operation to the 'Hardware_Model_name' column in the 'phone' table, and find the company with the lowest count. Since the unit to which the phone models being counted in the query belong is the company, we should apply the 'group by' operation to the 'Company_name' column in the 'phone' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['phone'].\n\n<3> SQL Generation: The query requires the name of the company that has the least number of phone models, so we should select the 'Company_name' column in the 'phone' table and the count of the 'Hardware_Model_name' column in the 'phone' table.\n\nSQL query: SELECT Company_name, COUNT(Hardware_Model_name) FROM phone GROUP BY Company_name ORDER BY COUNT(Hardware_Model_name) ASC LIMIT 1",
        "predict": "SELECT Company_name, COUNT(Hardware_Model_name) FROM phone GROUP BY Company_name ORDER BY COUNT(Hardware_Model_name) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "match_season",
        "gold": "SELECT POSITION FROM match_season GROUP BY POSITION ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the most common position of players in match seasons.",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n",
        "reasoning": "<1> Operation: The query requires the most common position of players in match seasons, so we should apply the 'count' operation to the 'Position' column in the 'match_season' table and find the position with the highest count. Since the unit to which the positions being counted in the query belong is the player, we should apply the 'group by' operation to the 'Position' column in the 'match_season' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'match_season' and 'team', and between table 'match_season' and 'country', we need to use tables ['match_season', 'team', 'country'].\n\n<3> SQL Generation: The query requires the most common position of players in match seasons, so we should select the 'Position' column in the 'match_season' table.\n\nSQL query: SELECT Position FROM match_season GROUP BY Position ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Position FROM match_season GROUP BY Position ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "match_season",
        "gold": "SELECT POSITION FROM match_season GROUP BY POSITION ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the position that is most common among players in match seasons?",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n",
        "reasoning": "<1> Operation: The query requires the position that is most common among players in match seasons, so we should apply the 'count' operation to the 'Position' column in the 'match_season' table and find the position with the highest count. Since the unit to which the positions being counted in the query belong is the player, we should apply the 'group by' operation to the 'Position' column in the 'match_season' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'match_season' and 'player', we need to use tables ['match_season', 'player'].\n\n<3> SQL Generation: The query requires the position that is most common among players in match seasons, so we should select the 'Position' column in the 'match_season' table.\n\nSQL query: SELECT Position FROM match_season GROUP BY Position ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Position FROM match_season GROUP BY Position ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "match_season",
        "gold": "SELECT College FROM match_season GROUP BY College HAVING count(*)  >=  2 ORDER BY College DESC",
        "question": "What are the names of colleges that have two or more players, listed in descending alphabetical order?",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n",
        "reasoning": "<1> Operation: The query requires the names of colleges that have two or more players, so we should apply the 'count' operation to the 'Player' column in the 'match_season' table, and find the colleges with a count greater than or equal to 2. Since the unit to which the players being counted in the query belong is the college, we should apply the 'group by' operation to the 'College' column in the 'match_season' table. We also need to sort the colleges in descending alphabetical order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'match_season' and 'team', we need to use tables ['match_season', 'team'].\n\n<3> SQL Generation: The query requires the names of colleges that have two or more players, so we should select the 'College' column in the 'match_season' table. We also need to filter the colleges with a count greater than or equal to 2.\n\nSQL query: SELECT College FROM match_season GROUP BY College HAVING COUNT(*) >= 2 ORDER BY College DESC",
        "predict": "SELECT College FROM match_season GROUP BY College HAVING COUNT(*) >= 2 ORDER BY College DESC",
        "hardness": "medium"
    },
    {
        "db_id": "climbing",
        "gold": "SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the range that has the most number of mountains.",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n",
        "reasoning": "<1> Operation: The query requires the range that has the most number of mountains, so we should apply the 'count' operation to the 'Mountain_ID' column in the 'mountain' table, and find the range with the highest count. Since the unit to which the mountains being counted in the query belong is the range, we should apply the 'group by' operation to the 'Range' column in the 'mountain' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'mountain'.\n\n<3> SQL Generation: The query requires the range that has the most number of mountains, so we should select the 'Range' column in the 'mountain' table.\n\nSQL query: SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "climbing",
        "gold": "SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which range contains the most mountains?",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n",
        "reasoning": "<1> Operation: The query requires the range that contains the most mountains, so we should apply the 'count' operation to the 'Mountain_ID' column in the 'mountain' table, and find the range with the highest count. Since the unit to which the mountains being counted in the query belong is the range, we should apply the 'group by' operation to the 'Range' column in the 'mountain' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'mountain'.\n\n<3> SQL Generation: The query requires the range that contains the most mountains, so we should select the 'Range' column in the 'mountain' table.\n\nSQL query: SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Range FROM mountain GROUP BY Range ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "body_builder",
        "gold": "SELECT Birth_Place FROM people GROUP BY Birth_Place ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the most common birth place of people?",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common birth place of people, so we should apply the 'count' operation to the 'Birth_Place' column in the 'people' table, and find the birth place with the highest count. Since the unit to which the birth places being counted in the query belong is the people, we should apply the 'group by' operation to the 'Birth_Place' column in the 'people' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'people'.\n\n<3> SQL Generation: The query requires the most common birth place of people, so we should select the 'Birth_Place' column in the 'people' table.\n\nSQL query: SELECT Birth_Place FROM people GROUP BY Birth_Place ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Birth_Place FROM people GROUP BY Birth_Place ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT apt_type_code ,  COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC",
        "question": "Show the apartment type codes and the corresponding number of apartments sorted by the number of apartments in ascending order.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Operation: The query requires the apartment type codes and the corresponding number of apartments, so we should apply the 'count' operation to the 'apt_id' column in the 'Apartments' table, and sort it in ascending order. Since the unit to which the apartments being counted in the query belong is the apartment type code and only table 'Apartments' has the column 'apt_type_code', so we should apply the 'group by' operation to the 'apt_type_code' column in table 'Apartments'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Apartments'].\n\n<3> SQL Generation: The query requires the apartment type codes and the corresponding number of apartments, so we should select the 'apt_type_code' column in the 'Apartments' table and count the 'apt_id' column in the 'Apartments' table.\n\nSQL query: SELECT apt_type_code, COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC",
        "predict": "SELECT apt_type_code, COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC",
        "hardness": "extra"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT apt_type_code ,  COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC",
        "question": "Return each apartment type code with the number of apartments having that apartment type, in ascending order of the number of apartments.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Operation: The query requires each apartment type code with the number of apartments having that apartment type, so we should apply the 'count' operation to the 'apt_id' column in the 'Apartments' table, and sort it in ascending order. Since the unit to which the apartments being counted in the query belong is the apartment type code, we should apply the 'group by' operation to the 'apt_type_code' column in the 'Apartments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Apartments'].\n\n<3> SQL Generation: The query requires each apartment type code with the number of apartments having that apartment type, so we should select the 'apt_type_code' column in the 'Apartments' table and count the 'apt_id' column in the 'Apartments' table.\n\nSQL query: SELECT apt_type_code, COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC",
        "predict": "SELECT apt_type_code, COUNT(*) FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) ASC",
        "hardness": "extra"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3",
        "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Operation: The query requires the top 3 apartment type codes sorted by the average number of rooms in descending order, so we should apply the 'average' operation to the 'room_count' column in the 'Apartments' table and sort it in descending order. Since the unit to which the average number of rooms being calculated in the query belongs is the apartment type code, we should apply the 'group by' operation to the 'apt_type_code' column in the 'Apartments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Apartments'].\n\n<3> SQL Generation: The query requires the top 3 apartment type codes sorted by the average number of rooms in descending order, so we should select the 'apt_type_code' column in the 'Apartments' table and the average of the 'room_count' column in the 'Apartments' table.\n\nSQL query: SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY AVG(room_count) DESC LIMIT 3",
        "predict": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY AVG(room_count) DESC LIMIT 3",
        "hardness": "hard"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the most common apartment type code.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Operation: The query requires the most common apartment type code, so we should apply the 'count' operation to the 'apt_type_code' column in the 'Apartments' table and find the apartment type code with the highest count. Since the unit to which the apartment type codes being counted in the query belong is the apartment, we should apply the 'group by' operation to the 'apt_type_code' column in the 'Apartments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Apartments'].\n\n<3> SQL Generation: The query requires the most common apartment type code, so we should select the 'apt_type_code' column in the 'Apartments' table.\n\nSQL query: SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Which apartment type code appears the most often?",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Operation: The query requires the apartment type code that appears the most often, so we should apply the 'count' operation to the 'apt_type_code' column in the 'Apartments' table and find the apartment type code with the highest count. Since the unit to which the apartment type codes being counted in the query belong is the apartment, we should apply the 'group by' operation to the 'apt_type_code' column in the 'Apartments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Apartments'].\n\n<3> SQL Generation: The query requires the apartment type code that appears the most often, so we should select the 'apt_type_code' column in the 'Apartments' table.\n\nSQL query: SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the most common apartment type code among apartments with more than 1 bathroom.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Operation: The query requires the most common apartment type code among apartments with more than 1 bathroom, so we should apply the 'count' operation to the 'apt_type_code' column in the 'Apartments' table, and find the apartment type code with the highest count. We also need to filter the apartments with more than 1 bathroom.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Apartments'].\n\n<3> SQL Generation: The query requires the most common apartment type code among apartments with more than 1 bathroom, so we should select the 'apt_type_code' column in the 'Apartments' table. We also need to filter the apartments with more than 1 bathroom.\n\nSQL query: SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Which apartment type code is the most common among apartments with more than one bathroom?",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Operation: The query requires the apartment type code that is the most common among apartments with more than one bathroom, so we should apply the 'count' operation to the 'apt_type_code' column in the 'Apartments' table, and find the apartment type code with the highest count. We also need to filter the apartments with more than one bathroom.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Apartments'].\n\n<3> SQL Generation: The query requires the apartment type code that is the most common among apartments with more than one bathroom, so we should select the 'apt_type_code' column in the 'Apartments' table. We also need to filter the apartments with more than one bathroom.\n\nSQL query: SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT gender_code ,  COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC",
        "question": "Show each gender code and the corresponding count of guests sorted by the count in descending order.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Operation: The query requires each gender code and the corresponding count of guests, so we should apply the 'count' operation to the 'guest_id' column in the 'Guests' table, and sort it in descending order. Since the unit to which the guests being counted in the query belong is the gender code and only table 'Guests' has the column 'gender_code', so we should apply the 'group by' operation to the 'gender_code' column in table 'Guests'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Guests'].\n\n<3> SQL Generation: The query requires each gender code and the corresponding count of guests, so we should select the 'gender_code' column in the 'Guests' table and the count of the 'guest_id' column in the 'Guests' table.\n\nSQL query: SELECT gender_code, COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC",
        "predict": "SELECT gender_code, COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT gender_code ,  COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC",
        "question": "Sort the gender codes in descending order of their corresponding number of guests. Return both the gender codes and counts.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Operation: The query requires sorting the gender codes in descending order of their corresponding number of guests, so we should apply the 'count' operation to the 'guest_id' column in the 'Guests' table and sort it in descending order. Since the unit to which the guests being counted in the query belong is the gender code and only table 'Guests' has the column 'gender_code', we should apply the 'group by' operation to the 'gender_code' column in the 'Guests' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Guests'.\n\n<3> SQL Generation: The query requires sorting the gender codes in descending order of their corresponding number of guests, so we should select the 'gender_code' column in the 'Guests' table and the count of the 'guest_id' column in the 'Guests' table.\n\nSQL query: SELECT gender_code, COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC",
        "predict": "SELECT gender_code, COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT T1.id ,  T1.name FROM stadium AS T1 JOIN game AS T2 ON T1.id  =  T2.stadium_id JOIN injury_accident AS T3 ON T2.id  =  T3.game_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the id and name of the stadium where the most injury accidents happened?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Operation: The query requires the id and name of the stadium where the most injury accidents happened, so we should apply the 'count' operation to the 'injury_accident' table for the 'game_id' column, and find the stadium with the highest count. Since the unit to which the injury accidents being counted in the query belong is the stadium, we should apply the 'group by' operation to the 'stadium_id' column in the 'game' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'game' and 'injury_accident', we need to use tables ['game', 'injury_accident'].\n\n<3> SQL Generation: The query requires the id and name of the stadium where the most injury accidents happened, so we should select the 'id' and 'name' columns in the 'stadium' table.\n\nSQL query: SELECT T2.id, T2.name FROM game AS T1 JOIN stadium AS T2 ON T1.stadium_id = T2.id JOIN injury_accident AS T3 ON T1.id = T3.game_id GROUP BY T1.stadium_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.id, T2.name FROM game AS T1 JOIN stadium AS T2 ON T1.stadium_id = T2.id JOIN injury_accident AS T3 ON T1.id = T3.game_id GROUP BY T1.stadium_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT T1.id ,  T1.name FROM stadium AS T1 JOIN game AS T2 ON T1.id  =  T2.stadium_id JOIN injury_accident AS T3 ON T2.id  =  T3.game_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the id and name of the stadium where the largest number of injury accidents occurred.",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Operation: The query requires the id and name of the stadium where the largest number of injury accidents occurred, so we should apply the 'count' operation to the 'injury_accident' table for the 'game_id' column, and find the stadium with the highest count. Since the unit to which the injury accidents being counted in the query belong is the stadium, we should apply the 'group by' operation to the 'stadium_id' column in the 'injury_accident' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'game' and 'stadium', we need to use tables ['game', 'stadium'].\n\n<3> SQL Generation: The query requires the id and name of the stadium where the largest number of injury accidents occurred, so we should select the 'id' and 'name' columns in the 'stadium' table.\n\nSQL query: SELECT T2.id, T2.name FROM game AS T1 JOIN stadium AS T2 ON T1.stadium_id = T2.id JOIN injury_accident AS T3 ON T1.id = T3.game_id GROUP BY T1.stadium_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.id, T2.name FROM game AS T1 JOIN stadium AS T2 ON T1.stadium_id = T2.id JOIN injury_accident AS T3 ON T1.id = T3.game_id GROUP BY T1.stadium_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "performance_attendance",
        "gold": "SELECT LOCATION FROM performance GROUP BY LOCATION ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common location of performances.",
        "fields": "Table member, columns = [*,Member_ID,Name,Nationality,Role]\nTable member_attendance, columns = [*,Member_ID,Performance_ID,Num_of_Pieces]\nTable performance, columns = [*,Performance_ID,Date,Host,Location,Attendance]\n",
        "foreign_keys": "Foreign_keys = [member_attendance.Performance_ID = performance.Performance_ID,member_attendance.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common location of performances, so we should apply the 'count' operation to the 'Location' column in the 'performance' table and find the location with the highest count. Since the unit to which the locations being counted in the query belong is the performance, we should apply the 'group by' operation to the 'Location' column in the 'performance' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['performance'].\n\n<3> SQL Generation: The query requires the most common location of performances, so we should select the 'Location' column in the 'performance' table.\n\nSQL query: SELECT Location FROM performance GROUP BY Location ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Location FROM performance GROUP BY Location ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY count(*) DESC LIMIT 3",
        "question": "Find the names of the top 3 departments that provide the largest amount of courses?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the names of the top 3 departments that provide the largest amount of courses, so we should apply the 'count' operation to the 'course_id' column in the 'course' table, and sort it in descending order. Since the unit to which the courses being counted in the query belong is the department, we should apply the 'group by' operation to the 'dept_name' column in the 'course' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['course'].\n\n<3> SQL Generation: The query requires the names of the top 3 departments that provide the largest amount of courses, so we should select the 'dept_name' column in the 'course' table.\n\nSQL query: SELECT dept_name FROM course GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 3",
        "predict": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 3",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY count(*) DESC LIMIT 3",
        "question": "What are the names of the 3 departments with the most courses?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the names of the 3 departments with the most courses, so we should apply the 'count' operation to the 'course_id' column in the 'course' table, and find the departments with the highest count. Since the unit to which the courses being counted in the query belong is the department, we should apply the 'group by' operation to the 'dept_name' column in the 'course' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['course'].\n\n<3> SQL Generation: The query requires the names of the 3 departments with the most courses, so we should select the 'dept_name' column in the 'course' table.\n\nSQL query: SELECT dept_name FROM course GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 3",
        "predict": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 3",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY sum(credits) DESC LIMIT 1",
        "question": "Find the name of the department that offers the highest total credits?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the department that offers the highest total credits, so we should apply the 'sum' operation to the 'credits' column in the 'course' table and find the department with the highest sum. Since the unit to which the credits being summed in the query belong is the department, we should apply the 'group by' operation to the 'dept_name' column in the 'course' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['course'].\n\n<3> SQL Generation: The query requires the name of the department that offers the highest total credits, so we should select the 'dept_name' column in the 'course' table and the sum of the 'credits' column in the 'course' table.\n\nSQL query: SELECT dept_name FROM course GROUP BY dept_name ORDER BY SUM(credits) DESC LIMIT 1",
        "predict": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY SUM(credits) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY sum(credits) DESC LIMIT 1",
        "question": "What is the name of the department with the most credits?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the department with the most credits, so we should apply the 'sum' operation to the 'credits' column in the 'course' table and find the department with the highest sum. Since the unit to which the credits being summed in the query belong is the department, we should apply the 'group by' operation to the 'dept_name' column in the 'course' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['course'].\n\n<3> SQL Generation: The query requires the name of the department with the most credits, so we should select the 'dept_name' column in the 'course' table and the sum of the 'credits' column in the 'course' table.\n\nSQL query: SELECT dept_name FROM course GROUP BY dept_name ORDER BY SUM(credits) DESC LIMIT 1",
        "predict": "SELECT dept_name FROM course GROUP BY dept_name ORDER BY SUM(credits) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT YEAR FROM SECTION GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the year which offers the largest number of courses.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the year that offers the largest number of courses, so we should apply the 'count' operation to the 'course_id' column in the 'section' table, and find the year with the highest count. Since the unit to which the courses being counted in the query belong is the year, we should apply the 'group by' operation to the 'year' column in the 'section' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['section'].\n\n<3> SQL Generation: The query requires the year that offers the largest number of courses, so we should select the 'year' column in the 'section' table.\n\nSQL query: SELECT year FROM section GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT year FROM section GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT YEAR FROM SECTION GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1",
        "question": "Which year had the greatest number of courses?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the year with the greatest number of courses, so we should apply the 'count' operation to the 'course_id' column in the 'section' table, and find the year with the highest count. Since the unit to which the courses being counted in the query belong is the year, we should apply the 'group by' operation to the 'year' column in the 'section' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['section'].\n\n<3> SQL Generation: The query requires the year with the greatest number of courses, so we should select the 'year' column in the 'section' table.\n\nSQL query: SELECT year FROM section GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT year FROM section GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT semester ,  YEAR FROM SECTION GROUP BY semester ,  YEAR ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the year and semester when offers the largest number of courses.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the year and semester when the largest number of courses are offered, so we should apply the 'count' operation to the 'course_id' column in the 'teaches' table, and find the year and semester with the highest count. Since the unit to which the courses being counted in the query belong is the year and semester, we should apply the 'group by' operation to the 'year' and 'semester' columns in the 'teaches' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['teaches'].\n\n<3> SQL Generation: The query requires the year and semester when the largest number of courses are offered, so we should select the 'year' and 'semester' columns in the 'teaches' table.\n\nSQL query: SELECT year, semester FROM teaches GROUP BY year, semester ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT year, semester FROM teaches GROUP BY year, semester ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT semester ,  YEAR FROM SECTION GROUP BY semester ,  YEAR ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the year and semester with the most courses?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the year and semester with the most courses, so we should apply the 'count' operation to the 'course_id' column in the 'section' table, and find the year and semester with the highest count. Since the unit to which the courses being counted in the query belong is the year and semester, we should apply the 'group by' operation to the 'year' and 'semester' columns in the 'section' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['section'].\n\n<3> SQL Generation: The query requires the year and semester with the most courses, so we should select the 'year' and 'semester' columns in the 'section' table.\n\nSQL query: SELECT year, semester FROM section GROUP BY year, semester ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT year, semester FROM section GROUP BY year, semester ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT dept_name FROM student GROUP BY dept_name ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of department has the highest amount of students?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the department with the highest amount of students, so we should apply the 'count' operation to the 'ID' column in the 'student' table, and find the department with the highest count. Since the unit to which the students being counted in the query belong is the department, we should apply the 'group by' operation to the 'dept_name' column in the 'student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['student'].\n\n<3> SQL Generation: The query requires the name of the department with the highest amount of students, so we should select the 'dept_name' column in the 'student' table.\n\nSQL query: SELECT dept_name FROM student GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT dept_name FROM student GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT dept_name FROM student GROUP BY dept_name ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the deparment with the highest enrollment?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the department with the highest enrollment, so we should apply the 'count' operation to the 'ID' column in the 'student' table, and find the department with the highest count. Since the unit to which the enrollments being counted in the query belong is the department, we should apply the 'group by' operation to the 'dept_name' column in the 'student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['student'].\n\n<3> SQL Generation: The query requires the name of the department with the highest enrollment, so we should select the 'dept_name' column in the 'student' table.\n\nSQL query: SELECT dept_name FROM student GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT dept_name FROM student GROUP BY dept_name ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT semester ,  YEAR FROM takes GROUP BY semester ,  YEAR ORDER BY count(*) LIMIT 1",
        "question": "Find the semester and year which has the least number of student taking any class.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the semester and year which has the least number of students taking any class, so we should apply the 'count' operation to the 'ID' column in the 'takes' table, and find the semester and year with the lowest count. Since the unit to which the students being counted in the query belong is the semester and year, we should apply the 'group by' operation to the 'semester' and 'year' columns in the 'takes' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['takes'].\n\n<3> SQL Generation: The query requires the semester and year which has the least number of students taking any class, so we should select the 'semester' and 'year' columns in the 'takes' table.\n\nSQL query: SELECT semester, year FROM takes GROUP BY semester, year ORDER BY COUNT(ID) ASC LIMIT 1",
        "predict": "SELECT semester, year FROM takes GROUP BY semester, year ORDER BY COUNT(ID) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT semester ,  YEAR FROM takes GROUP BY semester ,  YEAR ORDER BY count(*) LIMIT 1",
        "question": "Which semeseter and year had the fewest students?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the semester and year with the fewest students, so we should apply the 'count' operation to the 'ID' column in the 'takes' table, and find the semester and year with the lowest count. Since the unit to which the students being counted in the query belong is the semester and year, we should apply the 'group by' operation to the 'semester' and 'year' columns in the 'takes' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['takes'].\n\n<3> SQL Generation: The query requires the semester and year with the fewest students, so we should select the 'semester' and 'year' columns in the 'takes' table.\n\nSQL query: SELECT semester, year FROM takes GROUP BY semester, year ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT semester, year FROM takes GROUP BY semester, year ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY avg(salary) DESC LIMIT 1",
        "question": "Find the name of the department which has the highest average salary of professors.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the department with the highest average salary of professors, so we should apply the 'average' operation to the 'salary' column in the 'instructor' table and sort it in descending order. Since the unit to which the average salary being calculated in the query belongs is the department, we should apply the 'group by' operation to the 'dept_name' column in the 'instructor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['instructor'].\n\n<3> SQL Generation: The query requires the name of the department with the highest average salary of professors, so we should select the 'dept_name' column in the 'instructor' table and the average of the 'salary' column in the 'instructor' table.\n\nSQL query: SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY AVG(salary) DESC LIMIT 1",
        "predict": "SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY AVG(salary) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY avg(salary) DESC LIMIT 1",
        "question": "Which department has the highest average instructor salary?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Operation: The query requires the department with the highest average instructor salary, so we should apply the 'average' operation to the 'salary' column in the 'instructor' table and find the department with the highest average. Since the unit to which the average instructor salary being calculated in the query belongs is the department, we should apply the 'group by' operation to the 'dept_name' column in the 'instructor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['instructor'].\n\n<3> SQL Generation: The query requires the department with the highest average instructor salary, so we should select the 'dept_name' column in the 'instructor' table and the average of the 'salary' column in the 'instructor' table.\n\nSQL query: SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY AVG(salary) DESC LIMIT 1",
        "predict": "SELECT dept_name FROM instructor GROUP BY dept_name ORDER BY AVG(salary) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "debate",
        "gold": "SELECT Party FROM people GROUP BY Party ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the party that has the most people.",
        "fields": "Table debate, columns = [*,Debate_ID,Date,Venue,Num_of_Audience]\nTable debate_people, columns = [*,Debate_ID,Affirmative,Negative,If_Affirmative_Win]\nTable people, columns = [*,People_ID,District,Name,Party,Age]\n",
        "foreign_keys": "Foreign_keys = [debate_people.Negative = people.People_ID,debate_people.Affirmative = people.People_ID,debate_people.Debate_ID = debate.Debate_ID]\n",
        "reasoning": "<1> Operation: The query requires the party that has the most people, so we should apply the 'count' operation to the 'People_ID' column in the 'people' table, and find the party with the highest count. Since the unit to which the people being counted in the query belong is the party, we should apply the 'group by' operation to the 'Party' column in the 'people' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'people'.\n\n<3> SQL Generation: The query requires the party that has the most people, so we should select the 'Party' column in the 'people' table.\n\nSQL query: SELECT Party FROM people GROUP BY Party ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Party FROM people GROUP BY Party ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_and_eClaims",
        "gold": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Which type of policy is most frequently used? Give me the policy type code.",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n",
        "reasoning": "<1> Operation: The query requires the type of policy that is most frequently used, so we should apply the 'count' operation to the 'Policies' table for the 'Policy_Type_Code' column, and find the policy type with the highest count. Since the unit to which the policy types being counted in the query belong is the policy, we should apply the 'group by' operation to the 'Policy_Type_Code' column in the 'Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Policies'].\n\n<3> SQL Generation: The query requires the type of policy that is most frequently used, so we should select the 'Policy_Type_Code' column in the 'Policies' table.\n\nSQL query: SELECT Policy_Type_Code FROM Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Policy_Type_Code FROM Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_and_eClaims",
        "gold": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the type code of the most frequently used policy.",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n",
        "reasoning": "<1> Operation: The query requires the type code of the most frequently used policy, so we should apply the 'count' operation to the 'Policies' table for the 'Policy_Type_Code' column, and find the policy type code with the highest count. Since the unit to which the policy type codes being counted in the query belong is the policy, we should apply the 'group by' operation to the 'Policy_Type_Code' column in the 'Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Policies'].\n\n<3> SQL Generation: The query requires the type code of the most frequently used policy, so we should select the 'Policy_Type_Code' column in the 'Policies' table.\n\nSQL query: SELECT Policy_Type_Code FROM Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Policy_Type_Code FROM Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_and_eClaims",
        "gold": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t2.customer_details ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the customer that has been involved in the most policies.",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the customer that has been involved in the most policies, so we should apply the 'count' operation to the 'Policies' table for the 'Customer_ID' column, and find the customer with the highest count. Since the unit to which the policies being counted in the query belong is the customer, we should apply the 'group by' operation to the 'Customer_ID' column in the 'Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Customers', 'Policies'].\n\n<3> SQL Generation: The query requires the name of the customer that has been involved in the most policies, so we should select the 'Customer_Details' column in the 'Customers' table and the 'Customer_ID' column in the 'Policies' table.\n\nSQL query: SELECT Customer_Details FROM Customers WHERE Customer_ID = (SELECT Customer_ID FROM Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Customer_Details FROM Customers WHERE Customer_ID = (SELECT Customer_ID FROM Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_and_eClaims",
        "gold": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t2.customer_details ORDER BY count(*) DESC LIMIT 1",
        "question": "Which customer have the most policies? Give me the customer details.",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n",
        "reasoning": "<1> Operation: The query requires the customer with the most policies, so we should apply the 'count' operation to the 'Policies' table for the 'Customer_ID' column, and find the customer with the highest count. Since the unit to which the policies being counted in the query belong is the customer, we should apply the 'group by' operation to the 'Customer_ID' column in the 'Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Customers', 'Policies'].\n\n<3> SQL Generation: The query requires the customer with the most policies, so we should select the 'Customer_Details' column in the 'Customers' table and the 'Customer_ID' column in the 'Policies' table.\n\nSQL query: SELECT Customer_Details FROM Customers WHERE Customer_ID = (SELECT Customer_ID FROM Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Customer_Details FROM Customers WHERE Customer_ID = (SELECT Customer_ID FROM Policies GROUP BY Customer_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the customer id, first and last name with most number of accounts.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the customer id, first name, and last name with the most number of accounts, so we should apply the 'count' operation to the 'Accounts' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the accounts being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Accounts' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Accounts'].\n\n<3> SQL Generation: The query requires the customer id, first name, and last name with the most number of accounts, so we should select the 'customer_id', 'customer_first_name', and 'customer_last_name' columns in the 'Customers' table.\n\nSQL query: SELECT customer_id, customer_first_name, customer_last_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Accounts GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_id, customer_first_name, customer_last_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Accounts GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT account_id FROM Financial_transactions GROUP BY account_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the account id with most number of transactions.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the account id with the most number of transactions, so we should apply the 'count' operation to the 'account_id' column in the 'Financial_Transactions' table, and find the account id with the highest count. Since the unit to which the transactions being counted in the query belong is the account, we should apply the 'group by' operation to the 'account_id' column in the 'Financial_Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Financial_Transactions'].\n\n<3> SQL Generation: The query requires the account id with the most number of transactions, so we should select the 'account_id' column in the 'Financial_Transactions' table.\n\nSQL query: SELECT account_id FROM Financial_Transactions GROUP BY account_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT account_id FROM Financial_Transactions GROUP BY account_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT account_id FROM Financial_transactions GROUP BY account_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id of the account with the most transactions?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the id of the account with the most transactions, so we should apply the 'count' operation to the 'Financial_Transactions' table for the 'account_id' column, and find the account with the highest count. Since the unit to which the transactions being counted in the query belong is the account, we should apply the 'group by' operation to the 'account_id' column in the 'Financial_Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Financial_Transactions'].\n\n<3> SQL Generation: The query requires the id of the account with the most transactions, so we should select the 'account_id' column in the 'Financial_Transactions' table.\n\nSQL query: SELECT account_id FROM Financial_Transactions GROUP BY account_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT account_id FROM Financial_Transactions GROUP BY account_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the invoice number and invoice date for the invoice with most number of transactions?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the invoice number and invoice date for the invoice with the most number of transactions, so we should apply the 'count' operation to the 'invoice_number' column in the 'Financial_Transactions' table, and find the invoice number with the highest count. Since the unit to which the transactions being counted in the query belong is the invoice, we should apply the 'group by' operation to the 'invoice_number' column in the 'Financial_Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Financial_Transactions' and 'Invoices', we need to use tables ['Financial_Transactions', 'Invoices'].\n\n<3> SQL Generation: The query requires the invoice number and invoice date for the invoice with the most number of transactions, so we should select the 'invoice_number' column in the 'Invoices' table and the 'invoice_date' column in the 'Invoices' table.\n\nSQL query: SELECT invoice_number, invoice_date FROM Invoices WHERE invoice_number = (SELECT invoice_number FROM Financial_Transactions GROUP BY invoice_number ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT invoice_number, invoice_date FROM Invoices WHERE invoice_number = (SELECT invoice_number FROM Financial_Transactions GROUP BY invoice_number ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the invoice number and invoice date corresponding to the invoice with the greatest number of transactions, so we should apply the 'count' operation to the 'invoice_number' column in the 'Financial_Transactions' table, and find the invoice number with the highest count. Since the unit to which the transactions being counted in the query belong is the invoice, we should apply the 'group by' operation to the 'invoice_number' column in the 'Financial_Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Financial_Transactions' and 'Invoices', we need to use tables ['Financial_Transactions', 'Invoices'].\n\n<3> SQL Generation: The query requires the invoice number and invoice date corresponding to the invoice with the greatest number of transactions, so we should select the 'invoice_number' column in the 'Invoices' table and the 'invoice_date' column in the 'Invoices' table.\n\nSQL query: SELECT invoice_number, invoice_date FROM Invoices WHERE invoice_number = (SELECT invoice_number FROM Financial_Transactions GROUP BY invoice_number ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT invoice_number, invoice_date FROM Invoices WHERE invoice_number = (SELECT invoice_number FROM Financial_Transactions GROUP BY invoice_number ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT T2.customer_last_name ,  T1.customer_id ,  T2.phone_number FROM Orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the customer last name, id and phone number with most number of orders?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the customer last name, id, and phone number with the most number of orders, so we should apply the 'count' operation to the 'Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Customers', 'Orders'].\n\n<3> SQL Generation: The query requires the customer last name, id, and phone number with the most number of orders, so we should select the 'customer_last_name', 'customer_id', and 'phone_number' columns in the 'Customers' table.\n\nSQL query: SELECT customer_last_name, customer_id, phone_number FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_last_name, customer_id, phone_number FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT T2.customer_last_name ,  T1.customer_id ,  T2.phone_number FROM Orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the last name, id and phone number of the customer who has made the greatest number of orders.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the last name, id, and phone number of the customer who has made the greatest number of orders, so we should apply the 'count' operation to the 'Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Orders' and 'Customers', we need to use tables ['Orders', 'Customers'].\n\n<3> SQL Generation: The query requires the last name, id, and phone number of the customer who has made the greatest number of orders, so we should select the 'customer_last_name', 'customer_id', and 'phone_number' columns in the 'Customers' table.\n\nSQL query: SELECT customer_last_name, customer_id, phone_number FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_last_name, customer_id, phone_number FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT T2.name , T2.country FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id GROUP BY T1.artist_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name and country for the artist with most number of exhibitions?",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Operation: The query requires the name and country for the artist with the most number of exhibitions, so we should apply the 'count' operation to the 'Exhibition_ID' column in the 'exhibition_record' table, and find the artist with the highest count. Since the unit to which the exhibitions being counted in the query belong is the artist, we should apply the 'group by' operation to the 'Artist_ID' column in the 'exhibition' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'exhibition' and 'artist', we need to use tables ['exhibition', 'artist'].\n\n<3> SQL Generation: The query requires the name and country for the artist with the most number of exhibitions, so we should select the 'Name' column in the 'artist' table and the 'Country' column in the 'artist' table.\n\nSQL query: SELECT T1.Name, T1.Country FROM artist AS T1 JOIN exhibition AS T2 ON T1.Artist_ID = T2.Artist_ID JOIN exhibition_record AS T3 ON T2.Exhibition_ID = T3.Exhibition_ID GROUP BY T1.Artist_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Name, T1.Country FROM artist AS T1 JOIN exhibition AS T2 ON T1.Artist_ID = T2.Artist_ID JOIN exhibition_record AS T3 ON T2.Exhibition_ID = T3.Exhibition_ID GROUP BY T1.Artist_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT T2.name , T2.country FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id GROUP BY T1.artist_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the name and country corresponding to the artist who has had the most exhibitions.",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Operation: The query requires the name and country corresponding to the artist who has had the most exhibitions, so we should apply the 'count' operation to the 'Exhibition_ID' column in the 'exhibition' table, and find the artist with the highest count. Since the unit to which the exhibitions being counted in the query belong is the artist, we should apply the 'group by' operation to the 'Artist_ID' column in the 'exhibition' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'exhibition' and 'artist', we need to use tables ['exhibition', 'artist'].\n\n<3> SQL Generation: The query requires the name and country corresponding to the artist who has had the most exhibitions, so we should select the 'Name' column in the 'artist' table and the 'Country' column in the 'artist' table.\n\nSQL query: SELECT T1.Name, T1.Country FROM artist AS T1 JOIN exhibition AS T2 ON T1.Artist_ID = T2.Artist_ID GROUP BY T2.Artist_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Name, T1.Country FROM artist AS T1 JOIN exhibition AS T2 ON T1.Artist_ID = T2.Artist_ID GROUP BY T2.Artist_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id ORDER BY avg(T2.rating) LIMIT 1",
        "question": "Find the name of the item with the lowest average rating.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Operation: The query requires the item with the lowest average rating, so we should apply the 'average' operation to the 'rating' column in the 'review' table and sort it in ascending order. Since the unit to which the average rating being calculated in the query belongs is the item, we should apply the 'group by' operation to the 'i_id' column in the 'review' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['item', 'review'].\n\n<3> SQL Generation: The query requires the name of the item with the lowest average rating, so we should select the 'title' column in the 'item' table and the average of the 'rating' column in the 'review' table.\n\nSQL query: SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id = T2.i_id GROUP BY T2.i_id ORDER BY AVG(T2.rating) ASC LIMIT 1",
        "predict": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id = T2.i_id GROUP BY T2.i_id ORDER BY AVG(T2.rating) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT T1.name FROM useracct AS T1 JOIN review AS T2 ON T1.u_id  =  T2.u_id GROUP BY T2.u_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the user who gives the most reviews.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the user who gives the most reviews, so we should apply the 'count' operation to the 'review' table for the 'u_id' column, and find the user with the highest count. Since the unit to which the reviews being counted in the query belong is the user, we should apply the 'group by' operation to the 'u_id' column in the 'review' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['useracct'].\n\n<3> SQL Generation: The query requires the name of the user who gives the most reviews, so we should select the 'name' column in the 'useracct' table.\n\nSQL query: SELECT name FROM useracct WHERE u_id = (SELECT u_id FROM review GROUP BY u_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT name FROM useracct WHERE u_id = (SELECT u_id FROM review GROUP BY u_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT T1.title ,  T1.i_id FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id ORDER BY avg(T2.rating) DESC LIMIT 1",
        "question": "Find the name and id of the item with the highest average rating.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Operation: The query requires the item with the highest average rating, so we should apply the 'average' operation to the 'rating' column in the 'review' table and sort it in descending order. Since the unit to which the average rating being calculated in the query belongs is the item, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['item', 'review'].\n\n<3> SQL Generation: The query requires the name and id of the item with the highest average rating, so we should select the 'title' column and 'i_id' column in the 'item' table.\n\nSQL query: SELECT title, i_id FROM item ORDER BY (SELECT AVG(rating) FROM review WHERE review.i_id = item.i_id) DESC LIMIT 1",
        "predict": "SELECT title, i_id FROM item ORDER BY (SELECT AVG(rating) FROM review WHERE review.i_id = item.i_id) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT T1.title ,  T1.i_id FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id ORDER BY avg(T2.rank) DESC LIMIT 1",
        "question": "Find the name and id of the good with the highest average rank.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Operation: The query requires the name and id of the good with the highest average rank, so we should apply the 'average' operation to the 'rank' column in the 'review' table and sort it in descending order. Since the unit to which the average rank being calculated in the query belongs is the item, we should apply the 'group by' operation to the 'i_id' column in the 'review' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['item', 'review'].\n\n<3> SQL Generation: The query requires the name and id of the good with the highest average rank, so we should select the 'title' column in the 'item' table and the 'i_id' column in the 'item' table. We also need to calculate the average of the 'rank' column in the 'review' table.\n\nSQL query: SELECT T1.title, T1.i_id FROM item AS T1 JOIN review AS T2 ON T1.i_id = T2.i_id GROUP BY T2.i_id ORDER BY AVG(T2.rank) DESC LIMIT 1",
        "predict": "SELECT T1.title, T1.i_id FROM item AS T1 JOIN review AS T2 ON T1.i_id = T2.i_id GROUP BY T2.i_id ORDER BY AVG(T2.rank) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT T1.name FROM useracct AS T1 JOIN trust AS T2 ON T1.u_id  =  T2.source_u_id GROUP BY T2.source_u_id ORDER BY avg(trust) DESC LIMIT 1",
        "question": "Find the name of the source user with the highest average trust score.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the source user with the highest average trust score, so we should apply the 'average' operation to the 'trust' table for the 'trust' column, and find the source user with the highest average. Since the unit to which the trust scores being calculated in the query belong is the source user, we should apply the 'group by' operation to the 'source_u_id' column in the 'trust' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use table ['trust', 'useracct'].\n\n<3> SQL Generation: The query requires the name of the source user with the highest average trust score, so we should select the 'name' column in the 'useracct' table and the average of the 'trust' column in the 'trust' table.\n\nSQL query: SELECT T2.name FROM trust AS T1 JOIN useracct AS T2 ON T1.source_u_id = T2.u_id GROUP BY T1.source_u_id ORDER BY AVG(T1.trust) DESC LIMIT 1",
        "predict": "SELECT T2.name FROM trust AS T1 JOIN useracct AS T2 ON T1.source_u_id = T2.u_id GROUP BY T1.source_u_id ORDER BY AVG(T1.trust) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "riding_club",
        "gold": "SELECT Occupation FROM player GROUP BY Occupation ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Please show the most common occupation of players.",
        "fields": "Table club, columns = [*,Club_ID,Club_name,Region,Start_year]\nTable coach, columns = [*,Coach_ID,Coach_name,Gender,Club_ID,Rank]\nTable match_result, columns = [*,Rank,Club_ID,Gold,Big_Silver,Small_Silver,Bronze,Points]\nTable player, columns = [*,Player_ID,Sponsor_name,Player_name,Gender,Residence,Occupation,Votes,Rank]\nTable player_coach, columns = [*,Player_ID,Coach_ID,Starting_year]\n",
        "foreign_keys": "Foreign_keys = [coach.Club_ID = club.Club_ID,player_coach.Coach_ID = coach.Coach_ID,player_coach.Player_ID = player.Player_ID,match_result.Club_ID = club.Club_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common occupation of players, so we should apply the 'count' operation to the 'occupation' column in the 'player' table and find the occupation with the highest count. Since the unit to which the occupations being counted in the query belong is the player, we should apply the 'group by' operation to the 'occupation' column in the 'player' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['player'].\n\n<3> SQL Generation: The query requires the most common occupation of players, so we should select the 'occupation' column in the 'player' table.\n\nSQL query: SELECT occupation FROM player GROUP BY occupation ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT occupation FROM player GROUP BY occupation ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "gymnast",
        "gold": "SELECT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the most common hometown of gymnasts?",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common hometown of gymnasts, so we should apply the 'count' operation to the 'Hometown' column in the 'people' table, and find the hometown with the highest count. Since the unit to which the hometowns being counted in the query belong is the gymnast, we should apply the 'group by' operation to the 'Hometown' column in the 'people' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['people'].\n\n<3> SQL Generation: The query requires the most common hometown of gymnasts, so we should select the 'Hometown' column in the 'people' table.\n\nSQL query: SELECT Hometown FROM people GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Hometown FROM people GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "gymnast",
        "gold": "SELECT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Return the hometown that is most common among gymnasts.",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n",
        "reasoning": "<1> Operation: The query requires the hometown that is most common among gymnasts, so we should apply the 'count' operation to the 'Hometown' column in the 'people' table, and find the hometown with the highest count. Since the unit to which the hometowns being counted in the query belong is the gymnast, we should apply the 'group by' operation to the 'Hometown' column in the 'people' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['gymnast', 'people'].\n\n<3> SQL Generation: The query requires the hometown that is most common among gymnasts, so we should select the 'Hometown' column in the 'people' table.\n\nSQL query: SELECT Hometown FROM people GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Hometown FROM people GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "browser_web",
        "gold": "SELECT T1.id ,  T1.name FROM browser AS T1 JOIN accelerator_compatible_browser AS T2 ON T1.id  =  T2.browser_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id and name of the browser that is compatible with the most web accelerators?",
        "fields": "Table Web_client_accelerator, columns = [*,id,name,Operating_system,Client,Connection]\nTable accelerator_compatible_browser, columns = [*,accelerator_id,browser_id,compatible_since_year]\nTable browser, columns = [*,id,name,market_share]\n",
        "foreign_keys": "Foreign_keys = [accelerator_compatible_browser.browser_id = browser.id,accelerator_compatible_browser.accelerator_id = Web_client_accelerator.id]\n",
        "reasoning": "<1> Operation: The query requires the id and name of the browser that is compatible with the most web accelerators, so we should apply the 'count' operation to the 'accelerator_id' column in the 'accelerator_compatible_browser' table, and find the browser with the highest count. Since the unit to which the web accelerators being counted in the query belong is the browser, we should apply the 'group by' operation to the 'browser_id' column in the 'accelerator_compatible_browser' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'accelerator_compatible_browser' and 'browser', we need to use tables ['accelerator_compatible_browser', 'browser'].\n\n<3> SQL Generation: The query requires the id and name of the browser that is compatible with the most web accelerators, so we should select the 'id' and 'name' columns in the 'browser' table.\n\nSQL query: SELECT T2.id, T2.name FROM accelerator_compatible_browser AS T1 JOIN browser AS T2 ON T1.browser_id = T2.id GROUP BY T1.browser_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.id, T2.name FROM accelerator_compatible_browser AS T1 JOIN browser AS T2 ON T1.browser_id = T2.id GROUP BY T1.browser_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "wrestler",
        "gold": "SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Please show the most common reigns of wrestlers.",
        "fields": "Table Elimination, columns = [*,Elimination_ID,Wrestler_ID,Team,Eliminated_By,Elimination_Move,Time]\nTable wrestler, columns = [*,Wrestler_ID,Name,Reign,Days_held,Location,Event]\n",
        "foreign_keys": "Foreign_keys = [Elimination.Wrestler_ID = wrestler.Wrestler_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common reigns of wrestlers, so we should apply the 'count' operation to the 'Reign' column in the 'wrestler' table and find the most common reigns. Since the unit to which the reigns being counted in the query belong is the wrestler, we should apply the 'group by' operation to the 'Reign' column in the 'wrestler' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['wrestler'].\n\n<3> SQL Generation: The query requires the most common reigns of wrestlers, so we should select the 'Reign' column in the 'wrestler' table.\n\nSQL query: SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "wrestler",
        "gold": "SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which reign is the most common among wrestlers?",
        "fields": "Table Elimination, columns = [*,Elimination_ID,Wrestler_ID,Team,Eliminated_By,Elimination_Move,Time]\nTable wrestler, columns = [*,Wrestler_ID,Name,Reign,Days_held,Location,Event]\n",
        "foreign_keys": "Foreign_keys = [Elimination.Wrestler_ID = wrestler.Wrestler_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common reign among wrestlers, so we should apply the 'count' operation to the 'Reign' column in the 'wrestler' table and find the reign with the highest count. Since the unit to which the reigns being counted in the query belong is the wrestler, we should apply the 'group by' operation to the 'Reign' column in the 'wrestler' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['wrestler'].\n\n<3> SQL Generation: The query requires the most common reign among wrestlers, so we should select the 'Reign' column in the 'wrestler' table.\n\nSQL query: SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "school_finance",
        "gold": "SELECT donator_name ,  sum(amount) FROM endowment GROUP BY donator_name ORDER BY sum(amount) DESC",
        "question": "List each donator name and the amount of endowment in descending order of the amount of endowment.",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n",
        "reasoning": "<1> Operation: The query requires the donator name and the amount of endowment, so we should select the 'donator_name' and 'amount' columns in the 'endowment' table. We also need to sort the result in descending order of the amount of endowment.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. In this question, we only need to use table ['endowment'].\n\n<3> SQL Generation: The query requires the donator name and the amount of endowment, so we should select the 'donator_name' and 'amount' columns in the 'endowment' table. We also need to sort the result in descending order of the amount of endowment.\n\nSQL query: SELECT donator_name, amount FROM endowment ORDER BY amount DESC",
        "predict": "SELECT donator_name, amount FROM endowment ORDER BY amount DESC",
        "hardness": "extra"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT TYPE FROM institution GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the institution type with the largest number of institutions.",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Operation: The query requires the institution type with the largest number of institutions, so we should apply the 'count' operation to the 'Institution' table for the 'Institution_id' column, and find the institution type with the highest count. Since the unit to which the institutions being counted in the query belong is the institution type, we should apply the 'group by' operation to the 'Type' column in the 'Institution' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Institution'].\n\n<3> SQL Generation: The query requires the institution type with the largest number of institutions, so we should select the 'Type' column in the 'Institution' table.\n\nSQL query: SELECT Type FROM Institution GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM Institution GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cinema",
        "gold": "SELECT LOCATION FROM cinema WHERE openning_year  >=  2010 GROUP BY LOCATION ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the location with the most cinemas opened in year 2010 or later?",
        "fields": "Table cinema, columns = [*,Cinema_ID,Name,Openning_year,Capacity,Location]\nTable film, columns = [*,Film_ID,Rank_in_series,Number_in_season,Title,Directed_by,Original_air_date,Production_code]\nTable schedule, columns = [*,Cinema_ID,Film_ID,Date,Show_times_per_day,Price]\n",
        "foreign_keys": "Foreign_keys = [schedule.Cinema_ID = cinema.Cinema_ID,schedule.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Operation: The query requires the location with the most cinemas opened in the year 2010 or later, so we should apply the 'count' operation to the 'Cinema_ID' column in the 'cinema' table, and find the location with the highest count. Since the unit to which the cinemas being counted in the query belong is the location, we should apply the 'group by' operation to the 'Location' column in the 'cinema' table. We also need to filter the cinemas opened in the year 2010 or later.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['cinema'].\n\n<3> SQL Generation: The query requires the location with the most cinemas opened in the year 2010 or later, so we should select the 'Location' column in the 'cinema' table.\n\nSQL query: SELECT Location FROM cinema WHERE Openning_year >= 2010 GROUP BY Location ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Location FROM cinema WHERE Openning_year >= 2010 GROUP BY Location ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "products_for_hire",
        "gold": "SELECT customer_id ,  sum(amount_paid) FROM Payments GROUP BY customer_id ORDER BY sum(amount_paid) DESC LIMIT 1",
        "question": "What is the maximum total amount paid by a customer? List the customer id and amount.",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n",
        "reasoning": "<1> Operation: The query requires the maximum total amount paid by a customer, so we should apply the 'sum' operation to the 'amount_paid' column in the 'Payments' table, and find the customer with the highest sum. Since the unit to which the amounts being summed in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Payments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Payments'].\n\n<3> SQL Generation: The query requires the maximum total amount paid by a customer, so we should select the 'customer_id' column in the 'Payments' table and the sum of the 'amount_paid' column in the 'Payments' table.\n\nSQL query: SELECT customer_id, SUM(amount_paid) FROM Payments GROUP BY customer_id ORDER BY SUM(amount_paid) DESC LIMIT 1",
        "predict": "SELECT customer_id, SUM(amount_paid) FROM Payments GROUP BY customer_id ORDER BY SUM(amount_paid) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "products_for_hire",
        "gold": "SELECT T1.booking_id ,  T1.amount_of_refund FROM Bookings AS T1 JOIN Payments AS T2 ON T1.booking_id  =  T2.booking_id GROUP BY T1.booking_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the id and the amount of refund of the booking that incurred the most times of payments?",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n",
        "reasoning": "<1> Operation: The query requires the id and the amount of refund of the booking that incurred the most times of payments, so we should apply the 'count' operation to the 'Payments' table for the 'booking_id' column, and find the booking with the highest count. Since the unit to which the payments being counted in the query belong is the booking, we should apply the 'group by' operation to the 'booking_id' column in the 'Payments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Bookings', 'Payments'].\n\n<3> SQL Generation: The query requires the id and the amount of refund of the booking that incurred the most times of payments, so we should select the 'booking_id' column in the 'Payments' table and the 'amount_of_refund' column in the 'Bookings' table.\n\nSQL query: SELECT T1.booking_id, T2.amount_of_refund FROM Payments AS T1 JOIN Bookings AS T2 ON T1.booking_id = T2.booking_id GROUP BY T1.booking_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.booking_id, T2.amount_of_refund FROM Payments AS T1 JOIN Bookings AS T2 ON T1.booking_id = T2.booking_id GROUP BY T1.booking_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "phone_market",
        "gold": "SELECT Carrier FROM phone GROUP BY Carrier ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most frequently used carrier of the phones.",
        "fields": "Table market, columns = [*,Market_ID,District,Num_of_employees,Num_of_shops,Ranking]\nTable phone, columns = [*,Name,Phone_ID,Memory_in_G,Carrier,Price]\nTable phone_market, columns = [*,Market_ID,Phone_ID,Num_of_stock]\n",
        "foreign_keys": "Foreign_keys = [phone_market.Phone_ID = phone.Phone_ID,phone_market.Market_ID = market.Market_ID]\n",
        "reasoning": "<1> Operation: The query requires the most frequently used carrier of the phones, so we should apply the 'count' operation to the 'Carrier' column in the 'phone' table and find the carrier with the highest count. Since the unit to which the carriers being counted in the query belong is the phone, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['phone'].\n\n<3> SQL Generation: The query requires the most frequently used carrier of the phones, so we should select the 'Carrier' column in the 'phone' table.\n\nSQL query: SELECT Carrier FROM phone GROUP BY Carrier ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Carrier FROM phone GROUP BY Carrier ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "phone_market",
        "gold": "SELECT T2.Name FROM phone_market AS T1 JOIN phone AS T2 ON T1.Phone_ID  =  T2.Phone_ID GROUP BY T2.Name HAVING sum(T1.Num_of_stock)  >=  2000 ORDER BY sum(T1.Num_of_stock) DESC",
        "question": "Show the names of phones that have total number of stocks bigger than 2000, in descending order of the total number of stocks.",
        "fields": "Table market, columns = [*,Market_ID,District,Num_of_employees,Num_of_shops,Ranking]\nTable phone, columns = [*,Name,Phone_ID,Memory_in_G,Carrier,Price]\nTable phone_market, columns = [*,Market_ID,Phone_ID,Num_of_stock]\n",
        "foreign_keys": "Foreign_keys = [phone_market.Phone_ID = phone.Phone_ID,phone_market.Market_ID = market.Market_ID]\n",
        "reasoning": "<1> Operation: The query requires the names of phones that have a total number of stocks greater than 2000, so we should apply the 'sum' operation to the 'Num_of_stock' column in the 'phone_market' table and sort it in descending order. Since the unit to which the total number of stocks being calculated in the query belongs is the phone, we should apply the 'group by' operation to the 'Phone_ID' column in the 'phone_market' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['phone', 'phone_market'].\n\n<3> SQL Generation: The query requires the names of phones that have a total number of stocks greater than 2000, so we should select the 'Name' column in the 'phone' table. We also need to join the 'phone' and 'phone_market' tables on the 'Phone_ID' column and filter the total number of stocks greater than 2000.\n\nSQL query: SELECT T1.Name FROM phone AS T1 JOIN phone_market AS T2 ON T1.Phone_ID = T2.Phone_ID GROUP BY T2.Phone_ID HAVING SUM(T2.Num_of_stock) > 2000 ORDER BY SUM(T2.Num_of_stock) DESC",
        "predict": "SELECT T1.Name FROM phone AS T1 JOIN phone_market AS T2 ON T1.Phone_ID = T2.Phone_ID GROUP BY T2.Phone_ID HAVING SUM(T2.Num_of_stock) > 2000 ORDER BY SUM(T2.Num_of_stock) DESC",
        "hardness": "hard"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT LOCATION ,  count(*) FROM gas_station GROUP BY LOCATION ORDER BY count(*)",
        "question": "For each location, how many gas stations are there in order?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Operation: The query requires the number of gas stations for each location, so we should apply the 'count' operation to the 'Station_ID' column in the 'gas_station' table, and it does not need sorting. Since the unit to which the gas stations being counted in the query belong is the location and only table 'gas_station' has the column 'Location', so we should apply the 'group by' operation to the 'Location' column in table 'gas_station'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no direct foreign key connection between the tables, we only need to use the 'gas_station' table.\n\n<3> SQL Generation: The query requires the number of gas stations for each location, so we should select the 'Location' column in the 'gas_station' table and count the 'Station_ID' column in the 'gas_station' table.\n\nSQL query: SELECT Location, COUNT(Station_ID) FROM gas_station GROUP BY Location ORDER BY COUNT(Station_ID)",
        "predict": "SELECT Location, COUNT(Station_ID) FROM gas_station GROUP BY Location ORDER BY COUNT(Station_ID)",
        "hardness": "extra"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT manager_name FROM gas_station WHERE open_year  >  2000 GROUP BY manager_name ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the manager name with most number of gas stations opened after 2000.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Operation: The query requires the manager name with the most number of gas stations opened after 2000, so we should apply the 'count' operation to the 'Station_ID' column in the 'station_company' table, and find the manager name with the highest count. We also need to filter the gas stations opened after 2000 in the 'gas_station' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'station_company' and 'gas_station', we need to use tables ['station_company', 'gas_station'].\n\n<3> SQL Generation: The query requires the manager name with the most number of gas stations opened after 2000, so we should select the 'Manager_Name' column in the 'gas_station' table.\n\nSQL query: SELECT Manager_Name FROM gas_station WHERE Open_Year > 2000 GROUP BY Manager_Name ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Manager_Name FROM gas_station WHERE Open_Year > 2000 GROUP BY Manager_Name ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT manager_name FROM gas_station WHERE open_year  >  2000 GROUP BY manager_name ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the manager with the most gas stations that opened after 2000?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the manager with the most gas stations that opened after 2000, so we should apply the 'count' operation to the 'gas_station' table for the 'Manager_Name' column, and find the manager with the highest count. We also need to filter the gas stations that opened after 2000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['gas_station'].\n\n<3> SQL Generation: The query requires the name of the manager with the most gas stations that opened after 2000, so we should select the 'Manager_Name' column in the 'gas_station' table.\n\nSQL query: SELECT Manager_Name FROM gas_station WHERE Open_Year > 2000 GROUP BY Manager_Name ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Manager_Name FROM gas_station WHERE Open_Year > 2000 GROUP BY Manager_Name ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "party_people",
        "gold": "SELECT T2.party_name FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of party with most number of members?",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the party with the most number of members, so we should apply the 'count' operation to the 'member' table for the 'Party_ID' column, and find the party with the highest count. Since the unit to which the members being counted in the query belong is the party, we should apply the 'group by' operation to the 'Party_ID' column in the 'member' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['member'].\n\n<3> SQL Generation: The query requires the name of the party with the most number of members, so we should select the 'Party_ID' column in the 'member' table and the 'Party_name' column in the 'party' table.\n\nSQL query: SELECT Party_name FROM party WHERE Party_ID = (SELECT Party_ID FROM member GROUP BY Party_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Party_name FROM party WHERE Party_ID = (SELECT Party_ID FROM member GROUP BY Party_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "party_people",
        "gold": "SELECT T2.party_name FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the name of the party with the most members.",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the party with the most members, so we should apply the 'count' operation to the 'member' table for the 'Party_ID' column, and find the party with the highest count. Since the unit to which the members being counted in the query belong is the party, we should apply the 'group by' operation to the 'Party_ID' column in the 'member' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['member'].\n\n<3> SQL Generation: The query requires the name of the party with the most members, so we should select the 'Party_ID' column in the 'member' table and the 'Party_name' column in the 'party' table.\n\nSQL query: SELECT Party_name FROM party WHERE Party_ID = (SELECT Party_ID FROM member GROUP BY Party_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Party_name FROM party WHERE Party_ID = (SELECT Party_ID FROM member GROUP BY Party_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "party_people",
        "gold": "SELECT T1.member_name FROM member AS T1 JOIN party_events AS T2 ON T1.member_id  =  T2.member_in_charge_id GROUP BY T2.member_in_charge_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the name of the member who is in charge of the most events.",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the member who is in charge of the most events, so we should apply the 'count' operation to the 'Member_in_charge_ID' column in the 'party_events' table, and find the member with the highest count. Since the unit to which the events being counted in the query belong is the member, we should apply the 'group by' operation to the 'Member_in_charge_ID' column in the 'party_events' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'member' and 'party_events', we need to use tables ['member', 'party_events'].\n\n<3> SQL Generation: The query requires the name of the member who is in charge of the most events, so we should select the 'Member_Name' column in the 'member' table.\n\nSQL query: SELECT Member_Name FROM member WHERE Member_ID = (SELECT Member_in_charge_ID FROM party_events GROUP BY Member_in_charge_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Member_Name FROM member WHERE Member_ID = (SELECT Member_in_charge_ID FROM party_events GROUP BY Member_in_charge_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "pilot_record",
        "gold": "SELECT Nationality FROM pilot GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common nationality of pilots.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Order_Year,Manufacturer,Model,Fleet_Series,Powertrain,Fuel_Propulsion]\nTable pilot, columns = [*,Pilot_ID,Pilot_name,Rank,Age,Nationality,Position,Join_Year,Team]\nTable pilot_record, columns = [*,Record_ID,Pilot_ID,Aircraft_ID,Date]\n",
        "foreign_keys": "Foreign_keys = [pilot_record.Aircraft_ID = aircraft.Aircraft_ID,pilot_record.Pilot_ID = pilot.Pilot_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common nationality of pilots, so we should apply the 'count' operation to the 'Nationality' column in the 'pilot' table and find the nationality with the highest count. Since the unit to which the nationalities being counted in the query belong is the pilot, we should apply the 'group by' operation to the 'Nationality' column in the 'pilot' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['pilot'].\n\n<3> SQL Generation: The query requires the most common nationality of pilots, so we should select the 'Nationality' column in the 'pilot' table.\n\nSQL query: SELECT Nationality FROM pilot GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Nationality FROM pilot GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Control_Systems",
        "gold": "SELECT document_id , count(copy_number) FROM Draft_Copies GROUP BY document_id ORDER BY count(copy_number) DESC LIMIT 1;",
        "question": "Which document has the most draft copies? List its document id and number of draft copies.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Circulation_History, columns = [*,document_id,draft_number,copy_number,employee_id]\nTable Document_Drafts, columns = [*,document_id,draft_number,draft_details]\nTable Documents, columns = [*,document_id,document_status_code,document_type_code,shipping_agent_code,receipt_date,receipt_number,other_details]\nTable Documents_Mailed, columns = [*,document_id,mailed_to_address_id,mailing_date]\nTable Draft_Copies, columns = [*,document_id,draft_number,copy_number]\nTable Employees, columns = [*,employee_id,role_code,employee_name,other_details]\nTable Ref_Document_Status, columns = [*,document_status_code,document_status_description]\nTable Ref_Document_Types, columns = [*,document_type_code,document_type_description]\nTable Ref_Shipping_Agents, columns = [*,shipping_agent_code,shipping_agent_name,shipping_agent_description]\nTable Roles, columns = [*,role_code,role_description]\n",
        "foreign_keys": "Foreign_keys = [Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code,Documents.document_status_code = Ref_Document_Status.document_status_code,Documents.document_type_code = Ref_Document_Types.document_type_code,Employees.role_code = Roles.role_code,Document_Drafts.document_id = Documents.document_id,Draft_Copies.document_id = Document_Drafts.document_id,Draft_Copies.draft_number = Document_Drafts.draft_number,Circulation_History.employee_id = Employees.employee_id,Circulation_History.document_id = Draft_Copies.document_id,Circulation_History.draft_number = Draft_Copies.draft_number,Circulation_History.copy_number = Draft_Copies.copy_number,Documents_Mailed.mailed_to_address_id = Addresses.address_id,Documents_Mailed.document_id = Documents.document_id]\n",
        "reasoning": "<1> Operation: The query requires the document with the most draft copies, so we should apply the 'count' operation to the 'document_id' column in the 'Draft_Copies' table, and find the document with the highest count. Since the unit to which the draft copies being counted in the query belong is the document, we should apply the 'group by' operation to the 'document_id' column in the 'Draft_Copies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Draft_Copies'].\n\n<3> SQL Generation: The query requires the document with the most draft copies, so we should select the 'document_id' column in the 'Draft_Copies' table and the count of the 'document_id' column in the 'Draft_Copies' table.\n\nSQL query: SELECT document_id, COUNT(*) FROM Draft_Copies GROUP BY document_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT document_id, COUNT(*) FROM Draft_Copies GROUP BY document_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "local_govt_in_alabama",
        "gold": "SELECT participant_type_code FROM participants GROUP BY participant_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most common participant type?",
        "fields": "Table Events, columns = [*,Event_ID,Service_ID,Event_Details]\nTable Participants, columns = [*,Participant_ID,Participant_Type_Code,Participant_Details]\nTable Participants_in_Events, columns = [*,Event_ID,Participant_ID]\nTable Services, columns = [*,Service_ID,Service_Type_Code]\n",
        "foreign_keys": "Foreign_keys = [Events.Service_ID = Services.Service_ID,Participants_in_Events.Event_ID = Events.Event_ID,Participants_in_Events.Participant_ID = Participants.Participant_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common participant type, so we should apply the 'count' operation to the 'Participant_Type_Code' column in the 'Participants' table and find the participant type with the highest count. Since the unit to which the participant types being counted in the query belong is the participant, we should apply the 'group by' operation to the 'Participant_Type_Code' column in the 'Participants' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Participants'].\n\n<3> SQL Generation: The query requires the most common participant type, so we should select the 'Participant_Type_Code' column in the 'Participants' table.\n\nSQL query: SELECT Participant_Type_Code FROM Participants GROUP BY Participant_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Participant_Type_Code FROM Participants GROUP BY Participant_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "local_govt_in_alabama",
        "gold": "SELECT Event_ID FROM Participants_in_Events GROUP BY Event_ID ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id of the event with the most participants?",
        "fields": "Table Events, columns = [*,Event_ID,Service_ID,Event_Details]\nTable Participants, columns = [*,Participant_ID,Participant_Type_Code,Participant_Details]\nTable Participants_in_Events, columns = [*,Event_ID,Participant_ID]\nTable Services, columns = [*,Service_ID,Service_Type_Code]\n",
        "foreign_keys": "Foreign_keys = [Events.Service_ID = Services.Service_ID,Participants_in_Events.Event_ID = Events.Event_ID,Participants_in_Events.Participant_ID = Participants.Participant_ID]\n",
        "reasoning": "<1> Operation: The query requires the id of the event with the most participants, so we should apply the 'count' operation to the 'Participants_in_Events' table for the 'Event_ID' column, and find the event with the highest count. Since the unit to which the participants being counted in the query belong is the event, we should apply the 'group by' operation to the 'Event_ID' column in the 'Participants_in_Events' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Participants_in_Events'].\n\n<3> SQL Generation: The query requires the id of the event with the most participants, so we should select the 'Event_ID' column in the 'Participants_in_Events' table.\n\nSQL query: SELECT Event_ID FROM Participants_in_Events GROUP BY Event_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Event_ID FROM Participants_in_Events GROUP BY Event_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid JOIN races AS T3 ON T2.raceid = T3.raceid WHERE T3.year > 2010 GROUP BY T1.driverid ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id and last name of the driver who participated in the most races after 2010?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Operation: The query requires the id and last name of the driver who participated in the most races after 2010, so we should apply the 'count' operation to the 'driverId' column in the 'results' table, and find the driver with the highest count. We also need to filter the races that occurred after 2010 in the 'races' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'results' and 'drivers', we need to use tables ['results', 'drivers'].\n\n<3> SQL Generation: The query requires the id and last name of the driver who participated in the most races after 2010, so we should select the 'driverId' column in the 'results' table and the 'driverId' and 'surname' columns in the 'drivers' table. We also need to filter the races that occurred after 2010.\n\nSQL query: SELECT T2.driverId, T2.surname FROM results AS T1 JOIN drivers AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T1.raceId = T3.raceId WHERE T3.year > 2010 GROUP BY T2.driverId ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.driverId, T2.surname FROM results AS T1 JOIN drivers AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T1.raceId = T3.raceId WHERE T3.year > 2010 GROUP BY T2.driverId ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid = T2.driverid JOIN races AS T3 ON T2.raceid = T3.raceid GROUP BY T1.driverid ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the id and surname of the driver who participated the most number of races?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Operation: The query requires the id and surname of the driver who participated in the most number of races, so we should apply the 'count' operation to the 'driverId' column in the 'results' table, and find the driver with the highest count. Since the unit to which the races being counted in the query belong is the driver, we should apply the 'group by' operation to the 'driverId' column in the 'results' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['results', 'drivers'].\n\n<3> SQL Generation: The query requires the id and surname of the driver who participated in the most number of races, so we should select the 'driverId' column and 'surname' column in the 'drivers' table.\n\nSQL query: SELECT driverId, surname FROM drivers WHERE driverId = (SELECT driverId FROM results GROUP BY driverId ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT driverId, surname FROM drivers WHERE driverId = (SELECT driverId FROM results GROUP BY driverId ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid = T2.driverid JOIN races AS T3 ON T2.raceid = T3.raceid GROUP BY T1.driverid ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the ids and last names of all drivers who participated in the most races?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Operation: The query requires the ids and last names of all drivers who participated in the most races, so we should apply the 'count' operation to the 'driverId' column in the 'results' table, and find the driver with the highest count. Since the unit to which the races being counted in the query belong is the driver, we should apply the 'group by' operation to the 'driverId' column in the 'results' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['results', 'drivers'].\n\n<3> SQL Generation: The query requires the ids and last names of all drivers who participated in the most races, so we should select the 'driverId' column and 'surname' column in the 'drivers' table.\n\nSQL query: SELECT driverId, surname FROM drivers WHERE driverId IN (SELECT driverId FROM results GROUP BY driverId ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT driverId, surname FROM drivers WHERE driverId IN (SELECT driverId FROM results GROUP BY driverId ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Please show the team that has the most number of technicians.",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Operation: The query requires the team that has the most number of technicians, so we should apply the 'count' operation to the 'technician_id' column in the 'technician' table, and find the team with the highest count. Since the unit to which the technicians being counted in the query belong is the team, we should apply the 'group by' operation to the 'Team' column in the 'technician' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['technician'].\n\n<3> SQL Generation: The query requires the team that has the most number of technicians, so we should select the 'Team' column in the 'technician' table.\n\nSQL query: SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What are the teams with the most technicians?",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Operation: The query requires the teams with the most technicians, so we should apply the 'count' operation to the 'technician' table for the 'Team' column, and find the team with the highest count. Since the unit to which the technicians being counted in the query belong is the team, we should apply the 'group by' operation to the 'Team' column in the 'technician' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['technician'].\n\n<3> SQL Generation: The query requires the teams with the most technicians, so we should select the 'Team' column in the 'technician' table.\n\nSQL query: SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "entrepreneur",
        "gold": "SELECT Investor FROM entrepreneur GROUP BY Investor ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the investor that has invested in the most number of entrepreneurs?",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n",
        "reasoning": "<1> Operation: The query requires the investor that has invested in the most number of entrepreneurs, so we should apply the 'count' operation to the 'Entrepreneur_ID' column in the 'entrepreneur' table, and find the investor with the highest count. Since the unit to which the entrepreneurs being counted in the query belong is the investor, we should apply the 'group by' operation to the 'Investor' column in the 'entrepreneur' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['entrepreneur'].\n\n<3> SQL Generation: The query requires the investor that has invested in the most number of entrepreneurs, so we should select the 'Investor' column in the 'entrepreneur' table.\n\nSQL query: SELECT Investor FROM entrepreneur GROUP BY Investor ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Investor FROM entrepreneur GROUP BY Investor ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "entrepreneur",
        "gold": "SELECT Investor FROM entrepreneur GROUP BY Investor ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Return the investor who have invested in the greatest number of entrepreneurs.",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n",
        "reasoning": "<1> Operation: The query requires the investor who has invested in the greatest number of entrepreneurs, so we should apply the 'count' operation to the 'Entrepreneur_ID' column in the 'entrepreneur' table, and find the investor with the highest count. Since the unit to which the entrepreneurs being counted in the query belong is the investor, we should apply the 'group by' operation to the 'Investor' column in the 'entrepreneur' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['entrepreneur'].\n\n<3> SQL Generation: The query requires the investor who has invested in the greatest number of entrepreneurs, so we should select the 'Investor' column in the 'entrepreneur' table.\n\nSQL query: SELECT Investor FROM entrepreneur GROUP BY Investor ORDER BY COUNT(Entrepreneur_ID) DESC LIMIT 1",
        "predict": "SELECT Investor FROM entrepreneur GROUP BY Investor ORDER BY COUNT(Entrepreneur_ID) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1",
        "question": "Which campus has the most degrees conferred in all times?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Operation: The query requires the campus that has the most degrees conferred in all times, so we should apply the 'sum' operation to the 'Degrees' column in the 'degrees' table, and find the campus with the highest sum. Since the unit to which the degrees being summed in the query belong is the campus, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['degrees'].\n\n<3> SQL Generation: The query requires the campus that has the most degrees conferred in all times, so we should select the 'Campus' column in the 'degrees' table and sum the 'Degrees' column.\n\nSQL query: SELECT Campus FROM degrees GROUP BY Campus ORDER BY SUM(Degrees) DESC LIMIT 1",
        "predict": "SELECT Campus FROM degrees GROUP BY Campus ORDER BY SUM(Degrees) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1",
        "question": "Which poll resource provided the most number of candidate information?",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Operation: The query requires the poll resource that provided the most number of candidate information, so we should apply the 'count' operation to the 'Candidate_ID' column in the 'candidate' table and find the poll resource with the highest count. Since the unit to which the candidate information being counted in the query belong is the poll resource, we should apply the 'group by' operation to the 'Poll_Source' column in the 'candidate' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['candidate'].\n\n<3> SQL Generation: The query requires the poll resource that provided the most number of candidate information, so we should select the 'Poll_Source' column in the 'candidate' table.\n\nSQL query: SELECT Poll_Source FROM candidate GROUP BY Poll_Source ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Poll_Source FROM candidate GROUP BY Poll_Source ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the poll resource associated with the most candidates.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Operation: The query requires the poll resource associated with the most candidates, so we should apply the 'count' operation to the 'Candidate_ID' column in the 'candidate' table, and find the poll resource with the highest count. Since the unit to which the candidates being counted in the query belong is the poll resource, we should apply the 'group by' operation to the 'Poll_Source' column in the 'candidate' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['candidate'].\n\n<3> SQL Generation: The query requires the poll resource associated with the most candidates, so we should select the 'Poll_Source' column in the 'candidate' table.\n\nSQL query: SELECT Poll_Source FROM candidate GROUP BY Poll_Source ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Poll_Source FROM candidate GROUP BY Poll_Source ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex ORDER BY avg(t2.unsure_rate) DESC LIMIT 1",
        "question": "What is the sex of the candidate who had the highest unsure rate?",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Operation: The query requires the sex of the candidate who had the highest unsure rate, so we should find the candidate with the highest unsure rate. Since the unit to which the unsure rates being compared in the query belong is the candidate, we do not need to apply any specific operation.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['candidate', 'people'].\n\n<3> SQL Generation: The query requires the sex of the candidate who had the highest unsure rate, so we should select the 'Sex' column in the 'people' table. We also need to filter the candidate with the highest unsure rate in the 'candidate' table.\n\nSQL query: SELECT T2.Sex FROM candidate AS T1 JOIN people AS T2 ON T1.People_ID = T2.People_ID WHERE T1.Unsure_rate = (SELECT MAX(Unsure_rate) FROM candidate)",
        "predict": "SELECT T2.Sex FROM candidate AS T1 JOIN people AS T2 ON T1.People_ID = T2.People_ID WHERE T1.Unsure_rate = (SELECT MAX(Unsure_rate) FROM candidate)",
        "hardness": "extra"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1",
        "question": "Find the movies with the highest average rating. Return the movie titles and average rating.",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Operation: The query requires the movies with the highest average rating, so we should apply the 'average' operation to the 'stars' column in the 'Rating' table and sort it in descending order. Since the unit to which the average rating being calculated in the query belongs is the movie, we should apply the 'group by' operation to the 'mID' column in the 'Rating' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Movie', 'Rating'].\n\n<3> SQL Generation: The query requires the movies with the highest average rating, so we should select the 'title' column in the 'Movie' table and the average of the 'stars' column in the 'Rating' table.\n\nSQL query: SELECT Movie.title, AVG(Rating.stars) FROM Movie JOIN Rating ON Movie.mID = Rating.mID GROUP BY Rating.mID ORDER BY AVG(Rating.stars) DESC LIMIT 1",
        "predict": "SELECT Movie.title, AVG(Rating.stars) FROM Movie JOIN Rating ON Movie.mID = Rating.mID GROUP BY Rating.mID ORDER BY AVG(Rating.stars) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1",
        "question": "What are the movie titles with the highest average rating and what are those ratings?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Operation: The query requires the movie titles with the highest average rating, so we should apply the 'average' operation to the 'stars' column in the 'Rating' table and sort it in descending order. Since the unit to which the average rating being calculated in the query belongs is the movie, we should apply the 'group by' operation to the 'mID' column in the 'Rating' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use tables ['Movie', 'Rating'].\n\n<3> SQL Generation: The query requires the movie titles with the highest average rating, so we should select the 'title' column in the 'Movie' table and the average of the 'stars' column in the 'Rating' table.\n\nSQL query: SELECT T1.title, AVG(T2.stars) FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID = T2.mID GROUP BY T2.mID ORDER BY AVG(T2.stars) DESC LIMIT 1",
        "predict": "SELECT T1.title, AVG(T2.stars) FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID = T2.mID GROUP BY T2.mID ORDER BY AVG(T2.stars) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT 1",
        "question": "What are the movie titles and average rating of the movies with the lowest average rating?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Operation: The query requires the movie titles and average rating of the movies with the lowest average rating, so we should apply the 'average' operation to the 'stars' column in the 'Rating' table and sort it in ascending order. Since the unit to which the average ratings being calculated in the query belong is the movie, we should apply the 'group by' operation to the 'mID' column in the 'Rating' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Movie', 'Rating'].\n\n<3> SQL Generation: The query requires the movie titles and average rating of the movies with the lowest average rating, so we should select the 'title' column in the 'Movie' table and the average of the 'stars' column in the 'Rating' table.\n\nSQL query: SELECT T1.title, AVG(T2.stars) FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID = T2.mID GROUP BY T2.mID ORDER BY AVG(T2.stars) ASC LIMIT 1",
        "predict": "SELECT T1.title, AVG(T2.stars) FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID = T2.mID GROUP BY T2.mID ORDER BY AVG(T2.stars) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;",
        "question": "What kind of decor has the least number of reservations?",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Operation: The query requires the decor that has the least number of reservations, so we should apply the 'count' operation to the 'Room' column in the 'Reservations' table, and find the decor with the lowest count. Since the unit to which the reservations being counted in the query belong is the decor, we should apply the 'group by' operation to the 'decor' column in the 'Rooms' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Reservations', 'Rooms'].\n\n<3> SQL Generation: The query requires the decor that has the least number of reservations, so we should select the 'decor' column in the 'Rooms' table and count the 'Room' column in the 'Reservations' table.\n\nSQL query: SELECT decor FROM Rooms JOIN Reservations ON Rooms.RoomId = Reservations.Room GROUP BY decor ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT decor FROM Rooms JOIN Reservations ON Rooms.RoomId = Reservations.Room GROUP BY decor ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;",
        "question": "What is the least popular kind of decor?",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Operation: The query requires the least popular kind of decor, so we should apply the 'count' operation to the 'decor' column in the 'Rooms' table and sort it in ascending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Rooms'.\n\n<3> SQL Generation: The query requires the least popular kind of decor, so we should select the 'decor' column in the 'Rooms' table.\n\nSQL query: SELECT decor FROM Rooms GROUP BY decor ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT decor FROM Rooms GROUP BY decor ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "party_host",
        "gold": "SELECT Nationality FROM HOST GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common nationality of hosts.",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common nationality of hosts, so we should apply the 'count' operation to the 'Nationality' column in the 'host' table and find the nationality with the highest count. Since the unit to which the nationalities being counted in the query belong is the host, we should apply the 'group by' operation to the 'Nationality' column in the 'host' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'host'.\n\n<3> SQL Generation: The query requires the most common nationality of hosts, so we should select the 'Nationality' column in the 'host' table.\n\nSQL query: SELECT Nationality FROM host GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Nationality FROM host GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "party_host",
        "gold": "SELECT Nationality FROM HOST GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which nationality has the most hosts?",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n",
        "reasoning": "<1> Operation: The query requires the nationality that has the most hosts, so we should apply the 'count' operation to the 'Host_ID' column in the 'party_host' table, and find the nationality with the highest count. Since the unit to which the hosts being counted in the query belong is the nationality and only table 'host' has the column 'Nationality', so we should apply the 'group by' operation to the 'Nationality' column in table 'host'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'host'.\n\n<3> SQL Generation: The query requires the nationality that has the most hosts, so we should select the 'Nationality' column in the 'host' table.\n\nSQL query: SELECT Nationality FROM host GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Nationality FROM host GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT T1.name ,  T1.max_speed FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the storm name and max speed which affected the greatest number of regions?",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Operation: The query requires the storm name and max speed which affected the greatest number of regions, so we should apply the 'count' operation to the 'Region_id' column in the 'affected_region' table, and find the storm with the highest count. Since the unit to which the regions being counted in the query belong is the storm, we should apply the 'group by' operation to the 'Storm_ID' column in the 'affected_region' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'affected_region' and 'storm', we need to use tables ['affected_region', 'storm'].\n\n<3> SQL Generation: The query requires the storm name and max speed which affected the greatest number of regions, so we should select the 'Name' column in the 'storm' table and the 'Max_speed' column in the 'storm' table.\n\nSQL query: SELECT Name, Max_speed FROM storm WHERE Storm_ID = (SELECT Storm_ID FROM affected_region GROUP BY Storm_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Name, Max_speed FROM storm WHERE Storm_ID = (SELECT Storm_ID FROM affected_region GROUP BY Storm_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT T1.name ,  T1.max_speed FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the name and max speed of the storm that affected the most regions.",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Operation: The query requires the name and max speed of the storm that affected the most regions, so we should apply the 'count' operation to the 'Storm_ID' column in the 'affected_region' table, and find the storm with the highest count. Since the unit to which the regions being counted in the query belong is the storm, we should apply the 'group by' operation to the 'Storm_ID' column in the 'affected_region' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'affected_region' and 'storm', we need to use tables ['affected_region', 'storm'].\n\n<3> SQL Generation: The query requires the name and max speed of the storm that affected the most regions, so we should select the 'Name' column in the 'storm' table and the 'Max_speed' column in the 'storm' table.\n\nSQL query: SELECT T1.Name, T1.Max_speed FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID = T2.Storm_ID GROUP BY T2.Storm_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Name, T1.Max_speed FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID = T2.Storm_ID GROUP BY T2.Storm_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "election",
        "gold": "SELECT T2.Party FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID GROUP BY T1.Party ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the name of the party that has the most delegates.",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the party that has the most delegates, so we should apply the 'count' operation to the 'Delegate' column in the 'election' table, and find the party with the highest count. Since the unit to which the delegates being counted in the query belong is the party, we should apply the 'group by' operation to the 'Party' column in the 'party' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['election', 'party'].\n\n<3> SQL Generation: The query requires the name of the party that has the most delegates, so we should select the 'Party' column in the 'party' table and the count of the 'Delegate' column in the 'election' table.\n\nSQL query: SELECT Party FROM party WHERE Party_ID = (SELECT Party FROM election GROUP BY Party ORDER BY COUNT(Delegate) DESC LIMIT 1)",
        "predict": "SELECT Party FROM party WHERE Party_ID = (SELECT Party FROM election GROUP BY Party ORDER BY COUNT(Delegate) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "election",
        "gold": "SELECT T2.Party FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID GROUP BY T1.Party ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which party has the largest number of delegates?",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Operation: The query requires the party with the largest number of delegates, so we should apply the 'count' operation to the 'Delegate' column in the 'election' table, and find the party with the highest count. Since the unit to which the delegates being counted in the query belong is the party, we should apply the 'group by' operation to the 'Party' column in the 'party' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['election', 'party'].\n\n<3> SQL Generation: The query requires the party with the largest number of delegates, so we should select the 'Party' column in the 'party' table and the count of the 'Delegate' column in the 'election' table.\n\nSQL query: SELECT Party FROM party WHERE Party_ID = (SELECT Party FROM election GROUP BY Party ORDER BY COUNT(Delegate) DESC LIMIT 1)",
        "predict": "SELECT Party FROM party WHERE Party_ID = (SELECT Party FROM election GROUP BY Party ORDER BY COUNT(Delegate) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "election",
        "gold": "SELECT Governor FROM party GROUP BY Governor ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the people that have been governor the most times.",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Operation: The query requires the people who have been governor the most times, so we should apply the 'count' operation to the 'Governor' column in the 'party' table, and find the person with the highest count. Since the unit to which the governorships being counted in the query belong is the person, we should apply the 'group by' operation to the 'Governor' column in the 'party' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['party'].\n\n<3> SQL Generation: The query requires the people who have been governor the most times, so we should select the 'Governor' column in the 'party' table.\n\nSQL query: SELECT Governor FROM party GROUP BY Governor ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Governor FROM party GROUP BY Governor ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "election",
        "gold": "SELECT Governor FROM party GROUP BY Governor ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which people severed as governor most frequently?",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Operation: The query requires the person who served as governor most frequently, so we should apply the 'count' operation to the 'Governor' column in the 'party' table, and find the governor with the highest count. Since the unit to which the governors being counted in the query belong is the person, we should apply the 'group by' operation to the 'Governor' column in the 'party' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['party'].\n\n<3> SQL Generation: The query requires the person who served as governor most frequently, so we should select the 'Governor' column in the 'party' table.\n\nSQL query: SELECT Governor FROM party GROUP BY Governor ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Governor FROM party GROUP BY Governor ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "election",
        "gold": "SELECT Comptroller ,  COUNT(*) FROM party GROUP BY Comptroller ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the people that have been comptroller the most times and the corresponding number of times.",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Operation: The query requires the people who have been comptroller the most times and the corresponding number of times, so we should apply the 'count' operation to the 'Comptroller' column in the 'party' table, and find the person with the highest count. Since the unit to which the comptrollers being counted in the query belong is the person, we should apply the 'group by' operation to the 'Comptroller' column in the 'party' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['party'].\n\n<3> SQL Generation: The query requires the people who have been comptroller the most times and the corresponding number of times, so we should select the 'Comptroller' column in the 'party' table and the count of the 'Comptroller' column in the 'party' table.\n\nSQL query: SELECT Comptroller, COUNT(*) FROM party GROUP BY Comptroller ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Comptroller, COUNT(*) FROM party GROUP BY Comptroller ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "election",
        "gold": "SELECT Comptroller ,  COUNT(*) FROM party GROUP BY Comptroller ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which people severed as comptroller most frequently? Give me the name of the person and the frequency count.",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Operation: The query requires the person who served as comptroller most frequently, so we should apply the 'count' operation to the 'Comptroller' column in the 'party' table, and find the person with the highest count. Since the unit to which the comptrollers being counted in the query belong is the person, we should apply the 'group by' operation to the 'Comptroller' column in the 'party' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['party'].\n\n<3> SQL Generation: The query requires the name of the person who served as comptroller most frequently, so we should select the 'Comptroller' column in the 'party' table and the count of the 'Comptroller' column in the 'party' table.\n\nSQL query: SELECT Comptroller, COUNT(*) FROM party GROUP BY Comptroller ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Comptroller, COUNT(*) FROM party GROUP BY Comptroller ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "news_report",
        "gold": "SELECT Nationality FROM journalist GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common nationality for journalists.",
        "fields": "Table event, columns = [*,Event_ID,Date,Venue,Name,Event_Attendance]\nTable journalist, columns = [*,journalist_ID,Name,Nationality,Age,Years_working]\nTable news_report, columns = [*,journalist_ID,Event_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [news_report.Event_ID = event.Event_ID,news_report.journalist_ID = journalist.journalist_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common nationality for journalists, so we should apply the 'count' operation to the 'Nationality' column in the 'journalist' table and find the nationality with the highest count. Since the unit to which the nationalities being counted in the query belong is the journalist, we should apply the 'group by' operation to the 'Nationality' column in the 'journalist' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['journalist'].\n\n<3> SQL Generation: The query requires the most common nationality for journalists, so we should select the 'Nationality' column in the 'journalist' table.\n\nSQL query: SELECT Nationality FROM journalist GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Nationality FROM journalist GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT Advisor ,  count(*) FROM Student GROUP BY Advisor ORDER BY count(Advisor) DESC LIMIT 1;",
        "question": "Which Advisor has most of students? List advisor and the number of students.",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the advisor with the most students, so we should apply the 'count' operation to the 'StuID' column in the 'Student' table, and find the advisor with the highest count. Since the unit to which the students being counted in the query belong is the advisor, we should apply the 'group by' operation to the 'Advisor' column in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the advisor with the most students, so we should select the 'Advisor' column in the 'Student' table and the count of the 'StuID' column in the 'Student' table.\n\nSQL query: SELECT Advisor, COUNT(*) FROM Student GROUP BY Advisor ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Advisor, COUNT(*) FROM Student GROUP BY Advisor ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT Major ,  count(*) FROM Student GROUP BY Major ORDER BY count(Major) ASC LIMIT 1;",
        "question": "Which major has least number of students? List the major and the number of students.",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the major with the least number of students, so we should apply the 'count' operation to the 'StuID' column in the 'Student' table and find the major with the lowest count. Since the unit to which the students being counted in the query belong is the major, we should apply the 'group by' operation to the 'Major' column in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the major with the least number of students, so we should select the 'Major' column in the 'Student' table and the count of the 'StuID' column in the 'Student' table.\n\nSQL query: SELECT Major, COUNT(*) FROM Student GROUP BY Major ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Major, COUNT(*) FROM Student GROUP BY Major ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT Student.Fname , Student.Lname FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID GROUP BY Student.StuID ORDER BY count(*) DESC LIMIT 1;",
        "question": "Which student visited restaurant most often? List student's first name and last name.",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the student who visited the restaurant most often, so we should apply the 'count' operation to the 'Visits_Restaurant' table for the 'StuID' column, and find the student with the highest count. Since the unit to which the visits being counted in the query belong is the student, we should apply the 'group by' operation to the 'StuID' column in the 'Visits_Restaurant' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Visits_Restaurant' and 'Student', we need to use tables ['Visits_Restaurant', 'Student'].\n\n<3> SQL Generation: The query requires the student who visited the restaurant most often, so we should select the 'Fname' and 'LName' columns in the 'Student' table.\n\nSQL query: SELECT Fname, LName FROM Student WHERE StuID = (SELECT StuID FROM Visits_Restaurant GROUP BY StuID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Fname, LName FROM Student WHERE StuID = (SELECT StuID FROM Visits_Restaurant GROUP BY StuID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "customer_deliveries",
        "gold": "SELECT t1.product_name ,   t1.product_price FROM products AS t1 JOIN regular_order_products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t2.product_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name and price of the product that has been ordered the greatest number of times.",
        "fields": "Table Actual_Order_Products, columns = [*,actual_order_id,product_id]\nTable Actual_Orders, columns = [*,actual_order_id,order_status_code,regular_order_id,actual_order_date]\nTable Addresses, columns = [*,address_id,address_details,city,zip_postcode,state_province_county,country]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,address_type,date_to]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,date_became_customer]\nTable Delivery_Route_Locations, columns = [*,location_code,route_id,location_address_id,location_name]\nTable Delivery_Routes, columns = [*,route_id,route_name,other_route_details]\nTable Employees, columns = [*,employee_id,employee_address_id,employee_name,employee_phone]\nTable Order_Deliveries, columns = [*,location_code,actual_order_id,delivery_status_code,driver_employee_id,truck_id,delivery_date]\nTable Products, columns = [*,product_id,product_name,product_price,product_description]\nTable Regular_Order_Products, columns = [*,regular_order_id,product_id]\nTable Regular_Orders, columns = [*,regular_order_id,distributer_id]\nTable Trucks, columns = [*,truck_id,truck_licence_number,truck_details]\n",
        "foreign_keys": "Foreign_keys = [Regular_Orders.distributer_id = Customers.customer_id,Regular_Order_Products.regular_order_id = Regular_Orders.regular_order_id,Regular_Order_Products.product_id = Products.product_id,Actual_Orders.regular_order_id = Regular_Orders.regular_order_id,Actual_Order_Products.actual_order_id = Actual_Orders.actual_order_id,Actual_Order_Products.product_id = Products.product_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Delivery_Route_Locations.route_id = Delivery_Routes.route_id,Delivery_Route_Locations.location_address_id = Addresses.address_id,Employees.employee_address_id = Addresses.address_id,Order_Deliveries.driver_employee_id = Employees.employee_id,Order_Deliveries.location_code = Delivery_Route_Locations.location_code,Order_Deliveries.actual_order_id = Actual_Orders.actual_order_id,Order_Deliveries.truck_id = Trucks.truck_id]\n",
        "reasoning": "<1> Operation: The query requires the name and price of the product that has been ordered the greatest number of times, so we should apply the 'count' operation to the 'product_id' column in the 'Regular_Order_Products' table, and find the product with the highest count. Since the unit to which the products being counted in the query belong is the product, we should apply the 'group by' operation to the 'product_id' column in the 'Regular_Order_Products' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Regular_Order_Products' and 'Products', we need to use tables ['Regular_Order_Products', 'Products'].\n\n<3> SQL Generation: The query requires the name and price of the product that has been ordered the greatest number of times, so we should select the 'product_name' and 'product_price' columns in the 'Products' table.\n\nSQL query: SELECT T2.product_name, T2.product_price FROM Regular_Order_Products AS T1 JOIN Products AS T2 ON T1.product_id = T2.product_id GROUP BY T1.product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.product_name, T2.product_price FROM Regular_Order_Products AS T1 JOIN Products AS T2 ON T1.product_id = T2.product_id GROUP BY T1.product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "customer_deliveries",
        "gold": "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the payment method that is used most frequently.",
        "fields": "Table Actual_Order_Products, columns = [*,actual_order_id,product_id]\nTable Actual_Orders, columns = [*,actual_order_id,order_status_code,regular_order_id,actual_order_date]\nTable Addresses, columns = [*,address_id,address_details,city,zip_postcode,state_province_county,country]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,address_type,date_to]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,date_became_customer]\nTable Delivery_Route_Locations, columns = [*,location_code,route_id,location_address_id,location_name]\nTable Delivery_Routes, columns = [*,route_id,route_name,other_route_details]\nTable Employees, columns = [*,employee_id,employee_address_id,employee_name,employee_phone]\nTable Order_Deliveries, columns = [*,location_code,actual_order_id,delivery_status_code,driver_employee_id,truck_id,delivery_date]\nTable Products, columns = [*,product_id,product_name,product_price,product_description]\nTable Regular_Order_Products, columns = [*,regular_order_id,product_id]\nTable Regular_Orders, columns = [*,regular_order_id,distributer_id]\nTable Trucks, columns = [*,truck_id,truck_licence_number,truck_details]\n",
        "foreign_keys": "Foreign_keys = [Regular_Orders.distributer_id = Customers.customer_id,Regular_Order_Products.regular_order_id = Regular_Orders.regular_order_id,Regular_Order_Products.product_id = Products.product_id,Actual_Orders.regular_order_id = Regular_Orders.regular_order_id,Actual_Order_Products.actual_order_id = Actual_Orders.actual_order_id,Actual_Order_Products.product_id = Products.product_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Delivery_Route_Locations.route_id = Delivery_Routes.route_id,Delivery_Route_Locations.location_address_id = Addresses.address_id,Employees.employee_address_id = Addresses.address_id,Order_Deliveries.driver_employee_id = Employees.employee_id,Order_Deliveries.location_code = Delivery_Route_Locations.location_code,Order_Deliveries.actual_order_id = Actual_Orders.actual_order_id,Order_Deliveries.truck_id = Trucks.truck_id]\n",
        "reasoning": "<1> Operation: The query requires the payment method that is used most frequently, so we should apply the 'count' operation to the 'Customers' table for the 'payment_method' column, and find the payment method with the highest count.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers'].\n\n<3> SQL Generation: The query requires the payment method that is used most frequently, so we should select the 'payment_method' column in the 'Customers' table.\n\nSQL query: SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customer_deliveries",
        "gold": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of route that has the highest number of deliveries.",
        "fields": "Table Actual_Order_Products, columns = [*,actual_order_id,product_id]\nTable Actual_Orders, columns = [*,actual_order_id,order_status_code,regular_order_id,actual_order_date]\nTable Addresses, columns = [*,address_id,address_details,city,zip_postcode,state_province_county,country]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,address_type,date_to]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,date_became_customer]\nTable Delivery_Route_Locations, columns = [*,location_code,route_id,location_address_id,location_name]\nTable Delivery_Routes, columns = [*,route_id,route_name,other_route_details]\nTable Employees, columns = [*,employee_id,employee_address_id,employee_name,employee_phone]\nTable Order_Deliveries, columns = [*,location_code,actual_order_id,delivery_status_code,driver_employee_id,truck_id,delivery_date]\nTable Products, columns = [*,product_id,product_name,product_price,product_description]\nTable Regular_Order_Products, columns = [*,regular_order_id,product_id]\nTable Regular_Orders, columns = [*,regular_order_id,distributer_id]\nTable Trucks, columns = [*,truck_id,truck_licence_number,truck_details]\n",
        "foreign_keys": "Foreign_keys = [Regular_Orders.distributer_id = Customers.customer_id,Regular_Order_Products.regular_order_id = Regular_Orders.regular_order_id,Regular_Order_Products.product_id = Products.product_id,Actual_Orders.regular_order_id = Regular_Orders.regular_order_id,Actual_Order_Products.actual_order_id = Actual_Orders.actual_order_id,Actual_Order_Products.product_id = Products.product_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Delivery_Route_Locations.route_id = Delivery_Routes.route_id,Delivery_Route_Locations.location_address_id = Addresses.address_id,Employees.employee_address_id = Addresses.address_id,Order_Deliveries.driver_employee_id = Employees.employee_id,Order_Deliveries.location_code = Delivery_Route_Locations.location_code,Order_Deliveries.actual_order_id = Actual_Orders.actual_order_id,Order_Deliveries.truck_id = Trucks.truck_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the route that has the highest number of deliveries, so we should apply the 'count' operation to the 'route_id' column in the 'Delivery_Route_Locations' table, and find the route with the highest count. Since the unit to which the deliveries being counted in the query belong is the route, we should apply the 'group by' operation to the 'route_id' column in the 'Delivery_Route_Locations' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Delivery_Route_Locations' and 'Delivery_Routes', we need to use tables ['Delivery_Route_Locations', 'Delivery_Routes'].\n\n<3> SQL Generation: The query requires the name of the route that has the highest number of deliveries, so we should select the 'route_name' column in the 'Delivery_Routes' table and the 'route_id' column in the 'Delivery_Route_Locations' table.\n\nSQL query: SELECT T2.route_name FROM Delivery_Route_Locations AS T1 JOIN Delivery_Routes AS T2 ON T1.route_id = T2.route_id GROUP BY T1.route_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.route_name FROM Delivery_Route_Locations AS T1 JOIN Delivery_Routes AS T2 ON T1.route_id = T2.route_id GROUP BY T1.route_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT t1.lname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid GROUP BY t1.fname ,  t1.lname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the last name of the author that has published the most papers?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Operation: The query requires the last name of the author that has published the most papers, so we should apply the 'count' operation to the 'paperID' column in the 'Authorship' table, and find the author with the highest count. Since the unit to which the papers being counted in the query belong is the author, we should apply the 'group by' operation to the 'authID' column in the 'Authorship' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Authorship' and 'Authors', we need to use tables ['Authorship', 'Authors'].\n\n<3> SQL Generation: The query requires the last name of the author that has published the most papers, so we should select the 'lname' column in the 'Authors' table.\n\nSQL query: SELECT lname FROM Authors WHERE authID = (SELECT authID FROM Authorship GROUP BY authID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT lname FROM Authors WHERE authID = (SELECT authID FROM Authorship GROUP BY authID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT t1.lname FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid GROUP BY t1.fname ,  t1.lname ORDER BY count(*) DESC LIMIT 1",
        "question": "Which author has written the most papers? Find his or her last name.",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Operation: The query requires the author who has written the most papers, so we should apply the 'count' operation to the 'authID' column in the 'Authorship' table, and find the author with the highest count. Since the unit to which the papers being counted in the query belong is the author, we should apply the 'group by' operation to the 'authID' column in the 'Authorship' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Authors', 'Authorship'].\n\n<3> SQL Generation: The query requires the author who has written the most papers, so we should select the 'lname' column in the 'Authors' table. We also need to join the 'Authors' table with the 'Authorship' table on the 'authID' column.\n\nSQL query: SELECT lname FROM Authors JOIN Authorship ON Authors.authID = Authorship.authID GROUP BY Authors.authID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT lname FROM Authors JOIN Authorship ON Authors.authID = Authorship.authID GROUP BY Authors.authID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT t1.country FROM inst AS t1 JOIN authorship AS t2 ON t1.instid  =  t2.instid JOIN papers AS t3 ON t2.paperid  =  t3.paperid GROUP BY t1.country ORDER BY count(*) DESC LIMIT 1",
        "question": "Retrieve the country that has published the most papers.",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Operation: The query requires the country that has published the most papers, so we should apply the 'count' operation to the 'paperID' column in the 'Authorship' table, and find the country with the highest count. Since the unit to which the papers being counted in the query belong is the country, we should apply the 'group by' operation to the 'country' column in the 'Inst' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Authorship' and 'Inst', we need to use tables ['Authorship', 'Inst'].\n\n<3> SQL Generation: The query requires the country that has published the most papers, so we should select the 'country' column in the 'Inst' table and the count of the 'paperID' column in the 'Authorship' table.\n\nSQL query: SELECT T2.country FROM Authorship AS T1 JOIN Inst AS T2 ON T1.instID = T2.instID GROUP BY T2.country ORDER BY COUNT(T1.paperID) DESC LIMIT 1",
        "predict": "SELECT T2.country FROM Authorship AS T1 JOIN Inst AS T2 ON T1.instID = T2.instID GROUP BY T2.country ORDER BY COUNT(T1.paperID) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT t1.country FROM inst AS t1 JOIN authorship AS t2 ON t1.instid  =  t2.instid JOIN papers AS t3 ON t2.paperid  =  t3.paperid GROUP BY t1.country ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the country that the most papers are affiliated with.",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Operation: The query requires the country that the most papers are affiliated with, so we should apply the 'count' operation to the 'paperID' column in the 'Authorship' table, and find the country with the highest count. Since the unit to which the papers being counted in the query belong is the country, we should apply the 'group by' operation to the 'country' column in the 'Inst' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Authorship' and 'Inst', we need to use tables ['Authorship', 'Inst'].\n\n<3> SQL Generation: The query requires the country that the most papers are affiliated with, so we should select the 'country' column in the 'Inst' table and the count of the 'paperID' column in the 'Authorship' table.\n\nSQL query: SELECT T2.country FROM Authorship AS T1 JOIN Inst AS T2 ON T1.instID = T2.instID GROUP BY T2.country ORDER BY COUNT(T1.paperID) DESC LIMIT 1",
        "predict": "SELECT T2.country FROM Authorship AS T1 JOIN Inst AS T2 ON T1.instID = T2.instID GROUP BY T2.country ORDER BY COUNT(T1.paperID) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT t1.name FROM inst AS t1 JOIN authorship AS t2 ON t1.instid  =  t2.instid JOIN papers AS t3 ON t2.paperid  =  t3.paperid GROUP BY t1.name ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the organization that has published the largest number of papers.",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Operation: The query requires the organization that has published the largest number of papers, so we should apply the 'count' operation to the 'paperID' column in the 'Authorship' table, and sort it in descending order. Since the unit to which the papers being counted in the query belong is the organization and only table 'Inst' has the column 'instID', so we should apply the 'group by' operation to the 'instID' column in the 'Authorship' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Authorship' and 'Inst', we need to use tables ['Authorship', 'Inst'].\n\n<3> SQL Generation: The query requires the name of the organization that has published the largest number of papers, so we should select the 'name' column in the 'Inst' table. The query does not require the count of most papers, so it is only used for filtering and not selected.\n\nSQL query: SELECT T2.name FROM Authorship AS T1 JOIN Inst AS T2 ON T1.instID = T2.instID GROUP BY T1.instID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.name FROM Authorship AS T1 JOIN Inst AS T2 ON T1.instID = T2.instID GROUP BY T1.instID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT t1.name FROM inst AS t1 JOIN authorship AS t2 ON t1.instid  =  t2.instid JOIN papers AS t3 ON t2.paperid  =  t3.paperid GROUP BY t1.name ORDER BY count(*) DESC LIMIT 1",
        "question": "Which institution has the most papers? Find the name of the institution.",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Operation: The query requires the institution with the most papers, so we should apply the 'count' operation to the 'paperID' column in the 'Authorship' table, and find the institution with the highest count. Since the unit to which the papers being counted in the query belong is the institution, we should apply the 'group by' operation to the 'instID' column in the 'Authorship' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Inst', 'Authorship'].\n\n<3> SQL Generation: The query requires the institution with the most papers, so we should select the 'name' column in the 'Inst' table.\n\nSQL query: SELECT name FROM Inst WHERE instID = (SELECT instID FROM Authorship GROUP BY instID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT name FROM Inst WHERE instID = (SELECT instID FROM Authorship GROUP BY instID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT first_name FROM actor GROUP BY first_name ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most popular first name of the actors?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the most popular first name of the actors, so we should apply the 'count' operation to the 'actor' table for the 'first_name' column, and find the first name with the highest count. Since the unit to which the first names being counted in the query belong is the actor, we should apply the 'group by' operation to the 'first_name' column in the 'actor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['actor'].\n\n<3> SQL Generation: The query requires the most popular first name of the actors, so we should select the 'first_name' column in the 'actor' table.\n\nSQL query: SELECT first_name FROM actor GROUP BY first_name ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT first_name FROM actor GROUP BY first_name ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT first_name FROM actor GROUP BY first_name ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the most common first name among all actors.",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the most common first name among all actors, so we should apply the 'count' operation to the 'first_name' column in the 'actor' table, and find the first name with the highest count. Since the unit to which the first names being counted in the query belong is the actor, we should apply the 'group by' operation to the 'first_name' column in the 'actor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['actor'].\n\n<3> SQL Generation: The query requires the most common first name among all actors, so we should select the 'first_name' column in the 'actor' table.\n\nSQL query: SELECT first_name FROM actor GROUP BY first_name ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT first_name FROM actor GROUP BY first_name ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT first_name ,  last_name FROM actor GROUP BY first_name ,  last_name ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most popular full name of the actors?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the most popular full name of the actors, so we should apply the 'count' operation to the 'actor' table for the 'first_name' and 'last_name' columns, and find the combination of first name and last name with the highest count. Since the unit to which the full names being counted in the query belong is the actor, we should apply the 'group by' operation to the 'first_name' and 'last_name' columns in the 'actor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['actor'].\n\n<3> SQL Generation: The query requires the most popular full name of the actors, so we should select the 'first_name' and 'last_name' columns in the 'actor' table.\n\nSQL query: SELECT first_name, last_name FROM actor GROUP BY first_name, last_name ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT first_name, last_name FROM actor GROUP BY first_name, last_name ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT T2.city ,  count(*) ,  T1.city_id FROM address AS T1 JOIN city AS T2 ON T1.city_id  =  T2.city_id GROUP BY T1.city_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which city has the most addresses? List the city name, number of addresses, and city id.",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the city with the most addresses, so we should apply the 'count' operation to the 'address' table for the 'city_id' column, and find the city with the highest count. Since the unit to which the addresses being counted in the query belong is the city, we should apply the 'group by' operation to the 'city_id' column in the 'address' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['address', 'city'].\n\n<3> SQL Generation: The query requires the city with the most addresses, so we should select the 'city' column in the 'city' table and the count of the 'address_id' column in the 'address' table.\n\nSQL query: SELECT city.city, COUNT(address.address_id) AS num_addresses, city.city_id FROM address JOIN city ON address.city_id = city.city_id GROUP BY address.city_id ORDER BY num_addresses DESC LIMIT 1",
        "predict": "SELECT city.city, COUNT(address.address_id) AS num_addresses, city.city_id FROM address JOIN city ON address.city_id = city.city_id GROUP BY address.city_id ORDER BY num_addresses DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT T2.city ,  count(*) ,  T1.city_id FROM address AS T1 JOIN city AS T2 ON T1.city_id  =  T2.city_id GROUP BY T1.city_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the city name, id, and number of addresses corresponding to the city with the most addressed?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the city name, id, and number of addresses corresponding to the city with the most addresses, so we should apply the 'count' operation to the 'address' table for the 'city_id' column, and find the city with the highest count. Since the unit to which the addresses being counted in the query belong is the city, we should apply the 'group by' operation to the 'city_id' column in the 'address' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['city', 'address'].\n\n<3> SQL Generation: The query requires the city name, id, and number of addresses corresponding to the city with the most addresses, so we should select the 'city_id' and 'city' columns in the 'city' table and the count of the 'address_id' column in the 'address' table.\n\nSQL query: SELECT city.city_id, city.city, COUNT(address.address_id) FROM city JOIN address ON city.city_id = address.city_id GROUP BY city.city_id, city.city ORDER BY COUNT(address.address_id) DESC LIMIT 1",
        "predict": "SELECT city.city_id, city.city, COUNT(address.address_id) FROM city JOIN address ON city.city_id = address.city_id GROUP BY city.city_id, city.city ORDER BY COUNT(address.address_id) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT T2.title ,  T2.film_id ,  T2.description FROM film_actor AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id GROUP BY T2.film_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which film has the most number of actors or actresses? List the film name, film id and description.",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the film with the most number of actors or actresses, so we should apply the 'count' operation to the 'film_actor' table for the 'film_id' column, and find the film with the highest count. Since the unit to which the actors or actresses being counted in the query belong is the film, we should apply the 'group by' operation to the 'film_id' column in the 'film_actor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'film' and 'film_actor', we need to use tables ['film', 'film_actor'].\n\n<3> SQL Generation: The query requires the film with the most number of actors or actresses, so we should select the 'title', 'film_id', and 'description' columns in the 'film' table.\n\nSQL query: SELECT T1.title, T1.film_id, T1.description FROM film AS T1 JOIN film_actor AS T2 ON T1.film_id = T2.film_id GROUP BY T1.film_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.title, T1.film_id, T1.description FROM film AS T1 JOIN film_actor AS T2 ON T1.film_id = T2.film_id GROUP BY T1.film_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT T2.title ,  T2.film_id ,  T2.description FROM film_actor AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id GROUP BY T2.film_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the title, id, and description of the movie with the greatest number of actors?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the title, id, and description of the movie with the greatest number of actors, so we should apply the 'count' operation to the 'film_actor' table for the 'film_id' column, and find the movie with the highest count. Since the unit to which the actors being counted in the query belong is the movie, we should apply the 'group by' operation to the 'film_id' column in the 'film_actor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'film' and 'film_actor', we need to use tables ['film', 'film_actor'].\n\n<3> SQL Generation: The query requires the title, id, and description of the movie with the greatest number of actors, so we should select the 'title', 'film_id', and 'description' columns in the 'film' table.\n\nSQL query: SELECT title, film_id, description FROM film WHERE film_id = (SELECT film_id FROM film_actor GROUP BY film_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT title, film_id, description FROM film WHERE film_id = (SELECT film_id FROM film_actor GROUP BY film_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT T2.first_name ,  T2.last_name ,  T2.actor_id FROM film_actor AS T1 JOIN actor AS T2 ON T1.actor_id  =  T2.actor_id GROUP BY T2.actor_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which film actor (actress) starred the most films? List his or her first name, last name and actor id.",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the film actor (actress) who starred in the most films, so we should apply the 'count' operation to the 'film_actor' table for the 'actor_id' column, and find the actor with the highest count. Since the unit to which the films being counted in the query belong is the actor, we should apply the 'group by' operation to the 'actor_id' column in the 'film_actor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['actor'].\n\n<3> SQL Generation: The query requires the first name, last name, and actor id of the actor who starred in the most films, so we should select the 'first_name', 'last_name', and 'actor_id' columns in the 'actor' table.\n\nSQL query: SELECT first_name, last_name, actor_id FROM actor WHERE actor_id = (SELECT actor_id FROM film_actor GROUP BY actor_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT first_name, last_name, actor_id FROM actor WHERE actor_id = (SELECT actor_id FROM film_actor GROUP BY actor_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT T2.first_name ,  T2.last_name ,  T2.actor_id FROM film_actor AS T1 JOIN actor AS T2 ON T1.actor_id  =  T2.actor_id GROUP BY T2.actor_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the full name and id of the actor or actress who starred in the greatest number of films.",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the full name and id of the actor or actress who starred in the greatest number of films, so we should apply the 'count' operation to the 'film_actor' table for the 'actor_id' column, and find the actor or actress with the highest count. Since the unit to which the films being counted in the query belong is the actor or actress, we should apply the 'group by' operation to the 'actor_id' column in the 'film_actor' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['actor'].\n\n<3> SQL Generation: The query requires the full name and id of the actor or actress who starred in the greatest number of films, so we should select the 'first_name', 'last_name', and 'actor_id' columns in the 'actor' table.\n\nSQL query: SELECT first_name, last_name, actor_id FROM actor WHERE actor_id = (SELECT actor_id FROM film_actor GROUP BY actor_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT first_name, last_name, actor_id FROM actor WHERE actor_id = (SELECT actor_id FROM film_actor GROUP BY actor_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT store_id FROM inventory GROUP BY store_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which store owns most items?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the store that owns the most items, so we should apply the 'count' operation to the 'inventory' table for the 'film_id' column, and find the store with the highest count. Since the unit to which the items being counted in the query belong is the store, we should apply the 'group by' operation to the 'store_id' column in the 'inventory' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['inventory'].\n\n<3> SQL Generation: The query requires the store that owns the most items, so we should select the 'store_id' column in the 'inventory' table.\n\nSQL query: SELECT store_id FROM inventory GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT store_id FROM inventory GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT store_id FROM inventory GROUP BY store_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id of the store that has the most items in inventory?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the id of the store that has the most items in inventory, so we should apply the 'count' operation to the 'inventory' table for the 'film_id' column, and find the store with the highest count. Since the unit to which the items in inventory being counted in the query belong is the store, we should apply the 'group by' operation to the 'store_id' column in the 'inventory' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['inventory'].\n\n<3> SQL Generation: The query requires the id of the store that has the most items in inventory, so we should select the 'store_id' column in the 'inventory' table.\n\nSQL query: SELECT store_id FROM inventory GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT store_id FROM inventory GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT T1.title ,  T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which film has the most copies in the inventory? List both title and id.",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the film with the most copies in the inventory, so we should apply the 'count' operation to the 'film_id' column in the 'inventory' table, and find the film with the highest count. Since the unit to which the copies being counted in the query belong is the film, we should apply the 'group by' operation to the 'film_id' column in the 'inventory' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['film', 'inventory'].\n\n<3> SQL Generation: The query requires the film with the most copies in the inventory, so we should select the 'title' column in the 'film' table and the 'film_id' column in the 'inventory' table.\n\nSQL query: SELECT film.title, inventory.film_id FROM film JOIN inventory ON film.film_id = inventory.film_id GROUP BY inventory.film_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT film.title, inventory.film_id FROM film JOIN inventory ON film.film_id = inventory.film_id GROUP BY inventory.film_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT T1.title ,  T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the title and id of the film that has the greatest number of copies in inventory?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the title and id of the film that has the greatest number of copies in inventory, so we should apply the 'count' operation to the 'inventory' table for the 'film_id' column, and find the film with the highest count. Since the unit to which the copies being counted in the query belong is the film, we should apply the 'group by' operation to the 'film_id' column in the 'inventory' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'film' and 'inventory', we need to use tables ['film', 'inventory'].\n\n<3> SQL Generation: The query requires the title and id of the film that has the greatest number of copies in inventory, so we should select the 'title' and 'film_id' columns in the 'film' table and the count of the 'film_id' column in the 'inventory' table.\n\nSQL query: SELECT T1.title, T2.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id = T2.film_id GROUP BY T2.film_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.title, T2.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id = T2.film_id GROUP BY T2.film_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT store_id FROM customer GROUP BY store_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which store has most the customers?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the store that has the most customers, so we should apply the 'count' operation to the 'customer' table for the 'store_id' column, and find the store with the highest count. Since the unit to which the customers being counted in the query belong is the store, we should apply the 'group by' operation to the 'store_id' column in the 'customer' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['customer'].\n\n<3> SQL Generation: The query requires the store that has the most customers, so we should select the 'store_id' column in the 'customer' table.\n\nSQL query: SELECT store_id FROM customer GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT store_id FROM customer GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT store_id FROM customer GROUP BY store_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the id of the store with the most customers.",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the id of the store with the most customers, so we should apply the 'count' operation to the 'customer' table for the 'store_id' column, and find the store with the highest count. Since the unit to which the customers being counted in the query belong is the store, we should apply the 'group by' operation to the 'store_id' column in the 'customer' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['customer'].\n\n<3> SQL Generation: The query requires the id of the store with the most customers, so we should select the 'store_id' column in the 'customer' table.\n\nSQL query: SELECT store_id FROM customer GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT store_id FROM customer GROUP BY store_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount)",
        "question": "List the name of all different customers who have some loan sorted by their total loan amount.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of all different customers who have some loan, so we should apply the 'count' operation to the 'cust_ID' column in the 'loan' table, and it does not need sorting. Since the unit to which the loans being counted in the query belong is the customer, we should apply the 'group by' operation to the 'cust_ID' column in the 'loan' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'customer' and 'loan', we need to use tables ['customer', 'loan'].\n\n<3> SQL Generation: The query requires the name of all different customers who have some loan, so we should select the 'cust_name' column in the 'customer' table. The query does not require the count of loans, so it is only used for filtering and not selected. We also need to sort the result by the total loan amount.\n\nSQL query: SELECT DISTINCT cust_name FROM customer WHERE cust_ID IN (SELECT cust_ID FROM loan) ORDER BY (SELECT SUM(amount) FROM loan WHERE loan.cust_ID = customer.cust_ID)",
        "predict": "SELECT DISTINCT cust_name FROM customer WHERE cust_ID IN (SELECT cust_ID FROM loan) ORDER BY (SELECT SUM(amount) FROM loan WHERE loan.cust_ID = customer.cust_ID)",
        "hardness": "hard"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount) DESC LIMIT 1",
        "question": "Find the name of customer who has the highest amount of loans.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the customer who has the highest amount of loans, so we should apply the 'max' operation to the 'no_of_loans' column in the 'customer' table. Since we are looking for the customer with the highest amount of loans, we do not need to sort the results.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'customer'.\n\n<3> SQL Generation: The query requires the name of the customer who has the highest amount of loans, so we should select the 'cust_name' column in the 'customer' table.\n\nSQL query: SELECT cust_name FROM customer WHERE no_of_loans = (SELECT MAX(no_of_loans) FROM customer)",
        "predict": "SELECT cust_name FROM customer WHERE no_of_loans = (SELECT MAX(no_of_loans) FROM customer)",
        "hardness": "extra"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount) DESC LIMIT 1",
        "question": "What is the name of the customer who has greatest total loan amount?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the customer who has the greatest total loan amount, so we should apply the 'sum' operation to the 'amount' column in the 'loan' table and find the customer with the highest sum. Since the unit to which the loan amounts being summed in the query belong is the customer, we should apply the 'group by' operation to the 'cust_ID' column in the 'loan' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'customer' and 'loan', we need to use tables ['customer', 'loan'].\n\n<3> SQL Generation: The query requires the name of the customer who has the greatest total loan amount, so we should select the 'cust_name' column in the 'customer' table and the sum of the 'amount' column in the 'loan' table.\n\nSQL query: SELECT cust_name FROM customer WHERE cust_ID = (SELECT cust_ID FROM loan GROUP BY cust_ID ORDER BY SUM(amount) DESC LIMIT 1)",
        "predict": "SELECT cust_name FROM customer WHERE cust_ID = (SELECT cust_ID FROM loan GROUP BY cust_ID ORDER BY SUM(amount) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT state FROM bank GROUP BY state ORDER BY sum(no_of_customers) DESC LIMIT 1",
        "question": "Find the state which has the most number of customers.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Operation: The query requires the state with the most number of customers, so we should apply the 'count' operation to the 'cust_ID' column in the 'customer' table and find the state with the highest count. Since the unit to which the customers being counted in the query belong is the state, we should apply the 'group by' operation to the 'state' column in the 'customer' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'customer' and 'bank', we need to use tables ['customer', 'bank'].\n\n<3> SQL Generation: The query requires the state with the most number of customers, so we should select the 'state' column in the 'customer' table.\n\nSQL query: SELECT state FROM customer GROUP BY state ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT state FROM customer GROUP BY state ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id GROUP BY T1.bname ORDER BY sum(T2.amount) DESC LIMIT 1",
        "question": "Find the name of bank branch that provided the greatest total amount of loans.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Operation: The query requires the bank branch that provided the greatest total amount of loans, so we should apply the 'sum' operation to the 'amount' column in the 'loan' table and sort it in descending order. Since the unit to which the loan amounts being summed in the query belong is the bank branch, we should apply the 'group by' operation to the 'branch_ID' column in the 'loan' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'loan' and 'bank', we need to use tables ['loan', 'bank'].\n\n<3> SQL Generation: The query requires the name of the bank branch that provided the greatest total amount of loans, so we should select the 'bname' column in the 'bank' table. The query does not require the sum of loan amounts, so it is only used for sorting and not selected.\n\nSQL query: SELECT bname FROM bank JOIN loan ON bank.branch_ID = loan.branch_ID GROUP BY loan.branch_ID ORDER BY SUM(amount) DESC LIMIT 1",
        "predict": "SELECT bname FROM bank JOIN loan ON bank.branch_ID = loan.branch_ID GROUP BY loan.branch_ID ORDER BY SUM(amount) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id GROUP BY T1.bname ORDER BY sum(T2.amount) DESC LIMIT 1",
        "question": "What is the name of the bank branch that has lent the greatest amount?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the bank branch that has lent the greatest amount, so we should apply the 'sum' operation to the 'amount' column in the 'loan' table and sort it in descending order. Since the unit to which the amounts being summed in the query belong is the bank branch, we should apply the 'group by' operation to the 'branch_ID' column in the 'loan' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'loan' and 'bank', we need to use tables ['loan', 'bank'].\n\n<3> SQL Generation: The query requires the name of the bank branch that has lent the greatest amount, so we should select the 'bname' column in the 'bank' table. The query does not require the sum of the greatest amount, so it is only used for sorting and not selected.\n\nSQL query: SELECT bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_ID = T2.branch_ID GROUP BY T2.branch_ID ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "predict": "SELECT bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_ID = T2.branch_ID GROUP BY T2.branch_ID ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T2.bname FROM loan AS T1 JOIN bank AS T2 ON T1.branch_id  =  T2.branch_id JOIN customer AS T3 ON T1.cust_id  =  T3.cust_id WHERE T3.credit_score  <  100 GROUP BY T2.bname ORDER BY sum(T1.amount) DESC LIMIT 1",
        "question": "Find the name of bank branch that provided the greatest total amount of loans to customers with credit score is less than 100.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the bank branch that provided the greatest total amount of loans to customers with a credit score less than 100, so we should apply the 'sum' operation to the 'amount' column in the 'loan' table and sort it in descending order. We also need to filter the customers with a credit score less than 100 in the 'customer' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'customer' and 'loan', we need to use tables ['customer', 'loan'].\n\n<3> SQL Generation: The query requires the name of the bank branch that provided the greatest total amount of loans to customers with a credit score less than 100, so we should select the 'bname' column in the 'bank' table. We also need to join the 'customer' and 'loan' tables based on the branch ID and filter the customers with a credit score less than 100.\n\nSQL query: SELECT bname FROM bank WHERE branch_ID IN (SELECT branch_ID FROM customer WHERE credit_score < 100) ORDER BY (SELECT SUM(amount) FROM loan WHERE loan.branch_ID = bank.branch_ID) DESC LIMIT 1",
        "predict": "SELECT bname FROM bank WHERE branch_ID IN (SELECT branch_ID FROM customer WHERE credit_score < 100) ORDER BY (SELECT SUM(amount) FROM loan WHERE loan.branch_ID = bank.branch_ID) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T2.bname FROM loan AS T1 JOIN bank AS T2 ON T1.branch_id  =  T2.branch_id JOIN customer AS T3 ON T1.cust_id  =  T3.cust_id WHERE T3.credit_score  <  100 GROUP BY T2.bname ORDER BY sum(T1.amount) DESC LIMIT 1",
        "question": "What is the name of the bank branch that has lended the largest total amount in loans, specifically to customers with credit scores below 100?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the bank branch that has lent the largest total amount in loans to customers with credit scores below 100, so we should apply the 'sum' operation to the 'amount' column in the 'loan' table and sort it in descending order. We also need to filter the customers with credit scores below 100 in the 'customer' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'loan' and 'customer', we need to use tables ['loan', 'customer'].\n\n<3> SQL Generation: The query requires the name of the bank branch that has lent the largest total amount in loans to customers with credit scores below 100, so we should select the 'bname' column in the 'bank' table. We also need to join the 'loan' table with the 'customer' table and apply the filter for credit scores below 100.\n\nSQL query: SELECT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_ID = T2.branch_ID JOIN customer AS T3 ON T2.cust_ID = T3.cust_ID WHERE T3.credit_score < 100 GROUP BY T1.branch_ID ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "predict": "SELECT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_ID = T2.branch_ID JOIN customer AS T3 ON T2.cust_ID = T3.cust_ID WHERE T3.credit_score < 100 GROUP BY T1.branch_ID ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT T1.student_id ,  T2.first_name FROM Assessment_Notes AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the id and first name of the student that has the most number of assessment notes?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Operation: The query requires the id and first name of the student with the most number of assessment notes, so we should apply the 'count' operation to the 'Assessment_Notes' table for the 'student_id' column, and find the student with the highest count. Since the unit to which the assessment notes being counted in the query belong is the student, we should apply the 'group by' operation to the 'student_id' column in the 'Assessment_Notes' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Assessment_Notes', 'Students'].\n\n<3> SQL Generation: The query requires the id and first name of the student with the most number of assessment notes, so we should select the 'student_id' column in the 'Assessment_Notes' table and the 'first_name' column in the 'Students' table.\n\nSQL query: SELECT T2.student_id, T2.first_name FROM Assessment_Notes AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.student_id, T2.first_name FROM Assessment_Notes AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT T1.teacher_id ,  T2.first_name FROM Assessment_Notes AS T1 JOIN Teachers AS T2 ON T1.teacher_id  =  T2.teacher_id GROUP BY T1.teacher_id ORDER BY count(*) DESC LIMIT 3",
        "question": "Find the ids and first names of the 3 teachers that have the most number of assessment notes?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Operation: The query requires the ids and first names of the 3 teachers that have the most number of assessment notes, so we should apply the 'count' operation to the 'Assessment_Notes' table for the 'teacher_id' column, and find the teachers with the highest count. Since the unit to which the assessment notes being counted in the query belong is the teacher, we should apply the 'group by' operation to the 'teacher_id' column in the 'Assessment_Notes' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Teachers'].\n\n<3> SQL Generation: The query requires the ids and first names of the 3 teachers that have the most number of assessment notes, so we should select the 'teacher_id' column and the 'first_name' column in the 'Teachers' table.\n\nSQL query: SELECT teacher_id, first_name FROM Teachers WHERE teacher_id IN (SELECT teacher_id FROM Assessment_Notes GROUP BY teacher_id ORDER BY COUNT(*) DESC LIMIT 3)",
        "predict": "SELECT teacher_id, first_name FROM Teachers WHERE teacher_id IN (SELECT teacher_id FROM Assessment_Notes GROUP BY teacher_id ORDER BY COUNT(*) DESC LIMIT 3)",
        "hardness": "extra"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT T1.student_id ,  T2.last_name FROM Behavior_Incident AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the id and last name of the student that has the most behavior incidents?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Operation: The query requires the id and last name of the student with the most behavior incidents, so we should apply the 'count' operation to the 'Behavior_Incident' table for the 'student_id' column, and find the student with the highest count. Since the unit to which the behavior incidents being counted in the query belong is the student, we should apply the 'group by' operation to the 'student_id' column in the 'Behavior_Incident' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Students'].\n\n<3> SQL Generation: The query requires the id and last name of the student with the most behavior incidents, so we should select the 'student_id' column and 'last_name' column in the 'Students' table.\n\nSQL query: SELECT student_id, last_name FROM Students WHERE student_id = (SELECT student_id FROM Behavior_Incident GROUP BY student_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT student_id, last_name FROM Students WHERE student_id = (SELECT student_id FROM Behavior_Incident GROUP BY student_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT T1.teacher_id ,  T2.last_name FROM Detention AS T1 JOIN Teachers AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T1.detention_type_code  =  \"AFTER\" GROUP BY T1.teacher_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the id and last name of the teacher that has the most detentions with detention type code \"AFTER\"?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Operation: The query requires the id and last name of the teacher with the most detentions of type \"AFTER\", so we should apply the 'count' operation to the 'Teachers' table for the 'teacher_id' column, and find the teacher with the highest count. Since the unit to which the detentions being counted in the query belong is the teacher, we should apply the 'group by' operation to the 'teacher_id' column in the 'Teachers' table. We also need to filter the detentions with type code \"AFTER\" in the 'Detention' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Teachers' and 'Detention', we need to use tables ['Teachers', 'Detention'].\n\n<3> SQL Generation: The query requires the id and last name of the teacher with the most detentions of type \"AFTER\", so we should select the 'teacher_id' column in the 'Teachers' table and the 'last_name' column in the 'Teachers' table. We also need to filter the detentions with type code \"AFTER\" in the 'Detention' table.\n\nSQL query: SELECT T1.teacher_id, T1.last_name FROM Teachers AS T1 JOIN Detention AS T2 ON T1.teacher_id = T2.teacher_id WHERE T2.detention_type_code = 'AFTER' GROUP BY T1.teacher_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.teacher_id, T1.last_name FROM Teachers AS T1 JOIN Detention AS T2 ON T1.teacher_id = T2.teacher_id WHERE T2.detention_type_code = 'AFTER' GROUP BY T1.teacher_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT T1.student_id ,  T2.first_name FROM Student_Addresses AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY AVG(monthly_rental) DESC LIMIT 1",
        "question": "What are the id and first name of the student whose addresses have the highest average monthly rental?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Operation: The query requires the id and first name of the student whose addresses have the highest average monthly rental, so we should apply the 'average' operation to the 'monthly_rental' column in the 'Student_Addresses' table and find the student with the highest average. Since the unit to which the average monthly rental being calculated in the query belongs is the student, we should apply the 'group by' operation to the 'student_id' column in the 'Student_Addresses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Students' and 'Student_Addresses', we need to use tables ['Students', 'Student_Addresses'].\n\n<3> SQL Generation: The query requires the id and first name of the student whose addresses have the highest average monthly rental, so we should select the 'student_id' column in the 'Students' table and the 'first_name' column in the 'Students' table.\n\nSQL query: SELECT T1.student_id, T1.first_name FROM Students AS T1 JOIN Student_Addresses AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY AVG(T2.monthly_rental) DESC LIMIT 1",
        "predict": "SELECT T1.student_id, T1.first_name FROM Students AS T1 JOIN Student_Addresses AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY AVG(T2.monthly_rental) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT T2.address_id ,  T1.city FROM Addresses AS T1 JOIN Student_Addresses AS T2 ON T1.address_id  =  T2.address_id GROUP BY T2.address_id ORDER BY AVG(monthly_rental) DESC LIMIT 1",
        "question": "Find the id and city of the student address with the highest average monthly rental.",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Operation: The query requires the id and city of the student address with the highest average monthly rental, so we should apply the 'average' operation to the 'monthly_rental' column in the 'Student_Addresses' table and find the address with the highest average. Since the unit to which the average monthly rental being calculated in the query belongs is the address, we should apply the 'group by' operation to the 'address_id' column in the 'Student_Addresses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Student_Addresses' and 'Addresses', we need to use tables ['Student_Addresses', 'Addresses'].\n\n<3> SQL Generation: The query requires the id and city of the student address with the highest average monthly rental, so we should select the 'address_id' column in the 'Student_Addresses' table and the 'city' column in the 'Addresses' table.\n\nSQL query: SELECT T1.address_id, T2.city FROM Student_Addresses AS T1 JOIN Addresses AS T2 ON T1.address_id = T2.address_id GROUP BY T1.address_id ORDER BY AVG(T1.monthly_rental) DESC LIMIT 1",
        "predict": "SELECT T1.address_id, T2.city FROM Student_Addresses AS T1 JOIN Addresses AS T2 ON T1.address_id = T2.address_id GROUP BY T1.address_id ORDER BY AVG(T1.monthly_rental) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT T1.incident_type_code ,  T2.incident_type_description FROM Behavior_Incident AS T1 JOIN Ref_Incident_Type AS T2 ON T1.incident_type_code  =  T2.incident_type_code GROUP BY T1.incident_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the code and description of the most frequent behavior incident type?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Operation: The query requires the code and description of the most frequent behavior incident type, so we should apply the 'count' operation to the 'incident_type_code' column in the 'Behavior_Incident' table, and find the incident type with the highest count. Since the unit to which the incident types being counted in the query belong is the behavior incident, we should apply the 'group by' operation to the 'incident_type_code' column in the 'Behavior_Incident' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Behavior_Incident', 'Ref_Incident_Type'].\n\n<3> SQL Generation: The query requires the code and description of the most frequent behavior incident type, so we should select the 'incident_type_code' column in the 'Behavior_Incident' table and the 'incident_type_description' column in the 'Ref_Incident_Type' table.\n\nSQL query: SELECT T1.incident_type_code, T2.incident_type_description FROM Behavior_Incident AS T1 JOIN Ref_Incident_Type AS T2 ON T1.incident_type_code = T2.incident_type_code GROUP BY T1.incident_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.incident_type_code, T2.incident_type_description FROM Behavior_Incident AS T1 JOIN Ref_Incident_Type AS T2 ON T1.incident_type_code = T2.incident_type_code GROUP BY T1.incident_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "assets_maintenance",
        "gold": "SELECT count(*) ,  T1.fault_log_entry_id FROM Fault_Log AS T1 JOIN Engineer_Visits AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id GROUP BY T1.fault_log_entry_id ORDER BY count(*) DESC LIMIT 1",
        "question": "How many engineer visits are required at most for a single fault log? List the number and the log entry id.",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n",
        "reasoning": "<1> Operation: The query requires the maximum number of engineer visits for a single fault log, so we should apply the 'count' operation to the 'engineer_visit_id' column in the 'Engineer_Visits' table, and find the fault log entry with the highest count. Since the unit to which the engineer visits being counted in the query belong is the fault log entry, we should apply the 'group by' operation to the 'fault_log_entry_id' column in the 'Engineer_Visits' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Engineer_Visits' and 'Fault_Log', we need to use tables ['Engineer_Visits', 'Fault_Log'].\n\n<3> SQL Generation: The query requires the maximum number of engineer visits for a single fault log, so we should select the 'fault_log_entry_id' column in the 'Engineer_Visits' table and count the 'engineer_visit_id' column in the 'Engineer_Visits' table.\n\nSQL query: SELECT fault_log_entry_id, COUNT(engineer_visit_id) FROM Engineer_Visits GROUP BY fault_log_entry_id ORDER BY COUNT(engineer_visit_id) DESC LIMIT 1",
        "predict": "SELECT fault_log_entry_id, COUNT(engineer_visit_id) FROM Engineer_Visits GROUP BY fault_log_entry_id ORDER BY COUNT(engineer_visit_id) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "assets_maintenance",
        "gold": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which part fault requires the most number of skills to fix? List part id and name.",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n",
        "reasoning": "<1> Operation: The query requires the part fault that requires the most number of skills to fix, so we should apply the 'count' operation to the 'Skills_Required_To_Fix' table for the 'part_fault_id' column, and find the part fault with the highest count. Since the unit to which the skills being counted in the query belong is the part fault, we should apply the 'group by' operation to the 'part_fault_id' column in the 'Skills_Required_To_Fix' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Part_Faults' and 'Skills_Required_To_Fix', we need to use tables ['Part_Faults', 'Skills_Required_To_Fix'].\n\n<3> SQL Generation: The query requires the part fault that requires the most number of skills to fix, so we should select the 'part_id' and 'part_name' columns in the 'Parts' table and the 'part_fault_id' column in the 'Part_Faults' table.\n\nSQL query: SELECT T1.part_id, T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id = T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id = T3.part_fault_id GROUP BY T2.part_fault_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.part_id, T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id = T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id = T3.part_fault_id GROUP BY T2.part_fault_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "assets_maintenance",
        "gold": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 ON T1.engineer_id  =  T2.engineer_id GROUP BY T1.engineer_id ORDER BY count(*) ASC LIMIT 1",
        "question": "Among those engineers who have visited, which engineer makes the least number of visits? List the engineer id, first name and last name.",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n",
        "reasoning": "<1> Operation: The query requires the engineer who makes the least number of visits among those who have visited, so we should apply the 'count' operation to the 'engineer_id' column in the 'Engineer_Visits' table, and find the engineer with the lowest count. Since the unit to which the visits being counted in the query belong is the engineer, we should apply the 'group by' operation to the 'engineer_id' column in the 'Engineer_Visits' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Engineer_Visits', 'Maintenance_Engineers'].\n\n<3> SQL Generation: The query requires the engineer who makes the least number of visits among those who have visited, so we should select the 'engineer_id', 'first_name', and 'last_name' columns in the 'Maintenance_Engineers' table and the 'engineer_id' column in the 'Engineer_Visits' table.\n\nSQL query: SELECT T1.engineer_id, T2.first_name, T2.last_name FROM Engineer_Visits AS T1 JOIN Maintenance_Engineers AS T2 ON T1.engineer_id = T2.engineer_id GROUP BY T1.engineer_id ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT T1.engineer_id, T2.first_name, T2.last_name FROM Engineer_Visits AS T1 JOIN Maintenance_Engineers AS T2 ON T1.engineer_id = T2.engineer_id GROUP BY T1.engineer_id ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "assets_maintenance",
        "gold": "SELECT T1.fault_log_entry_id ,  T1.fault_description ,  T1.fault_log_entry_datetime FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id GROUP BY T1.fault_log_entry_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which fault log included the most number of faulty parts? List the fault log id, description and record time.",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n",
        "reasoning": "<1> Operation: The query requires the fault log that included the most number of faulty parts, so we should apply the 'count' operation to the 'part_fault_id' column in the 'Fault_Log_Parts' table, and find the fault log with the highest count. Since the unit to which the faulty parts being counted in the query belong is the fault log, we should apply the 'group by' operation to the 'fault_log_entry_id' column in the 'Fault_Log_Parts' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Fault_Log' and 'Fault_Log_Parts', we need to use tables ['Fault_Log', 'Fault_Log_Parts'].\n\n<3> SQL Generation: The query requires the fault log id, description, and record time of the fault log that included the most number of faulty parts, so we should select the 'fault_log_entry_id', 'fault_description', and 'fault_log_entry_datetime' columns in the 'Fault_Log' table.\n\nSQL query: SELECT T1.fault_log_entry_id, T1.fault_description, T1.fault_log_entry_datetime FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id = T2.fault_log_entry_id GROUP BY T1.fault_log_entry_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.fault_log_entry_id, T1.fault_description, T1.fault_log_entry_datetime FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id = T2.fault_log_entry_id GROUP BY T1.fault_log_entry_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "assets_maintenance",
        "gold": "SELECT gender FROM staff GROUP BY gender ORDER BY count(*) DESC LIMIT 1",
        "question": "Which gender makes up the majority of the staff?",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n",
        "reasoning": "<1> Operation: The query requires the gender that makes up the majority of the staff, so we should apply the 'count' operation to the 'Staff' table for the 'gender' column, and find the gender with the highest count. Since the unit to which the genders being counted in the query belong is the staff, we should apply the 'group by' operation to the 'gender' column in the 'Staff' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Staff'].\n\n<3> SQL Generation: The query requires the gender that makes up the majority of the staff, so we should select the 'gender' column in the 'Staff' table.\n\nSQL query: SELECT gender FROM Staff GROUP BY gender ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT gender FROM Staff GROUP BY gender ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "station_weather",
        "gold": "SELECT t1.name FROM train AS t1 JOIN route AS t2 ON t1.id  =  t2.train_id GROUP BY t2.train_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the train whose route runs through greatest number of stations.",
        "fields": "Table route, columns = [*,train_id,station_id]\nTable station, columns = [*,id,network_name,services,local_authority]\nTable train, columns = [*,id,train_number,name,origin,destination,time,interval]\nTable weekly_weather, columns = [*,station_id,day_of_week,high_temperature,low_temperature,precipitation,wind_speed_mph]\n",
        "foreign_keys": "Foreign_keys = [route.station_id = station.id,route.train_id = train.id,weekly_weather.station_id = station.id]\n",
        "reasoning": "<1> Operation: The query requires the name of the train whose route runs through the greatest number of stations, so we should apply the 'count' operation to the 'station_id' column in the 'route' table, and find the train with the highest count. Since the unit to which the stations being counted in the query belong is the train, we should apply the 'group by' operation to the 'train_id' column in the 'route' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['route', 'train'].\n\n<3> SQL Generation: The query requires the name of the train whose route runs through the greatest number of stations, so we should select the 'name' column in the 'train' table. We also need to join the 'route' table with the 'train' table on the 'train_id' column.\n\nSQL query: SELECT T2.name FROM route AS T1 JOIN train AS T2 ON T1.train_id = T2.id GROUP BY T1.train_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.name FROM route AS T1 JOIN train AS T2 ON T1.train_id = T2.id GROUP BY T1.train_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT emp_jobcode ,  count(*) FROM employee GROUP BY emp_jobcode ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the count and code of the job has most employees.",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the count and code of the job that has the most employees, so we should apply the 'count' operation to the 'EMP_NUM' column in the 'EMPLOYEE' table, and find the job code with the highest count. Since the unit to which the employees being counted in the query belong is the job code, we should apply the 'group by' operation to the 'EMP_JOBCODE' column in the 'EMPLOYEE' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['EMPLOYEE'].\n\n<3> SQL Generation: The query requires the count and code of the job that has the most employees, so we should select the 'EMP_JOBCODE' column in the 'EMPLOYEE' table and the count of the 'EMP_NUM' column in the 'EMPLOYEE' table.\n\nSQL query: SELECT EMP_JOBCODE, COUNT(*) FROM EMPLOYEE GROUP BY EMP_JOBCODE ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT EMP_JOBCODE, COUNT(*) FROM EMPLOYEE GROUP BY EMP_JOBCODE ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT emp_jobcode ,  count(*) FROM employee GROUP BY emp_jobcode ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the count and code of the job with the most employee?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the count and code of the job with the most employees, so we should apply the 'count' operation to the 'EMP_NUM' column in the 'EMPLOYEE' table, and find the job with the highest count. Since the unit to which the employees being counted in the query belong is the job, we should apply the 'group by' operation to the 'EMP_JOBCODE' column in the 'EMPLOYEE' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['EMPLOYEE'].\n\n<3> SQL Generation: The query requires the count and code of the job with the most employees, so we should select the 'EMP_JOBCODE' column in the 'EMPLOYEE' table and the count of the 'EMP_NUM' column in the 'EMPLOYEE' table.\n\nSQL query: SELECT EMP_JOBCODE, COUNT(*) FROM EMPLOYEE GROUP BY EMP_JOBCODE ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT EMP_JOBCODE, COUNT(*) FROM EMPLOYEE GROUP BY EMP_JOBCODE ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1",
        "question": "Which school has the smallest amount of professors?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the school with the smallest amount of professors, so we should apply the 'count' operation to the 'EMP_NUM' column in the 'DEPARTMENT' table, and find the school with the lowest count. Since the unit to which the professors being counted in the query belong is the school, we should apply the 'group by' operation to the 'SCHOOL_CODE' column in the 'DEPARTMENT' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['DEPARTMENT'].\n\n<3> SQL Generation: The query requires the school with the smallest amount of professors, so we should select the 'SCHOOL_CODE' column in the 'DEPARTMENT' table.\n\nSQL query: SELECT SCHOOL_CODE FROM DEPARTMENT GROUP BY SCHOOL_CODE ORDER BY COUNT(EMP_NUM) ASC LIMIT 1",
        "predict": "SELECT SCHOOL_CODE FROM DEPARTMENT GROUP BY SCHOOL_CODE ORDER BY COUNT(EMP_NUM) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1",
        "question": "Which school has the fewest professors?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the school with the fewest professors, so we should apply the 'count' operation to the 'PROF_NUM' column in the 'DEPARTMENT' table, and find the school with the lowest count. Since the unit to which the professors being counted in the query belong is the school, we should apply the 'group by' operation to the 'SCHOOL_CODE' column in the 'DEPARTMENT' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['DEPARTMENT'].\n\n<3> SQL Generation: The query requires the school with the fewest professors, so we should select the 'SCHOOL_CODE' column in the 'DEPARTMENT' table.\n\nSQL query: SELECT SCHOOL_CODE FROM DEPARTMENT GROUP BY SCHOOL_CODE ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT SCHOOL_CODE FROM DEPARTMENT GROUP BY SCHOOL_CODE ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T2.dept_name ,  avg(T1.stu_gpa) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY avg(T1.stu_gpa) DESC LIMIT 1",
        "question": "What is the name and the average gpa of department whose students have the highest average gpa?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the name and average GPA of the department whose students have the highest average GPA, so we should apply the 'average' operation to the 'STU_GPA' column in the 'STUDENT' table and find the department with the highest average GPA. Since the unit to which the average GPA being calculated in the query belongs is the department, we should apply the 'group by' operation to the 'DEPT_CODE' column in the 'STUDENT' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'STUDENT' and 'DEPARTMENT', we need to use tables ['STUDENT', 'DEPARTMENT'].\n\n<3> SQL Generation: The query requires the name and average GPA of the department whose students have the highest average GPA, so we should select the 'DEPT_NAME' column in the 'DEPARTMENT' table and the average of the 'STU_GPA' column in the 'STUDENT' table.\n\nSQL query: SELECT DEPARTMENT.DEPT_NAME, AVG(STUDENT.STU_GPA) FROM STUDENT JOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE GROUP BY STUDENT.DEPT_CODE ORDER BY AVG(STUDENT.STU_GPA) DESC LIMIT 1",
        "predict": "SELECT DEPARTMENT.DEPT_NAME, AVG(STUDENT.STU_GPA) FROM STUDENT JOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE GROUP BY STUDENT.DEPT_CODE ORDER BY AVG(STUDENT.STU_GPA) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T2.dept_name ,  avg(T1.stu_gpa) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY avg(T1.stu_gpa) DESC LIMIT 1",
        "question": "Which department has the highest average student GPA, and what is the average gpa?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the department with the highest average student GPA, so we should apply the 'average' operation to the 'STU_GPA' column in the 'STUDENT' table and find the department with the highest average. Since the unit to which the average student GPA being calculated in the query belongs is the department, we should apply the 'group by' operation to the 'DEPT_CODE' column in the 'STUDENT' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'STUDENT' and 'DEPARTMENT', we need to use tables ['STUDENT', 'DEPARTMENT'].\n\n<3> SQL Generation: The query requires the department with the highest average student GPA, so we should select the 'DEPT_NAME' column in the 'DEPARTMENT' table and the average of the 'STU_GPA' column in the 'STUDENT' table.\n\nSQL query: SELECT DEPT_NAME, AVG(STU_GPA) FROM DEPARTMENT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE GROUP BY DEPARTMENT.DEPT_CODE ORDER BY AVG(STU_GPA) DESC LIMIT 1",
        "predict": "SELECT DEPT_NAME, AVG(STU_GPA) FROM DEPARTMENT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE GROUP BY DEPARTMENT.DEPT_CODE ORDER BY AVG(STU_GPA) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1",
        "question": "Find the name of the department that offers the largest number of credits of all classes.",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the name of the department that offers the largest number of credits of all classes, so we should apply the 'sum' operation to the 'CRS_CREDIT' column in the 'COURSE' table and find the department with the highest sum. Since the unit to which the credits being summed in the query belong is the department, we should apply the 'group by' operation to the 'DEPT_CODE' column in the 'COURSE' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['COURSE', 'DEPARTMENT'].\n\n<3> SQL Generation: The query requires the name of the department that offers the largest number of credits of all classes, so we should select the 'DEPT_NAME' column in the 'DEPARTMENT' table and the sum of the 'CRS_CREDIT' column in the 'COURSE' table.\n\nSQL query: SELECT DEPARTMENT.DEPT_NAME FROM DEPARTMENT JOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE GROUP BY DEPARTMENT.DEPT_CODE ORDER BY SUM(COURSE.CRS_CREDIT) DESC LIMIT 1",
        "predict": "SELECT DEPARTMENT.DEPT_NAME FROM DEPARTMENT JOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE GROUP BY DEPARTMENT.DEPT_CODE ORDER BY SUM(COURSE.CRS_CREDIT) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T2.dept_name FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) LIMIT 1",
        "question": "What is the name of department where has the smallest number of professors?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the name of the department with the smallest number of professors, so we should apply the 'count' operation to the 'EMP_NUM' column in the 'PROFESSOR' table, and find the department with the lowest count. Since the unit to which the professors being counted in the query belong is the department, we should apply the 'group by' operation to the 'DEPT_CODE' column in the 'PROFESSOR' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['DEPARTMENT', 'PROFESSOR'].\n\n<3> SQL Generation: The query requires the name of the department with the smallest number of professors, so we should select the 'DEPT_NAME' column in the 'DEPARTMENT' table.\n\nSQL query: SELECT DEPT_NAME FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM PROFESSOR GROUP BY DEPT_CODE ORDER BY COUNT(*) ASC LIMIT 1)",
        "predict": "SELECT DEPT_NAME FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM PROFESSOR GROUP BY DEPT_CODE ORDER BY COUNT(*) ASC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T2.dept_name ,  T2.dept_address FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name and address of the department that has the highest number of students.",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the name and address of the department that has the highest number of students, so we should apply the 'count' operation to the 'STU_NUM' column in the 'STUDENT' table, and find the department with the highest count. Since the unit to which the students being counted in the query belong is the department, we should apply the 'group by' operation to the 'DEPT_CODE' column in the 'STUDENT' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'STUDENT' and 'DEPARTMENT', we need to use tables ['STUDENT', 'DEPARTMENT'].\n\n<3> SQL Generation: The query requires the name and address of the department that has the highest number of students, so we should select the 'DEPT_NAME' column in the 'DEPARTMENT' table and the 'DEPT_ADDRESS' column in the 'DEPARTMENT' table.\n\nSQL query: SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM STUDENT GROUP BY DEPT_CODE ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM STUDENT GROUP BY DEPT_CODE ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T2.dept_name ,  T2.dept_address FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name and address of the department with the most students?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the name and address of the department with the most students, so we should apply the 'count' operation to the 'STU_NUM' column in the 'STUDENT' table, and find the department with the highest count. Since the unit to which the students being counted in the query belong is the department, we should apply the 'group by' operation to the 'DEPT_CODE' column in the 'STUDENT' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['DEPARTMENT', 'STUDENT'].\n\n<3> SQL Generation: The query requires the name and address of the department with the most students, so we should select the 'DEPT_NAME' column in the 'DEPARTMENT' table and the 'DEPT_ADDRESS' column in the 'DEPARTMENT' table.\n\nSQL query: SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM STUDENT GROUP BY DEPT_CODE ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM STUDENT GROUP BY DEPT_CODE ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T2.dept_name ,  T2.dept_address ,  count(*) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 3",
        "question": "Find the name, address, number of students in the departments that have the top 3 highest number of students.",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Operation: The query requires the name, address, and number of students in the departments that have the top 3 highest number of students, so we should apply the 'count' operation to the 'STU_NUM' column in the 'STUDENT' table, and find the top 3 departments with the highest count. Since the unit to which the students being counted in the query belong is the department, we should apply the 'group by' operation to the 'DEPT_CODE' column in the 'STUDENT' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'STUDENT' and 'DEPARTMENT', we need to use tables ['STUDENT', 'DEPARTMENT'].\n\n<3> SQL Generation: The query requires the name, address, and number of students in the departments that have the top 3 highest number of students, so we should select the 'DEPT_NAME' column in the 'DEPARTMENT' table, the 'DEPT_ADDRESS' column in the 'DEPARTMENT' table, and the count of 'STU_NUM' column in the 'STUDENT' table.\n\nSQL query: SELECT DEPARTMENT.DEPT_NAME, DEPARTMENT.DEPT_ADDRESS, COUNT(STUDENT.STU_NUM) FROM STUDENT JOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE GROUP BY STUDENT.DEPT_CODE ORDER BY COUNT(STUDENT.STU_NUM) DESC LIMIT 3",
        "predict": "SELECT DEPARTMENT.DEPT_NAME, DEPARTMENT.DEPT_ADDRESS, COUNT(STUDENT.STU_NUM) FROM STUDENT JOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE GROUP BY STUDENT.DEPT_CODE ORDER BY COUNT(STUDENT.STU_NUM) DESC LIMIT 3",
        "hardness": "extra"
    },
    {
        "db_id": "sports_competition",
        "gold": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "List the most common type of competition.",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common type of competition, so we should apply the 'count' operation to the 'Competition_type' column in the 'competition' table and find the competition type with the highest count. Since the unit to which the competition types being counted in the query belong is the competition, we should apply the 'group by' operation to the 'Competition_type' column in the 'competition' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['competition'].\n\n<3> SQL Generation: The query requires the most common type of competition, so we should select the 'Competition_type' column in the 'competition' table.\n\nSQL query: SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "sports_competition",
        "gold": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the most common competition type?",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common competition type, so we should apply the 'count' operation to the 'Competition_type' column in the 'competition' table and find the competition type with the highest count. Since the unit to which the competition types being counted in the query belong is the competition, we should apply the 'group by' operation to the 'Competition_type' column in the 'competition' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['competition'].\n\n<3> SQL Generation: The query requires the most common competition type, so we should select the 'Competition_type' column in the 'competition' table.\n\nSQL query: SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1",
        "question": "What is the most popular file format?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Operation: The query requires the most popular file format, so we should apply the 'count' operation to the 'formats' column in the 'files' table and find the file format with the highest count. Since the unit to which the file formats being counted in the query belong is the file, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'files'.\n\n<3> SQL Generation: The query requires the most popular file format, so we should select the 'formats' column in the 'files' table.\n\nSQL query: SELECT formats FROM files GROUP BY formats ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1",
        "question": "Find the file format that is used by the most files.",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Operation: The query requires the file format that is used by the most files, so we should apply the 'count' operation to the 'formats' column in the 'files' table, and find the file format with the highest count. Since the unit to which the file formats being counted in the query belong is the file, we should apply the 'group by' operation to the 'formats' column in the 'files' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['files'].\n\n<3> SQL Generation: The query requires the file format that is used by the most files, so we should select the 'formats' column in the 'files' table.\n\nSQL query: SELECT formats FROM files GROUP BY formats ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the language used most often in the songs?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Operation: The query requires the language used most often in the songs, so we should apply the 'count' operation to the 'languages' column in the 'song' table and find the language with the highest count. Since the unit to which the languages being counted in the query belong is the song, we should apply the 'group by' operation to the 'languages' column in the 'song' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['song'].\n\n<3> SQL Generation: The query requires the language used most often in the songs, so we should select the 'languages' column in the 'song' table.\n\nSQL query: SELECT languages FROM song GROUP BY languages ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT languages FROM song GROUP BY languages ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the languages that are used most often in songs?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Operation: The query requires the languages that are used most often in songs, so we should apply the 'count' operation to the 'languages' column in the 'song' table and find the language with the highest count. Since the unit to which the languages being counted in the query belong is the song, we should apply the 'group by' operation to the 'languages' column in the 'song' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['song'].\n\n<3> SQL Generation: The query requires the languages that are used most often in songs, so we should select the 'languages' column in the 'song' table.\n\nSQL query: SELECT languages FROM song GROUP BY languages ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT languages FROM song GROUP BY languages ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT T1.artist_name ,  count(*) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3",
        "question": "What are the names of the three artists who have produced the most songs, and how many works did they produce?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Operation: The query requires the names of the three artists who have produced the most songs and the number of works they have produced. So we should apply the 'count' operation to the 'song' table for the 'artist_name' column, and find the top three artists with the highest count.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['song'].\n\n<3> SQL Generation: The query requires the names of the three artists who have produced the most songs and the number of works they have produced, so we should select the 'artist_name' column in the 'song' table and count the 'artist_name' column in the 'song' table. We also need to group by the 'artist_name' column and sort the count in descending order. Finally, we limit the result to the top three artists.\n\nSQL query: SELECT artist_name, COUNT(*) AS works_produced FROM song GROUP BY artist_name ORDER BY COUNT(*) DESC LIMIT 3",
        "predict": "SELECT artist_name, COUNT(*) AS works_produced FROM song GROUP BY artist_name ORDER BY COUNT(*) DESC LIMIT 3",
        "hardness": "extra"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) LIMIT 1",
        "question": "Find the country of origin for the artist who made the least number of songs?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Operation: The query requires the country of origin for the artist who made the least number of songs, so we should apply the 'count' operation to the 'song' table for the 'artist_name' column, and find the artist with the lowest count. Since the unit to which the songs being counted in the query belong is the artist, we should apply the 'group by' operation to the 'artist_name' column in the 'song' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['artist'].\n\n<3> SQL Generation: The query requires the country of origin for the artist who made the least number of songs, so we should select the 'country' column in the 'artist' table and the 'artist_name' column in the 'song' table.\n\nSQL query: SELECT country FROM artist WHERE artist_name = (SELECT artist_name FROM song GROUP BY artist_name ORDER BY COUNT(*) ASC LIMIT 1)",
        "predict": "SELECT country FROM artist WHERE artist_name = (SELECT artist_name FROM song GROUP BY artist_name ORDER BY COUNT(*) ASC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) LIMIT 1",
        "question": "What country is the artist who made the fewest songs from?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Operation: The query requires the country of the artist who made the fewest songs, so we should apply the 'count' operation to the 'song' table for the 'artist_name' column, and find the artist with the lowest count. Since the unit to which the songs being counted in the query belong is the artist, we should apply the 'group by' operation to the 'artist_name' column in the 'song' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['artist', 'song'].\n\n<3> SQL Generation: The query requires the country of the artist who made the fewest songs, so we should select the 'country' column in the 'artist' table and the 'artist_name' column in the 'song' table.\n\nSQL query: SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name GROUP BY T2.artist_name ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name GROUP BY T2.artist_name ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "mountain_photos",
        "gold": "SELECT T2.name FROM photos AS T1 JOIN camera_lens AS T2 ON T1.camera_lens_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the names of the cameras that have taken picture of the most mountains?",
        "fields": "Table camera_lens, columns = [*,id,brand,name,focal_length_mm,max_aperture]\nTable mountain, columns = [*,id,name,Height,Prominence,Range,Country]\nTable photos, columns = [*,id,camera_lens_id,mountain_id,color,name]\n",
        "foreign_keys": "Foreign_keys = [photos.mountain_id = mountain.id,photos.camera_lens_id = camera_lens.id]\n",
        "reasoning": "<1> Operation: The query requires the names of the cameras that have taken pictures of the most mountains, so we should apply the 'count' operation to the 'mountain_id' column in the 'photos' table, and find the camera with the highest count. Since the unit to which the mountains being counted in the query belong is the camera, we should apply the 'group by' operation to the 'camera_lens_id' column in the 'photos' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['camera_lens', 'photos'].\n\n<3> SQL Generation: The query requires the names of the cameras that have taken pictures of the most mountains, so we should select the 'name' column in the 'camera_lens' table and the 'camera_lens_id' column in the 'photos' table.\n\nSQL query: SELECT T1.name FROM camera_lens AS T1 JOIN photos AS T2 ON T1.id = T2.camera_lens_id GROUP BY T2.camera_lens_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.name FROM camera_lens AS T1 JOIN photos AS T2 ON T1.id = T2.camera_lens_id GROUP BY T2.camera_lens_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "program_share",
        "gold": "SELECT t1.name FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id GROUP BY t2.program_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the program that is broadcast most frequently.",
        "fields": "Table broadcast, columns = [*,Channel_ID,Program_ID,Time_of_day]\nTable broadcast_share, columns = [*,Channel_ID,Program_ID,Date,Share_in_percent]\nTable channel, columns = [*,Channel_ID,Name,Owner,Share_in_percent,Rating_in_percent]\nTable program, columns = [*,Program_ID,Name,Origin,Launch,Owner]\n",
        "foreign_keys": "Foreign_keys = [broadcast.Program_ID = program.Program_ID,broadcast.Channel_ID = channel.Channel_ID,broadcast_share.Program_ID = program.Program_ID,broadcast_share.Channel_ID = channel.Channel_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the program that is broadcast most frequently, so we should apply the 'count' operation to the 'Program_ID' column in the 'broadcast' table, and find the program with the highest count. Since the unit to which the broadcasts being counted in the query belong is the program, we should apply the 'group by' operation to the 'Program_ID' column in the 'broadcast' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['broadcast'].\n\n<3> SQL Generation: The query requires the name of the program that is broadcast most frequently, so we should select the 'Name' column in the 'program' table.\n\nSQL query: SELECT Name FROM program WHERE Program_ID = (SELECT Program_ID FROM broadcast GROUP BY Program_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Name FROM program WHERE Program_ID = (SELECT Program_ID FROM broadcast GROUP BY Program_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "program_share",
        "gold": "SELECT t1.name FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id GROUP BY t2.program_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which program is broadcast most frequently? Give me the program name.",
        "fields": "Table broadcast, columns = [*,Channel_ID,Program_ID,Time_of_day]\nTable broadcast_share, columns = [*,Channel_ID,Program_ID,Date,Share_in_percent]\nTable channel, columns = [*,Channel_ID,Name,Owner,Share_in_percent,Rating_in_percent]\nTable program, columns = [*,Program_ID,Name,Origin,Launch,Owner]\n",
        "foreign_keys": "Foreign_keys = [broadcast.Program_ID = program.Program_ID,broadcast.Channel_ID = channel.Channel_ID,broadcast_share.Program_ID = program.Program_ID,broadcast_share.Channel_ID = channel.Channel_ID]\n",
        "reasoning": "<1> Operation: The query requires the program that is broadcast most frequently, so we should apply the 'count' operation to the 'Program_ID' column in the 'broadcast' table, and find the program with the highest count. Since the unit to which the broadcasts being counted in the query belong is the program, we should apply the 'group by' operation to the 'Program_ID' column in the 'broadcast' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['broadcast'].\n\n<3> SQL Generation: The query requires the program that is broadcast most frequently, so we should select the 'Program_ID' column in the 'broadcast' table and the 'Name' column in the 'program' table.\n\nSQL query: SELECT T2.Name FROM broadcast AS T1 JOIN program AS T2 ON T1.Program_ID = T2.Program_ID GROUP BY T1.Program_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.Name FROM broadcast AS T1 JOIN program AS T2 ON T1.Program_ID = T2.Program_ID GROUP BY T1.Program_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT test_result ,  COUNT(*) FROM Student_Tests_Taken GROUP BY test_result ORDER BY COUNT(*) DESC",
        "question": "List each test result and its count in descending order of count.",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Operation: The query requires each test result and its count, so we should apply the 'count' operation to the 'test_result' column in the 'Student_Tests_Taken' table, and sort it in descending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student_Tests_Taken'].\n\n<3> SQL Generation: The query requires each test result and its count, so we should select the 'test_result' column in the 'Student_Tests_Taken' table and count the occurrences of each test result.\n\nSQL query: SELECT test_result, COUNT(*) FROM Student_Tests_Taken GROUP BY test_result ORDER BY COUNT(*) DESC",
        "predict": "SELECT test_result, COUNT(*) FROM Student_Tests_Taken GROUP BY test_result ORDER BY COUNT(*) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.personal_name ,  T1.family_name ,  T2.author_id FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id GROUP BY T2.author_id ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Find the personal name, family name, and author ID of the course author that teaches the most courses.",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Operation: The query requires the personal name, family name, and author ID of the course author that teaches the most courses, so we should apply the 'count' operation to the 'Courses' table for the 'author_id' column, and find the author with the highest count. Since the unit to which the courses being counted in the query belong is the author, we should apply the 'group by' operation to the 'author_id' column in the 'Courses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Courses', 'Course_Authors_and_Tutors'].\n\n<3> SQL Generation: The query requires the personal name, family name, and author ID of the course author that teaches the most courses, so we should select the 'personal_name', 'family_name', and 'author_id' columns in the 'Course_Authors_and_Tutors' table.\n\nSQL query: SELECT personal_name, family_name, author_id FROM Course_Authors_and_Tutors WHERE author_id = (SELECT author_id FROM Courses GROUP BY author_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT personal_name, family_name, author_id FROM Course_Authors_and_Tutors WHERE author_id = (SELECT author_id FROM Courses GROUP BY author_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.personal_name ,  T1.family_name ,  T2.author_id FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id GROUP BY T2.author_id ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What are the personal name, family name, and author ID of the course author who teaches the most courses?",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Operation: The query requires the personal name, family name, and author ID of the course author who teaches the most courses, so we should apply the 'count' operation to the 'Courses' table for the 'author_id' column, and find the author with the highest count. Since the unit to which the courses being counted in the query belong is the author, we should apply the 'group by' operation to the 'author_id' column in the 'Courses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Courses', 'Course_Authors_and_Tutors'].\n\n<3> SQL Generation: The query requires the personal name, family name, and author ID of the course author who teaches the most courses, so we should select the 'personal_name', 'family_name', and 'author_id' columns in the 'Course_Authors_and_Tutors' table.\n\nSQL query: SELECT personal_name, family_name, author_id FROM Course_Authors_and_Tutors WHERE author_id = (SELECT author_id FROM Courses GROUP BY author_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT personal_name, family_name, author_id FROM Course_Authors_and_Tutors WHERE author_id = (SELECT author_id FROM Courses GROUP BY author_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.subject_id ,  T2.subject_name ,  COUNT(*) FROM Courses AS T1 JOIN Subjects AS T2 ON T1.subject_id  =  T2.subject_id GROUP BY T1.subject_id ORDER BY COUNT(*) ASC",
        "question": "Find the subject ID, name of subject and the corresponding number of courses for each subject, and sort by the course count in ascending order.",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Operation: The query requires the subject ID, name of subject, and the corresponding number of courses for each subject, and it should be sorted by the course count in ascending order. So we should apply the 'count' operation to the 'course_id' column in the 'Courses' table, and sort it in ascending order. Since the unit to which the courses being counted in the query belong is the subject, we should apply the 'group by' operation to the 'subject_id' column in the 'Courses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Courses', 'Subjects'].\n\n<3> SQL Generation: The query requires the subject ID, name of subject, and the corresponding number of courses for each subject, so we should select the 'subject_id' column in the 'Courses' table, the 'subject_name' column in the 'Subjects' table, and count the 'course_id' column in the 'Courses' table.\n\nSQL query: SELECT Courses.subject_id, Subjects.subject_name, COUNT(Courses.course_id) FROM Courses JOIN Subjects ON Courses.subject_id = Subjects.subject_id GROUP BY Courses.subject_id, Subjects.subject_name ORDER BY COUNT(Courses.course_id) ASC",
        "predict": "SELECT Courses.subject_id, Subjects.subject_name, COUNT(Courses.course_id) FROM Courses JOIN Subjects ON Courses.subject_id = Subjects.subject_id GROUP BY Courses.subject_id, Subjects.subject_name ORDER BY COUNT(Courses.course_id) ASC",
        "hardness": "hard"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.subject_id ,  T2.subject_name ,  COUNT(*) FROM Courses AS T1 JOIN Subjects AS T2 ON T1.subject_id  =  T2.subject_id GROUP BY T1.subject_id ORDER BY COUNT(*) ASC",
        "question": "List the subject ID, name of subject and the number of courses available for each subject in ascending order of the course counts.",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Operation: The query requires the subject ID, name of the subject, and the number of courses available for each subject, so we should apply the 'count' operation to the 'course_id' column in the 'Courses' table, and sort it in ascending order. Since the unit to which the courses being counted in the query belong is the subject, we should apply the 'group by' operation to the 'subject_id' column in the 'Courses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Courses', 'Subjects'].\n\n<3> SQL Generation: The query requires the subject ID, name of the subject, and the number of courses available for each subject, so we should select the 'subject_id' column in the 'Courses' table, the 'subject_name' column in the 'Subjects' table, and count the 'course_id' column in the 'Courses' table.\n\nSQL query: SELECT Courses.subject_id, Subjects.subject_name, COUNT(Courses.course_id) FROM Courses JOIN Subjects ON Courses.subject_id = Subjects.subject_id GROUP BY Courses.subject_id, Subjects.subject_name ORDER BY COUNT(Courses.course_id) ASC",
        "predict": "SELECT Courses.subject_id, Subjects.subject_name, COUNT(Courses.course_id) FROM Courses JOIN Subjects ON Courses.subject_id = Subjects.subject_id GROUP BY Courses.subject_id, Subjects.subject_name ORDER BY COUNT(Courses.course_id) ASC",
        "hardness": "hard"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the name of the course that has the most student enrollment?",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the course that has the most student enrollment, so we should apply the 'count' operation to the 'Student_Course_Enrolment' table for the 'course_id' column, and find the course with the highest count. Since the unit to which the enrollments being counted in the query belong is the course, we should apply the 'group by' operation to the 'course_id' column in the 'Student_Course_Enrolment' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Courses', 'Student_Course_Enrolment'].\n\n<3> SQL Generation: The query requires the name of the course that has the most student enrollment, so we should select the 'course_name' column in the 'Courses' table and the 'course_id' column in the 'Student_Course_Enrolment' table.\n\nSQL query: SELECT course_name FROM Courses WHERE course_id = (SELECT course_id FROM Student_Course_Enrolment GROUP BY course_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT course_name FROM Courses WHERE course_id = (SELECT course_id FROM Student_Course_Enrolment GROUP BY course_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which course is enrolled in by the most students? Give me the course name.",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Operation: The query requires the course enrolled in by the most students, so we should apply the 'count' operation to the 'course_id' column in the 'Student_Course_Enrolment' table, and find the course with the highest count. Since the unit to which the enrollments being counted in the query belong is the course, we should apply the 'group by' operation to the 'course_id' column in the 'Student_Course_Enrolment' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Courses', 'Student_Course_Enrolment'].\n\n<3> SQL Generation: The query requires the course enrolled in by the most students, so we should select the 'course_name' column in the 'Courses' table.\n\nSQL query: SELECT course_name FROM Courses WHERE course_id = (SELECT course_id FROM Student_Course_Enrolment GROUP BY course_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT course_name FROM Courses WHERE course_id = (SELECT course_id FROM Student_Course_Enrolment GROUP BY course_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.student_id ,  T2.login_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Find the student ID and login name of the student with the most course enrollments",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Operation: The query requires the student ID and login name of the student with the most course enrollments, so we should apply the 'count' operation to the 'Student_Course_Enrolment' table for the 'student_id' column, and find the student with the highest count. Since the unit to which the course enrollments being counted in the query belong is the student, we should apply the 'group by' operation to the 'student_id' column in the 'Student_Course_Enrolment' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student_Course_Enrolment', 'Students'].\n\n<3> SQL Generation: The query requires the student ID and login name of the student with the most course enrollments, so we should select the 'student_id' column in the 'Student_Course_Enrolment' table and the 'login_name' column in the 'Students' table.\n\nSQL query: SELECT T1.student_id, T2.login_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.student_id, T2.login_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.student_id ,  T2.login_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What are the student ID and login name of the student who are enrolled in the most courses?",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Operation: The query requires the student ID and login name of the student who is enrolled in the most courses, so we should apply the 'count' operation to the 'Student_Course_Enrolment' table for the 'student_id' column, and find the student with the highest count. Since the unit to which the courses being counted in the query belong is the student, we should apply the 'group by' operation to the 'student_id' column in the 'Student_Course_Enrolment' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student_Course_Enrolment', 'Students'].\n\n<3> SQL Generation: The query requires the student ID and login name of the student who is enrolled in the most courses, so we should select the 'student_id' column in the 'Student_Course_Enrolment' table and the 'login_name' column in the 'Students' table.\n\nSQL query: SELECT T1.student_id, T2.login_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.student_id, T2.login_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_policies",
        "gold": "SELECT T1.claim_id ,  T1.date_claim_made ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which claim incurred the most number of settlements? List the claim id, the date the claim was made, and the number.",
        "fields": "Table Claims, columns = [*,Claim_ID,Policy_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled]\nTable Customer_Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Payments, columns = [*,Payment_ID,Settlement_ID,Payment_Method_Code,Date_Payment_Made,Amount_Payment]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled,Customer_Policy_ID]\n",
        "foreign_keys": "Foreign_keys = [Customer_Policies.Customer_ID = Customers.Customer_ID,Claims.Policy_ID = Customer_Policies.Policy_ID,Settlements.Claim_ID = Claims.Claim_ID,Payments.Settlement_ID = Settlements.Settlement_ID]\n",
        "reasoning": "<1> Operation: The query requires the claim that incurred the most number of settlements, so we should apply the 'count' operation to the 'Settlements' table for the 'Claim_ID' column, and find the claim with the highest count. Since the unit to which the settlements being counted in the query belong is the claim, we should apply the 'group by' operation to the 'Claim_ID' column in the 'Settlements' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Claims', 'Settlements'].\n\n<3> SQL Generation: The query requires the claim that incurred the most number of settlements, so we should select the 'Claim_ID' column in the 'Settlements' table and the 'Date_Claim_Made' column in the 'Claims' table. We also need to count the number of settlements for each claim.\n\nSQL query: SELECT T1.Claim_ID, T2.Date_Claim_Made, COUNT(*) FROM Settlements AS T1 JOIN Claims AS T2 ON T1.Claim_ID = T2.Claim_ID GROUP BY T1.Claim_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Claim_ID, T2.Date_Claim_Made, COUNT(*) FROM Settlements AS T1 JOIN Claims AS T2 ON T1.Claim_ID = T2.Claim_ID GROUP BY T1.Claim_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_policies",
        "gold": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most popular payment method?",
        "fields": "Table Claims, columns = [*,Claim_ID,Policy_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled]\nTable Customer_Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Payments, columns = [*,Payment_ID,Settlement_ID,Payment_Method_Code,Date_Payment_Made,Amount_Payment]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled,Customer_Policy_ID]\n",
        "foreign_keys": "Foreign_keys = [Customer_Policies.Customer_ID = Customers.Customer_ID,Claims.Policy_ID = Customer_Policies.Policy_ID,Settlements.Claim_ID = Claims.Claim_ID,Payments.Settlement_ID = Settlements.Settlement_ID]\n",
        "reasoning": "<1> Operation: The query requires the most popular payment method, so we should apply the 'count' operation to the 'Payment_Method_Code' column in the 'Payments' table and find the payment method with the highest count. Since the unit to which the payment methods being counted in the query belong is the payment method itself, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Payments'.\n\n<3> SQL Generation: The query requires the most popular payment method, so we should select the 'Payment_Method_Code' column in the 'Payments' table.\n\nSQL query: SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_policies",
        "gold": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1",
        "question": "Which payment method is used the most often?",
        "fields": "Table Claims, columns = [*,Claim_ID,Policy_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled]\nTable Customer_Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Payments, columns = [*,Payment_ID,Settlement_ID,Payment_Method_Code,Date_Payment_Made,Amount_Payment]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled,Customer_Policy_ID]\n",
        "foreign_keys": "Foreign_keys = [Customer_Policies.Customer_ID = Customers.Customer_ID,Claims.Policy_ID = Customer_Policies.Policy_ID,Settlements.Claim_ID = Claims.Claim_ID,Payments.Settlement_ID = Settlements.Settlement_ID]\n",
        "reasoning": "<1> Operation: The query requires the payment method that is used the most often, so we should apply the 'count' operation to the 'Payment_Method_Code' column in the 'Payments' table and find the payment method with the highest count. Since the unit to which the payment methods being counted in the query belong is the payment, we should apply the 'group by' operation to the 'Payment_Method_Code' column in the 'Payments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Payments'].\n\n<3> SQL Generation: The query requires the payment method that is used the most often, so we should select the 'Payment_Method_Code' column in the 'Payments' table.\n\nSQL query: SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_policies",
        "gold": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1",
        "question": "With which kind of payment method were the least number of payments processed?",
        "fields": "Table Claims, columns = [*,Claim_ID,Policy_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled]\nTable Customer_Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Payments, columns = [*,Payment_ID,Settlement_ID,Payment_Method_Code,Date_Payment_Made,Amount_Payment]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled,Customer_Policy_ID]\n",
        "foreign_keys": "Foreign_keys = [Customer_Policies.Customer_ID = Customers.Customer_ID,Claims.Policy_ID = Customer_Policies.Policy_ID,Settlements.Claim_ID = Claims.Claim_ID,Payments.Settlement_ID = Settlements.Settlement_ID]\n",
        "reasoning": "<1> Operation: The query requires the kind of payment method with the least number of payments processed, so we should apply the 'count' operation to the 'Payments' table for the 'Payment_Method_Code' column, and find the payment method with the lowest count.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Payments'].\n\n<3> SQL Generation: The query requires the kind of payment method with the least number of payments processed, so we should select the 'Payment_Method_Code' column in the 'Payments' table.\n\nSQL query: SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_policies",
        "gold": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1",
        "question": "What is the payment method that were used the least often?",
        "fields": "Table Claims, columns = [*,Claim_ID,Policy_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled]\nTable Customer_Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Payments, columns = [*,Payment_ID,Settlement_ID,Payment_Method_Code,Date_Payment_Made,Amount_Payment]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled,Customer_Policy_ID]\n",
        "foreign_keys": "Foreign_keys = [Customer_Policies.Customer_ID = Customers.Customer_ID,Claims.Policy_ID = Customer_Policies.Policy_ID,Settlements.Claim_ID = Claims.Claim_ID,Payments.Settlement_ID = Settlements.Settlement_ID]\n",
        "reasoning": "<1> Operation: The query requires the payment method that was used the least often, so we should apply the 'count' operation to the 'Payments' table for the 'Payment_Method_Code' column, and find the payment method with the lowest count.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Payments'].\n\n<3> SQL Generation: The query requires the payment method that was used the least often, so we should select the 'Payment_Method_Code' column in the 'Payments' table.\n\nSQL query: SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_policies",
        "gold": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1",
        "question": "Which kind of policy type was chosen by the most customers?",
        "fields": "Table Claims, columns = [*,Claim_ID,Policy_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled]\nTable Customer_Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Payments, columns = [*,Payment_ID,Settlement_ID,Payment_Method_Code,Date_Payment_Made,Amount_Payment]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled,Customer_Policy_ID]\n",
        "foreign_keys": "Foreign_keys = [Customer_Policies.Customer_ID = Customers.Customer_ID,Claims.Policy_ID = Customer_Policies.Policy_ID,Settlements.Claim_ID = Claims.Claim_ID,Payments.Settlement_ID = Settlements.Settlement_ID]\n",
        "reasoning": "<1> Operation: The query requires the kind of policy type chosen by the most customers, so we should apply the 'count' operation to the 'Policy_Type_Code' column in the 'Customer_Policies' table, and find the policy type with the highest count. Since the unit to which the policy types being counted in the query belong is the customer, we should apply the 'group by' operation to the 'Policy_Type_Code' column in the 'Customer_Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customer_Policies'].\n\n<3> SQL Generation: The query requires the kind of policy type chosen by the most customers, so we should select the 'Policy_Type_Code' column in the 'Customer_Policies' table.\n\nSQL query: SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_policies",
        "gold": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the policy type the most customers choose.",
        "fields": "Table Claims, columns = [*,Claim_ID,Policy_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled]\nTable Customer_Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Payments, columns = [*,Payment_ID,Settlement_ID,Payment_Method_Code,Date_Payment_Made,Amount_Payment]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled,Customer_Policy_ID]\n",
        "foreign_keys": "Foreign_keys = [Customer_Policies.Customer_ID = Customers.Customer_ID,Claims.Policy_ID = Customer_Policies.Policy_ID,Settlements.Claim_ID = Claims.Claim_ID,Payments.Settlement_ID = Settlements.Settlement_ID]\n",
        "reasoning": "<1> Operation: The query requires the policy type that the most customers choose, so we should apply the 'count' operation to the 'Policy_Type_Code' column in the 'Customer_Policies' table, and find the policy type with the highest count. Since the unit to which the policy types being counted in the query belong is the customer, we should apply the 'group by' operation to the 'Policy_Type_Code' column in the 'Customer_Policies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customer_Policies'].\n\n<3> SQL Generation: The query requires the policy type that the most customers choose, so we should select the 'Policy_Type_Code' column in the 'Customer_Policies' table.\n\nSQL query: SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;",
        "question": "Which department has the largest number of employees?",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Operation: The query requires the department with the largest number of employees, so we should apply the 'count' operation to the 'EmployeeID' column in the 'Physician' table, and find the department with the highest count. Since the unit to which the employees being counted in the query belong is the department, we should apply the 'group by' operation to the 'DepartmentID' column in the 'Department' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Department', 'Physician'].\n\n<3> SQL Generation: The query requires the department with the largest number of employees, so we should select the 'Name' column in the 'Department' table and the 'EmployeeID' column in the 'Physician' table.\n\nSQL query: SELECT Name FROM Department WHERE DepartmentID = (SELECT Department FROM Affiliated_With GROUP BY Department ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Name FROM Department WHERE DepartmentID = (SELECT Department FROM Affiliated_With GROUP BY Department ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "hard"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;",
        "question": "What is the employee id of the head whose department has the least number of employees?",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Operation: The query requires the employee id of the head whose department has the least number of employees, so we should apply the 'count' operation to the 'Physician' table for the 'EmployeeID' column, and find the department with the lowest count. Since the unit to which the employees being counted in the query belong is the department, we should apply the 'group by' operation to the 'DepartmentID' column in the 'Department' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Department' and 'Physician', we need to use tables ['Department', 'Physician'].\n\n<3> SQL Generation: The query requires the employee id of the head whose department has the least number of employees, so we should select the 'EmployeeID' column in the 'Physician' table and the 'DepartmentID' column in the 'Department' table.\n\nSQL query: SELECT Physician.EmployeeID FROM Physician JOIN Department ON Department.Head = Physician.EmployeeID GROUP BY Department.DepartmentID ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Physician.EmployeeID FROM Physician JOIN Department ON Department.Head = Physician.EmployeeID GROUP BY Department.DepartmentID ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;",
        "question": "Tell me the employee id of the head of the department with the least employees.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Operation: The query requires the employee id of the head of the department with the least employees, so we should apply the 'count' operation to the 'Physician' table for the 'EmployeeID' column, and find the department with the lowest count. Since the unit to which the employees being counted in the query belong is the department, we should apply the 'group by' operation to the 'DepartmentID' column in the 'Department' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Department' and 'Physician', we need to use tables ['Department', 'Physician'].\n\n<3> SQL Generation: The query requires the employee id of the head of the department with the least employees, so we should select the 'EmployeeID' column in the 'Physician' table and the 'DepartmentID' column in the 'Department' table.\n\nSQL query: SELECT Physician.EmployeeID FROM Physician JOIN Department ON Department.Head = Physician.EmployeeID GROUP BY Department.DepartmentID ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Physician.EmployeeID FROM Physician JOIN Department ON Department.Head = Physician.EmployeeID GROUP BY Department.DepartmentID ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;",
        "question": "what is the name and position of the head whose department has least number of employees?",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Operation: The query requires the name and position of the head whose department has the least number of employees, so we should apply the 'count' operation to the 'Physician' table for the 'EmployeeID' column, and find the department with the lowest count. Since the unit to which the employees being counted in the query belong is the department, we should apply the 'group by' operation to the 'DepartmentID' column in the 'Department' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Department' and 'Physician', we need to use tables ['Department', 'Physician'].\n\n<3> SQL Generation: The query requires the name and position of the head whose department has the least number of employees, so we should select the 'Name' and 'Position' columns in the 'Physician' table.\n\nSQL query: SELECT T1.Name, T1.Position FROM Physician AS T1 JOIN Department AS T2 ON T1.EmployeeID = T2.Head GROUP BY T2.DepartmentID ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT T1.Name, T1.Position FROM Physician AS T1 JOIN Department AS T2 ON T1.EmployeeID = T2.Head GROUP BY T2.DepartmentID ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;",
        "question": "Find the name and position of the head of the department with the least employees.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Operation: The query requires the name and position of the head of the department with the least employees, so we should apply the 'count' operation to the 'Physician' table for the 'EmployeeID' column, and find the department with the lowest count. Since the unit to which the employees being counted in the query belong is the department, we should apply the 'group by' operation to the 'DepartmentID' column in the 'Department' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Department' and 'Physician', we need to use tables ['Department', 'Physician'].\n\n<3> SQL Generation: The query requires the name and position of the head of the department with the least employees, so we should select the 'Name' column in the 'Physician' table and the 'Position' column in the 'Physician' table.\n\nSQL query: SELECT T1.Name, T1.Position FROM Physician AS T1 JOIN Department AS T2 ON T1.EmployeeID = T2.Head GROUP BY T2.DepartmentID ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT T1.Name, T1.Position FROM Physician AS T1 JOIN Department AS T2 ON T1.EmployeeID = T2.Head GROUP BY T2.DepartmentID ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "ship_mission",
        "gold": "SELECT TYPE FROM ship GROUP BY TYPE ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Please show the most common type of ships.",
        "fields": "Table mission, columns = [*,Mission_ID,Ship_ID,Code,Launched_Year,Location,Speed_knots,Fate]\nTable ship, columns = [*,Ship_ID,Name,Type,Nationality,Tonnage]\n",
        "foreign_keys": "Foreign_keys = [mission.Ship_ID = ship.Ship_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common type of ships, so we should apply the 'count' operation to the 'Type' column in the 'ship' table and find the type with the highest count. Since the unit to which the ship types being counted in the query belong is the ship, we should apply the 'group by' operation to the 'Type' column in the 'ship' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['ship'].\n\n<3> SQL Generation: The query requires the most common type of ships, so we should select the 'Type' column in the 'ship' table.\n\nSQL query: SELECT Type FROM ship GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM ship GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "ship_mission",
        "gold": "SELECT TYPE FROM ship GROUP BY TYPE ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the most common type of ships?",
        "fields": "Table mission, columns = [*,Mission_ID,Ship_ID,Code,Launched_Year,Location,Speed_knots,Fate]\nTable ship, columns = [*,Ship_ID,Name,Type,Nationality,Tonnage]\n",
        "foreign_keys": "Foreign_keys = [mission.Ship_ID = ship.Ship_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common type of ships, so we should apply the 'count' operation to the 'Type' column in the 'ship' table and find the type with the highest count. Since the unit to which the ship types being counted in the query belong is the ship, we should apply the 'group by' operation to the 'Type' column in the 'ship' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['ship'].\n\n<3> SQL Generation: The query requires the most common type of ships, so we should select the 'Type' column in the 'ship' table.\n\nSQL query: SELECT Type FROM ship GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM ship GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT classroom FROM list GROUP BY classroom ORDER BY count(*) DESC LIMIT 1",
        "question": "Which classroom has the most students?",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Operation: The query requires the classroom with the most students, so we should apply the 'count' operation to the 'LastName' column in the 'list' table, and find the classroom with the highest count. Since the unit to which the students being counted in the query belong is the classroom, we should apply the 'group by' operation to the 'Classroom' column in the 'list' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['list'].\n\n<3> SQL Generation: The query requires the classroom with the most students, so we should select the 'Classroom' column in the 'list' table.\n\nSQL query: SELECT Classroom FROM list GROUP BY Classroom ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Classroom FROM list GROUP BY Classroom ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT classroom FROM list GROUP BY classroom ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the classroom that the most students use.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Operation: The query requires the classroom that the most students use, so we should apply the 'count' operation to the 'Classroom' column in the 'list' table, and find the classroom with the highest count. Since the unit to which the students being counted in the query belong is the classroom, we should apply the 'group by' operation to the 'Classroom' column in the 'list' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['list'].\n\n<3> SQL Generation: The query requires the classroom that the most students use, so we should select the 'Classroom' column in the 'list' table.\n\nSQL query: SELECT Classroom FROM list GROUP BY Classroom ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Classroom FROM list GROUP BY Classroom ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "company_employee",
        "gold": "SELECT Headquarters FROM company GROUP BY Headquarters ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common headquarter for companies.",
        "fields": "Table company, columns = [*,Company_ID,Name,Headquarters,Industry,Sales_in_Billion,Profits_in_Billion,Assets_in_Billion,Market_Value_in_Billion]\nTable employment, columns = [*,Company_ID,People_ID,Year_working]\nTable people, columns = [*,People_ID,Age,Name,Nationality,Graduation_College]\n",
        "foreign_keys": "Foreign_keys = [employment.People_ID = people.People_ID,employment.Company_ID = company.Company_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common headquarters for companies, so we should apply the 'count' operation to the 'Headquarters' column in the 'company' table and find the headquarters with the highest count. Since the unit to which the headquarters being counted in the query belong is the company, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['company'].\n\n<3> SQL Generation: The query requires the most common headquarters for companies, so we should select the 'Headquarters' column in the 'company' table.\n\nSQL query: SELECT Headquarters FROM company GROUP BY Headquarters ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Headquarters FROM company GROUP BY Headquarters ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT Studio FROM film GROUP BY Studio ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "List the name of film studio that have the most number of films.",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the film studio that has the most number of films, so we should apply the 'count' operation to the 'Film_ID' column in the 'film' table, and find the film studio with the highest count. Since the unit to which the films being counted in the query belong is the film studio, we should apply the 'group by' operation to the 'Studio' column in the 'film' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['film'].\n\n<3> SQL Generation: The query requires the name of the film studio that has the most number of films, so we should select the 'Studio' column in the 'film' table.\n\nSQL query: SELECT Studio FROM film GROUP BY Studio ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Studio FROM film GROUP BY Studio ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT Studio FROM film GROUP BY Studio ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the name of teh studio that created the most films?",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the studio that created the most films, so we should apply the 'count' operation to the 'Film_ID' column in the 'film' table, and find the studio with the highest count. Since the unit to which the films being counted in the query belong is the studio, we should apply the 'group by' operation to the 'Studio' column in the 'film' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['film'].\n\n<3> SQL Generation: The query requires the name of the studio that created the most films, so we should select the 'Studio' column in the 'film' table.\n\nSQL query: SELECT Studio FROM film GROUP BY Studio ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Studio FROM film GROUP BY Studio ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "gold": "SELECT role_code FROM Employees GROUP BY role_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the role code with the largest number of employees?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n",
        "reasoning": "<1> Operation: The query requires the role code with the largest number of employees, so we should apply the 'count' operation to the 'Employees' table for the 'Role_Code' column, and find the role code with the highest count. Since the unit to which the employees being counted in the query belong is the role code, we should apply the 'group by' operation to the 'Role_Code' column in the 'Employees' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Employees'].\n\n<3> SQL Generation: The query requires the role code with the largest number of employees, so we should select the 'Role_Code' column in the 'Employees' table.\n\nSQL query: SELECT Role_Code FROM Employees GROUP BY Role_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Role_Code FROM Employees GROUP BY Role_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "gold": "SELECT role_code FROM Employees GROUP BY role_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the code of the role that have the most employees.",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n",
        "reasoning": "<1> Operation: The query requires the code of the role that has the most employees, so we should apply the 'count' operation to the 'Employees' table for the 'Role_Code' column, and find the role code with the highest count. Since the unit to which the employees being counted in the query belong is the role, we should apply the 'group by' operation to the 'Role_Code' column in the 'Employees' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Employees'].\n\n<3> SQL Generation: The query requires the code of the role that has the most employees, so we should select the 'Role_Code' column in the 'Employees' table.\n\nSQL query: SELECT Role_Code FROM Employees GROUP BY Role_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Role_Code FROM Employees GROUP BY Role_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "gold": "SELECT role_code FROM Employees GROUP BY role_code ORDER BY count(*) ASC LIMIT 1",
        "question": "Show the role code with the least employees.",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n",
        "reasoning": "<1> Operation: The query requires the role code with the least employees, so we should apply the 'count' operation to the 'Employees' table for the 'Role_Code' column, and find the role code with the lowest count. Since the unit to which the employees being counted in the query belong is the role, we should apply the 'group by' operation to the 'Role_Code' column in the 'Employees' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Employees'].\n\n<3> SQL Generation: The query requires the role code with the least employees, so we should select the 'Role_Code' column in the 'Employees' table.\n\nSQL query: SELECT Role_Code FROM Employees GROUP BY Role_Code ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Role_Code FROM Employees GROUP BY Role_Code ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "gold": "SELECT location_code FROM Document_locations GROUP BY location_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the location code with the most documents?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n",
        "reasoning": "<1> Operation: The query requires the location code with the most documents, so we should apply the 'count' operation to the 'Document_ID' column in the 'Document_Locations' table, and find the location code with the highest count. Since the unit to which the documents being counted in the query belong is the location code, we should apply the 'group by' operation to the 'Location_Code' column in the 'Document_Locations' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Document_Locations'].\n\n<3> SQL Generation: The query requires the location code with the most documents, so we should select the 'Location_Code' column in the 'Document_Locations' table.\n\nSQL query: SELECT Location_Code FROM Document_Locations GROUP BY Location_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Location_Code FROM Document_Locations GROUP BY Location_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "gold": "SELECT location_code FROM Document_locations GROUP BY location_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the code of the location with the largest number of documents.",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n",
        "reasoning": "<1> Operation: The query requires the code of the location with the largest number of documents, so we should apply the 'count' operation to the 'Document_ID' column in the 'Document_Locations' table, and find the location code with the highest count. Since the unit to which the documents being counted in the query belong is the location, we should apply the 'group by' operation to the 'Location_Code' column in the 'Document_Locations' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Document_Locations'].\n\n<3> SQL Generation: The query requires the code of the location with the largest number of documents, so we should select the 'Location_Code' column in the 'Document_Locations' table.\n\nSQL query: SELECT Location_Code FROM Document_Locations GROUP BY Location_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Location_Code FROM Document_Locations GROUP BY Location_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "gold": "SELECT T2.location_name ,  T1.location_code FROM Document_locations AS T1 JOIN Ref_locations AS T2 ON T1.location_code  =  T2.location_code GROUP BY T1.location_code ORDER BY count(*) ASC LIMIT 1",
        "question": "Show the location name and code with the least documents.",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n",
        "reasoning": "<1> Operation: The query requires the location name and code with the least documents, so we should apply the 'count' operation to the 'Document_ID' column in the 'Document_Locations' table, and sort it in ascending order. Since the unit to which the documents being counted in the query belong is the location, we should apply the 'group by' operation to the 'Location_Code' column in the 'Document_Locations' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Document_Locations', 'Ref_Locations'].\n\n<3> SQL Generation: The query requires the location name and code with the least documents, so we should select the 'Location_Name' column in the 'Ref_Locations' table and the 'Location_Code' column in the 'Ref_Locations' table.\n\nSQL query: SELECT Location_Name, Location_Code FROM Ref_Locations WHERE Location_Code = (SELECT Location_Code FROM Document_Locations GROUP BY Location_Code ORDER BY COUNT(*) ASC LIMIT 1)",
        "predict": "SELECT Location_Name, Location_Code FROM Ref_Locations WHERE Location_Code = (SELECT Location_Code FROM Document_Locations GROUP BY Location_Code ORDER BY COUNT(*) ASC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "gold": "SELECT T2.location_name ,  T1.location_code FROM Document_locations AS T1 JOIN Ref_locations AS T2 ON T1.location_code  =  T2.location_code GROUP BY T1.location_code ORDER BY count(*) ASC LIMIT 1",
        "question": "What are the name and code of the location with the smallest number of documents?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n",
        "reasoning": "<1> Operation: The query requires the name and code of the location with the smallest number of documents, so we should apply the 'count' operation to the 'Document_ID' column in the 'Document_Locations' table, and find the location with the lowest count. Since the unit to which the documents being counted in the query belong is the location, we should apply the 'group by' operation to the 'Location_Code' column in the 'Document_Locations' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Document_Locations'].\n\n<3> SQL Generation: The query requires the name and code of the location with the smallest number of documents, so we should select the 'Location_Name' column in the 'Ref_Locations' table and the 'Location_Code' column in the 'Ref_Locations' table.\n\nSQL query: SELECT Location_Name, Location_Code FROM Ref_Locations WHERE Location_Code = (SELECT Location_Code FROM Document_Locations GROUP BY Location_Code ORDER BY COUNT(*) ASC LIMIT 1)",
        "predict": "SELECT Location_Name, Location_Code FROM Ref_Locations WHERE Location_Code = (SELECT Location_Code FROM Document_Locations GROUP BY Location_Code ORDER BY COUNT(*) ASC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  \"600\" GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1",
        "question": "Which club has the most members majoring in \"600\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the club with the most members majoring in \"600\", so we should apply the 'count' operation to the 'StuID' column in the 'Member_of_club' table, and find the club with the highest count. Since the unit to which the members being counted in the query belong is the club, we should apply the 'group by' operation to the 'ClubID' column in the 'Member_of_club' table. We also need to filter the members majoring in \"600\" in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Club', 'Member_of_club', and 'Student', we need to use tables ['Club', 'Member_of_club', 'Student'].\n\n<3> SQL Generation: The query requires the club with the most members majoring in \"600\", so we should select the 'ClubName' column in the 'Club' table and the 'StuID' column in the 'Member_of_club' table. We also need to filter the members majoring in \"600\" in the 'Student' table.\n\nSQL query: SELECT T1.ClubName FROM Club AS T1 JOIN Member_of_club AS T2 ON T1.ClubID = T2.ClubID JOIN Student AS T3 ON T2.StuID = T3.StuID WHERE T3.Major = \"600\" GROUP BY T1.ClubID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.ClubName FROM Club AS T1 JOIN Member_of_club AS T2 ON T1.ClubID = T2.ClubID JOIN Student AS T3 ON T2.StuID = T3.StuID WHERE T3.Major = \"600\" GROUP BY T1.ClubID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  \"600\" GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the club which has the largest number of members majoring in \"600\".",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the club with the largest number of members majoring in \"600\", so we should apply the 'count' operation to the 'StuID' column in the 'Member_of_club' table, and find the club with the highest count. Since the unit to which the members being counted in the query belong is the club, we should apply the 'group by' operation to the 'ClubID' column in the 'Member_of_club' table. We also need to filter the members majoring in \"600\" in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Club', 'Member_of_club', and 'Student', we need to use tables ['Club', 'Member_of_club', 'Student'].\n\n<3> SQL Generation: The query requires the club with the largest number of members majoring in \"600\", so we should select the 'ClubName' column in the 'Club' table and the 'StuID' column in the 'Member_of_club' table.\n\nSQL query: SELECT ClubName FROM Club WHERE ClubID = (SELECT ClubID FROM Member_of_club WHERE StuID IN (SELECT StuID FROM Student WHERE Major = \"600\") GROUP BY ClubID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT ClubName FROM Club WHERE ClubID = (SELECT ClubID FROM Member_of_club WHERE StuID IN (SELECT StuID FROM Student WHERE Major = \"600\") GROUP BY ClubID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  \"F\" GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the club that has the most female students.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the name of the club that has the most female students, so we should apply the 'count' operation to the 'StuID' column in the 'Member_of_club' table for female students, and find the club with the highest count. Since the unit to which the female students being counted in the query belong is the club, we should apply the 'group by' operation to the 'ClubID' column in the 'Member_of_club' table. We also need to filter for female students in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Club', 'Member_of_club', and 'Student', we need to use tables ['Club', 'Member_of_club', 'Student'].\n\n<3> SQL Generation: The query requires the name of the club that has the most female students, so we should select the 'ClubName' column in the 'Club' table and the 'StuID' column in the 'Member_of_club' table. We also need to filter for female students in the 'Student' table.\n\nSQL query: SELECT ClubName FROM Club WHERE ClubID = (SELECT ClubID FROM Member_of_club WHERE StuID IN (SELECT StuID FROM Student WHERE Sex = 'female') GROUP BY ClubID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT ClubName FROM Club WHERE ClubID = (SELECT ClubID FROM Member_of_club WHERE StuID IN (SELECT StuID FROM Student WHERE Sex = 'female') GROUP BY ClubID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  \"F\" GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1",
        "question": "Which club has the most female students as their members? Give me the name of the club.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the club that has the most female students as their members, so we should apply the 'count' operation to the 'StuID' column in the 'Member_of_club' table for female students, and find the club with the highest count. Since the unit to which the female students being counted in the query belong is the club, we should apply the 'group by' operation to the 'ClubID' column in the 'Member_of_club' table. We also need to filter for female students in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Club', 'Member_of_club', and 'Student', we need to use tables ['Club', 'Member_of_club', 'Student'].\n\n<3> SQL Generation: The query requires the club that has the most female students as their members, so we should select the 'ClubName' column in the 'Club' table and the 'StuID' column in the 'Member_of_club' table. We also need to filter for female students in the 'Student' table.\n\nSQL query: SELECT ClubName FROM Club WHERE ClubID = (SELECT ClubID FROM Member_of_club WHERE StuID IN (SELECT StuID FROM Student WHERE Sex = 'female') GROUP BY ClubID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT ClubName FROM Club WHERE ClubID = (SELECT ClubID FROM Member_of_club WHERE StuID IN (SELECT StuID FROM Student WHERE Sex = 'female') GROUP BY ClubID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the organisation type and id of the organisation which has the most number of research staff?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the organisation type and id of the organisation which has the most number of research staff, so we should apply the 'count' operation to the 'Research_Staff' table for the 'employer_organisation_id' column, and find the organisation with the highest count. Since the unit to which the research staff being counted in the query belong is the organisation, we should apply the 'group by' operation to the 'employer_organisation_id' column in the 'Research_Staff' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Research_Staff' and 'Organisations', we need to use tables ['Research_Staff', 'Organisations'].\n\n<3> SQL Generation: The query requires the organisation type and id of the organisation which has the most number of research staff, so we should select the 'organisation_type' column and 'organisation_id' column in the 'Organisations' table.\n\nSQL query: SELECT organisation_type, organisation_id FROM Organisations WHERE organisation_id = (SELECT employer_organisation_id FROM Research_Staff GROUP BY employer_organisation_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT organisation_type, organisation_id FROM Organisations WHERE organisation_id = (SELECT employer_organisation_id FROM Research_Staff GROUP BY employer_organisation_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the type and id of the organization that has the most research staff?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the type and id of the organization that has the most research staff, so we should apply the 'count' operation to the 'Research_Staff' table for the 'employer_organisation_id' column, and find the organization with the highest count. Since the unit to which the research staff being counted in the query belong is the organization, we should apply the 'group by' operation to the 'employer_organisation_id' column in the 'Research_Staff' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Research_Staff' and 'Organisations', we need to use tables ['Research_Staff', 'Organisations'].\n\n<3> SQL Generation: The query requires the type and id of the organization that has the most research staff, so we should select the 'organisation_type' column in the 'Organisations' table and the 'employer_organisation_id' column in the 'Research_Staff' table.\n\nSQL query: SELECT T1.organisation_type, T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T2.employer_organisation_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.organisation_type, T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T2.employer_organisation_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1",
        "question": "Which organisation type hires most research staff?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the organisation type that hires the most research staff, so we should apply the 'count' operation to the 'Research_Staff' table for the 'employer_organisation_id' column, and find the organisation type with the highest count. Since the unit to which the research staff being counted in the query belong is the organisation type, we should apply the 'group by' operation to the 'organisation_type' column in the 'Organisation_Types' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Research_Staff' and 'Organisations', we need to use tables ['Research_Staff', 'Organisations', 'Organisation_Types'].\n\n<3> SQL Generation: The query requires the organisation type that hires the most research staff, so we should select the 'organisation_type' column in the 'Organisation_Types' table and the 'employer_organisation_id' column in the 'Research_Staff' table.\n\nSQL query: SELECT T1.organisation_type FROM Organisation_Types AS T1 JOIN Organisations AS T2 ON T1.organisation_type = T2.organisation_type JOIN Research_Staff AS T3 ON T2.organisation_id = T3.employer_organisation_id GROUP BY T1.organisation_type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.organisation_type FROM Organisation_Types AS T1 JOIN Organisations AS T2 ON T1.organisation_type = T2.organisation_type JOIN Research_Staff AS T3 ON T2.organisation_id = T3.employer_organisation_id GROUP BY T1.organisation_type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC",
        "question": "How many staff does each project has? List the project id and the number in an ascending order.",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the number of staff for each project, so we should apply the 'count' operation to the 'staff_id' column in the 'Project_Staff' table, and it does not need sorting. Since the unit to which the staff being counted in the query belong is the project, we should apply the 'group by' operation to the 'project_id' column in the 'Project_Staff' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Project_Staff' and 'Projects', we need to use tables ['Project_Staff', 'Projects'].\n\n<3> SQL Generation: The query requires the number of staff for each project, so we should select the 'project_id' column in the 'Projects' table and count the 'staff_id' column in the 'Project_Staff' table.\n\nSQL query: SELECT T2.project_id, COUNT(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id = T2.project_id GROUP BY T2.project_id ORDER BY COUNT(*) ASC",
        "predict": "SELECT T2.project_id, COUNT(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id = T2.project_id GROUP BY T2.project_id ORDER BY COUNT(*) ASC",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC",
        "question": "For each project id, how many staff does it have? List them in increasing order.",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the number of staff for each project id, so we should apply the 'count' operation to the 'staff_id' column in the 'Project_Staff' table, and sort it in ascending order. Since the unit to which the staff being counted in the query belong is the project id, we should apply the 'group by' operation to the 'project_id' column in the 'Project_Staff' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Project_Staff'].\n\n<3> SQL Generation: The query requires the number of staff for each project id, so we should select the 'project_id' column in the 'Project_Staff' table and count the 'staff_id' column in the 'Project_Staff' table.\n\nSQL query: SELECT project_id, COUNT(staff_id) FROM Project_Staff GROUP BY project_id ORDER BY COUNT(staff_id) ASC",
        "predict": "SELECT project_id, COUNT(staff_id) FROM Project_Staff GROUP BY project_id ORDER BY COUNT(staff_id) ASC",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the details and id of the project with the most outcomes?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the details and id of the project with the most outcomes, so we should apply the 'count' operation to the 'Project_Outcomes' table for the 'project_id' column, and find the project with the highest count. Since the unit to which the outcomes being counted in the query belong is the project, we should apply the 'group by' operation to the 'project_id' column in the 'Project_Outcomes' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Projects'].\n\n<3> SQL Generation: The query requires the details and id of the project with the most outcomes, so we should select the 'project_id' column and the 'project_details' column in the 'Projects' table.\n\nSQL query: SELECT project_id, project_details FROM Projects WHERE project_id = (SELECT project_id FROM Project_Outcomes GROUP BY project_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT project_id, project_details FROM Projects WHERE project_id = (SELECT project_id FROM Project_Outcomes GROUP BY project_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the organisation that hired the most number of research staff, so we should apply the 'count' operation to the 'Research_Staff' table for the 'employer_organisation_id' column, and find the organisation with the highest count. Since the unit to which the research staff being counted in the query belong is the organisation, we should apply the 'group by' operation to the 'employer_organisation_id' column in the 'Research_Staff' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Research_Staff' and 'Organisations', we need to use tables ['Research_Staff', 'Organisations'].\n\n<3> SQL Generation: The query requires the organisation that hired the most number of research staff, so we should select the 'organisation_id', 'organisation_type', and 'organisation_details' columns in the 'Organisations' table.\n\nSQL query: SELECT T1.organisation_id, T1.organisation_type, T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T2.employer_organisation_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.organisation_id, T1.organisation_type, T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T2.employer_organisation_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the ids, types, and details of the organization with the most research staff?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the ids, types, and details of the organization with the most research staff, so we should apply the 'count' operation to the 'Research_Staff' table for the 'employer_organisation_id' column, and find the organization with the highest count. Since the unit to which the research staff being counted in the query belong is the organization, we should apply the 'group by' operation to the 'employer_organisation_id' column in the 'Research_Staff' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Research_Staff' and 'Organisations', we need to use tables ['Research_Staff', 'Organisations'].\n\n<3> SQL Generation: The query requires the ids, types, and details of the organization with the most research staff, so we should select the 'organisation_id', 'organisation_type', and 'organisation_details' columns in the 'Organisations' table.\n\nSQL query: SELECT organisation_id, organisation_type, organisation_details FROM Organisations WHERE organisation_id = (SELECT employer_organisation_id FROM Research_Staff GROUP BY employer_organisation_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT organisation_id, organisation_type, organisation_details FROM Organisations WHERE organisation_id = (SELECT employer_organisation_id FROM Research_Staff GROUP BY employer_organisation_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the role description and the id of the project staff involved in most number of project outcomes?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the role description and the id of the project staff involved in the most number of project outcomes, so we should apply the 'count' operation to the 'project_id' column in the 'Project_Outcomes' table and find the project staff with the highest count. Since the unit to which the project outcomes being counted in the query belong is the project staff, we should apply the 'group by' operation to the 'staff_id' column in the 'Project_Staff' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Project_Outcomes' and 'Project_Staff', we need to use tables ['Project_Outcomes', 'Project_Staff'].\n\n<3> SQL Generation: The query requires the role description and the id of the project staff involved in the most number of project outcomes, so we should select the 'role_description' column in the 'Staff_Roles' table and the 'staff_id' column in the 'Project_Staff' table.\n\nSQL query: SELECT T1.role_description, T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code = T2.role_code JOIN Project_Outcomes AS T3 ON T2.project_id = T3.project_id GROUP BY T2.staff_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.role_description, T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code = T2.role_code JOIN Project_Outcomes AS T3 ON T2.project_id = T3.project_id GROUP BY T2.staff_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1",
        "question": "How many documents can one grant have at most? List the grant id and number.",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the maximum number of documents that can be associated with a grant, so we should apply the 'count' operation to the 'document_id' column in the 'Documents' table, and find the maximum count. Since the unit to which the documents being counted in the query belong is the grant, we should apply the 'group by' operation to the 'grant_id' column in the 'Documents' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Documents' and 'Grants', we need to use tables ['Documents', 'Grants'].\n\n<3> SQL Generation: The query requires the maximum number of documents that can be associated with a grant, so we should select the 'grant_id' column in the 'Grants' table and the count of the 'document_id' column in the 'Documents' table.\n\nSQL query: SELECT grant_id, COUNT(document_id) FROM Documents GROUP BY grant_id ORDER BY COUNT(document_id) DESC LIMIT 1",
        "predict": "SELECT grant_id, COUNT(document_id) FROM Documents GROUP BY grant_id ORDER BY COUNT(document_id) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1",
        "question": "List the organisation id with the maximum outcome count, and the count.",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the organization ID with the maximum outcome count, so we should apply the 'count' operation to the 'outcome_code' column in the 'Project_Outcomes' table and find the organization ID with the highest count. Since the unit to which the outcomes being counted in the query belong is the organization, we should apply the 'group by' operation to the 'organisation_id' column in the 'Projects' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Projects' and 'Project_Outcomes', we need to use tables ['Projects', 'Project_Outcomes'].\n\n<3> SQL Generation: The query requires the organization ID with the maximum outcome count, so we should select the 'organisation_id' column in the 'Projects' table and the count of the 'outcome_code' column in the 'Project_Outcomes' table.\n\nSQL query: SELECT T1.organisation_id, COUNT(*) FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id GROUP BY T1.organisation_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.organisation_id, COUNT(*) FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id GROUP BY T1.organisation_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the id of the organization with the maximum number of outcomes, so we should apply the 'count' operation to the 'outcome_code' column in the 'Project_Outcomes' table, and find the organization with the highest count. Since the unit to which the outcomes being counted in the query belong is the organization, we should apply the 'group by' operation to the 'organisation_id' column in the 'Projects' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Projects' and 'Project_Outcomes', we need to use tables ['Projects', 'Project_Outcomes'].\n\n<3> SQL Generation: The query requires the id of the organization with the maximum number of outcomes, so we should select the 'organisation_id' column in the 'Projects' table and count the 'outcome_code' column in the 'Project_Outcomes' table.\n\nSQL query: SELECT T1.organisation_id, COUNT(*) FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id GROUP BY T1.organisation_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.organisation_id, COUNT(*) FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id GROUP BY T1.organisation_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Which role is most common for the staff?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the role that is most common for the staff, so we should apply the 'count' operation to the 'Project_Staff' table for the 'role_code' column, and find the role with the highest count. Since the unit to which the roles being counted in the query belong is the staff, we should apply the 'group by' operation to the 'role_code' column in the 'Project_Staff' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Project_Staff'].\n\n<3> SQL Generation: The query requires the role that is most common for the staff, so we should select the 'role_code' column in the 'Project_Staff' table.\n\nSQL query: SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most common role for the staff?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Operation: The query requires the most common role for the staff, so we should apply the 'count' operation to the 'Project_Staff' table for the 'role_code' column, and find the role with the highest count. Since the unit to which the roles being counted in the query belong is the staff, we should apply the 'group by' operation to the 'role_code' column in the 'Project_Staff' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Project_Staff'].\n\n<3> SQL Generation: The query requires the most common role for the staff, so we should select the 'role_code' column in the 'Project_Staff' table.\n\nSQL query: SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "decoration_competition",
        "gold": "SELECT Country FROM member GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common country across members.",
        "fields": "Table college, columns = [*,College_ID,Name,Leader_Name,College_Location]\nTable member, columns = [*,Member_ID,Name,Country,College_ID]\nTable round, columns = [*,Round_ID,Member_ID,Decoration_Theme,Rank_in_Round]\n",
        "foreign_keys": "Foreign_keys = [member.College_ID = college.College_ID,round.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common country across members, so we should apply the 'count' operation to the 'Country' column in the 'member' table and find the country with the highest count. Since the unit to which the countries being counted in the query belong is the member, we should apply the 'group by' operation to the 'Country' column in the 'member' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['member'].\n\n<3> SQL Generation: The query requires the most common country across members, so we should select the 'Country' column in the 'member' table.\n\nSQL query: SELECT Country FROM member GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Country FROM member GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the total access count of documents that are of the most common document type?",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Operation: The query requires the total access count of documents that are of the most common document type, so we should apply the 'count' operation to the 'document_type_code' column in the 'Documents' table, and find the document type with the highest count. Since the unit to which the document types being counted in the query belong is the document, we should apply the 'group by' operation to the 'document_type_code' column in the 'Documents' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Documents'].\n\n<3> SQL Generation: The query requires the total access count of documents that are of the most common document type, so we should select the sum of the 'access_count' column in the 'Documents' table.\n\nSQL query: SELECT SUM(access_count) FROM Documents WHERE document_type_code = (SELECT document_type_code FROM Documents GROUP BY document_type_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT SUM(access_count) FROM Documents WHERE document_type_code = (SELECT document_type_code FROM Documents GROUP BY document_type_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "hard"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the structure description of the document that has been accessed the fewest number of times.",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Operation: The query requires the structure description of the document that has been accessed the fewest number of times, so we should apply the 'min' operation to the 'access_count' column in the 'Documents' table. Since the unit to which the access counts being compared in the query belong is the document, we do not need to apply any grouping or sorting operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Documents'].\n\n<3> SQL Generation: The query requires the structure description of the document that has been accessed the fewest number of times, so we should select the 'document_structure_description' column in the 'Document_Structures' table and the 'access_count' column in the 'Documents' table.\n\nSQL query: SELECT document_structure_description FROM Document_Structures WHERE document_structure_code = (SELECT document_structure_code FROM Documents WHERE access_count = (SELECT MIN(access_count) FROM Documents))",
        "predict": "SELECT document_structure_description FROM Document_Structures WHERE document_structure_code = (SELECT document_structure_code FROM Documents WHERE access_count = (SELECT MIN(access_count) FROM Documents))",
        "hardness": "extra"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code GROUP BY t1.document_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the document with the most number of sections?",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the document with the most number of sections, so we should apply the 'count' operation to the 'section_id' column in the 'Document_Sections' table, and find the document with the highest count. Since the unit to which the sections being counted in the query belong is the document, we should apply the 'group by' operation to the 'document_code' column in the 'Document_Sections' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Documents', 'Document_Sections'].\n\n<3> SQL Generation: The query requires the name of the document with the most number of sections, so we should select the 'document_name' column in the 'Documents' table and the 'document_code' column in the 'Document_Sections' table.\n\nSQL query: SELECT document_name FROM Documents WHERE document_code = (SELECT document_code FROM Document_Sections GROUP BY document_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT document_name FROM Documents WHERE document_code = (SELECT document_code FROM Document_Sections GROUP BY document_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code GROUP BY t1.document_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the name of the document that has the most sections.",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the document that has the most sections, so we should apply the 'count' operation to the 'section_id' column in the 'Document_Sections' table, and find the document with the highest count. Since the unit to which the sections being counted in the query belong is the document, we should apply the 'group by' operation to the 'document_code' column in the 'Document_Sections' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Documents', 'Document_Sections'].\n\n<3> SQL Generation: The query requires the name of the document that has the most sections, so we should select the 'document_name' column in the 'Documents' table and the 'document_code' column in the 'Document_Sections' table.\n\nSQL query: SELECT document_name FROM Documents WHERE document_code = (SELECT document_code FROM Document_Sections GROUP BY document_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT document_name FROM Documents WHERE document_code = (SELECT document_code FROM Document_Sections GROUP BY document_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT role_description FROM ROLES WHERE role_code  =  (SELECT role_code FROM users WHERE user_login  =  1 GROUP BY role_code ORDER BY count(*) DESC LIMIT 1)",
        "question": "Find the description of the most popular role among the users that have logged in.",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Operation: The query requires the description of the most popular role among the users that have logged in, so we should apply the 'count' operation to the 'Users' table for the 'role_code' column, and find the role with the highest count. Since the unit to which the roles being counted in the query belong is the user, we should apply the 'group by' operation to the 'role_code' column in the 'Users' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use tables ['Users', 'Roles'].\n\n<3> SQL Generation: The query requires the description of the most popular role among the users that have logged in, so we should select the 'role_description' column in the 'Roles' table.\n\nSQL query: SELECT role_description FROM Roles WHERE role_code = (SELECT role_code FROM Users GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT role_description FROM Roles WHERE role_code = (SELECT role_code FROM Users GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "hard"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT role_description FROM ROLES WHERE role_code  =  (SELECT role_code FROM users WHERE user_login  =  1 GROUP BY role_code ORDER BY count(*) DESC LIMIT 1)",
        "question": "What is the description of the most popular role among users that have logged in?",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Operation: The query requires the description of the most popular role among users that have logged in, so we should apply the 'count' operation to the 'Users' table for the 'role_code' column, and find the role with the highest count. Since the unit to which the roles being counted in the query belong is the user, we should apply the 'group by' operation to the 'role_code' column in the 'Users' table. We also need to filter the users that have logged in.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use tables ['Users', 'Roles'].\n\n<3> SQL Generation: The query requires the description of the most popular role among users that have logged in, so we should select the 'role_description' column in the 'Roles' table.\n\nSQL query: SELECT role_description FROM Roles WHERE role_code = (SELECT role_code FROM Users WHERE user_login IS NOT NULL GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT role_description FROM Roles WHERE role_code = (SELECT role_code FROM Users WHERE user_login IS NOT NULL GROUP BY role_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "hard"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT 1",
        "question": "Find the average access count of documents with the least popular structure.",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Operation: The query requires the average access count of documents with the least popular structure, so we should apply the 'average' operation to the 'access_count' column in the 'Documents' table and find the structure with the lowest count. Since the unit to which the access counts being calculated in the query belong is the document structure, we should apply the 'group by' operation to the 'document_structure_code' column in the 'Documents' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Documents', 'Document_Structures'].\n\n<3> SQL Generation: The query requires the average access count of documents with the least popular structure, so we should select the 'access_count' column in the 'Documents' table and the 'document_structure_code' column in the 'Documents' table. We also need to filter for the structure with the lowest count.\n\nSQL query: SELECT AVG(access_count) FROM Documents WHERE document_structure_code = (SELECT document_structure_code FROM Documents GROUP BY document_structure_code ORDER BY COUNT(*) ASC LIMIT 1)",
        "predict": "SELECT AVG(access_count) FROM Documents WHERE document_structure_code = (SELECT document_structure_code FROM Documents GROUP BY document_structure_code ORDER BY COUNT(*) ASC LIMIT 1)",
        "hardness": "hard"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT 1",
        "question": "What is the average access count of documents that have the least common structure?",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Operation: The query requires the average access count of documents that have the least common structure, so we should apply the 'average' operation to the 'access_count' column in the 'Documents' table and find the documents with the least common structure. Since the unit to which the access counts being calculated in the query belong is the document, we should apply the 'group by' operation to the 'document_structure_code' column in the 'Documents' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Documents', 'Document_Structures'].\n\n<3> SQL Generation: The query requires the average access count of documents that have the least common structure, so we should select the 'access_count' column in the 'Documents' table and the 'document_structure_code' column in the 'Documents' table. We also need to filter the documents with the least common structure.\n\nSQL query: SELECT AVG(access_count) FROM Documents WHERE document_structure_code = (SELECT document_structure_code FROM Documents GROUP BY document_structure_code ORDER BY COUNT(*) ASC LIMIT 1)",
        "predict": "SELECT AVG(access_count) FROM Documents WHERE document_structure_code = (SELECT document_structure_code FROM Documents GROUP BY document_structure_code ORDER BY COUNT(*) ASC LIMIT 1)",
        "hardness": "hard"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT T2.name FROM Office_locations AS T1 JOIN buildings AS T2 ON T1.building_id  =  T2.id JOIN Companies AS T3 ON T1.company_id  =  T3.id GROUP BY T1.building_id ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the name of the building that has the most company offices.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Operation: The query requires the name of the building that has the most company offices, so we should apply the 'count' operation to the 'company_id' column in the 'Office_locations' table, and find the building with the highest count. Since the unit to which the company offices being counted in the query belong is the building, we should apply the 'group by' operation to the 'building_id' column in the 'Office_locations' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Office_locations' and 'buildings', we need to use tables ['Office_locations', 'buildings'].\n\n<3> SQL Generation: The query requires the name of the building that has the most company offices, so we should select the 'name' column in the 'buildings' table.\n\nSQL query: SELECT T2.name FROM Office_locations AS T1 JOIN buildings AS T2 ON T1.building_id = T2.id GROUP BY T1.building_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.name FROM Office_locations AS T1 JOIN buildings AS T2 ON T1.building_id = T2.id GROUP BY T1.building_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT T2.name FROM Office_locations AS T1 JOIN buildings AS T2 ON T1.building_id  =  T2.id JOIN Companies AS T3 ON T1.company_id  =  T3.id GROUP BY T1.building_id ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which building has the largest number of company offices? Give me the building name.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Operation: The query requires the building with the largest number of company offices, so we should apply the 'count' operation to the 'company_id' column in the 'Office_locations' table, and find the building with the highest count. Since the unit to which the company offices being counted in the query belong is the building, we should apply the 'group by' operation to the 'building_id' column in the 'Office_locations' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Office_locations' and 'buildings', we need to use tables ['Office_locations', 'buildings'].\n\n<3> SQL Generation: The query requires the building with the largest number of company offices, so we should select the 'name' column in the 'buildings' table.\n\nSQL query: SELECT name FROM buildings WHERE id = (SELECT building_id FROM Office_locations GROUP BY building_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT name FROM buildings WHERE id = (SELECT building_id FROM Office_locations GROUP BY building_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "List the industry shared by the most companies.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Operation: The query requires the industry shared by the most companies, so we should apply the 'count' operation to the 'Companies' table for the 'Industry' column, and find the industry with the highest count. Since the unit to which the industries being counted in the query belong is the company, we should apply the 'group by' operation to the 'Industry' column in the 'Companies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Companies'].\n\n<3> SQL Generation: The query requires the industry shared by the most companies, so we should select the 'Industry' column in the 'Companies' table.\n\nSQL query: SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which industry has the most companies?",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Operation: The query requires the industry with the most companies, so we should apply the 'count' operation to the 'Companies' table for the 'industry' column, and find the industry with the highest count. Since the unit to which the companies being counted in the query belong is the industry, we should apply the 'group by' operation to the 'industry' column in the 'Companies' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Companies'].\n\n<3> SQL Generation: The query requires the industry with the most companies, so we should select the 'industry' column in the 'Companies' table.\n\nSQL query: SELECT industry FROM Companies GROUP BY industry ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT industry FROM Companies GROUP BY industry ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "solvency_ii",
        "gold": "SELECT Product_Type_Code FROM Products GROUP BY Product_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common type code across products.",
        "fields": "Table Addresses, columns = [*,Address_ID,address_details]\nTable Agreements, columns = [*,Document_ID,Event_ID]\nTable Assets, columns = [*,Asset_ID,Other_Details]\nTable Assets_in_Events, columns = [*,Asset_ID,Event_ID]\nTable Channels, columns = [*,Channel_ID,Other_Details]\nTable Events, columns = [*,Event_ID,Address_ID,Channel_ID,Event_Type_Code,Finance_ID,Location_ID]\nTable Finances, columns = [*,Finance_ID,Other_Details]\nTable Locations, columns = [*,Location_ID,Other_Details]\nTable Parties, columns = [*,Party_ID,Party_Details]\nTable Parties_in_Events, columns = [*,Party_ID,Event_ID,Role_Code]\nTable Products, columns = [*,Product_ID,Product_Type_Code,Product_Name,Product_Price]\nTable Products_in_Events, columns = [*,Product_in_Event_ID,Event_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [Events.Finance_ID = Finances.Finance_ID,Events.Address_ID = Addresses.Address_ID,Events.Location_ID = Locations.Location_ID,Products_in_Events.Product_ID = Products.Product_ID,Products_in_Events.Event_ID = Events.Event_ID,Parties_in_Events.Event_ID = Events.Event_ID,Parties_in_Events.Party_ID = Parties.Party_ID,Agreements.Event_ID = Events.Event_ID,Assets_in_Events.Event_ID = Events.Event_ID,Assets_in_Events.Event_ID = Events.Event_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common type code across products, so we should apply the 'count' operation to the 'Product_Type_Code' column in the 'Products' table and find the type code with the highest count. Since the unit to which the type codes being counted in the query belong is the product, we should apply the 'group by' operation to the 'Product_Type_Code' column in the 'Products' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Products'].\n\n<3> SQL Generation: The query requires the most common type code across products, so we should select the 'Product_Type_Code' column in the 'Products' table.\n\nSQL query: SELECT Product_Type_Code FROM Products GROUP BY Product_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Product_Type_Code FROM Products GROUP BY Product_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "solvency_ii",
        "gold": "SELECT T1.Product_Name FROM Products AS T1 JOIN Products_in_Events AS T2 ON T1.Product_ID  =  T2.Product_ID GROUP BY T1.Product_Name HAVING COUNT(*)  >=  2 ORDER BY T1.Product_Name",
        "question": "Show the names of products that are in at least two events in ascending alphabetical order of product name.",
        "fields": "Table Addresses, columns = [*,Address_ID,address_details]\nTable Agreements, columns = [*,Document_ID,Event_ID]\nTable Assets, columns = [*,Asset_ID,Other_Details]\nTable Assets_in_Events, columns = [*,Asset_ID,Event_ID]\nTable Channels, columns = [*,Channel_ID,Other_Details]\nTable Events, columns = [*,Event_ID,Address_ID,Channel_ID,Event_Type_Code,Finance_ID,Location_ID]\nTable Finances, columns = [*,Finance_ID,Other_Details]\nTable Locations, columns = [*,Location_ID,Other_Details]\nTable Parties, columns = [*,Party_ID,Party_Details]\nTable Parties_in_Events, columns = [*,Party_ID,Event_ID,Role_Code]\nTable Products, columns = [*,Product_ID,Product_Type_Code,Product_Name,Product_Price]\nTable Products_in_Events, columns = [*,Product_in_Event_ID,Event_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [Events.Finance_ID = Finances.Finance_ID,Events.Address_ID = Addresses.Address_ID,Events.Location_ID = Locations.Location_ID,Products_in_Events.Product_ID = Products.Product_ID,Products_in_Events.Event_ID = Events.Event_ID,Parties_in_Events.Event_ID = Events.Event_ID,Parties_in_Events.Party_ID = Parties.Party_ID,Agreements.Event_ID = Events.Event_ID,Assets_in_Events.Event_ID = Events.Event_ID,Assets_in_Events.Event_ID = Events.Event_ID]\n",
        "reasoning": "<1> Operation: The query requires the names of products that are in at least two events, so we should apply the 'count' operation to the 'Product_ID' column in the 'Products_in_Events' table, and filter for products with a count greater than or equal to 2. We also need to sort the product names in ascending alphabetical order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Products', 'Products_in_Events'].\n\n<3> SQL Generation: The query requires the names of products that are in at least two events, so we should select the 'Product_Name' column in the 'Products' table and count the 'Product_ID' column in the 'Products_in_Events' table. We also need to filter for products with a count greater than or equal to 2 and sort the product names in ascending alphabetical order.\n\nSQL query: SELECT Product_Name FROM Products WHERE Product_ID IN (SELECT Product_ID FROM Products_in_Events GROUP BY Product_ID HAVING COUNT(*) >= 2) ORDER BY Product_Name ASC",
        "predict": "SELECT Product_Name FROM Products WHERE Product_ID IN (SELECT Product_ID FROM Products_in_Events GROUP BY Product_ID HAVING COUNT(*) >= 2) ORDER BY Product_Name ASC",
        "hardness": "hard"
    },
    {
        "db_id": "entertainment_awards",
        "gold": "SELECT TYPE FROM artwork GROUP BY TYPE ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "List the most common type of artworks.",
        "fields": "Table artwork, columns = [*,Artwork_ID,Type,Name]\nTable festival_detail, columns = [*,Festival_ID,Festival_Name,Chair_Name,Location,Year,Num_of_Audience]\nTable nomination, columns = [*,Artwork_ID,Festival_ID,Result]\n",
        "foreign_keys": "Foreign_keys = [nomination.Festival_ID = festival_detail.Festival_ID,nomination.Artwork_ID = artwork.Artwork_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common type of artworks, so we should apply the 'count' operation to the 'Type' column in the 'artwork' table and find the type with the highest count. Since the unit to which the types being counted in the query belong is the artwork, we should apply the 'group by' operation to the 'Type' column in the 'artwork' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['artwork'].\n\n<3> SQL Generation: The query requires the most common type of artworks, so we should select the 'Type' column in the 'artwork' table.\n\nSQL query: SELECT Type FROM artwork GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM artwork GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_campaigns_ecommerce",
        "gold": "SELECT T2.customer_name FROM mailshot_customers AS T1 JOIN customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the names of customers who have the most mailshots.",
        "fields": "Table Customer_Addresses, columns = [*,customer_id,premise_id,date_address_from,address_type_code,date_address_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,shipping_method_code,order_placed_datetime,order_delivered_datetime,order_shipping_charges]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,customer_address,customer_login,customer_password]\nTable Mailshot_Campaigns, columns = [*,mailshot_id,product_category,mailshot_name,mailshot_start_date,mailshot_end_date]\nTable Mailshot_Customers, columns = [*,mailshot_id,customer_id,outcome_code,mailshot_customer_date]\nTable Order_Items, columns = [*,item_id,order_item_status_code,order_id,product_id,item_status_code,item_delivered_datetime,item_order_quantity]\nTable Premises, columns = [*,premise_id,premises_type,premise_details]\nTable Products, columns = [*,product_id,product_category,product_name]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.premise_id = Premises.premise_id,Customer_Orders.customer_id = Customers.customer_id,Mailshot_Customers.mailshot_id = Mailshot_Campaigns.mailshot_id,Mailshot_Customers.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Operation: The query requires the names of customers who have the most mailshots, so we should apply the 'count' operation to the 'Mailshot_Customers' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the mailshots being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Mailshot_Customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Mailshot_Customers'].\n\n<3> SQL Generation: The query requires the names of customers who have the most mailshots, so we should select the 'customer_id' column in the 'Mailshot_Customers' table and the 'customer_name' column in the 'Customers' table.\n\nSQL query: SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Mailshot_Customers GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Mailshot_Customers GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T1.DName FROM DEPARTMENT AS T1 JOIN MINOR_IN AS T2 ON T1.DNO  =  T2.DNO GROUP BY T2.DNO ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the department that has the biggest number of students minored in?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the name of the department that has the biggest number of students minored in, so we should apply the 'count' operation to the 'StuID' column in the 'Minor_in' table, and find the department with the highest count. Since the unit to which the students being counted in the query belong is the department, we should apply the 'group by' operation to the 'DNO' column in the 'Minor_in' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Minor_in' and 'Department', we need to use tables ['Minor_in', 'Department'].\n\n<3> SQL Generation: The query requires the name of the department that has the biggest number of students minored in, so we should select the 'DName' column in the 'Department' table.\n\nSQL query: SELECT DName FROM Department WHERE DNO = (SELECT DNO FROM Minor_in GROUP BY DNO ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT DName FROM Department WHERE DNO = (SELECT DNO FROM Minor_in GROUP BY DNO ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T1.DName FROM DEPARTMENT AS T1 JOIN MINOR_IN AS T2 ON T1.DNO  =  T2.DNO GROUP BY T2.DNO ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the department with the most students minoring in it?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the name of the department with the most students minoring in it, so we should apply the 'count' operation to the 'Minor_in' table for the 'DNO' column, and find the department with the highest count. Since the unit to which the minors being counted in the query belong is the department, we should apply the 'group by' operation to the 'DNO' column in the 'Minor_in' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Department', 'Minor_in'].\n\n<3> SQL Generation: The query requires the name of the department with the most students minoring in it, so we should select the 'DName' column in the 'Department' table.\n\nSQL query: SELECT DName FROM Department WHERE DNO = (SELECT DNO FROM Minor_in GROUP BY DNO ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT DName FROM Department WHERE DNO = (SELECT DNO FROM Minor_in GROUP BY DNO ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T1.DName FROM DEPARTMENT AS T1 JOIN MEMBER_OF AS T2 ON T1.DNO  =  T2.DNO GROUP BY T2.DNO ORDER BY count(*) ASC LIMIT 1",
        "question": "Find the name of the department that has the fewest members.",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the name of the department that has the fewest members, so we should apply the 'count' operation to the 'Member_of' table for the 'DNO' column, and find the department with the lowest count. Since the unit to which the members being counted in the query belong is the department, we should apply the 'group by' operation to the 'DNO' column in the 'Member_of' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Member_of', 'Department'].\n\n<3> SQL Generation: The query requires the name of the department that has the fewest members, so we should select the 'DName' column in the 'Department' table.\n\nSQL query: SELECT DName FROM Department WHERE DNO = (SELECT DNO FROM Member_of GROUP BY DNO ORDER BY COUNT(*) ASC LIMIT 1)",
        "predict": "SELECT DName FROM Department WHERE DNO = (SELECT DNO FROM Member_of GROUP BY DNO ORDER BY COUNT(*) ASC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T1.DName FROM DEPARTMENT AS T1 JOIN MEMBER_OF AS T2 ON T1.DNO  =  T2.DNO GROUP BY T2.DNO ORDER BY count(*) ASC LIMIT 1",
        "question": "What is the name of the department with the fewest members?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the name of the department with the fewest members, so we should apply the 'count' operation to the 'Member_of' table for the 'DNO' column, and find the department with the lowest count. Since the unit to which the members being counted in the query belong is the department, we should apply the 'group by' operation to the 'DNO' column in the 'Member_of' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Department', 'Member_of'].\n\n<3> SQL Generation: The query requires the name of the department with the fewest members, so we should select the 'DName' column in the 'Department' table.\n\nSQL query: SELECT DName FROM Department WHERE DNO = (SELECT DNO FROM Member_of GROUP BY DNO ORDER BY COUNT(*) ASC LIMIT 1)",
        "predict": "SELECT DName FROM Department WHERE DNO = (SELECT DNO FROM Member_of GROUP BY DNO ORDER BY COUNT(*) ASC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Rank FROM FACULTY GROUP BY Rank ORDER BY count(*) ASC LIMIT 1",
        "question": "Find the rank of the faculty that the fewest faculties belong to.",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the rank of the faculty that the fewest faculties belong to, so we should apply the 'count' operation to the 'Member_of' table for the 'FacID' column, and find the rank with the lowest count. Since the unit to which the faculties being counted in the query belong is the rank, we should apply the 'group by' operation to the 'Rank' column in the 'Faculty' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Faculty'].\n\n<3> SQL Generation: The query requires the rank of the faculty that the fewest faculties belong to, so we should select the 'Rank' column in the 'Faculty' table.\n\nSQL query: SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Rank FROM FACULTY GROUP BY Rank ORDER BY count(*) ASC LIMIT 1",
        "question": "What is the least common faculty rank?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the least common faculty rank, so we should apply the 'count' operation to the 'Rank' column in the 'Faculty' table and find the rank with the lowest count. Since the unit to which the ranks being counted in the query belong is the faculty, we should apply the 'group by' operation to the 'Rank' column in the 'Faculty' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Faculty'].\n\n<3> SQL Generation: The query requires the least common faculty rank, so we should select the 'Rank' column in the 'Faculty' table.\n\nSQL query: SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T2.Fname ,  T2.Lname FROM COURSE AS T1 JOIN FACULTY AS T2 ON T1.Instructor  =  T2.FacID GROUP BY T1.Instructor ORDER BY count(*) DESC LIMIT 3",
        "question": "What are the first and last names of the instructors who teach the top 3 number of courses?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the first and last names of the instructors who teach the top 3 number of courses, so we should apply the 'count' operation to the 'CID' column in the 'Course' table and find the instructors with the highest count. Since the unit to which the courses being counted in the query belong is the instructor, we should apply the 'group by' operation to the 'Instructor' column in the 'Course' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Course' and 'Faculty', we need to use tables ['Course', 'Faculty'].\n\n<3> SQL Generation: The query requires the first and last names of the instructors who teach the top 3 number of courses, so we should select the 'Fname' and 'Lname' columns in the 'Faculty' table and the 'Instructor' column in the 'Course' table.\n\nSQL query: SELECT T2.Fname, T2.Lname FROM Course AS T1 JOIN Faculty AS T2 ON T1.Instructor = T2.FacID GROUP BY T1.Instructor ORDER BY COUNT(T1.CID) DESC LIMIT 3",
        "predict": "SELECT T2.Fname, T2.Lname FROM Course AS T1 JOIN Faculty AS T2 ON T1.Instructor = T2.FacID GROUP BY T1.Instructor ORDER BY COUNT(T1.CID) DESC LIMIT 3",
        "hardness": "extra"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T2.Building FROM COURSE AS T1 JOIN FACULTY AS T2 ON T1.Instructor  =  T2.FacID GROUP BY T1.Instructor ORDER BY count(*) DESC LIMIT 1",
        "question": "Which building does the instructor who teaches the most number of courses live in?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the building in which the instructor who teaches the most number of courses lives, so we should apply the 'count' operation to the 'Course' table for the 'Instructor' column, and find the instructor with the highest count. Since the unit to which the courses being counted in the query belong is the instructor, we should apply the 'group by' operation to the 'Instructor' column in the 'Course' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Course' and 'Faculty', we need to use tables ['Course', 'Faculty'].\n\n<3> SQL Generation: The query requires the building in which the instructor who teaches the most number of courses lives, so we should select the 'Building' column in the 'Faculty' table. The query does not require the count of courses, so it is only used for filtering and not selected.\n\nSQL query: SELECT Building FROM Faculty WHERE FacID = (SELECT Instructor FROM Course GROUP BY Instructor ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Building FROM Faculty WHERE FacID = (SELECT Instructor FROM Course GROUP BY Instructor ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T2.Building FROM COURSE AS T1 JOIN FACULTY AS T2 ON T1.Instructor  =  T2.FacID GROUP BY T1.Instructor ORDER BY count(*) DESC LIMIT 1",
        "question": "Give the building that the instructor who teaches the greatest number of courses lives in.",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the building that the instructor who teaches the greatest number of courses lives in, so we should apply the 'count' operation to the 'CID' column in the 'Course' table for each instructor, and find the instructor with the highest count. Since the unit to which the courses being counted in the query belong is the instructor, we should apply the 'group by' operation to the 'Instructor' column in the 'Course' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Course' and 'Faculty', we need to use tables ['Course', 'Faculty'].\n\n<3> SQL Generation: The query requires the building that the instructor who teaches the greatest number of courses lives in, so we should select the 'Building' column in the 'Faculty' table. The query does not require the count of courses, so it is only used for filtering and not selected.\n\nSQL query: SELECT Building FROM Faculty WHERE FacID = (SELECT Instructor FROM Course GROUP BY Instructor ORDER BY COUNT(CID) DESC LIMIT 1)",
        "predict": "SELECT Building FROM Faculty WHERE FacID = (SELECT Instructor FROM Course GROUP BY Instructor ORDER BY COUNT(CID) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT product_id FROM order_items GROUP BY product_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id of the product that was ordered the most often?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Operation: The query requires the id of the product that was ordered the most often, so we should apply the 'count' operation to the 'product_id' column in the 'Order_Items' table, and find the product with the highest count. Since the unit to which the products being counted in the query belong is the product, we should apply the 'group by' operation to the 'product_id' column in the 'Order_Items' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Order_Items'].\n\n<3> SQL Generation: The query requires the id of the product that was ordered the most often, so we should select the 'product_id' column in the 'Order_Items' table.\n\nSQL query: SELECT product_id FROM Order_Items GROUP BY product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT product_id FROM Order_Items GROUP BY product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT product_id FROM order_items GROUP BY product_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Give the product id for the product that was ordered most frequently.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Operation: The query requires the product id for the product that was ordered most frequently, so we should apply the 'count' operation to the 'Order_Items' table for the 'product_id' column, and find the product with the highest count. Since the unit to which the products being counted in the query belong is the product, we should apply the 'group by' operation to the 'product_id' column in the 'Order_Items' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Order_Items'].\n\n<3> SQL Generation: The query requires the product id for the product that was ordered most frequently, so we should select the 'product_id' column in the 'Order_Items' table.\n\nSQL query: SELECT product_id FROM Order_Items GROUP BY product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT product_id FROM Order_Items GROUP BY product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT T1.customer_name ,  T1.customer_phone ,  T1.customer_email FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T2.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the name, phone number and email address of the customer who made the largest number of orders?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Operation: The query requires the name, phone number, and email address of the customer who made the largest number of orders, so we should apply the 'count' operation to the 'Customer_Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Customer_Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers'].\n\n<3> SQL Generation: The query requires the name, phone number, and email address of the customer who made the largest number of orders, so we should select the 'customer_name', 'customer_phone', and 'customer_email' columns in the 'Customers' table.\n\nSQL query: SELECT customer_name, customer_phone, customer_email FROM Customers WHERE customer_id = (SELECT customer_id FROM Customer_Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_name, customer_phone, customer_email FROM Customers WHERE customer_id = (SELECT customer_id FROM Customer_Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT T1.customer_name ,  T1.customer_phone ,  T1.customer_email FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T2.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the name, phone number and email address for the customer with the most orders.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Operation: The query requires the name, phone number, and email address for the customer with the most orders, so we should apply the 'count' operation to the 'Customer_Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Customer_Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Customer_Orders' and 'Customers', we need to use tables ['Customer_Orders', 'Customers'].\n\n<3> SQL Generation: The query requires the name, phone number, and email address for the customer with the most orders, so we should select the 'customer_name', 'customer_phone', and 'customer_email' columns in the 'Customers' table.\n\nSQL query: SELECT customer_name, customer_phone, customer_email FROM Customers WHERE customer_id = (SELECT customer_id FROM Customer_Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_name, customer_phone, customer_email FROM Customers WHERE customer_id = (SELECT customer_id FROM Customer_Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT dept_store_chain_id FROM department_stores GROUP BY dept_store_chain_id ORDER BY count(*) DESC LIMIT 2",
        "question": "What are the ids of the two department store chains with the largest number of department stores?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Operation: The query requires the ids of the two department store chains with the largest number of department stores, so we should apply the 'count' operation to the 'Department_Stores' table for the 'dept_store_chain_id' column, and find the department store chains with the highest count. Since the unit to which the department stores being counted in the query belong is the department store chain, we should apply the 'group by' operation to the 'dept_store_chain_id' column in the 'Department_Stores' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Department_Stores'].\n\n<3> SQL Generation: The query requires the ids of the two department store chains with the largest number of department stores, so we should select the 'dept_store_chain_id' column in the 'Department_Stores' table.\n\nSQL query: SELECT dept_store_chain_id FROM Department_Stores GROUP BY dept_store_chain_id ORDER BY COUNT(*) DESC LIMIT 2",
        "predict": "SELECT dept_store_chain_id FROM Department_Stores GROUP BY dept_store_chain_id ORDER BY COUNT(*) DESC LIMIT 2",
        "hardness": "hard"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT dept_store_chain_id FROM department_stores GROUP BY dept_store_chain_id ORDER BY count(*) DESC LIMIT 2",
        "question": "Return the ids of the two department store chains with the most department stores.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Operation: The query requires the ids of the two department store chains with the most department stores, so we should apply the 'count' operation to the 'dept_store_chain_id' column in the 'Department_Stores' table, and find the department store chains with the highest count. Since the unit to which the department stores being counted in the query belong is the department store chain, we should apply the 'group by' operation to the 'dept_store_chain_id' column in the 'Department_Stores' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Department_Stores'].\n\n<3> SQL Generation: The query requires the ids of the two department store chains with the most department stores, so we should select the 'dept_store_chain_id' column in the 'Department_Stores' table.\n\nSQL query: SELECT dept_store_chain_id FROM Department_Stores GROUP BY dept_store_chain_id ORDER BY COUNT(*) DESC LIMIT 2",
        "predict": "SELECT dept_store_chain_id FROM Department_Stores GROUP BY dept_store_chain_id ORDER BY COUNT(*) DESC LIMIT 2",
        "hardness": "hard"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT department_id FROM staff_department_assignments GROUP BY department_id ORDER BY count(*) LIMIT 1",
        "question": "What is the id of the department with the least number of staff?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Operation: The query requires the id of the department with the least number of staff, so we should apply the 'count' operation to the 'staff_id' column in the 'Staff_Department_Assignments' table, and find the department with the lowest count. Since the unit to which the staff being counted in the query belong is the department, we should apply the 'group by' operation to the 'department_id' column in the 'Staff_Department_Assignments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Staff_Department_Assignments'].\n\n<3> SQL Generation: The query requires the id of the department with the least number of staff, so we should select the 'department_id' column in the 'Staff_Department_Assignments' table.\n\nSQL query: SELECT department_id FROM Staff_Department_Assignments GROUP BY department_id ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT department_id FROM Staff_Department_Assignments GROUP BY department_id ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT department_id FROM staff_department_assignments GROUP BY department_id ORDER BY count(*) LIMIT 1",
        "question": "Return the id of the department with the fewest staff assignments.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Operation: The query requires the id of the department with the fewest staff assignments, so we should apply the 'count' operation to the 'staff_id' column in the 'Staff_Department_Assignments' table, and find the department with the lowest count. Since the unit to which the staff assignments being counted in the query belong is the department, we should apply the 'group by' operation to the 'department_id' column in the 'Staff_Department_Assignments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Staff_Department_Assignments'].\n\n<3> SQL Generation: The query requires the id of the department with the fewest staff assignments, so we should select the 'department_id' column in the 'Staff_Department_Assignments' table.\n\nSQL query: SELECT department_id FROM Staff_Department_Assignments GROUP BY department_id ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT department_id FROM Staff_Department_Assignments GROUP BY department_id ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT max(product_price) ,  min(product_price) ,  product_type_code FROM products GROUP BY product_type_code ORDER BY product_type_code",
        "question": "What are the highest and lowest prices of products, grouped by and alphabetically ordered by product type?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Operation: The query requires the highest and lowest prices of products, grouped by and alphabetically ordered by product type, so we should apply the 'max' and 'min' operations to the 'product_price' column in the 'Products' table, and group the results by the 'product_type_code' column. We also need to sort the results in alphabetical order by the 'product_type_code' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Products'].\n\n<3> SQL Generation: The query requires the highest and lowest prices of products, grouped by and alphabetically ordered by product type, so we should select the 'product_type_code' column in the 'Products' table, the 'max' of the 'product_price' column in the 'Products' table, and the 'min' of the 'product_price' column in the 'Products' table. We also need to group the results by the 'product_type_code' column and sort them in alphabetical order.\n\nSQL query: SELECT product_type_code, MAX(product_price), MIN(product_price) FROM Products GROUP BY product_type_code ORDER BY product_type_code ASC",
        "predict": "SELECT product_type_code, MAX(product_price), MIN(product_price) FROM Products GROUP BY product_type_code ORDER BY product_type_code ASC",
        "hardness": "extra"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT max(product_price) ,  min(product_price) ,  product_type_code FROM products GROUP BY product_type_code ORDER BY product_type_code",
        "question": "Give the maximum and minimum product prices for each product type, grouped and ordered by product type.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Operation: The query requires the maximum and minimum product prices for each product type, so we should apply the 'maximum' and 'minimum' operations to the 'product_price' column in the 'Products' table, and group them by the 'product_type_code' column. We also need to sort the results by the 'product_type_code' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Products'].\n\n<3> SQL Generation: The query requires the maximum and minimum product prices for each product type, so we should select the 'product_type_code' column and the maximum and minimum of the 'product_price' column in the 'Products' table.\n\nSQL query: SELECT product_type_code, MAX(product_price), MIN(product_price) FROM Products GROUP BY product_type_code ORDER BY product_type_code",
        "predict": "SELECT product_type_code, MAX(product_price), MIN(product_price) FROM Products GROUP BY product_type_code ORDER BY product_type_code",
        "hardness": "extra"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT T1.Aircraft FROM aircraft AS T1 JOIN MATCH AS T2 ON T1.Aircraft_ID  =  T2.Winning_Aircraft GROUP BY T2.Winning_Aircraft ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "List the name of the aircraft that has been named winning aircraft the most number of times.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the aircraft that has been named the winning aircraft the most number of times, so we should apply the 'count' operation to the 'Winning_Aircraft' column in the 'match' table and find the aircraft with the highest count. Since the unit to which the winning aircrafts being counted in the query belong is the aircraft, we should apply the 'group by' operation to the 'Winning_Aircraft' column in the 'match' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'match' and 'aircraft', we need to use tables ['match', 'aircraft'].\n\n<3> SQL Generation: The query requires the name of the aircraft that has been named the winning aircraft the most number of times, so we should select the 'Aircraft' column in the 'aircraft' table.\n\nSQL query: SELECT Aircraft FROM aircraft WHERE Aircraft_ID = (SELECT Winning_Aircraft FROM match GROUP BY Winning_Aircraft ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Aircraft FROM aircraft WHERE Aircraft_ID = (SELECT Winning_Aircraft FROM match GROUP BY Winning_Aircraft ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT T1.Aircraft FROM aircraft AS T1 JOIN MATCH AS T2 ON T1.Aircraft_ID  =  T2.Winning_Aircraft GROUP BY T2.Winning_Aircraft ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the name of the aircraft that has won an award the most?",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the aircraft that has won an award the most, so we should apply the 'count' operation to the 'Winning_Aircraft' column in the 'match' table, and find the aircraft with the highest count. Since the unit to which the awards being counted in the query belong is the aircraft, we should apply the 'group by' operation to the 'Winning_Aircraft' column in the 'match' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'match' and 'aircraft', we need to use tables ['match', 'aircraft'].\n\n<3> SQL Generation: The query requires the name of the aircraft that has won an award the most, so we should select the 'Aircraft' column in the 'aircraft' table.\n\nSQL query: SELECT T2.Aircraft FROM match AS T1 JOIN aircraft AS T2 ON T1.Winning_Aircraft = T2.Aircraft_ID GROUP BY T1.Winning_Aircraft ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.Aircraft FROM match AS T1 JOIN aircraft AS T2 ON T1.Winning_Aircraft = T2.Aircraft_ID GROUP BY T1.Winning_Aircraft ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT t1.name ,  t1.age FROM pilot AS t1 JOIN MATCH AS t2 ON t1.pilot_id  =  t2.winning_pilot WHERE t1.age  <  30 GROUP BY t2.winning_pilot ORDER BY count(*) DESC LIMIT 1",
        "question": "find the name and age of the pilot who has won the most number of times among the pilots who are younger than 30.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Operation: The query requires the name and age of the pilot who has won the most number of times among the pilots who are younger than 30, so we should apply the 'count' operation to the 'match' table for the 'Winning_Pilot' column, and find the pilot with the highest count. We also need to filter the pilots who are younger than 30.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'match' and 'pilot', we need to use tables ['match', 'pilot'].\n\n<3> SQL Generation: The query requires the name and age of the pilot who has won the most number of times among the pilots who are younger than 30, so we should select the 'Name' and 'Age' columns in the 'pilot' table. We also need to filter the pilots who are younger than 30.\n\nSQL query: SELECT Name, Age FROM pilot WHERE Age < 30 AND Pilot_Id = (SELECT Winning_Pilot FROM match GROUP BY Winning_Pilot ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Name, Age FROM pilot WHERE Age < 30 AND Pilot_Id = (SELECT Winning_Pilot FROM match GROUP BY Winning_Pilot ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT t1.name ,  t1.age FROM pilot AS t1 JOIN MATCH AS t2 ON t1.pilot_id  =  t2.winning_pilot WHERE t1.age  <  30 GROUP BY t2.winning_pilot ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name and age of the pilot younger than 30 who has won the most number of times?",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Operation: The query requires the name and age of the pilot younger than 30 who has won the most number of times, so we should apply the 'count' operation to the 'match' table for the 'Winning_Pilot' column, and find the pilot with the highest count. We also need to filter the pilots younger than 30 in the 'pilot' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'match' and 'pilot', we need to use tables ['match', 'pilot'].\n\n<3> SQL Generation: The query requires the name and age of the pilot younger than 30 who has won the most number of times, so we should select the 'Name' and 'Age' columns in the 'pilot' table.\n\nSQL query: SELECT Name, Age FROM pilot WHERE Age < 30 AND Pilot_Id = (SELECT Winning_Pilot FROM match GROUP BY Winning_Pilot ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Name, Age FROM pilot WHERE Age < 30 AND Pilot_Id = (SELECT Winning_Pilot FROM match GROUP BY Winning_Pilot ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "local_govt_and_lot",
        "gold": "SELECT T1.resident_id ,  T1.other_details ,  count(*) FROM Residents AS T1 JOIN Residents_Services AS T2 ON T1.resident_id  =  T2.resident_id GROUP BY T1.resident_id ORDER BY count(*) DESC",
        "question": "How many services has each resident requested? List the resident id, details, and the count in descending order of the count.",
        "fields": "Table Customer_Event_Notes, columns = [*,Customer_Event_Note_ID,Customer_Event_ID,service_type_code,resident_id,property_id,date_moved_in]\nTable Customer_Events, columns = [*,Customer_Event_ID,customer_id,date_moved_in,property_id,resident_id,thing_id]\nTable Customers, columns = [*,customer_id,customer_details]\nTable Organizations, columns = [*,organization_id,parent_organization_id,organization_details]\nTable Properties, columns = [*,property_id,property_type_code,property_address,other_details]\nTable Residents, columns = [*,resident_id,property_id,date_moved_in,date_moved_out,other_details]\nTable Residents_Services, columns = [*,resident_id,service_id,date_moved_in,property_id,date_requested,date_provided,other_details]\nTable Services, columns = [*,service_id,organization_id,service_type_code,service_details]\nTable Things, columns = [*,thing_id,organization_id,Type_of_Thing_Code,service_type_code,service_details]\nTable Timed_Locations_of_Things, columns = [*,thing_id,Date_and_Time,Location_Code]\nTable Timed_Status_of_Things, columns = [*,thing_id,Date_and_Date,Status_of_Thing_Code]\n",
        "foreign_keys": "Foreign_keys = [Residents.property_id = Properties.property_id,Services.organization_id = Organizations.organization_id,Residents_Services.resident_id = Residents.resident_id,Residents_Services.property_id = Residents.property_id,Residents_Services.date_moved_in = Residents.date_moved_in,Residents_Services.service_id = Services.service_id,Things.organization_id = Organizations.organization_id,Customer_Events.resident_id = Residents.resident_id,Customer_Events.property_id = Residents.property_id,Customer_Events.date_moved_in = Residents.date_moved_in,Customer_Events.customer_id = Customers.customer_id,Customer_Events.thing_id = Things.thing_id,Customer_Event_Notes.Customer_Event_ID = Customer_Events.Customer_Event_ID,Timed_Status_of_Things.thing_id = Things.thing_id,Timed_Locations_of_Things.thing_id = Things.thing_id]\n",
        "reasoning": "<1> Operation: The query requires the number of services requested by each resident, so we should apply the 'count' operation to the 'service_id' column in the 'Residents_Services' table, and it does not need sorting. Since the unit to which the services being counted in the query belong is the resident, we should apply the 'group by' operation to the 'resident_id' column in the 'Residents_Services' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Residents_Services' and 'Residents', we need to use tables ['Residents_Services', 'Residents'].\n\n<3> SQL Generation: The query requires the number of services requested by each resident, so we should select the 'resident_id' column in the 'Residents' table and the count of the 'service_id' column in the 'Residents_Services' table.\n\nSQL query: SELECT T1.resident_id, T1.other_details, COUNT(*) FROM Residents AS T1 JOIN Residents_Services AS T2 ON T1.resident_id = T2.resident_id GROUP BY T1.resident_id ORDER BY COUNT(*) DESC",
        "predict": "SELECT T1.resident_id, T1.other_details, COUNT(*) FROM Residents AS T1 JOIN Residents_Services AS T2 ON T1.resident_id = T2.resident_id GROUP BY T1.resident_id ORDER BY COUNT(*) DESC",
        "hardness": "hard"
    },
    {
        "db_id": "school_player",
        "gold": "SELECT T2.Denomination FROM player AS T1 JOIN school AS T2 ON T1.School_ID  =  T2.School_ID GROUP BY T1.School_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the denomination of the school that has the most players.",
        "fields": "Table player, columns = [*,Player_ID,Player,Team,Age,Position,School_ID]\nTable school, columns = [*,School_ID,School,Location,Enrollment,Founded,Denomination,Boys_or_Girls,Day_or_Boarding,Year_Entered_Competition,School_Colors]\nTable school_details, columns = [*,School_ID,Nickname,Colors,League,Class,Division]\nTable school_performance, columns = [*,School_Id,School_Year,Class_A,Class_AA]\n",
        "foreign_keys": "Foreign_keys = [school_details.School_ID = school.School_ID,school_performance.School_Id = school.School_ID,player.School_ID = school.School_ID]\n",
        "reasoning": "<1> Operation: The query requires the denomination of the school that has the most players, so we should apply the 'count' operation to the 'player' table for the 'School_ID' column, and find the school with the highest count. Since the unit to which the players being counted in the query belong is the school, we should apply the 'group by' operation to the 'School_ID' column in the 'player' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['player', 'school'].\n\n<3> SQL Generation: The query requires the denomination of the school that has the most players, so we should select the 'Denomination' column in the 'school' table.\n\nSQL query: SELECT Denomination FROM school WHERE School_ID = (SELECT School_ID FROM player GROUP BY School_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Denomination FROM school WHERE School_ID = (SELECT School_ID FROM player GROUP BY School_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "school_player",
        "gold": "SELECT T2.Denomination FROM player AS T1 JOIN school AS T2 ON T1.School_ID  =  T2.School_ID GROUP BY T1.School_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the denomination of the school the most players belong to?",
        "fields": "Table player, columns = [*,Player_ID,Player,Team,Age,Position,School_ID]\nTable school, columns = [*,School_ID,School,Location,Enrollment,Founded,Denomination,Boys_or_Girls,Day_or_Boarding,Year_Entered_Competition,School_Colors]\nTable school_details, columns = [*,School_ID,Nickname,Colors,League,Class,Division]\nTable school_performance, columns = [*,School_Id,School_Year,Class_A,Class_AA]\n",
        "foreign_keys": "Foreign_keys = [school_details.School_ID = school.School_ID,school_performance.School_Id = school.School_ID,player.School_ID = school.School_ID]\n",
        "reasoning": "<1> Operation: The query requires the denomination of the school that the most players belong to, so we should apply the 'count' operation to the 'player' table for the 'School_ID' column, and find the school with the highest count. Since the unit to which the players being counted in the query belong is the school, we should apply the 'group by' operation to the 'School_ID' column in the 'player' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['player', 'school'].\n\n<3> SQL Generation: The query requires the denomination of the school that the most players belong to, so we should select the 'Denomination' column in the 'school' table.\n\nSQL query: SELECT Denomination FROM school WHERE School_ID = (SELECT School_ID FROM player GROUP BY School_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Denomination FROM school WHERE School_ID = (SELECT School_ID FROM player GROUP BY School_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "school_player",
        "gold": "SELECT Denomination ,  COUNT(*) FROM school GROUP BY Denomination ORDER BY COUNT(*) DESC",
        "question": "Please show different denominations and the corresponding number of schools in descending order.",
        "fields": "Table player, columns = [*,Player_ID,Player,Team,Age,Position,School_ID]\nTable school, columns = [*,School_ID,School,Location,Enrollment,Founded,Denomination,Boys_or_Girls,Day_or_Boarding,Year_Entered_Competition,School_Colors]\nTable school_details, columns = [*,School_ID,Nickname,Colors,League,Class,Division]\nTable school_performance, columns = [*,School_Id,School_Year,Class_A,Class_AA]\n",
        "foreign_keys": "Foreign_keys = [school_details.School_ID = school.School_ID,school_performance.School_Id = school.School_ID,player.School_ID = school.School_ID]\n",
        "reasoning": "<1> Operation: The query requires the different denominations and the corresponding number of schools, so we should apply the 'count' operation to the 'School_ID' column in the 'school' table, and it does not need sorting. Since the unit to which the schools being counted in the query belong is the denomination and only table 'school' has the column 'Denomination', so we should apply the 'group by' operation to the 'Denomination' column in the 'school' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['school'].\n\n<3> SQL Generation: The query requires the different denominations and the corresponding number of schools, so we should select the 'Denomination' column in the 'school' table and count the 'School_ID' column in the 'school' table.\n\nSQL query: SELECT Denomination, COUNT(School_ID) FROM school GROUP BY Denomination ORDER BY COUNT(School_ID) DESC",
        "predict": "SELECT Denomination, COUNT(School_ID) FROM school GROUP BY Denomination ORDER BY COUNT(School_ID) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "school_player",
        "gold": "SELECT Denomination ,  COUNT(*) FROM school GROUP BY Denomination ORDER BY COUNT(*) DESC",
        "question": "Order denominations in descending order of the count of schools with the denomination. Return each denomination with the count of schools.",
        "fields": "Table player, columns = [*,Player_ID,Player,Team,Age,Position,School_ID]\nTable school, columns = [*,School_ID,School,Location,Enrollment,Founded,Denomination,Boys_or_Girls,Day_or_Boarding,Year_Entered_Competition,School_Colors]\nTable school_details, columns = [*,School_ID,Nickname,Colors,League,Class,Division]\nTable school_performance, columns = [*,School_Id,School_Year,Class_A,Class_AA]\n",
        "foreign_keys": "Foreign_keys = [school_details.School_ID = school.School_ID,school_performance.School_Id = school.School_ID,player.School_ID = school.School_ID]\n",
        "reasoning": "<1> Operation: The query requires the denominations in descending order of the count of schools with the denomination, so we should apply the 'count' operation to the 'School_ID' column in the 'school' table, and sort it in descending order. Since the unit to which the schools being counted in the query belong is the denomination and only table 'school' has the column 'Denomination', so we should apply the 'group by' operation to the 'Denomination' column in the 'school' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['school'].\n\n<3> SQL Generation: The query requires the denominations in descending order of the count of schools with the denomination, so we should select the 'Denomination' column in the 'school' table and the count of the 'School_ID' column in the 'school' table.\n\nSQL query: SELECT Denomination, COUNT(*) FROM school GROUP BY Denomination ORDER BY COUNT(*) DESC",
        "predict": "SELECT Denomination, COUNT(*) FROM school GROUP BY Denomination ORDER BY COUNT(*) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "store_product",
        "gold": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the city with the most number of stores.",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n",
        "reasoning": "<1> Operation: The query requires the city with the most number of stores, so we should apply the 'count' operation to the 'Store_ID' column in the 'store_district' table, and find the city with the highest count. Since the unit to which the stores being counted in the query belong is the city, we should apply the 'group by' operation to the 'Headquartered_City' column in the 'district' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'store_district' and 'district', we need to use tables ['store_district', 'district'].\n\n<3> SQL Generation: The query requires the city with the most number of stores, so we should select the 'Headquartered_City' column in the 'district' table and count the 'Store_ID' column in the 'store_district' table.\n\nSQL query: SELECT T1.Headquartered_City FROM district AS T1 JOIN store_district AS T2 ON T1.District_ID = T2.District_ID GROUP BY T1.Headquartered_City ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Headquartered_City FROM district AS T1 JOIN store_district AS T2 ON T1.District_ID = T2.District_ID GROUP BY T1.Headquartered_City ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "store_product",
        "gold": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the city with the most number of flagship stores?",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n",
        "reasoning": "<1> Operation: The query requires the city with the most number of flagship stores, so we should apply the 'count' operation to the 'Store_ID' column in the 'store_district' table, and find the city with the highest count. Since the unit to which the flagship stores being counted in the query belong is the city, we should apply the 'group by' operation to the 'Headquartered_City' column in the 'district' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'store_district' and 'district', we need to use tables ['store_district', 'district'].\n\n<3> SQL Generation: The query requires the city with the most number of flagship stores, so we should select the 'Headquartered_City' column in the 'district' table and count the 'Store_ID' column in the 'store_district' table.\n\nSQL query: SELECT T2.Headquartered_City FROM store_district AS T1 JOIN district AS T2 ON T1.District_ID = T2.District_ID GROUP BY T2.Headquartered_City ORDER BY COUNT(T1.Store_ID) DESC LIMIT 1",
        "predict": "SELECT T2.Headquartered_City FROM store_district AS T1 JOIN district AS T2 ON T1.District_ID = T2.District_ID GROUP BY T2.Headquartered_City ORDER BY COUNT(T1.Store_ID) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "store_product",
        "gold": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the most prominent max page size among all the products.",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n",
        "reasoning": "<1> Operation: The query requires the most prominent max page size among all the products, so we should find the maximum value of the 'max_page_size' column in the 'product' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['product'].\n\n<3> SQL Generation: The query requires the most prominent max page size among all the products, so we should select the maximum value of the 'max_page_size' column in the 'product' table.\n\nSQL query: SELECT MAX(max_page_size) FROM product",
        "predict": "SELECT MAX(max_page_size) FROM product",
        "hardness": "hard"
    },
    {
        "db_id": "store_product",
        "gold": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most common maximum page size?",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common maximum page size, so we should apply the 'count' operation to the 'max_page_size' column in the 'product' table and find the maximum count. Since the unit to which the maximum page sizes being counted in the query belong is the product, we should apply the 'group by' operation to the 'max_page_size' column in the 'product' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['product'].\n\n<3> SQL Generation: The query requires the most common maximum page size, so we should select the 'max_page_size' column in the 'product' table.\n\nSQL query: SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1",
        "question": "Which position is most popular among players in the tryout?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Operation: The query requires the position that is most popular among players in the tryout, so we should apply the 'count' operation to the 'pPos' column in the 'Tryout' table and find the position with the highest count. Since the unit to which the positions being counted in the query belong is the player, we should apply the 'group by' operation to the 'pPos' column in the 'Tryout' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Tryout'].\n\n<3> SQL Generation: The query requires the position that is most popular among players in the tryout, so we should select the 'pPos' column in the 'Tryout' table.\n\nSQL query: SELECT pPos FROM Tryout GROUP BY pPos ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT pPos FROM Tryout GROUP BY pPos ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1",
        "question": "What was the most popular position at tryouts?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Operation: The query requires the most popular position at tryouts, so we should apply the 'count' operation to the 'pPos' column in the 'Tryout' table and find the position with the highest count. Since the unit to which the positions being counted in the query belong is the tryout, we should apply the 'group by' operation to the 'pPos' column in the 'Tryout' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Tryout'].\n\n<3> SQL Generation: The query requires the most popular position at tryouts, so we should select the 'pPos' column in the 'Tryout' table.\n\nSQL query: SELECT pPos FROM Tryout GROUP BY pPos ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT pPos FROM Tryout GROUP BY pPos ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(*) ,  cName FROM tryout GROUP BY cName ORDER BY count(*) DESC",
        "question": "Find the number of students who participate in the tryout for each college ordered by descending count.",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Operation: The query requires the number of students who participate in the tryout for each college, so we should apply the 'count' operation to the 'pID' column in the 'Tryout' table, and it does not need sorting. Since the unit to which the students being counted in the query belong is the college and only table 'College' has the column 'cName', so we should apply the 'group by' operation to the 'cName' column in the 'College' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Tryout' and 'College', we need to use tables ['Tryout', 'College'].\n\n<3> SQL Generation: The query requires the number of students who participate in the tryout for each college, so we should select the 'cName' column in the 'College' table and count the 'pID' column in the 'Tryout' table.\n\nSQL query: SELECT T1.cName, COUNT(*) FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName GROUP BY T1.cName ORDER BY COUNT(*) DESC",
        "predict": "SELECT T1.cName, COUNT(*) FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName GROUP BY T1.cName ORDER BY COUNT(*) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(*) ,  cName FROM tryout GROUP BY cName ORDER BY count(*) DESC",
        "question": "How many students participated in tryouts for each college by descennding count?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Operation: The query requires the number of students who participated in tryouts for each college, so we should apply the 'count' operation to the 'pID' column in the 'Tryout' table, and sort it in descending order. Since the unit to which the students being counted in the query belong is the college, we should apply the 'group by' operation to the 'cName' column in the 'Tryout' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Tryout' and 'College', we need to use tables ['Tryout', 'College'].\n\n<3> SQL Generation: The query requires the number of students who participated in tryouts for each college, so we should select the 'cName' column in the 'College' table and count the 'pID' column in the 'Tryout' table.\n\nSQL query: SELECT T1.cName, COUNT(*) FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName GROUP BY T1.cName ORDER BY COUNT(*) DESC",
        "predict": "SELECT T1.cName, COUNT(*) FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName GROUP BY T1.cName ORDER BY COUNT(*) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "device",
        "gold": "SELECT T2.Shop_Name FROM stock AS T1 JOIN shop AS T2 ON T1.Shop_ID  =  T2.Shop_ID GROUP BY T1.Shop_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the name of the shop that has the most kind of devices in stock.",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the shop that has the most kinds of devices in stock, so we should apply the 'count' operation to the 'Device_ID' column in the 'stock' table, and find the shop with the highest count. Since the unit to which the devices being counted in the query belong is the shop, we should apply the 'group by' operation to the 'Shop_ID' column in the 'stock' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use tables ['stock', 'shop'].\n\n<3> SQL Generation: The query requires the name of the shop that has the most kinds of devices in stock, so we should select the 'Shop_Name' column in the 'shop' table. The query does not require the count of devices, so it is only used for filtering and not selected.\n\nSQL query: SELECT Shop_Name FROM shop WHERE Shop_ID = (SELECT Shop_ID FROM stock GROUP BY Shop_ID ORDER BY COUNT(DISTINCT Device_ID) DESC LIMIT 1)",
        "predict": "SELECT Shop_Name FROM shop WHERE Shop_ID = (SELECT Shop_ID FROM stock GROUP BY Shop_ID ORDER BY COUNT(DISTINCT Device_ID) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "device",
        "gold": "SELECT T2.Shop_Name FROM stock AS T1 JOIN shop AS T2 ON T1.Shop_ID  =  T2.Shop_ID GROUP BY T1.Shop_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the name of the shop that has the most different kinds of devices in stock?",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the shop that has the most different kinds of devices in stock, so we should apply the 'count' operation to the 'Device_ID' column in the 'stock' table, and find the shop with the highest count. Since the unit to which the devices being counted in the query belong is the shop, we should apply the 'group by' operation to the 'Shop_ID' column in the 'stock' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['shop', 'stock'].\n\n<3> SQL Generation: The query requires the name of the shop that has the most different kinds of devices in stock, so we should select the 'Shop_Name' column in the 'shop' table. The query does not require the count of different kinds of devices, so it is only used for filtering and not selected.\n\nSQL query: SELECT Shop_Name FROM shop WHERE Shop_ID = (SELECT Shop_ID FROM stock GROUP BY Shop_ID ORDER BY COUNT(DISTINCT Device_ID) DESC LIMIT 1)",
        "predict": "SELECT Shop_Name FROM shop WHERE Shop_ID = (SELECT Shop_ID FROM stock GROUP BY Shop_ID ORDER BY COUNT(DISTINCT Device_ID) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "device",
        "gold": "SELECT T2.Shop_Name FROM stock AS T1 JOIN shop AS T2 ON T1.Shop_ID  =  T2.Shop_ID GROUP BY T1.Shop_ID ORDER BY SUM(T1.quantity) DESC LIMIT 1",
        "question": "Show the name of the shop that have the largest quantity of devices in stock.",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the shop that has the largest quantity of devices in stock, so we should apply the 'sum' operation to the 'Quantity' column in the 'stock' table and find the shop with the highest sum. Since the unit to which the quantities being summed in the query belong is the shop, we should apply the 'group by' operation to the 'Shop_ID' column in the 'stock' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use tables ['shop', 'stock'].\n\n<3> SQL Generation: The query requires the name of the shop that has the largest quantity of devices in stock, so we should select the 'Shop_Name' column in the 'shop' table and the sum of the 'Quantity' column in the 'stock' table.\n\nSQL query: SELECT T1.Shop_Name FROM shop AS T1 JOIN stock AS T2 ON T1.Shop_ID = T2.Shop_ID GROUP BY T2.Shop_ID ORDER BY SUM(T2.Quantity) DESC LIMIT 1",
        "predict": "SELECT T1.Shop_Name FROM shop AS T1 JOIN stock AS T2 ON T1.Shop_ID = T2.Shop_ID GROUP BY T2.Shop_ID ORDER BY SUM(T2.Quantity) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "device",
        "gold": "SELECT T2.Shop_Name FROM stock AS T1 JOIN shop AS T2 ON T1.Shop_ID  =  T2.Shop_ID GROUP BY T1.Shop_ID ORDER BY SUM(T1.quantity) DESC LIMIT 1",
        "question": "What is the name of the shop that has the greatest quantity of devices in stock?",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the shop that has the greatest quantity of devices in stock, so we should apply the 'sum' operation to the 'Quantity' column in the 'stock' table, and sort it in descending order. Since the unit to which the quantities being summed in the query belong is the shop, we should apply the 'group by' operation to the 'Shop_ID' column in the 'stock' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use tables ['shop', 'stock'].\n\n<3> SQL Generation: The query requires the name of the shop that has the greatest quantity of devices in stock, so we should select the 'Shop_Name' column in the 'shop' table. The query also requires the sum of the 'Quantity' column in the 'stock' table.\n\nSQL query: SELECT T1.Shop_Name FROM shop AS T1 JOIN stock AS T2 ON T1.Shop_ID = T2.Shop_ID GROUP BY T2.Shop_ID ORDER BY SUM(T2.Quantity) DESC LIMIT 1",
        "predict": "SELECT T1.Shop_Name FROM shop AS T1 JOIN stock AS T2 ON T1.Shop_ID = T2.Shop_ID GROUP BY T2.Shop_ID ORDER BY SUM(T2.Quantity) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "device",
        "gold": "SELECT Software_Platform FROM device GROUP BY Software_Platform ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "List the software platform shared by the greatest number of devices.",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Operation: The query requires the software platform shared by the greatest number of devices, so we should apply the 'count' operation to the 'Device_ID' column in the 'stock' table, and find the software platform with the highest count. Since the unit to which the devices being counted in the query belong is the software platform, we should apply the 'group by' operation to the 'Software_Platform' column in the 'device' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['device'].\n\n<3> SQL Generation: The query requires the software platform shared by the greatest number of devices, so we should select the 'Software_Platform' column in the 'device' table.\n\nSQL query: SELECT Software_Platform FROM device GROUP BY Software_Platform ORDER BY COUNT(Device_ID) DESC LIMIT 1",
        "predict": "SELECT Software_Platform FROM device GROUP BY Software_Platform ORDER BY COUNT(Device_ID) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "device",
        "gold": "SELECT Software_Platform FROM device GROUP BY Software_Platform ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the software platform that is most common amongst all devices?",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Operation: The query requires the software platform that is most common amongst all devices, so we should apply the 'count' operation to the 'Device_ID' column in the 'stock' table, and find the software platform with the highest count. Since the unit to which the devices being counted in the query belong is the software platform, we should apply the 'group by' operation to the 'Software_Platform' column in the 'device' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['device'].\n\n<3> SQL Generation: The query requires the software platform that is most common amongst all devices, so we should select the 'Software_Platform' column in the 'device' table.\n\nSQL query: SELECT Software_Platform FROM device GROUP BY Software_Platform ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Software_Platform FROM device GROUP BY Software_Platform ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT label FROM albums GROUP BY label ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the label that has the most albums?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the label that has the most albums, so we should apply the 'count' operation to the 'Albums' table for the 'Label' column, and find the label with the highest count. Since the unit to which the albums being counted in the query belong is the label, we should apply the 'group by' operation to the 'Label' column in the 'Albums' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Albums'].\n\n<3> SQL Generation: The query requires the label that has the most albums, so we should select the 'Label' column in the 'Albums' table.\n\nSQL query: SELECT Label FROM Albums GROUP BY Label ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Label FROM Albums GROUP BY Label ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT label FROM albums GROUP BY label ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the label with the most albums?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the label with the most albums, so we should apply the 'count' operation to the 'Albums' table for the 'Label' column, and find the label with the highest count. Since the unit to which the albums being counted in the query belong is the label, we should apply the 'group by' operation to the 'Label' column in the 'Albums' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Albums'].\n\n<3> SQL Generation: The query requires the label with the most albums, so we should select the 'Label' column in the 'Albums' table.\n\nSQL query: SELECT Label FROM Albums GROUP BY Label ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Label FROM Albums GROUP BY Label ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the last name of the musician that have produced the most number of songs?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the last name of the musician who has produced the most number of songs, so we should apply the 'count' operation to the 'SongId' column in the 'Instruments' table, and find the musician with the highest count. Since the unit to which the songs being counted in the query belong is the musician, we should apply the 'group by' operation to the 'BandmateId' column in the 'Instruments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Band', 'Instruments'].\n\n<3> SQL Generation: The query requires the last name of the musician who has produced the most number of songs, so we should select the 'Lastname' column in the 'Band' table.\n\nSQL query: SELECT Lastname FROM Band WHERE Id = (SELECT BandmateId FROM Instruments GROUP BY BandmateId ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Lastname FROM Band WHERE Id = (SELECT BandmateId FROM Instruments GROUP BY BandmateId ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the last name of the musician who was in the most songs?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the last name of the musician who was in the most songs, so we should apply the 'count' operation to the 'Bandmate' column in the 'Performance' table, and find the musician with the highest count. Since the unit to which the songs being counted in the query belong is the musician, we should apply the 'group by' operation to the 'Bandmate' column in the 'Performance' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Band', 'Performance'].\n\n<3> SQL Generation: The query requires the last name of the musician who was in the most songs, so we should select the 'Lastname' column in the 'Band' table.\n\nSQL query: SELECT Lastname FROM Band WHERE Id = (SELECT Bandmate FROM Performance GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Lastname FROM Band WHERE Id = (SELECT Bandmate FROM Performance GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id WHERE stageposition  =  \"back\" GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the last name of the musician that has been at the back position the most?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the last name of the musician who has been at the back position the most, so we should apply the 'count' operation to the 'Bandmate' column in the 'Performance' table for the 'StagePosition' column with a value of 'back', and find the musician with the highest count. Since the unit to which the musicians being counted in the query belong is the last name, we should apply the 'group by' operation to the 'Bandmate' column in the 'Band' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Performance' and 'Band', we need to use tables ['Performance', 'Band'].\n\n<3> SQL Generation: The query requires the last name of the musician who has been at the back position the most, so we should select the 'Lastname' column in the 'Band' table and the 'Bandmate' column in the 'Performance' table.\n\nSQL query: SELECT Lastname FROM Band WHERE Id = (SELECT Bandmate FROM Performance WHERE StagePosition = 'back' GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Lastname FROM Band WHERE Id = (SELECT Bandmate FROM Performance WHERE StagePosition = 'back' GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id WHERE stageposition  =  \"back\" GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the last name of the musicians who has played back position the most?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the last name of the musician who has played the back position the most, so we should apply the 'count' operation to the 'StagePosition' column in the 'Performance' table for the 'Back' position, and find the musician with the highest count. Since the unit to which the positions being counted in the query belong is the musician, we should apply the 'group by' operation to the 'Bandmate' column in the 'Performance' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Performance' and 'Band', we need to use tables ['Performance', 'Band'].\n\n<3> SQL Generation: The query requires the last name of the musician who has played the back position the most, so we should select the 'Lastname' column in the 'Band' table.\n\nSQL query: SELECT Lastname FROM Band WHERE Id = (SELECT Bandmate FROM Performance WHERE StagePosition = 'Back' GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Lastname FROM Band WHERE Id = (SELECT Bandmate FROM Performance WHERE StagePosition = 'Back' GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT instrument FROM instruments GROUP BY instrument ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most used instrument?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the most used instrument, so we should apply the 'count' operation to the 'Instrument' column in the 'Instruments' table and find the instrument with the highest count. Since the unit to which the instruments being counted in the query belong is the instrument itself, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Instruments'.\n\n<3> SQL Generation: The query requires the most used instrument, so we should select the 'Instrument' column in the 'Instruments' table.\n\nSQL query: SELECT Instrument FROM Instruments GROUP BY Instrument ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Instrument FROM Instruments GROUP BY Instrument ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT instrument FROM instruments GROUP BY instrument ORDER BY count(*) DESC LIMIT 1",
        "question": "What instrument is used the most?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the instrument that is used the most, so we should apply the 'count' operation to the 'Instrument' column in the 'Instruments' table and find the instrument with the highest count. Since the unit to which the instruments being counted in the query belong is the instrument itself, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Instruments'.\n\n<3> SQL Generation: The query requires the instrument that is used the most, so we should select the 'Instrument' column in the 'Instruments' table.\n\nSQL query: SELECT Instrument FROM Instruments GROUP BY Instrument ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Instrument FROM Instruments GROUP BY Instrument ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT title FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid GROUP BY T1.songid ORDER BY count(*) DESC LIMIT 1",
        "question": "Which song has the most vocals?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the song with the most vocals, so we should apply the 'count' operation to the 'SongId' column in the 'Vocals' table, and find the song with the highest count. Since the unit to which the vocals being counted in the query belong is the song, we should apply the 'group by' operation to the 'SongId' column in the 'Vocals' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Vocals'].\n\n<3> SQL Generation: The query requires the song with the most vocals, so we should select the 'SongId' column in the 'Vocals' table.\n\nSQL query: SELECT SongId FROM Vocals GROUP BY SongId ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT SongId FROM Vocals GROUP BY SongId ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT title FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid GROUP BY T1.songid ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the song with the most vocals?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the song with the most vocals, so we should apply the 'count' operation to the 'SongId' column in the 'Vocals' table, and find the song with the highest count. Since the unit to which the vocals being counted in the query belong is the song, we should apply the 'group by' operation to the 'SongId' column in the 'Vocals' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Vocals'].\n\n<3> SQL Generation: The query requires the song with the most vocals, so we should select the 'SongId' column in the 'Vocals' table.\n\nSQL query: SELECT SongId FROM Vocals GROUP BY SongId ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT SongId FROM Vocals GROUP BY SongId ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "Which vocal type is the most frequently appearring type?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the vocal type that appears most frequently, so we should apply the 'count' operation to the 'Type' column in the 'Vocals' table and find the vocal type with the highest count. Since the unit to which the vocal types being counted in the query belong is the vocal type itself, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Vocals'].\n\n<3> SQL Generation: The query requires the vocal type that appears most frequently, so we should select the 'Type' column in the 'Vocals' table.\n\nSQL query: SELECT Type FROM Vocals GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM Vocals GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the type of vocables that appears most frequently?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the type of vocals that appears most frequently, so we should apply the 'count' operation to the 'Type' column in the 'Vocals' table and find the type with the highest count. Since the unit to which the vocals being counted in the query belong is the type, we should apply the 'group by' operation to the 'Type' column in the 'Vocals' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Vocals'].\n\n<3> SQL Generation: The query requires the type of vocals that appears most frequently, so we should select the 'Type' column in the 'Vocals' table.\n\nSQL query: SELECT Type FROM Vocals GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM Vocals GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id WHERE lastname  =  \"Heilo\" GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "Which vocal type has the band mate with last name \"Heilo\" played the most?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the vocal type that the band mate with the last name \"Heilo\" has played the most, so we should apply the 'count' operation to the 'Type' column in the 'Vocals' table for the band mate with the last name \"Heilo\", and find the vocal type with the highest count. Since the unit to which the vocal types being counted in the query belong is the band mate, we should apply the 'group by' operation to the 'Type' column in the 'Vocals' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Vocals' and 'Band', we need to use tables ['Vocals', 'Band'].\n\n<3> SQL Generation: The query requires the vocal type that the band mate with the last name \"Heilo\" has played the most, so we should select the 'Type' column in the 'Vocals' table and filter for the band mate with the last name \"Heilo\".\n\nSQL query: SELECT Type FROM Vocals WHERE Bandmate = (SELECT Id FROM Band WHERE Lastname = 'Heilo') GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM Vocals WHERE Bandmate = (SELECT Id FROM Band WHERE Lastname = 'Heilo') GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id WHERE lastname  =  \"Heilo\" GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the type of vocals that the band member with the last name \"Heilo\" played the most?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the type of vocals that the band member with the last name \"Heilo\" played the most, so we should apply the 'count' operation to the 'Type' column in the 'Vocals' table for the band member with the last name \"Heilo\", and find the type with the highest count. Since the unit to which the vocals being counted in the query belong is the band member, we should apply the 'group by' operation to the 'Type' column in the 'Vocals' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Vocals' and 'Band', we need to use tables ['Vocals', 'Band'].\n\n<3> SQL Generation: The query requires the type of vocals that the band member with the last name \"Heilo\" played the most, so we should select the 'Type' column in the 'Vocals' table and filter for the band member with the last name \"Heilo\".\n\nSQL query: SELECT Type FROM Vocals WHERE Bandmate = (SELECT Id FROM Band WHERE Lastname = 'Heilo') GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM Vocals WHERE Bandmate = (SELECT Id FROM Band WHERE Lastname = 'Heilo') GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the last name of the musician that have produced the most songs?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the last name of the musician who has produced the most songs, so we should apply the 'count' operation to the 'SongId' column in the 'Instruments' table, and find the musician with the highest count. Since the unit to which the songs being counted in the query belong is the musician, we should apply the 'group by' operation to the 'BandmateId' column in the 'Instruments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Band'].\n\n<3> SQL Generation: The query requires the last name of the musician who has produced the most songs, so we should select the 'Lastname' column in the 'Band' table and the 'BandmateId' column in the 'Instruments' table.\n\nSQL query: SELECT Lastname FROM Band WHERE Id = (SELECT BandmateId FROM Instruments GROUP BY BandmateId ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Lastname FROM Band WHERE Id = (SELECT BandmateId FROM Instruments GROUP BY BandmateId ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the last name of the artist who sang the most songs?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the last name of the artist who sang the most songs, so we should apply the 'count' operation to the 'Bandmate' column in the 'Vocals' table, and find the artist with the highest count. Since the unit to which the songs being counted in the query belong is the artist, we should apply the 'group by' operation to the 'Bandmate' column in the 'Vocals' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Band'].\n\n<3> SQL Generation: The query requires the last name of the artist who sang the most songs, so we should select the 'Lastname' column in the 'Band' table and the 'Bandmate' column in the 'Vocals' table.\n\nSQL query: SELECT Lastname FROM Band WHERE Id = (SELECT Bandmate FROM Vocals GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Lastname FROM Band WHERE Id = (SELECT Bandmate FROM Vocals GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id WHERE firstname  =  \"Solveig\" GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "Which vocal type has the band mate with first name \"Solveig\" played the most?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the vocal type that the band mate with the first name \"Solveig\" has played the most, so we should apply the 'count' operation to the 'Type' column in the 'Vocals' table, and find the vocal type with the highest count. Since the unit to which the vocal types being counted in the query belong is the band mate, we should apply the 'group by' operation to the 'Bandmate' column in the 'Vocals' table. We also need to filter the band mate with the first name \"Solveig\" in the 'Band' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Vocals' and 'Band', we need to use tables ['Vocals', 'Band'].\n\n<3> SQL Generation: The query requires the vocal type that the band mate with the first name \"Solveig\" has played the most, so we should select the 'Type' column in the 'Vocals' table and the 'Bandmate' column in the 'Vocals' table. We also need to filter the band mate with the first name \"Solveig\" in the 'Band' table.\n\nSQL query: SELECT Type FROM Vocals WHERE Bandmate = (SELECT Id FROM Band WHERE Firstname = 'Solveig') GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM Vocals WHERE Bandmate = (SELECT Id FROM Band WHERE Firstname = 'Solveig') GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id WHERE firstname  =  \"Solveig\" GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the types of vocals that the band member with the first name \"Solveig\" played the most?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the types of vocals that the band member with the first name \"Solveig\" played the most, so we should apply the 'count' operation to the 'Type' column in the 'Vocals' table, and find the type with the highest count. Since the unit to which the vocals being counted in the query belong is the band member, we should apply the 'group by' operation to the 'Bandmate' column in the 'Vocals' table. We also need to filter the band member with the first name \"Solveig\" in the 'Band' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Vocals' and 'Band', we need to use tables ['Vocals', 'Band'].\n\n<3> SQL Generation: The query requires the types of vocals that the band member with the first name \"Solveig\" played the most, so we should select the 'Type' column in the 'Vocals' table and the 'Bandmate' column in the 'Vocals' table. We also need to filter the band member with the first name \"Solveig\" in the 'Band' table.\n\nSQL query: SELECT Type FROM Vocals WHERE Bandmate = (SELECT Id FROM Band WHERE Firstname = 'Solveig') GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM Vocals WHERE Bandmate = (SELECT Id FROM Band WHERE Firstname = 'Solveig') GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT t2.firstname FROM Performance AS t1 JOIN Band AS t2 ON t1.bandmate  =  t2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY firstname ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the first name of the band mate that has performed in most songs.",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the first name of the band mate that has performed in the most songs, so we should apply the 'count' operation to the 'Bandmate' column in the 'Performance' table, and find the band mate with the highest count. Since the unit to which the performances being counted in the query belong is the band mate, we should apply the 'group by' operation to the 'Bandmate' column in the 'Performance' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Performance', 'Band'].\n\n<3> SQL Generation: The query requires the first name of the band mate that has performed in the most songs, so we should select the 'Firstname' column in the 'Band' table and the 'Bandmate' column in the 'Performance' table.\n\nSQL query: SELECT Firstname FROM Band WHERE Id = (SELECT Bandmate FROM Performance GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Firstname FROM Band WHERE Id = (SELECT Bandmate FROM Performance GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT t2.firstname FROM Performance AS t1 JOIN Band AS t2 ON t1.bandmate  =  t2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY firstname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the first name of the band mate who perfomed in the most songs?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the first name of the band mate who performed in the most songs, so we should apply the 'count' operation to the 'Bandmate' column in the 'Performance' table, and find the band mate with the highest count. Since the unit to which the performances being counted in the query belong is the band mate, we should apply the 'group by' operation to the 'Bandmate' column in the 'Performance' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Performance', 'Band'].\n\n<3> SQL Generation: The query requires the first name of the band mate who performed in the most songs, so we should select the 'Firstname' column in the 'Band' table and the 'Bandmate' column in the 'Performance' table.\n\nSQL query: SELECT Firstname FROM Band WHERE Id = (SELECT Bandmate FROM Performance GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Firstname FROM Band WHERE Id = (SELECT Bandmate FROM Performance GROUP BY Bandmate ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id WHERE firstname  =  \"Marianne\" GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "Which vocal type has the band mate with first name \"Marianne\" played the most?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the vocal type that the band mate with the first name \"Marianne\" has played the most, so we should apply the 'count' operation to the 'Type' column in the 'Vocals' table, and find the vocal type with the highest count. Since the unit to which the vocal types being counted in the query belong is the band mate, we should apply the 'group by' operation to the 'Bandmate' column in the 'Vocals' table. We also need to filter the band mate with the first name \"Marianne\" in the 'Band' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Vocals' and 'Band', we need to use tables ['Vocals', 'Band'].\n\n<3> SQL Generation: The query requires the vocal type that the band mate with the first name \"Marianne\" has played the most, so we should select the 'Type' column in the 'Vocals' table and the 'Bandmate' column in the 'Vocals' table. We also need to filter the band mate with the first name \"Marianne\" in the 'Band' table.\n\nSQL query: SELECT Type FROM Vocals WHERE Bandmate = (SELECT Id FROM Band WHERE Firstname = 'Marianne') GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type FROM Vocals WHERE Bandmate = (SELECT Id FROM Band WHERE Firstname = 'Marianne') GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id WHERE firstname  =  \"Marianne\" GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the vocal type of the band mate whose first name is \"Marianne\" played the most?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Operation: The query requires the vocal type of the band mate whose first name is \"Marianne\" and played the most, so we should apply the 'count' operation to the 'Bandmate' column in the 'Vocals' table, and find the band mate with the highest count. Since the unit to which the band mates being counted in the query belong is the band mate, we should apply the 'group by' operation to the 'Bandmate' column in the 'Vocals' table. We also need to filter the band mates with the first name \"Marianne\" in the 'Band' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Vocals' and 'Band', we need to use tables ['Vocals', 'Band'].\n\n<3> SQL Generation: The query requires the vocal type of the band mate whose first name is \"Marianne\" and played the most, so we should select the 'Type' column in the 'Vocals' table and the 'Bandmate' column in the 'Vocals' table. We also need to filter the band mates with the first name \"Marianne\" in the 'Band' table.\n\nSQL query: SELECT T1.Type FROM Vocals AS T1 JOIN Band AS T2 ON T1.Bandmate = T2.Id WHERE T2.Firstname = 'Marianne' GROUP BY T1.Bandmate ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Type FROM Vocals AS T1 JOIN Band AS T2 ON T1.Bandmate = T2.Id WHERE T2.Firstname = 'Marianne' GROUP BY T1.Bandmate ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT count(*) ,  T1.product_name FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id GROUP BY T1.product_name ORDER BY count(*) DESC LIMIT 1",
        "question": "How many problems does the product with the most problems have? List the number of the problems and product name.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the number of problems for the product with the most problems, so we should apply the 'count' operation to the 'problem_id' column in the 'Problems' table and find the product with the highest count. Since the unit to which the problems being counted in the query belong is the product, we should apply the 'group by' operation to the 'product_id' column in the 'Problems' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Problems', 'Product'].\n\n<3> SQL Generation: The query requires the number of problems for the product with the most problems, so we should select the 'product_name' column in the 'Product' table and the count of the 'problem_id' column in the 'Problems' table.\n\nSQL query: SELECT T2.product_name, COUNT(*) FROM Problems AS T1 JOIN Product AS T2 ON T1.product_id = T2.product_id GROUP BY T1.product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.product_name, COUNT(*) FROM Problems AS T1 JOIN Product AS T2 ON T1.product_id = T2.product_id GROUP BY T1.product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT count(*) ,  T1.product_name FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id GROUP BY T1.product_name ORDER BY count(*) DESC LIMIT 1",
        "question": "Which product has the most problems? Give me the number of problems and the product name.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the product with the most problems, so we should apply the 'count' operation to the 'Problems' table for the 'product_id' column, and find the product with the highest count. Since the unit to which the problems being counted in the query belong is the product, we should apply the 'group by' operation to the 'product_id' column in the 'Problems' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Problems', 'Product'].\n\n<3> SQL Generation: The query requires the product with the most problems, so we should select the 'product_name' column in the 'Product' table and the count of the 'problem_id' column in the 'Problems' table.\n\nSQL query: SELECT T2.product_name, COUNT(*) FROM Problems AS T1 JOIN Product AS T2 ON T1.product_id = T2.product_id GROUP BY T1.product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.product_name, COUNT(*) FROM Problems AS T1 JOIN Product AS T2 ON T1.product_id = T2.product_id GROUP BY T1.product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT LEVEL FROM member GROUP BY LEVEL ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the membership level with most number of members.",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Operation: The query requires the membership level with the most number of members, so we should apply the 'count' operation to the 'Member_ID' column in the 'member' table, and find the membership level with the highest count. Since the unit to which the members being counted in the query belong is the membership level, we should apply the 'group by' operation to the 'Level' column in the 'member' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['member'].\n\n<3> SQL Generation: The query requires the membership level with the most number of members, so we should select the 'Level' column in the 'member' table.\n\nSQL query: SELECT Level FROM member GROUP BY Level ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Level FROM member GROUP BY Level ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT LEVEL FROM member GROUP BY LEVEL ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the membership level with the most people?",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Operation: The query requires the membership level with the most people, so we should apply the 'count' operation to the 'Member_ID' column in the 'membership_register_branch' table, and find the membership level with the highest count. Since the unit to which the members being counted in the query belong is the membership level, we should apply the 'group by' operation to the 'Level' column in the 'member' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'membership_register_branch' and 'member', we need to use tables ['membership_register_branch', 'member'].\n\n<3> SQL Generation: The query requires the membership level with the most people, so we should select the 'Level' column in the 'member' table and count the 'Member_ID' column in the 'membership_register_branch' table.\n\nSQL query: SELECT T2.Level FROM member AS T2 JOIN membership_register_branch AS T1 ON T1.Member_ID = T2.Member_ID GROUP BY T2.Level ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.Level FROM member AS T2 JOIN membership_register_branch AS T1 ON T1.Member_ID = T2.Member_ID GROUP BY T2.Level ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT T2.name ,  T2.open_year FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T1.register_year  =  2016 GROUP BY T2.branch_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name and open year for the branch with most number of memberships registered in 2016?",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Operation: The query requires the name and open year for the branch with the most number of memberships registered in 2016, so we should apply the 'count' operation to the 'membership_register_branch' table for the 'Branch_ID' column, and find the branch with the highest count. Since the unit to which the memberships being counted in the query belong is the branch, we should apply the 'group by' operation to the 'Branch_ID' column in the 'membership_register_branch' table. We also need to filter the memberships registered in 2016 in the 'membership_register_branch' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'membership_register_branch' and 'branch', we need to use tables ['membership_register_branch', 'branch'].\n\n<3> SQL Generation: The query requires the name and open year for the branch with the most number of memberships registered in 2016, so we should select the 'Name' and 'Open_year' columns in the 'branch' table.\n\nSQL query: SELECT T1.Name, T1.Open_year FROM branch AS T1 JOIN membership_register_branch AS T2 ON T1.Branch_ID = T2.Branch_ID WHERE T2.Register_Year = 2016 GROUP BY T2.Branch_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Name, T1.Open_year FROM branch AS T1 JOIN membership_register_branch AS T2 ON T1.Branch_ID = T2.Branch_ID WHERE T2.Register_Year = 2016 GROUP BY T2.Branch_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT T2.name ,  T2.open_year FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T1.register_year  =  2016 GROUP BY T2.branch_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name and opening year for the branch that registered the most members in 2016?",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Operation: The query requires the name and opening year for the branch that registered the most members in 2016, so we should apply the 'count' operation to the 'membership_register_branch' table for the 'Branch_ID' column, and find the branch with the highest count. Since the unit to which the members being counted in the query belong is the branch, we should apply the 'group by' operation to the 'Branch_ID' column in the 'membership_register_branch' table. We also need to filter the registrations in 2016.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'membership_register_branch' and 'branch', we need to use tables ['membership_register_branch', 'branch'].\n\n<3> SQL Generation: The query requires the name and opening year for the branch that registered the most members in 2016, so we should select the 'Name' and 'Open_year' columns in the 'branch' table.\n\nSQL query: SELECT T1.Name, T1.Open_year FROM branch AS T1 JOIN membership_register_branch AS T2 ON T1.Branch_ID = T2.Branch_ID WHERE T2.Register_Year = 2016 GROUP BY T2.Branch_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Name, T1.Open_year FROM branch AS T1 JOIN membership_register_branch AS T2 ON T1.Branch_ID = T2.Branch_ID WHERE T2.Register_Year = 2016 GROUP BY T2.Branch_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "voter_2",
        "gold": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT 1",
        "question": "Which major has the most students?",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the major that has the most students, so we should apply the 'count' operation to the 'Student' table for the 'Major' column, and find the major with the highest count. Since the unit to which the students being counted in the query belong is the major, we should apply the 'group by' operation to the 'Major' column in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the major that has the most students, so we should select the 'Major' column in the 'Student' table.\n\nSQL query: SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "voter_2",
        "gold": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the major that is studied by the largest number of students.",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the major that is studied by the largest number of students, so we should apply the 'count' operation to the 'Student' table for the 'Major' column, and find the major with the highest count. Since the unit to which the majors being counted in the query belong is the major, we should apply the 'group by' operation to the 'Major' column in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the major that is studied by the largest number of students, so we should select the 'Major' column in the 'Student' table.\n\nSQL query: SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "voter_2",
        "gold": "SELECT Major FROM STUDENT WHERE Sex  =  \"F\" GROUP BY major ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most common major among female (sex is F) students?",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the most common major among female students, so we should apply the 'count' operation to the 'Major' column in the 'Student' table, and find the major with the highest count. Since the unit to which the majors being counted in the query belong is the student, we should apply the 'group by' operation to the 'Major' column in the 'Student' table. We also need to filter for female students by selecting rows where 'Sex' is 'F'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the most common major among female students, so we should select the 'Major' column in the 'Student' table. We also need to filter for female students by adding a condition where 'Sex' is 'F'.\n\nSQL query: SELECT Major FROM Student WHERE Sex = 'F' GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Major FROM Student WHERE Sex = 'F' GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "voter_2",
        "gold": "SELECT Major FROM STUDENT WHERE Sex  =  \"F\" GROUP BY major ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the major that is studied by the most female students.",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the major that is studied by the most female students, so we should apply the 'count' operation to the 'Student' table for the 'Major' column, and find the major with the highest count. Since the unit to which the majors being counted in the query belong is the major and only table 'Student' has the column 'Major', we should apply the 'group by' operation to the 'Major' column in the 'Student' table. We also need to filter for female students in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the major that is studied by the most female students, so we should select the 'Major' column in the 'Student' table and filter for female students.\n\nSQL query: SELECT Major FROM Student WHERE Sex = 'Female' GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Major FROM Student WHERE Sex = 'Female' GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "voter_2",
        "gold": "SELECT city_code FROM STUDENT GROUP BY city_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the city_code of the city that the most students live in?",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the city_code of the city that the most students live in, so we should apply the 'count' operation to the 'Student' table for the 'city_code' column, and find the city_code with the highest count. Since the unit to which the students being counted in the query belong is the city, we should apply the 'group by' operation to the 'city_code' column in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the city_code of the city that the most students live in, so we should select the 'city_code' column in the 'Student' table.\n\nSQL query: SELECT city_code FROM Student GROUP BY city_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT city_code FROM Student GROUP BY city_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "voter_2",
        "gold": "SELECT city_code FROM STUDENT GROUP BY city_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the code of the city that has the most students.",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the code of the city that has the most students, so we should apply the 'count' operation to the 'Student' table for the 'city_code' column, and find the city code with the highest count. Since the unit to which the students being counted in the query belong is the city, we should apply the 'group by' operation to the 'city_code' column in the 'Student' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the code of the city that has the most students, so we should select the 'city_code' column in the 'Student' table.\n\nSQL query: SELECT city_code FROM Student GROUP BY city_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT city_code FROM Student GROUP BY city_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the description of the color for most products?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Operation: The query requires the description of the color for the most products, so we should apply the 'count' operation to the 'color_code' column in the 'Products' table, and find the color with the highest count. Since the unit to which the colors being counted in the query belong is the product, we should apply the 'group by' operation to the 'color_code' column in the 'Products' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Products'].\n\n<3> SQL Generation: The query requires the description of the color for the most products, so we should select the 'color_description' column in the 'Ref_Colors' table based on the 'color_code' column in the 'Products' table.\n\nSQL query: SELECT color_description FROM Ref_Colors WHERE color_code = (SELECT color_code FROM Products GROUP BY color_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT color_description FROM Ref_Colors WHERE color_code = (SELECT color_code FROM Products GROUP BY color_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the color description that is most common across all products.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Operation: The query requires the color description that is most common across all products, so we should apply the 'count' operation to the 'color_code' column in the 'Products' table, and find the color code with the highest count. Since the unit to which the color codes being counted in the query belong is the product, we should apply the 'group by' operation to the 'color_code' column in the 'Products' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Products', 'Ref_Colors'].\n\n<3> SQL Generation: The query requires the color description that is most common across all products, so we should select the 'color_description' column in the 'Ref_Colors' table.\n\nSQL query: SELECT color_description FROM Ref_Colors WHERE color_code = (SELECT color_code FROM Products GROUP BY color_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT color_description FROM Ref_Colors WHERE color_code = (SELECT color_code FROM Products GROUP BY color_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the name of the characteristic that is most common across all products.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the characteristic that is most common across all products, so we should apply the 'count' operation to the 'characteristic_id' column in the 'Product_Characteristics' table, and find the characteristic with the highest count. Since the unit to which the characteristics being counted in the query belong is the product, we should apply the 'group by' operation to the 'characteristic_id' column in the 'Product_Characteristics' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Characteristics', 'Product_Characteristics'].\n\n<3> SQL Generation: The query requires the name of the characteristic that is most common across all products, so we should select the 'characteristic_name' column in the 'Characteristics' table and the 'characteristic_id' column in the 'Product_Characteristics' table.\n\nSQL query: SELECT characteristic_name FROM Characteristics WHERE characteristic_id = (SELECT characteristic_id FROM Product_Characteristics GROUP BY characteristic_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT characteristic_name FROM Characteristics WHERE characteristic_id = (SELECT characteristic_id FROM Product_Characteristics GROUP BY characteristic_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "swimming",
        "gold": "SELECT country FROM stadium GROUP BY country ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the country that has the most stadiums.",
        "fields": "Table event, columns = [*,ID,Name,Stadium_ID,Year]\nTable record, columns = [*,ID,Result,Swimmer_ID,Event_ID]\nTable stadium, columns = [*,ID,name,Capacity,City,Country,Opening_year]\nTable swimmer, columns = [*,ID,name,Nationality,meter_100,meter_200,meter_300,meter_400,meter_500,meter_600,meter_700,Time]\n",
        "foreign_keys": "Foreign_keys = [event.Stadium_ID = stadium.ID,record.Swimmer_ID = swimmer.ID,record.Event_ID = event.ID]\n",
        "reasoning": "<1> Operation: The query requires the country that has the most stadiums, so we should apply the 'count' operation to the 'ID' column in the 'stadium' table, and find the country with the highest count. Since the unit to which the stadiums being counted in the query belong is the country, we should apply the 'group by' operation to the 'Country' column in the 'stadium' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'stadium'.\n\n<3> SQL Generation: The query requires the country that has the most stadiums, so we should select the 'Country' column in the 'stadium' table.\n\nSQL query: SELECT Country FROM stadium GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Country FROM stadium GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "swimming",
        "gold": "SELECT t1.name FROM stadium AS t1 JOIN event AS t2 ON t1.id  =  t2.stadium_id GROUP BY t2.stadium_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the stadium which held the most events?",
        "fields": "Table event, columns = [*,ID,Name,Stadium_ID,Year]\nTable record, columns = [*,ID,Result,Swimmer_ID,Event_ID]\nTable stadium, columns = [*,ID,name,Capacity,City,Country,Opening_year]\nTable swimmer, columns = [*,ID,name,Nationality,meter_100,meter_200,meter_300,meter_400,meter_500,meter_600,meter_700,Time]\n",
        "foreign_keys": "Foreign_keys = [event.Stadium_ID = stadium.ID,record.Swimmer_ID = swimmer.ID,record.Event_ID = event.ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the stadium which held the most events, so we should apply the 'count' operation to the 'event' table for the 'ID' column, and find the stadium with the highest count. Since the unit to which the events being counted in the query belong is the stadium, we should apply the 'group by' operation to the 'Stadium_ID' column in the 'event' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['event', 'stadium'].\n\n<3> SQL Generation: The query requires the name of the stadium which held the most events, so we should select the 'name' column in the 'stadium' table.\n\nSQL query: SELECT name FROM stadium WHERE ID = (SELECT Stadium_ID FROM event GROUP BY Stadium_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT name FROM stadium WHERE ID = (SELECT Stadium_ID FROM event GROUP BY Stadium_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "swimming",
        "gold": "SELECT t1.name FROM swimmer AS t1 JOIN record AS t2 ON t1.id  =  t2.swimmer_id GROUP BY t2.swimmer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the swimmer who has the most records.",
        "fields": "Table event, columns = [*,ID,Name,Stadium_ID,Year]\nTable record, columns = [*,ID,Result,Swimmer_ID,Event_ID]\nTable stadium, columns = [*,ID,name,Capacity,City,Country,Opening_year]\nTable swimmer, columns = [*,ID,name,Nationality,meter_100,meter_200,meter_300,meter_400,meter_500,meter_600,meter_700,Time]\n",
        "foreign_keys": "Foreign_keys = [event.Stadium_ID = stadium.ID,record.Swimmer_ID = swimmer.ID,record.Event_ID = event.ID]\n",
        "reasoning": "<1> Operation: The query requires the name of the swimmer who has the most records, so we should apply the 'count' operation to the 'record' table for the 'Swimmer_ID' column, and find the swimmer with the highest count. Since the unit to which the records being counted in the query belong is the swimmer, we should apply the 'group by' operation to the 'Swimmer_ID' column in the 'record' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['swimmer'].\n\n<3> SQL Generation: The query requires the name of the swimmer who has the most records, so we should select the 'name' column in the 'swimmer' table.\n\nSQL query: SELECT name FROM swimmer WHERE ID = (SELECT Swimmer_ID FROM record GROUP BY Swimmer_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT name FROM swimmer WHERE ID = (SELECT Swimmer_ID FROM record GROUP BY Swimmer_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "railway",
        "gold": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the id and builder of the railway that are associated with the most trains.",
        "fields": "Table manager, columns = [*,Manager_ID,Name,Country,Working_year_starts,Age,Level]\nTable railway, columns = [*,Railway_ID,Railway,Builder,Built,Wheels,Location,ObjectNumber]\nTable railway_manage, columns = [*,Railway_ID,Manager_ID,From_Year]\nTable train, columns = [*,Train_ID,Train_Num,Name,From,Arrival,Railway_ID]\n",
        "foreign_keys": "Foreign_keys = [train.Railway_ID = railway.Railway_ID,railway_manage.Railway_ID = railway.Railway_ID,railway_manage.Manager_ID = manager.Manager_ID]\n",
        "reasoning": "<1> Operation: The query requires the id and builder of the railway that are associated with the most trains, so we should apply the 'count' operation to the 'Railway_ID' column in the 'train' table, and find the railway with the highest count. Since the unit to which the trains being counted in the query belong is the railway, we should apply the 'group by' operation to the 'Railway_ID' column in the 'train' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'train' and 'railway', we need to use tables ['train', 'railway'].\n\n<3> SQL Generation: The query requires the id and builder of the railway that are associated with the most trains, so we should select the 'Railway_ID' column and the 'Builder' column in the 'railway' table.\n\nSQL query: SELECT Railway_ID, Builder FROM railway WHERE Railway_ID = (SELECT Railway_ID FROM train GROUP BY Railway_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Railway_ID, Builder FROM railway WHERE Railway_ID = (SELECT Railway_ID FROM train GROUP BY Railway_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "railway",
        "gold": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common builder of railways.",
        "fields": "Table manager, columns = [*,Manager_ID,Name,Country,Working_year_starts,Age,Level]\nTable railway, columns = [*,Railway_ID,Railway,Builder,Built,Wheels,Location,ObjectNumber]\nTable railway_manage, columns = [*,Railway_ID,Manager_ID,From_Year]\nTable train, columns = [*,Train_ID,Train_Num,Name,From,Arrival,Railway_ID]\n",
        "foreign_keys": "Foreign_keys = [train.Railway_ID = railway.Railway_ID,railway_manage.Railway_ID = railway.Railway_ID,railway_manage.Manager_ID = manager.Manager_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common builder of railways, so we should apply the 'count' operation to the 'Builder' column in the 'railway' table and find the builder with the highest count. Since the unit to which the builders being counted in the query belong is the railway, we should apply the 'group by' operation to the 'Builder' column in the 'railway' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['railway'].\n\n<3> SQL Generation: The query requires the most common builder of railways, so we should select the 'Builder' column in the 'railway' table.\n\nSQL query: SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_products_contacts",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the name of the customer who has the most orders.",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Contacts, columns = [*,contact_id,customer_id,gender,first_name,last_name,contact_phone]\nTable Customer_Address_History, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\n",
        "foreign_keys": "Foreign_keys = [Customer_Address_History.address_id = Addresses.address_id,Customer_Address_History.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the customer who has the most orders, so we should apply the 'count' operation to the 'Customer_Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Customer_Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers', 'Customer_Orders'].\n\n<3> SQL Generation: The query requires the name of the customer who has the most orders, so we should select the 'customer_name' column in the 'Customers' table and the 'customer_id' column in the 'Customer_Orders' table.\n\nSQL query: SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Customer_Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Customer_Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT fname ,  lname FROM student WHERE major != (SELECT major FROM student GROUP BY major ORDER BY count(*) DESC LIMIT 1)",
        "question": "Find the first and last name of students who are not in the largest major.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the first and last name of students who are not in the largest major, so we should apply the 'count' operation to the 'Major' column in the 'Student' table, and find the major with the highest count. Then, we need to filter out the students who have the largest major.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the first and last name of students who are not in the largest major, so we should select the 'Fname' and 'LName' columns in the 'Student' table. We also need to filter out the students who have the largest major.\n\nSQL query: SELECT Fname, LName FROM Student WHERE Major != (SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Fname, LName FROM Student WHERE Major != (SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT fname ,  lname FROM student WHERE major != (SELECT major FROM student GROUP BY major ORDER BY count(*) DESC LIMIT 1)",
        "question": "What is the first and last name of the students who are not in the largest major?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the first and last name of the students who are not in the largest major, so we should apply the 'count' operation to the 'Major' column in the 'Student' table, and find the major with the highest count. Then, we need to filter out the students who have the largest major.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Student'].\n\n<3> SQL Generation: The query requires the first and last name of the students who are not in the largest major, so we should select the 'Fname' and 'LName' columns in the 'Student' table. We also need to filter out the students who have the largest major.\n\nSQL query: SELECT Fname, LName FROM Student WHERE Major != (SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Fname, LName FROM Student WHERE Major != (SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of amenity that is most common in all dorms.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the name of the amenity that is most common in all dorms, so we should apply the 'count' operation to the 'amenid' column in the 'Has_amenity' table, and find the amenity with the highest count. Since the unit to which the amenities being counted in the query belong is the dorm, we should apply the 'group by' operation to the 'amenid' column in the 'Has_amenity' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Dorm_amenity', 'Has_amenity'].\n\n<3> SQL Generation: The query requires the name of the amenity that is most common in all dorms, so we should select the 'amenity_name' column in the 'Dorm_amenity' table and the 'amenid' column in the 'Has_amenity' table.\n\nSQL query: SELECT amenity_name FROM Dorm_amenity WHERE amenid = (SELECT amenid FROM Has_amenity GROUP BY amenid ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT amenity_name FROM Dorm_amenity WHERE amenid = (SELECT amenid FROM Has_amenity GROUP BY amenid ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most common amenity in the dorms?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the most common amenity in the dorms, so we should apply the 'count' operation to the 'amenid' column in the 'Has_amenity' table, and find the amenity with the highest count. Since the unit to which the amenities being counted in the query belong is the dorm, we should apply the 'group by' operation to the 'dormid' column in the 'Has_amenity' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Dorm_amenity', 'Has_amenity'].\n\n<3> SQL Generation: The query requires the most common amenity in the dorms, so we should select the 'amenity_name' column in the 'Dorm_amenity' table.\n\nSQL query: SELECT amenity_name FROM Dorm_amenity WHERE amenid = (SELECT amenid FROM Has_amenity GROUP BY amenid ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT amenity_name FROM Dorm_amenity WHERE amenid = (SELECT amenid FROM Has_amenity GROUP BY amenid ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT T1.dorm_name ,  T1.student_capacity FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid GROUP BY T2.dormid ORDER BY count(*) LIMIT 1",
        "question": "Find the name and capacity of the dorm with least number of amenities.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the name and capacity of the dorm with the least number of amenities, so we should apply the 'count' operation to the 'amenid' column in the 'Has_amenity' table, and find the dorm with the lowest count. Since the unit to which the amenities being counted in the query belong is the dorm, we should apply the 'group by' operation to the 'dormid' column in the 'Has_amenity' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Dorm', 'Dorm_amenity', 'Has_amenity', and 'Lives_in', we need to use tables ['Dorm', 'Dorm_amenity', 'Has_amenity'].\n\n<3> SQL Generation: The query requires the name and capacity of the dorm with the least number of amenities, so we should select the 'dorm_name' and 'student_capacity' columns in the 'Dorm' table and the 'amenid' column in the 'Has_amenity' table.\n\nSQL query: SELECT T1.dorm_name, T1.student_capacity FROM Dorm AS T1 JOIN Has_amenity AS T2 ON T1.dormid = T2.dormid GROUP BY T2.dormid ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT T1.dorm_name, T1.student_capacity FROM Dorm AS T1 JOIN Has_amenity AS T2 ON T1.dormid = T2.dormid GROUP BY T2.dormid ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT T1.dorm_name ,  T1.student_capacity FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid GROUP BY T2.dormid ORDER BY count(*) LIMIT 1",
        "question": "What is the name and capacity of the dorm with the fewest amount of amenities?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the name and capacity of the dorm with the fewest amount of amenities, so we should apply the 'count' operation to the 'amenid' column in the 'Has_amenity' table, and find the dorm with the lowest count. Since the unit to which the amenities being counted in the query belong is the dorm, we should apply the 'group by' operation to the 'dormid' column in the 'Has_amenity' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Dorm_amenity' and 'Has_amenity', we need to use tables ['Dorm_amenity', 'Has_amenity', 'Dorm'].\n\n<3> SQL Generation: The query requires the name and capacity of the dorm with the fewest amount of amenities, so we should select the 'dorm_name' and 'student_capacity' columns in the 'Dorm' table and the 'amenid' column in the 'Has_amenity' table.\n\nSQL query: SELECT T1.dorm_name, T1.student_capacity FROM Dorm AS T1 JOIN Has_amenity AS T2 ON T1.dormid = T2.dormid GROUP BY T2.dormid ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT T1.dorm_name, T1.student_capacity FROM Dorm AS T1 JOIN Has_amenity AS T2 ON T1.dormid = T2.dormid GROUP BY T2.dormid ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "customer_complaints",
        "gold": "SELECT town_city FROM customers WHERE customer_type_code  =  \"Good Credit Rating\" GROUP BY town_city ORDER BY count(*) LIMIT 1",
        "question": "Which city has the least number of customers whose type code is \"Good Credit Rating\"?",
        "fields": "Table Complaints, columns = [*,complaint_id,product_id,customer_id,complaint_outcome_code,complaint_status_code,complaint_type_code,date_complaint_raised,date_complaint_closed,staff_id]\nTable Customers, columns = [*,customer_id,customer_type_code,address_line_1,address_line_2,town_city,state,email_address,phone_number]\nTable Products, columns = [*,product_id,parent_product_id,product_category_code,date_product_first_available,date_product_discontinued,product_name,product_description,product_price]\nTable Staff, columns = [*,staff_id,gender,first_name,last_name,email_address,phone_number]\n",
        "foreign_keys": "Foreign_keys = [Complaints.customer_id = Customers.customer_id,Complaints.product_id = Products.product_id,Complaints.staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the city with the least number of customers whose type code is \"Good Credit Rating\", so we should apply the 'count' operation to the 'Customers' table for the 'customer_id' column, and find the city with the lowest count. Since the unit to which the customers being counted in the query belong is the city, we should apply the 'group by' operation to the 'town_city' column in the 'Customers' table. We also need to filter the customers whose type code is \"Good Credit Rating\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers'].\n\n<3> SQL Generation: The query requires the city with the least number of customers whose type code is \"Good Credit Rating\", so we should select the 'town_city' column in the 'Customers' table and count the 'customer_id' column in the 'Customers' table.\n\nSQL query: SELECT town_city FROM Customers WHERE customer_type_code = 'Good Credit Rating' GROUP BY town_city ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT town_city FROM Customers WHERE customer_type_code = 'Good Credit Rating' GROUP BY town_city ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "customer_complaints",
        "gold": "SELECT town_city FROM customers WHERE customer_type_code  =  \"Good Credit Rating\" GROUP BY town_city ORDER BY count(*) LIMIT 1",
        "question": "Return the city with the customer type code \"Good Credit Rating\" that had the fewest customers.",
        "fields": "Table Complaints, columns = [*,complaint_id,product_id,customer_id,complaint_outcome_code,complaint_status_code,complaint_type_code,date_complaint_raised,date_complaint_closed,staff_id]\nTable Customers, columns = [*,customer_id,customer_type_code,address_line_1,address_line_2,town_city,state,email_address,phone_number]\nTable Products, columns = [*,product_id,parent_product_id,product_category_code,date_product_first_available,date_product_discontinued,product_name,product_description,product_price]\nTable Staff, columns = [*,staff_id,gender,first_name,last_name,email_address,phone_number]\n",
        "foreign_keys": "Foreign_keys = [Complaints.customer_id = Customers.customer_id,Complaints.product_id = Products.product_id,Complaints.staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Operation: The query requires the city with the customer type code \"Good Credit Rating\" that had the fewest customers, so we should apply the 'count' operation to the 'customer_id' column in the 'Customers' table, and find the city with the lowest count. Since the unit to which the customers being counted in the query belong is the city, we should apply the 'group by' operation to the 'town_city' column in the 'Customers' table. We also need to filter the customers with the customer type code \"Good Credit Rating\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers'].\n\n<3> SQL Generation: The query requires the city with the customer type code \"Good Credit Rating\" that had the fewest customers, so we should select the 'town_city' column in the 'Customers' table and the 'customer_type_code' column in the 'Customers' table.\n\nSQL query: SELECT town_city FROM Customers WHERE customer_type_code = 'Good Credit Rating' GROUP BY town_city ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT town_city FROM Customers WHERE customer_type_code = 'Good Credit Rating' GROUP BY town_city ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "workshop_paper",
        "gold": "SELECT College FROM submission GROUP BY College ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common college of authors of submissions.",
        "fields": "Table Acceptance, columns = [*,Submission_ID,Workshop_ID,Result]\nTable submission, columns = [*,Submission_ID,Scores,Author,College]\nTable workshop, columns = [*,Workshop_ID,Date,Venue,Name]\n",
        "foreign_keys": "Foreign_keys = [Acceptance.Workshop_ID = workshop.Workshop_ID,Acceptance.Submission_ID = submission.Submission_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common college of authors of submissions, so we should apply the 'count' operation to the 'College' column in the 'submission' table and find the college with the highest count. Since the unit to which the colleges being counted in the query belong is the author, we should apply the 'group by' operation to the 'Author' column in the 'submission' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['submission'].\n\n<3> SQL Generation: The query requires the most common college of authors of submissions, so we should select the 'College' column in the 'submission' table.\n\nSQL query: SELECT College FROM submission GROUP BY Author ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT College FROM submission GROUP BY Author ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_share_transactions",
        "gold": "SELECT investor_id ,  avg(share_count) FROM TRANSACTIONS GROUP BY investor_id ORDER BY avg(share_count)",
        "question": "Show the average share count of transactions each each investor, ordered by average share count.",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n",
        "reasoning": "<1> Operation: The query requires the average share count of transactions for each investor, so we should apply the 'average' operation to the 'share_count' column in the 'Transactions' table and sort it in ascending order. Since the unit to which the average share count being calculated in the query belongs is the investor, we should apply the 'group by' operation to the 'investor_id' column in the 'Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Transactions' and 'Investors', we need to use tables ['Transactions', 'Investors'].\n\n<3> SQL Generation: The query requires the average share count of transactions for each investor, so we should select the 'investor_id' column in the 'Transactions' table and the average of the 'share_count' column in the 'Transactions' table.\n\nSQL query: SELECT investor_id, AVG(share_count) FROM Transactions GROUP BY investor_id ORDER BY AVG(share_count) ASC",
        "predict": "SELECT investor_id, AVG(share_count) FROM Transactions GROUP BY investor_id ORDER BY AVG(share_count) ASC",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_share_transactions",
        "gold": "SELECT T2.lot_id ,  avg(amount_of_transaction) FROM TRANSACTIONS AS T1 JOIN Transactions_Lots AS T2 ON T1.transaction_id  =  T2.transaction_id GROUP BY T2.lot_id ORDER BY avg(amount_of_transaction)",
        "question": "Show the average amount of transactions for different lots, ordered by average amount of transactions.",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n",
        "reasoning": "<1> Operation: The query requires the average amount of transactions for different lots, so we should apply the 'average' operation to the 'amount_of_transaction' column in the 'Transactions' table and sort it in ascending order. Since the unit to which the average amount of transactions being calculated in the query belongs is the lot, we should apply the 'group by' operation to the 'lot_id' column in the 'Transactions_Lots' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'Transactions', 'Transactions_Lots', and 'Lots', we need to use tables ['Transactions', 'Transactions_Lots', 'Lots'].\n\n<3> SQL Generation: The query requires the average amount of transactions for different lots, so we should select the 'lot_id' column in the 'Transactions_Lots' table and the average of the 'amount_of_transaction' column in the 'Transactions' table.\n\nSQL query: SELECT T2.lot_id, AVG(T1.amount_of_transaction) FROM Transactions AS T1 JOIN Transactions_Lots AS T2 ON T1.transaction_id = T2.transaction_id GROUP BY T2.lot_id ORDER BY AVG(T1.amount_of_transaction) ASC",
        "predict": "SELECT T2.lot_id, AVG(T1.amount_of_transaction) FROM Transactions AS T1 JOIN Transactions_Lots AS T2 ON T1.transaction_id = T2.transaction_id GROUP BY T2.lot_id ORDER BY AVG(T1.amount_of_transaction) ASC",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_share_transactions",
        "gold": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) ASC LIMIT 1",
        "question": "Show the transaction type code that occurs the fewest times.",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n",
        "reasoning": "<1> Operation: The query requires the transaction type code that occurs the fewest times, so we should apply the 'count' operation to the 'transaction_type_code' column in the 'Transactions' table and find the transaction type code with the lowest count. Since the unit to which the transaction types being counted in the query belong is the transaction, we should apply the 'group by' operation to the 'transaction_type_code' column in the 'Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Transactions'].\n\n<3> SQL Generation: The query requires the transaction type code that occurs the fewest times, so we should select the 'transaction_type_code' column in the 'Transactions' table.\n\nSQL query: SELECT transaction_type_code FROM Transactions GROUP BY transaction_type_code ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT transaction_type_code FROM Transactions GROUP BY transaction_type_code ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_share_transactions",
        "gold": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the transaction type code that occurs the most frequently.",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n",
        "reasoning": "<1> Operation: The query requires the transaction type code that occurs the most frequently, so we should apply the 'count' operation to the 'transaction_type_code' column in the 'Transactions' table and find the transaction type code with the highest count. Since the unit to which the transaction type codes being counted in the query belong is the transaction, we should apply the 'group by' operation to the 'transaction_type_code' column in the 'Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Transactions'].\n\n<3> SQL Generation: The query requires the transaction type code that occurs the most frequently, so we should select the 'transaction_type_code' column in the 'Transactions' table.\n\nSQL query: SELECT transaction_type_code FROM Transactions GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT transaction_type_code FROM Transactions GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_share_transactions",
        "gold": "SELECT T1.transaction_type_description FROM Ref_Transaction_Types AS T1 JOIN TRANSACTIONS AS T2 ON T1.transaction_type_code  =  T2.transaction_type_code GROUP BY T1.transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the description of the transaction type that occurs most frequently.",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n",
        "reasoning": "<1> Operation: The query requires the description of the transaction type that occurs most frequently, so we should apply the 'count' operation to the 'transaction_type_code' column in the 'Transactions' table, and find the transaction type with the highest count. Since the unit to which the transaction types being counted in the query belong is the transaction, we should apply the 'group by' operation to the 'transaction_type_code' column in the 'Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Transactions', 'Ref_Transaction_Types'].\n\n<3> SQL Generation: The query requires the description of the transaction type that occurs most frequently, so we should select the 'transaction_type_description' column in the 'Ref_Transaction_Types' table.\n\nSQL query: SELECT transaction_type_description FROM Ref_Transaction_Types WHERE transaction_type_code = (SELECT transaction_type_code FROM Transactions GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT transaction_type_description FROM Ref_Transaction_Types WHERE transaction_type_code = (SELECT transaction_type_code FROM Transactions GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_share_transactions",
        "gold": "SELECT T2.investor_id ,  T1.Investor_details FROM INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id GROUP BY T2.investor_id ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the id and details of the investor that has the largest number of transactions.",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n",
        "reasoning": "<1> Operation: The query requires the id and details of the investor with the largest number of transactions, so we should apply the 'count' operation to the 'Transactions' table for the 'investor_id' column, and find the investor with the highest count. Since the unit to which the transactions being counted in the query belong is the investor, we should apply the 'group by' operation to the 'investor_id' column in the 'Transactions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Transactions' and 'Investors', we need to use tables ['Transactions', 'Investors'].\n\n<3> SQL Generation: The query requires the id and details of the investor with the largest number of transactions, so we should select the 'investor_id' column in the 'Investors' table and the 'Investor_details' column in the 'Investors' table.\n\nSQL query: SELECT investor_id, Investor_details FROM Investors WHERE investor_id = (SELECT investor_id FROM Transactions GROUP BY investor_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT investor_id, Investor_details FROM Investors WHERE investor_id = (SELECT investor_id FROM Transactions GROUP BY investor_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the transportation method most people choose to get to tourist attractions.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Operation: The query requires the transportation method most people choose to get to tourist attractions, so we should apply the 'count' operation to the 'Tourist_Attractions' table for the 'How_to_Get_There' column, and find the transportation method with the highest count. Since the unit to which the transportation methods being counted in the query belong is the tourist attraction, we should apply the 'group by' operation to the 'How_to_Get_There' column in the 'Tourist_Attractions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Tourist_Attractions'].\n\n<3> SQL Generation: The query requires the transportation method most people choose to get to tourist attractions, so we should select the 'How_to_Get_There' column in the 'Tourist_Attractions' table.\n\nSQL query: SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which transportation method is used the most often to get to tourist attractions?",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Operation: The query requires the transportation method that is used the most often to get to tourist attractions, so we should apply the 'count' operation to the 'How_to_Get_There' column in the 'Tourist_Attractions' table, and find the transportation method with the highest count. Since the unit to which the transportation methods being counted in the query belong is the tourist attraction, we should apply the 'group by' operation to the 'How_to_Get_There' column in the 'Tourist_Attractions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Tourist_Attractions'].\n\n<3> SQL Generation: The query requires the transportation method that is used the most often to get to tourist attractions, so we should select the 'How_to_Get_There' column in the 'Tourist_Attractions' table.\n\nSQL query: SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT T1.Attraction_Type_Description ,  T2.Attraction_Type_Code FROM Ref_Attraction_Types AS T1 JOIN Tourist_Attractions AS T2 ON T1.Attraction_Type_Code  =  T2.Attraction_Type_Code GROUP BY T2.Attraction_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the description and code of the attraction type most tourist attractions belong to.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Operation: The query requires the description and code of the attraction type that most tourist attractions belong to, so we should apply the 'count' operation to the 'Attraction_Type_Code' column in the 'Tourist_Attractions' table and find the attraction type with the highest count. Since the unit to which the attraction types being counted in the query belong is the tourist attraction, we should apply the 'group by' operation to the 'Attraction_Type_Code' column in the 'Tourist_Attractions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Tourist_Attractions', 'Ref_Attraction_Types'].\n\n<3> SQL Generation: The query requires the description and code of the attraction type that most tourist attractions belong to, so we should select the 'Attraction_Type_Description' column in the 'Ref_Attraction_Types' table and the 'Attraction_Type_Code' column in the 'Ref_Attraction_Types' table.\n\nSQL query: SELECT Attraction_Type_Description, Attraction_Type_Code FROM Ref_Attraction_Types WHERE Attraction_Type_Code = (SELECT Attraction_Type_Code FROM Tourist_Attractions GROUP BY Attraction_Type_Code ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Attraction_Type_Description, Attraction_Type_Code FROM Ref_Attraction_Types WHERE Attraction_Type_Code = (SELECT Attraction_Type_Code FROM Tourist_Attractions GROUP BY Attraction_Type_Code ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT T1.Attraction_Type_Description ,  T2.Attraction_Type_Code FROM Ref_Attraction_Types AS T1 JOIN Tourist_Attractions AS T2 ON T1.Attraction_Type_Code  =  T2.Attraction_Type_Code GROUP BY T2.Attraction_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which attraction type does the most tourist attractions belong to? Tell me its  attraction type description and code.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Operation: The query requires the attraction type to which the most tourist attractions belong, so we should apply the 'count' operation to the 'Tourist_Attractions' table for the 'Attraction_Type_Code' column, and find the attraction type with the highest count. Since the unit to which the attraction types being counted in the query belong is the tourist attraction, we should apply the 'group by' operation to the 'Attraction_Type_Code' column in the 'Tourist_Attractions' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Tourist_Attractions', 'Ref_Attraction_Types'].\n\n<3> SQL Generation: The query requires the attraction type to which the most tourist attractions belong, so we should select the 'Attraction_Type_Description' column and the 'Attraction_Type_Code' column in the 'Ref_Attraction_Types' table.\n\nSQL query: SELECT T2.Attraction_Type_Description, T1.Attraction_Type_Code FROM Tourist_Attractions AS T1 JOIN Ref_Attraction_Types AS T2 ON T1.Attraction_Type_Code = T2.Attraction_Type_Code GROUP BY T1.Attraction_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.Attraction_Type_Description, T1.Attraction_Type_Code FROM Tourist_Attractions AS T1 JOIN Ref_Attraction_Types AS T2 ON T1.Attraction_Type_Code = T2.Attraction_Type_Code GROUP BY T1.Attraction_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1",
        "question": "What type has the most games?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the type that has the most games, so we should apply the 'count' operation to the 'GameID' column in the 'Video_Games' table, and find the type with the highest count. Since the unit to which the games being counted in the query belong is the type, we should apply the 'group by' operation to the 'GType' column in the 'Video_Games' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Video_Games'].\n\n<3> SQL Generation: The query requires the type that has the most games, so we should select the 'GType' column in the 'Video_Games' table.\n\nSQL query: SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1",
        "question": "Which game type has least number of games?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the game type with the least number of games, so we should apply the 'count' operation to the 'GameID' column in the 'Video_Games' table and find the game type with the lowest count. Since the unit to which the games being counted in the query belong is the game type, we should apply the 'group by' operation to the 'GType' column in the 'Video_Games' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Video_Games'].\n\n<3> SQL Generation: The query requires the game type with the least number of games, so we should select the 'GType' column in the 'Video_Games' table and count the 'GameID' column in the 'Video_Games' table.\n\nSQL query: SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the first name and last name of the student who have most number of sports?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the first name and last name of the student who has the most number of sports, so we should apply the 'count' operation to the 'SportName' column in the 'SportsInfo' table, and find the student with the highest count. Since the unit to which the sports being counted in the query belong is the student, we should apply the 'group by' operation to the 'StuID' column in the 'SportsInfo' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Student', 'SportsInfo'].\n\n<3> SQL Generation: The query requires the first name and last name of the student who has the most number of sports, so we should select the 'Fname' and 'LName' columns in the 'Student' table.\n\nSQL query: SELECT Fname, LName FROM Student WHERE StuID = (SELECT StuID FROM SportsInfo GROUP BY StuID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Fname, LName FROM Student WHERE StuID = (SELECT StuID FROM SportsInfo GROUP BY StuID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the first and last name of the student who played the most sports?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the first and last name of the student who played the most sports, so we should apply the 'count' operation to the 'StuID' column in the 'SportsInfo' table, and find the student with the highest count. Since the unit to which the sports being counted in the query belong is the student, we should apply the 'group by' operation to the 'StuID' column in the 'SportsInfo' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Student', 'SportsInfo'].\n\n<3> SQL Generation: The query requires the first and last name of the student who played the most sports, so we should select the 'Fname' and 'LName' columns in the 'Student' table.\n\nSQL query: SELECT Fname, LName FROM Student WHERE StuID = (SELECT StuID FROM SportsInfo GROUP BY StuID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Fname, LName FROM Student WHERE StuID = (SELECT StuID FROM SportsInfo GROUP BY StuID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the sport with the most scholarship students?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Operation: The query requires the sport with the most scholarship students, so we should apply the 'count' operation to the 'SportsInfo' table for the 'OnScholarship' column, and find the sport with the highest count. Since the unit to which the scholarship students being counted in the query belong is the sport, we should apply the 'group by' operation to the 'SportName' column in the 'SportsInfo' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['SportsInfo'].\n\n<3> SQL Generation: The query requires the sport with the most scholarship students, so we should select the 'SportName' column in the 'SportsInfo' table.\n\nSQL query: SELECT SportName FROM SportsInfo WHERE OnScholarship = 'Yes' GROUP BY SportName ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT SportName FROM SportsInfo WHERE OnScholarship = 'Yes' GROUP BY SportName ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1",
        "question": "Which payment method is used by most customers?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Operation: The query requires the payment method used by the most customers, so we should apply the 'count' operation to the 'Customers' table for the 'payment_method' column, and find the payment method with the highest count.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Customers'.\n\n<3> SQL Generation: The query requires the payment method used by the most customers, so we should select the 'payment_method' column in the 'Customers' table.\n\nSQL query: SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the payment method that is used most frequently.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Operation: The query requires the payment method that is used most frequently, so we should apply the 'count' operation to the 'Customers' table for the 'payment_method' column, and find the payment method with the highest count.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Customers'.\n\n<3> SQL Generation: The query requires the payment method that is used most frequently, so we should select the 'payment_method' column in the 'Customers' table.\n\nSQL query: SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT customer_name FROM customers WHERE payment_method  =  (SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1)",
        "question": "What are the names of customers using the most popular payment method?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Operation: The query requires the names of customers using the most popular payment method, so we should apply the 'count' operation to the 'Customers' table for the 'payment_method' column, and find the payment method with the highest count. Since the unit to which the payment methods being counted in the query belong is the customer, we should apply the 'group by' operation to the 'payment_method' column in the 'Customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers'].\n\n<3> SQL Generation: The query requires the names of customers using the most popular payment method, so we should select the 'customer_name' column in the 'Customers' table and the 'payment_method' column in the 'Customers' table.\n\nSQL query: SELECT customer_name FROM Customers WHERE payment_method = (SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_name FROM Customers WHERE payment_method = (SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT customer_name FROM customers WHERE payment_method  =  (SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1)",
        "question": "Find the name of the customers who use the most frequently used payment method.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the customers who use the most frequently used payment method, so we should apply the 'count' operation to the 'Customers' table for the 'payment_method' column, and find the payment method with the highest count. Since the unit to which the payment methods being counted in the query belong is the customer, we should apply the 'group by' operation to the 'payment_method' column in the 'Customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers'].\n\n<3> SQL Generation: The query requires the name of the customers who use the most frequently used payment method, so we should select the 'customer_name' column in the 'Customers' table and the 'payment_method' column in the 'Customers' table.\n\nSQL query: SELECT customer_name FROM Customers WHERE payment_method = (SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_name FROM Customers WHERE payment_method = (SELECT payment_method FROM Customers GROUP BY payment_method ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1",
        "question": "Which city has the most customers living in?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Operation: The query requires the city that has the most customers living in, so we should apply the 'count' operation to the 'customer_id' column in the 'Customer_Addresses' table, and find the city with the highest count. Since the unit to which the customers being counted in the query belong is the city, we should apply the 'group by' operation to the 'city' column in the 'Addresses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Customer_Addresses' and 'Addresses', we need to use tables ['Customer_Addresses', 'Addresses'].\n\n<3> SQL Generation: The query requires the city that has the most customers living in, so we should select the 'city' column in the 'Addresses' table and count the 'customer_id' column in the 'Customer_Addresses' table.\n\nSQL query: SELECT T1.city FROM Addresses AS T1 JOIN Customer_Addresses AS T2 ON T1.address_id = T2.address_id GROUP BY T1.city ORDER BY COUNT(T2.customer_id) DESC LIMIT 1",
        "predict": "SELECT T1.city FROM Addresses AS T1 JOIN Customer_Addresses AS T2 ON T1.address_id = T2.address_id GROUP BY T1.city ORDER BY COUNT(T2.customer_id) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the city where the most customers live.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Operation: The query requires the city where the most customers live, so we should apply the 'count' operation to the 'customer_id' column in the 'Customer_Addresses' table, and find the city with the highest count. Since the unit to which the customers being counted in the query belong is the city, we should apply the 'group by' operation to the 'city' column in the 'Addresses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Customer_Addresses' and 'Addresses', we need to use tables ['Customer_Addresses', 'Addresses'].\n\n<3> SQL Generation: The query requires the city where the most customers live, so we should select the 'city' column in the 'Addresses' table and count the 'customer_id' column in the 'Customer_Addresses' table.\n\nSQL query: SELECT T1.city FROM Addresses AS T1 JOIN Customer_Addresses AS T2 ON T1.address_id = T2.address_id GROUP BY T1.city ORDER BY COUNT(T2.customer_id) DESC LIMIT 1",
        "predict": "SELECT T1.city FROM Addresses AS T1 JOIN Customer_Addresses AS T2 ON T1.address_id = T2.address_id GROUP BY T1.city ORDER BY COUNT(T2.customer_id) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most frequently ordered product? Tell me the detail of the product",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Operation: The query requires the most frequently ordered product, so we should apply the 'count' operation to the 'product_id' column in the 'Order_Items' table, and find the product with the highest count. Since the unit to which the products being counted in the query belong is the product, we should apply the 'group by' operation to the 'product_id' column in the 'Order_Items' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Order_Items', 'Products'].\n\n<3> SQL Generation: The query requires the most frequently ordered product, so we should select the 'product_id' column in the 'Order_Items' table and the 'product_details' column in the 'Products' table.\n\nSQL query: SELECT T2.product_details FROM Order_Items AS T1 JOIN Products AS T2 ON T1.product_id = T2.product_id GROUP BY T1.product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.product_details FROM Order_Items AS T1 JOIN Products AS T2 ON T1.product_id = T2.product_id GROUP BY T1.product_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "music_4",
        "gold": "SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "What is the most common result of the music festival?",
        "fields": "Table artist, columns = [*,Artist_ID,Artist,Age,Famous_Title,Famous_Release_date]\nTable music_festival, columns = [*,ID,Music_Festival,Date_of_ceremony,Category,Volume,Result]\nTable volume, columns = [*,Volume_ID,Volume_Issue,Issue_Date,Weeks_on_Top,Song,Artist_ID]\n",
        "foreign_keys": "Foreign_keys = [volume.Artist_ID = artist.Artist_ID,music_festival.Volume = volume.Volume_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common result of the music festival, so we should apply the 'count' operation to the 'Result' column in the 'music_festival' table and find the result with the highest count. Since the unit to which the results being counted in the query belong is the music festival, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['music_festival'].\n\n<3> SQL Generation: The query requires the most common result of the music festival, so we should select the 'Result' column in the 'music_festival' table.\n\nSQL query: SELECT Result FROM music_festival GROUP BY Result ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Result FROM music_festival GROUP BY Result ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_4",
        "gold": "SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Return the result that is most frequent at music festivals.",
        "fields": "Table artist, columns = [*,Artist_ID,Artist,Age,Famous_Title,Famous_Release_date]\nTable music_festival, columns = [*,ID,Music_Festival,Date_of_ceremony,Category,Volume,Result]\nTable volume, columns = [*,Volume_ID,Volume_Issue,Issue_Date,Weeks_on_Top,Song,Artist_ID]\n",
        "foreign_keys": "Foreign_keys = [volume.Artist_ID = artist.Artist_ID,music_festival.Volume = volume.Volume_ID]\n",
        "reasoning": "<1> Operation: The query requires the result that is most frequent at music festivals, so we should apply the 'count' operation to the 'Result' column in the 'music_festival' table and find the result with the highest count. Since the unit to which the results being counted in the query belong is the music festival, we should apply the 'group by' operation to the 'Result' column in the 'music_festival' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'music_festival' and 'volume', we need to use tables ['music_festival', 'volume'].\n\n<3> SQL Generation: The query requires the result that is most frequent at music festivals, so we should select the 'Result' column in the 'music_festival' table.\n\nSQL query: SELECT Result FROM music_festival GROUP BY Result ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Result FROM music_festival GROUP BY Result ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "music_4",
        "gold": "SELECT RESULT ,  COUNT(*) FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC",
        "question": "Please show the results of music festivals and the number of music festivals that have had each, ordered by this count.",
        "fields": "Table artist, columns = [*,Artist_ID,Artist,Age,Famous_Title,Famous_Release_date]\nTable music_festival, columns = [*,ID,Music_Festival,Date_of_ceremony,Category,Volume,Result]\nTable volume, columns = [*,Volume_ID,Volume_Issue,Issue_Date,Weeks_on_Top,Song,Artist_ID]\n",
        "foreign_keys": "Foreign_keys = [volume.Artist_ID = artist.Artist_ID,music_festival.Volume = volume.Volume_ID]\n",
        "reasoning": "<1> Operation: The query requires the results of music festivals and the number of music festivals that have had each, ordered by this count. So we should apply the 'count' operation to the 'Music_Festival' column in the 'music_festival' table, and it does not need sorting. Since the unit to which the music festivals being counted in the query belong is the result and only table 'music_festival' has the column 'Result', so we should apply the 'group by' operation to the 'Result' column in table 'music_festival'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['music_festival'].\n\n<3> SQL Generation: The query requires the results of music festivals and the number of music festivals that have had each, ordered by this count. So we should select the 'Result' column in the 'music_festival' table and count the 'Music_Festival' column in the 'music_festival' table.\n\nSQL query: SELECT Result, COUNT(*) FROM music_festival GROUP BY Result ORDER BY COUNT(*) DESC",
        "predict": "SELECT Result, COUNT(*) FROM music_festival GROUP BY Result ORDER BY COUNT(*) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "music_4",
        "gold": "SELECT RESULT ,  COUNT(*) FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC",
        "question": "How many music festivals have had each kind of result, ordered descending by count?",
        "fields": "Table artist, columns = [*,Artist_ID,Artist,Age,Famous_Title,Famous_Release_date]\nTable music_festival, columns = [*,ID,Music_Festival,Date_of_ceremony,Category,Volume,Result]\nTable volume, columns = [*,Volume_ID,Volume_Issue,Issue_Date,Weeks_on_Top,Song,Artist_ID]\n",
        "foreign_keys": "Foreign_keys = [volume.Artist_ID = artist.Artist_ID,music_festival.Volume = volume.Volume_ID]\n",
        "reasoning": "<1> Operation: The query requires the number of music festivals for each kind of result, so we should apply the 'count' operation to the 'Result' column in the 'music_festival' table, and sort it in descending order. Since the unit to which the music festivals being counted in the query belong is the result, we should apply the 'group by' operation to the 'Result' column in the 'music_festival' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'music_festival' and 'volume', we need to use tables ['music_festival', 'volume'].\n\n<3> SQL Generation: The query requires the number of music festivals for each kind of result, so we should select the 'Result' column in the 'music_festival' table and count the 'ID' column in the 'music_festival' table.\n\nSQL query: SELECT Result, COUNT(ID) FROM music_festival GROUP BY Result ORDER BY COUNT(ID) DESC",
        "predict": "SELECT Result, COUNT(ID) FROM music_festival GROUP BY Result ORDER BY COUNT(ID) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "roller_coaster",
        "gold": "SELECT Status FROM roller_coaster GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Please show the most common status of roller coasters.",
        "fields": "Table country, columns = [*,Country_ID,Name,Population,Area,Languages]\nTable roller_coaster, columns = [*,Roller_Coaster_ID,Name,Park,Country_ID,Length,Height,Speed,Opened,Status]\n",
        "foreign_keys": "Foreign_keys = [roller_coaster.Country_ID = country.Country_ID]\n",
        "reasoning": "<1> Operation: The query requires the most common status of roller coasters, so we should apply the 'count' operation to the 'Status' column in the 'roller_coaster' table and find the status with the highest count. Since the unit to which the statuses being counted in the query belong is the roller coaster, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'roller_coaster'.\n\n<3> SQL Generation: The query requires the most common status of roller coasters, so we should select the 'Status' column in the 'roller_coaster' table.\n\nSQL query: SELECT Status FROM roller_coaster GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Status FROM roller_coaster GROUP BY Status ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT rank FROM captain GROUP BY rank ORDER BY count(*) DESC LIMIT 1",
        "question": "Which rank is the most common among captains?",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Operation: The query requires the rank that is the most common among captains, so we should apply the 'count' operation to the 'Rank' column in the 'captain' table, and find the rank with the highest count. Since the unit to which the ranks being counted in the query belong is the captain, we should apply the 'group by' operation to the 'Rank' column in the 'captain' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['captain'].\n\n<3> SQL Generation: The query requires the rank that is the most common among captains, so we should select the 'Rank' column in the 'captain' table.\n\nSQL query: SELECT Rank FROM captain GROUP BY Rank ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Rank FROM captain GROUP BY Rank ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT flag FROM ship GROUP BY flag ORDER BY count(*) DESC LIMIT 1",
        "question": "Which flag is most widely used among all ships?",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Operation: The query requires the flag that is most widely used among all ships, so we should apply the 'count' operation to the 'Ship' table for the 'Flag' column, and find the flag with the highest count. Since the unit to which the flags being counted in the query belong is the ship, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Ship'.\n\n<3> SQL Generation: The query requires the flag that is most widely used among all ships, so we should select the 'Flag' column in the 'Ship' table.\n\nSQL query: SELECT Flag FROM Ship GROUP BY Flag ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Flag FROM Ship GROUP BY Flag ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT flag FROM ship GROUP BY flag ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the flag that is most common among all ships.",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Operation: The query requires the flag that is most common among all ships, so we should apply the 'count' operation to the 'flag' column in the 'Ship' table and find the flag with the highest count. Since the unit to which the flags being counted in the query belong is the ship, we do not need to apply any additional operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Ship'.\n\n<3> SQL Generation: The query requires the flag that is most common among all ships, so we should select the 'flag' column in the 'Ship' table.\n\nSQL query: SELECT flag FROM Ship GROUP BY flag ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT flag FROM Ship GROUP BY flag ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT built_year FROM ship GROUP BY built_year ORDER BY count(*) DESC LIMIT 1",
        "question": "In which year were most of ships built?",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Operation: The query requires the year in which most ships were built, so we should apply the 'count' operation to the 'Ship' table for the 'Built_Year' column, and find the year with the highest count. Since the unit to which the ships being counted in the query belong is the year, we should apply the 'group by' operation to the 'Built_Year' column in the 'Ship' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'Ship'.\n\n<3> SQL Generation: The query requires the year in which most ships were built, so we should select the 'Built_Year' column in the 'Ship' table.\n\nSQL query: SELECT Built_Year FROM Ship GROUP BY Built_Year ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Built_Year FROM Ship GROUP BY Built_Year ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT built_year FROM ship GROUP BY built_year ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the year in which most ships were built?",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Operation: The query requires the year in which the most ships were built, so we should apply the 'count' operation to the 'Ship' table for the 'Built_Year' column, and find the year with the highest count. Since the unit to which the ships being counted in the query belong is the year, we should apply the 'group by' operation to the 'Built_Year' column in the 'Ship' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Ship'].\n\n<3> SQL Generation: The query requires the year in which the most ships were built, so we should select the 'Built_Year' column in the 'Ship' table.\n\nSQL query: SELECT Built_Year FROM Ship GROUP BY Built_Year ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Built_Year FROM Ship GROUP BY Built_Year ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "city_record",
        "gold": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1",
        "question": "Which city has hosted the most events?",
        "fields": "Table city, columns = [*,City_ID,City,Hanzi,Hanyu_Pinyin,Regional_Population,GDP]\nTable hosting_city, columns = [*,Year,Match_ID,Host_City]\nTable match, columns = [*,Match_ID,Date,Venue,Score,Result,Competition]\nTable temperature, columns = [*,City_ID,Jan,Feb,Mar,Apr,Jun,Jul,Aug,Sep,Oct,Nov,Dec]\n",
        "foreign_keys": "Foreign_keys = [temperature.City_ID = city.City_ID,hosting_city.Match_ID = match.Match_ID,hosting_city.Host_City = city.City_ID]\n",
        "reasoning": "<1> Operation: The query requires the city that has hosted the most events, so we should apply the 'count' operation to the 'Match_ID' column in the 'hosting_city' table, and find the city with the highest count. Since the unit to which the events being counted in the query belong is the city, we should apply the 'group by' operation to the 'Host_City' column in the 'hosting_city' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'hosting_city' and 'city', we need to use tables ['hosting_city', 'city'].\n\n<3> SQL Generation: The query requires the city that has hosted the most events, so we should select the 'City' column in the 'city' table.\n\nSQL query: SELECT T2.City FROM hosting_city AS T1 JOIN city AS T2 ON T1.Host_City = T2.City_ID GROUP BY T1.Host_City ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.City FROM hosting_city AS T1 JOIN city AS T2 ON T1.Host_City = T2.City_ID GROUP BY T1.Host_City ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "city_record",
        "gold": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the city that hosted the most events.",
        "fields": "Table city, columns = [*,City_ID,City,Hanzi,Hanyu_Pinyin,Regional_Population,GDP]\nTable hosting_city, columns = [*,Year,Match_ID,Host_City]\nTable match, columns = [*,Match_ID,Date,Venue,Score,Result,Competition]\nTable temperature, columns = [*,City_ID,Jan,Feb,Mar,Apr,Jun,Jul,Aug,Sep,Oct,Nov,Dec]\n",
        "foreign_keys": "Foreign_keys = [temperature.City_ID = city.City_ID,hosting_city.Match_ID = match.Match_ID,hosting_city.Host_City = city.City_ID]\n",
        "reasoning": "<1> Operation: The query requires the city that hosted the most events, so we should apply the 'count' operation to the 'Match_ID' column in the 'hosting_city' table, and find the city with the highest count. Since the unit to which the events being counted in the query belong is the city, we should apply the 'group by' operation to the 'Host_City' column in the 'hosting_city' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'hosting_city' and 'city', we need to use tables ['hosting_city', 'city'].\n\n<3> SQL Generation: The query requires the city that hosted the most events, so we should select the 'City' column in the 'city' table.\n\nSQL query: SELECT T2.City FROM hosting_city AS T1 JOIN city AS T2 ON T1.Host_City = T2.City_ID GROUP BY T1.Host_City ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.City FROM hosting_city AS T1 JOIN city AS T2 ON T1.Host_City = T2.City_ID GROUP BY T1.Host_City ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the most popular party form.",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the most popular party form, so we should apply the 'count' operation to the 'form_id' column in the 'Party_Forms' table, and find the form with the highest count. Since the unit to which the forms being counted in the query belong is the party, we should apply the 'group by' operation to the 'form_id' column in the 'Party_Forms' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Party_Forms', 'Forms'].\n\n<3> SQL Generation: The query requires the name of the most popular party form, so we should select the 'form_name' column in the 'Forms' table.\n\nSQL query: SELECT form_name FROM Forms WHERE form_id = (SELECT form_id FROM Party_Forms GROUP BY form_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT form_name FROM Forms WHERE form_id = (SELECT form_id FROM Party_Forms GROUP BY form_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the party form that is most common?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the party form that is most common, so we should apply the 'count' operation to the 'Party_Forms' table for the 'form_id' column, and find the form with the highest count. Since the unit to which the forms being counted in the query belong is the party, we should apply the 'group by' operation to the 'form_id' column in the 'Party_Forms' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Party_Forms'].\n\n<3> SQL Generation: The query requires the name of the party form that is most common, so we should select the 'form_name' column in the 'Forms' table and the 'form_id' column in the 'Party_Forms' table.\n\nSQL query: SELECT form_name FROM Forms WHERE form_id = (SELECT form_id FROM Party_Forms GROUP BY form_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT form_name FROM Forms WHERE form_id = (SELECT form_id FROM Party_Forms GROUP BY form_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT t1.party_email FROM parties AS t1 JOIN party_services AS t2 ON t1.party_id  =  t2.customer_id GROUP BY t1.party_email ORDER BY count(*) DESC LIMIT 1",
        "question": "Which is the email of the party that has used the services the most number of times?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Operation: The query requires the email of the party that has used the services the most number of times, so we should apply the 'count' operation to the 'Party_Services' table for the 'customer_id' column, and find the party with the highest count. Since the unit to which the services being counted in the query belong is the party, we should apply the 'group by' operation to the 'customer_id' column in the 'Party_Services' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Party_Services', 'Parties'].\n\n<3> SQL Generation: The query requires the email of the party that has used the services the most number of times, so we should select the 'party_email' column in the 'Parties' table and the 'customer_id' column in the 'Party_Services' table.\n\nSQL query: SELECT party_email FROM Parties WHERE party_id = (SELECT customer_id FROM Party_Services GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT party_email FROM Parties WHERE party_id = (SELECT customer_id FROM Party_Services GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT t1.party_email FROM parties AS t1 JOIN party_services AS t2 ON t1.party_id  =  t2.customer_id GROUP BY t1.party_email ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the party email that has used party services the greatest number of times.",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Operation: The query requires the party email that has used party services the greatest number of times, so we should apply the 'count' operation to the 'Party_Services' table for the 'customer_id' column, and find the party with the highest count. Since the unit to which the party services being counted in the query belong is the party, we should apply the 'group by' operation to the 'customer_id' column in the 'Party_Services' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Party_Services' and 'Parties', we need to use tables ['Party_Services', 'Parties'].\n\n<3> SQL Generation: The query requires the party email that has used party services the greatest number of times, so we should select the 'party_email' column in the 'Parties' table and the 'customer_id' column in the 'Party_Services' table.\n\nSQL query: SELECT party_email FROM Parties WHERE party_id = (SELECT customer_id FROM Party_Services GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT party_email FROM Parties WHERE party_id = (SELECT customer_id FROM Party_Services GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT t1.organization_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id GROUP BY t1.organization_name ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of organization that has the greatest number of contact individuals?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the organization that has the greatest number of contact individuals, so we should apply the 'count' operation to the 'Organization_Contact_Individuals' table for the 'organization_id' column, and find the organization with the highest count. Since the unit to which the contact individuals being counted in the query belong is the organization, we should apply the 'group by' operation to the 'organization_id' column in the 'Organization_Contact_Individuals' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Organizations', 'Organization_Contact_Individuals'].\n\n<3> SQL Generation: The query requires the name of the organization that has the greatest number of contact individuals, so we should select the 'organization_name' column in the 'Organizations' table and the 'organization_id' column in the 'Organization_Contact_Individuals' table.\n\nSQL query: SELECT organization_name FROM Organizations WHERE organization_id = (SELECT organization_id FROM Organization_Contact_Individuals GROUP BY organization_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT organization_name FROM Organizations WHERE organization_id = (SELECT organization_id FROM Organization_Contact_Individuals GROUP BY organization_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT t1.organization_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id GROUP BY t1.organization_name ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the name of the organization which has the most contact individuals.",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the organization which has the most contact individuals, so we should apply the 'count' operation to the 'Organization_Contact_Individuals' table for the 'organization_id' column, and find the organization with the highest count. Since the unit to which the contact individuals being counted in the query belong is the organization, we should apply the 'group by' operation to the 'organization_id' column in the 'Organization_Contact_Individuals' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Organizations'].\n\n<3> SQL Generation: The query requires the name of the organization which has the most contact individuals, so we should select the 'organization_name' column in the 'Organizations' table.\n\nSQL query: SELECT organization_name FROM Organizations WHERE organization_id = (SELECT organization_id FROM Organization_Contact_Individuals GROUP BY organization_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT organization_name FROM Organizations WHERE organization_id = (SELECT organization_id FROM Organization_Contact_Individuals GROUP BY organization_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "school_bus",
        "gold": "SELECT home_city FROM driver GROUP BY home_city ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the home city with the most number of drivers.",
        "fields": "Table driver, columns = [*,Driver_ID,Name,Party,Home_city,Age]\nTable school, columns = [*,School_ID,Grade,School,Location,Type]\nTable school_bus, columns = [*,School_ID,Driver_ID,Years_Working,If_full_time]\n",
        "foreign_keys": "Foreign_keys = [school_bus.Driver_ID = driver.Driver_ID,school_bus.School_ID = school.School_ID]\n",
        "reasoning": "<1> Operation: The query requires the home city with the most number of drivers, so we should apply the 'count' operation to the 'Driver_ID' column in the 'driver' table and sort it in descending order. Since the unit to which the drivers being counted in the query belong is the home city and only table 'driver' has the column 'Home_city', so we should apply the 'group by' operation to the 'Home_city' column in the 'driver' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['driver'].\n\n<3> SQL Generation: The query requires the home city with the most number of drivers, so we should select the 'Home_city' column in the 'driver' table.\n\nSQL query: SELECT Home_city FROM driver GROUP BY Home_city ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Home_city FROM driver GROUP BY Home_city ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "flight_company",
        "gold": "SELECT TYPE ,  count(*) FROM operate_company GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most common company type, and how many are there?",
        "fields": "Table airport, columns = [*,id,City,Country,IATA,ICAO,name]\nTable flight, columns = [*,id,Vehicle_Flight_number,Date,Pilot,Velocity,Altitude,airport_id,company_id]\nTable operate_company, columns = [*,id,name,Type,Principal_activities,Incorporated_in,Group_Equity_Shareholding]\n",
        "foreign_keys": "Foreign_keys = [flight.company_id = operate_company.id,flight.airport_id = airport.id]\n",
        "reasoning": "<1> Operation: The query requires the most common company type, so we should apply the 'count' operation to the 'Type' column in the 'operate_company' table and find the company type with the highest count. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'operate_company'.\n\n<3> SQL Generation: The query requires the most common company type, so we should select the 'Type' column in the 'operate_company' table and count the occurrences of each type.\n\nSQL query: SELECT Type, COUNT(*) FROM operate_company GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Type, COUNT(*) FROM operate_company GROUP BY Type ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "flight_company",
        "gold": "SELECT pilot FROM flight GROUP BY pilot ORDER BY count(*) DESC LIMIT 1",
        "question": "which pilot is in charge of the most number of flights?",
        "fields": "Table airport, columns = [*,id,City,Country,IATA,ICAO,name]\nTable flight, columns = [*,id,Vehicle_Flight_number,Date,Pilot,Velocity,Altitude,airport_id,company_id]\nTable operate_company, columns = [*,id,name,Type,Principal_activities,Incorporated_in,Group_Equity_Shareholding]\n",
        "foreign_keys": "Foreign_keys = [flight.company_id = operate_company.id,flight.airport_id = airport.id]\n",
        "reasoning": "<1> Operation: The query requires the pilot who is in charge of the most number of flights, so we should apply the 'count' operation to the 'Pilot' column in the 'flight' table and find the pilot with the highest count. Since the unit to which the flights being counted in the query belong is the pilot, we should apply the 'group by' operation to the 'Pilot' column in the 'flight' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['flight'].\n\n<3> SQL Generation: The query requires the pilot who is in charge of the most number of flights, so we should select the 'Pilot' column in the 'flight' table.\n\nSQL query: SELECT Pilot FROM flight GROUP BY Pilot ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Pilot FROM flight GROUP BY Pilot ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "gold": "SELECT T1.statement_id ,  T2.statement_details FROM Accounts AS T1 JOIN Statements AS T2 ON T1.statement_id  =  T2.statement_id GROUP BY T1.statement_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the statement id and the statement detail for the statement with most number of accounts.",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n",
        "reasoning": "<1> Operation: The query requires the statement ID and statement detail for the statement with the most number of accounts, so we should apply the 'count' operation to the 'Accounts' table for the 'Statement_ID' column, and find the statement with the highest count. Since the unit to which the accounts being counted in the query belong is the statement, we should apply the 'group by' operation to the 'Statement_ID' column in the 'Accounts' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Accounts' and 'Statements', we need to use tables ['Accounts', 'Statements'].\n\n<3> SQL Generation: The query requires the statement ID and statement detail for the statement with the most number of accounts, so we should select the 'Statement_ID' column in the 'Statements' table and the 'Statement_Details' column in the 'Statements' table.\n\nSQL query: SELECT Statement_ID, Statement_Details FROM Statements WHERE Statement_ID = (SELECT Statement_ID FROM Accounts GROUP BY Statement_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Statement_ID, Statement_Details FROM Statements WHERE Statement_ID = (SELECT Statement_ID FROM Accounts GROUP BY Statement_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "gold": "SELECT T1.statement_id ,  T2.statement_details FROM Accounts AS T1 JOIN Statements AS T2 ON T1.statement_id  =  T2.statement_id GROUP BY T1.statement_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the statement id and statement detail for the statement that has the most corresponding accounts?",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n",
        "reasoning": "<1> Operation: The query requires the statement ID and statement detail for the statement that has the most corresponding accounts, so we should apply the 'count' operation to the 'Accounts' table for the 'Statement_ID' column, and find the statement with the highest count. Since the unit to which the accounts being counted in the query belong is the statement, we should apply the 'group by' operation to the 'Statement_ID' column in the 'Accounts' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Accounts' and 'Statements', we need to use tables ['Accounts', 'Statements'].\n\n<3> SQL Generation: The query requires the statement ID and statement detail for the statement that has the most corresponding accounts, so we should select the 'Statement_ID' column and 'Statement_Details' column in the 'Statements' table.\n\nSQL query: SELECT Statement_ID, Statement_Details FROM Statements WHERE Statement_ID = (SELECT Statement_ID FROM Accounts GROUP BY Statement_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Statement_ID, Statement_Details FROM Statements WHERE Statement_ID = (SELECT Statement_ID FROM Accounts GROUP BY Statement_ID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "gold": "SELECT project_id FROM Documents GROUP BY project_id ORDER BY count(*) ASC LIMIT 1",
        "question": "Return the id of the project that has the fewest corresponding documents.",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n",
        "reasoning": "<1> Operation: The query requires the id of the project that has the fewest corresponding documents, so we should apply the 'count' operation to the 'Documents' table for the 'Project_ID' column, and find the project with the lowest count. Since the unit to which the documents being counted in the query belong is the project, we should apply the 'group by' operation to the 'Project_ID' column in the 'Documents' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Projects', 'Documents'].\n\n<3> SQL Generation: The query requires the id of the project that has the fewest corresponding documents, so we should select the 'Project_ID' column in the 'Projects' table and the count of the 'Document_ID' column in the 'Documents' table.\n\nSQL query: SELECT Project_ID FROM Documents GROUP BY Project_ID ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Project_ID FROM Documents GROUP BY Project_ID ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "gold": "SELECT document_type_code FROM Documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the document type code with most number of documents?",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n",
        "reasoning": "<1> Operation: The query requires the document type code with the most number of documents, so we should apply the 'count' operation to the 'Document_Type_Code' column in the 'Documents' table, and find the document type code with the highest count. Since the unit to which the document types being counted in the query belong is the document, we should apply the 'group by' operation to the 'Document_Type_Code' column in the 'Documents' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Documents'].\n\n<3> SQL Generation: The query requires the document type code with the most number of documents, so we should select the 'Document_Type_Code' column in the 'Documents' table.\n\nSQL query: SELECT Document_Type_Code FROM Documents GROUP BY Document_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Document_Type_Code FROM Documents GROUP BY Document_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "gold": "SELECT document_type_code FROM Documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the code of the document type that is most common.",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n",
        "reasoning": "<1> Operation: The query requires the code of the document type that is most common, so we should apply the 'count' operation to the 'Document_Type_Code' column in the 'Documents' table and find the document type code with the highest count. Since the unit to which the document types being counted in the query belong is the document, we should apply the 'group by' operation to the 'Document_Type_Code' column in the 'Documents' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Documents'].\n\n<3> SQL Generation: The query requires the code of the document type that is most common, so we should select the 'Document_Type_Code' column in the 'Documents' table.\n\nSQL query: SELECT Document_Type_Code FROM Documents GROUP BY Document_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Document_Type_Code FROM Documents GROUP BY Document_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "gold": "SELECT budget_type_code FROM Documents_with_expenses GROUP BY budget_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the budget type code with most number of documents.",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n",
        "reasoning": "<1> Operation: The query requires the budget type code with the most number of documents, so we should apply the 'count' operation to the 'Budget_Type_Code' column in the 'Documents_with_Expenses' table, and find the budget type code with the highest count. Since the unit to which the documents being counted in the query belong is the budget type code, we should apply the 'group by' operation to the 'Budget_Type_Code' column in the 'Documents_with_Expenses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Documents_with_Expenses'].\n\n<3> SQL Generation: The query requires the budget type code with the most number of documents, so we should select the 'Budget_Type_Code' column in the 'Documents_with_Expenses' table.\n\nSQL query: SELECT Budget_Type_Code FROM Documents_with_Expenses GROUP BY Budget_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Budget_Type_Code FROM Documents_with_Expenses GROUP BY Budget_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "gold": "SELECT budget_type_code FROM Documents_with_expenses GROUP BY budget_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Give the budget type code that is most common among documents with expenses.",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n",
        "reasoning": "<1> Operation: The query requires the budget type code that is most common among documents with expenses, so we should apply the 'count' operation to the 'Budget_Type_Code' column in the 'Documents_with_Expenses' table, and find the budget type code with the highest count. Since the unit to which the budget type codes being counted in the query belong is the document, we should apply the 'group by' operation to the 'Budget_Type_Code' column in the 'Documents_with_Expenses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Documents_with_Expenses'].\n\n<3> SQL Generation: The query requires the budget type code that is most common among documents with expenses, so we should select the 'Budget_Type_Code' column in the 'Documents_with_Expenses' table.\n\nSQL query: SELECT Budget_Type_Code FROM Documents_with_Expenses GROUP BY Budget_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Budget_Type_Code FROM Documents_with_Expenses GROUP BY Budget_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT T1.name ,  T1.hours FROM projects AS T1 JOIN assignedto AS T2 ON T1.code  =  T2.project GROUP BY T2.project ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name and hours of project that has the most number of scientists.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Operation: The query requires the name and hours of the project that has the most number of scientists, so we should apply the 'count' operation to the 'Scientist' column in the 'AssignedTo' table, and find the project with the highest count. Since the unit to which the scientists being counted in the query belong is the project, we should apply the 'group by' operation to the 'Project' column in the 'AssignedTo' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'AssignedTo' and 'Projects', we need to use tables ['AssignedTo', 'Projects'].\n\n<3> SQL Generation: The query requires the name and hours of the project that has the most number of scientists, so we should select the 'Name' column in the 'Projects' table and the 'Hours' column in the 'Projects' table.\n\nSQL query: SELECT T2.Name, T2.Hours FROM AssignedTo AS T1 JOIN Projects AS T2 ON T1.Project = T2.Code GROUP BY T1.Project ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.Name, T2.Hours FROM AssignedTo AS T1 JOIN Projects AS T2 ON T1.Project = T2.Code GROUP BY T1.Project ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT T1.name ,  T1.hours FROM projects AS T1 JOIN assignedto AS T2 ON T1.code  =  T2.project GROUP BY T2.project ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name and hours for the project which has the most scientists assigned to it?",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Operation: The query requires the name and hours for the project which has the most scientists assigned to it, so we should apply the 'count' operation to the 'Scientist' column in the 'AssignedTo' table, and find the project with the highest count. Since the unit to which the scientists being counted in the query belong is the project, we should apply the 'group by' operation to the 'Project' column in the 'AssignedTo' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'AssignedTo' and 'Projects', we need to use tables ['AssignedTo', 'Projects'].\n\n<3> SQL Generation: The query requires the name and hours for the project which has the most scientists assigned to it, so we should select the 'Name' column in the 'Projects' table and the 'Hours' column in the 'Projects' table.\n\nSQL query: SELECT T1.Name, T1.Hours FROM Projects AS T1 JOIN AssignedTo AS T2 ON T1.Code = T2.Project GROUP BY T2.Project ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T1.Name, T1.Hours FROM Projects AS T1 JOIN AssignedTo AS T2 ON T1.Code = T2.Project GROUP BY T2.Project ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT T1.Area FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING T2.year  <  2010 ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the area of the appelation that produces the highest number of wines before the year of 2010?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Operation: The query requires the area of the appellation that produces the highest number of wines before the year 2010, so we should apply the 'count' operation to the 'No' column in the 'wine' table, and find the appellation with the highest count. Since the unit to which the wines being counted in the query belong is the appellation, we should apply the 'group by' operation to the 'Appelation' column in the 'wine' table. We also need to filter the wines before the year 2010.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'wine' and 'appellations', we need to use tables ['wine', 'appellations'].\n\n<3> SQL Generation: The query requires the area of the appellation that produces the highest number of wines before the year 2010, so we should select the 'Area' column in the 'appellations' table. The query does not require the count of wines, so it is only used for filtering and not selected.\n\nSQL query: SELECT Area FROM appellations AS T1 JOIN wine AS T2 ON T1.Appelation = T2.Appelation WHERE T2.Year < 2010 GROUP BY T2.Appelation ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Area FROM appellations AS T1 JOIN wine AS T2 ON T1.Appelation = T2.Appelation WHERE T2.Year < 2010 GROUP BY T2.Appelation ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT T1.Area FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING T2.year  <  2010 ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the area for the appelation which produced the most wines prior to 2010?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Operation: The query requires the area for the appellation which produced the most wines prior to 2010, so we should apply the 'count' operation to the 'wine' table for the 'Appelation' column, and find the appellation with the highest count. We also need to filter the wines that were produced prior to 2010.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'wine' and 'appellations', we need to use tables ['wine', 'appellations'].\n\n<3> SQL Generation: The query requires the area for the appellation which produced the most wines prior to 2010, so we should select the 'Area' column in the 'appellations' table. We also need to filter the wines that were produced prior to 2010 in the 'wine' table.\n\nSQL query: SELECT Area FROM appellations WHERE Appelation = (SELECT Appelation FROM wine WHERE Year < 2010 GROUP BY Appelation ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Area FROM appellations WHERE Appelation = (SELECT Appelation FROM wine WHERE Year < 2010 GROUP BY Appelation ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1",
        "question": "What is the color of the grape whose wine products has the highest average price?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Operation: The query requires the color of the grape whose wine products have the highest average price, so we should apply the 'average' operation to the 'Price' column in the 'wine' table and find the grape with the highest average price. Since the unit to which the average price being calculated in the query belongs is the grape, we should apply the 'group by' operation to the 'Grape' column in the 'wine' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'wine' and 'grapes', we need to use tables ['wine', 'grapes'].\n\n<3> SQL Generation: The query requires the color of the grape whose wine products have the highest average price, so we should select the 'Color' column in the 'grapes' table. The query does not require the average price, so it is only used for filtering and not selected.\n\nSQL query: SELECT Color FROM grapes WHERE Grape = (SELECT Grape FROM wine GROUP BY Grape ORDER BY AVG(Price) DESC LIMIT 1)",
        "predict": "SELECT Color FROM grapes WHERE Grape = (SELECT Grape FROM wine GROUP BY Grape ORDER BY AVG(Price) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1",
        "question": "Give the color of the grape whose wine products have the highest average price?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Operation: The query requires the color of the grape whose wine products have the highest average price, so we should apply the 'average' operation to the 'Price' column in the 'wine' table and sort it in descending order. Since the unit to which the average price being calculated in the query belongs is the grape, we should apply the 'group by' operation to the 'Grape' column in the 'wine' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'wine' and 'grapes', we need to use tables ['wine', 'grapes'].\n\n<3> SQL Generation: The query requires the color of the grape whose wine products have the highest average price, so we should select the 'Color' column in the 'grapes' table. The query does not require the average price, so it is only used for filtering and not selected.\n\nSQL query: SELECT Color FROM grapes WHERE Grape = (SELECT Grape FROM wine GROUP BY Grape ORDER BY AVG(Price) DESC LIMIT 1)",
        "predict": "SELECT Color FROM grapes WHERE Grape = (SELECT Grape FROM wine GROUP BY Grape ORDER BY AVG(Price) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  \"White\" GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3",
        "question": "Which 3 wineries produce the most wines made from white grapes?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Operation: The query requires the 3 wineries that produce the most wines made from white grapes, so we should apply the 'count' operation to the 'Winery' column in the 'wine' table for the wines made from white grapes, and find the wineries with the highest count. Since the unit to which the wines being counted in the query belong is the winery, we should apply the 'group by' operation to the 'Winery' column in the 'wine' table. We also need to filter the wines made from white grapes in the 'grapes' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'wine' and 'grapes', we need to use tables ['wine', 'grapes'].\n\n<3> SQL Generation: The query requires the 3 wineries that produce the most wines made from white grapes, so we should select the 'Winery' column in the 'wine' table and count the wines made from white grapes in the 'grapes' table.\n\nSQL query: SELECT Winery FROM wine WHERE Grape IN (SELECT Grape FROM grapes WHERE Color = 'white') GROUP BY Winery ORDER BY COUNT(*) DESC LIMIT 3",
        "predict": "SELECT Winery FROM wine WHERE Grape IN (SELECT Grape FROM grapes WHERE Color = 'white') GROUP BY Winery ORDER BY COUNT(*) DESC LIMIT 3",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the county where produces the most number of wines with score higher than 90.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Operation: The query requires the county that produces the most number of wines with a score higher than 90, so we should apply the 'count' operation to the 'No' column in the 'wine' table for the wines with a score higher than 90, and find the county with the highest count. Since the unit to which the wines being counted in the query belong is the county, we should apply the 'group by' operation to the 'County' column in the 'appellations' table. We also need to filter the wines with a score higher than 90 in the 'wine' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'wine' and 'appellations', we need to use tables ['wine', 'appellations'].\n\n<3> SQL Generation: The query requires the county that produces the most number of wines with a score higher than 90, so we should select the 'County' column in the 'appellations' table and count the 'No' column in the 'wine' table for the wines with a score higher than 90.\n\nSQL query: SELECT County FROM appellations AS T1 JOIN wine AS T2 ON T1.Appelation = T2.Appelation WHERE T2.Score > 90 GROUP BY T1.County ORDER BY COUNT(T2.No) DESC LIMIT 1",
        "predict": "SELECT County FROM appellations AS T1 JOIN wine AS T2 ON T1.Appelation = T2.Appelation WHERE T2.Score > 90 GROUP BY T1.County ORDER BY COUNT(T2.No) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the county that produces the most wines scoring higher than 90?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Operation: The query requires the county that produces the most wines scoring higher than 90, so we should apply the 'count' operation to the 'wine' table for the 'No' column, and find the county with the highest count. We also need to filter the wines with a score higher than 90.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'wine' and 'appellations', we need to use tables ['wine', 'appellations'].\n\n<3> SQL Generation: The query requires the county that produces the most wines scoring higher than 90, so we should select the 'County' column in the 'appellations' table. We also need to filter the wines with a score higher than 90 in the 'wine' table.\n\nSQL query: SELECT T2.County FROM wine AS T1 JOIN appellations AS T2 ON T1.Appelation = T2.Appelation WHERE T1.Score > 90 GROUP BY T2.County ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.County FROM wine AS T1 JOIN appellations AS T2 ON T1.Appelation = T2.Appelation WHERE T1.Score > 90 GROUP BY T2.County ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "train_station",
        "gold": "SELECT LOCATION FROM station GROUP BY LOCATION ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the location with most number of train stations.",
        "fields": "Table station, columns = [*,Station_ID,Name,Annual_entry_exit,Annual_interchanges,Total_Passengers,Location,Main_Services,Number_of_Platforms]\nTable train, columns = [*,Train_ID,Name,Time,Service]\nTable train_station, columns = [*,Train_ID,Station_ID]\n",
        "foreign_keys": "Foreign_keys = [train_station.Station_ID = station.Station_ID,train_station.Train_ID = train.Train_ID]\n",
        "reasoning": "<1> Operation: The query requires the location with the most number of train stations, so we should apply the 'count' operation to the 'Station_ID' column in the 'train_station' table, and find the location with the highest count. Since the unit to which the train stations being counted in the query belong is the location, we should apply the 'group by' operation to the 'Location' column in the 'station' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['station'].\n\n<3> SQL Generation: The query requires the location with the most number of train stations, so we should select the 'Location' column in the 'station' table.\n\nSQL query: SELECT Location FROM station GROUP BY Location ORDER BY COUNT(Station_ID) DESC LIMIT 1",
        "predict": "SELECT Location FROM station GROUP BY Location ORDER BY COUNT(Station_ID) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "train_station",
        "gold": "SELECT T2.name FROM train_station AS T1 JOIN station AS T2 ON T1.station_id  =  T2.station_id GROUP BY T1.station_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Show the station name with greatest number of trains.",
        "fields": "Table station, columns = [*,Station_ID,Name,Annual_entry_exit,Annual_interchanges,Total_Passengers,Location,Main_Services,Number_of_Platforms]\nTable train, columns = [*,Train_ID,Name,Time,Service]\nTable train_station, columns = [*,Train_ID,Station_ID]\n",
        "foreign_keys": "Foreign_keys = [train_station.Station_ID = station.Station_ID,train_station.Train_ID = train.Train_ID]\n",
        "reasoning": "<1> Operation: The query requires the station name with the greatest number of trains, so we should apply the 'count' operation to the 'Train_ID' column in the 'train_station' table, and sort it in descending order. Since the unit to which the trains being counted in the query belong is the station, we should apply the 'group by' operation to the 'Station_ID' column in the 'train_station' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'train_station' and 'station', we need to use tables ['train_station', 'station'].\n\n<3> SQL Generation: The query requires the station name with the greatest number of trains, so we should select the 'Name' column in the 'station' table. The query does not require the count of most trains, so it is only used for filtering and not selected.\n\nSQL query: SELECT T2.Name FROM train_station AS T1 JOIN station AS T2 ON T1.Station_ID = T2.Station_ID GROUP BY T1.Station_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.Name FROM train_station AS T1 JOIN station AS T2 ON T1.Station_ID = T2.Station_ID GROUP BY T1.Station_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT 1;",
        "question": "Which city lives most of staffs? List the city name and number of staffs.",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Operation: The query requires the city where most of the staff live, so we should apply the 'count' operation to the 'Staff' table for the 'staff_id' column, and find the city with the highest count. Since the unit to which the staff members being counted in the query belong is the city, we should apply the 'group by' operation to the 'city' column in the 'Addresses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Staff' and 'Addresses', we need to use tables ['Staff', 'Addresses'].\n\n<3> SQL Generation: The query requires the city where most of the staff live, so we should select the 'city' column in the 'Addresses' table and the count of the 'staff_id' column in the 'Staff' table.\n\nSQL query: SELECT city, COUNT(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT city, COUNT(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT 1;",
        "question": "In which city do the most employees live and how many of them live there?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Operation: The query requires the city where the most employees live and the number of employees living there, so we should apply the 'count' operation to the 'staff_id' column in the 'Staff' table and find the city with the highest count. Since the unit to which the employees being counted in the query belong is the city, we should apply the 'group by' operation to the 'city' column in the 'Addresses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Staff' and 'Addresses', we need to use tables ['Staff', 'Addresses'].\n\n<3> SQL Generation: The query requires the city where the most employees live and the number of employees living there, so we should select the 'city' column in the 'Addresses' table and count the 'staff_id' column in the 'Staff' table.\n\nSQL query: SELECT city, COUNT(*) FROM Addresses JOIN Staff ON Addresses.address_id = Staff.staff_address_id GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT city, COUNT(*) FROM Addresses JOIN Staff ON Addresses.address_id = Staff.staff_address_id GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY count(*) ASC LIMIT 1;",
        "question": "Which customer status code has least number of customers?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Operation: The query requires the customer status code with the least number of customers, so we should apply the 'count' operation to the 'Customers' table for the 'customer_status_code' column, and find the customer status code with the lowest count. Since the unit to which the customer status codes being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_status_code' column in the 'Customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers'].\n\n<3> SQL Generation: The query requires the customer status code with the least number of customers, so we should select the 'customer_status_code' column in the 'Customers' table.\n\nSQL query: SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY count(*) ASC LIMIT 1;",
        "question": "What is the status code with the least number of customers?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Operation: The query requires the status code with the least number of customers, so we should apply the 'count' operation to the 'Customers' table for the 'customer_status_code' column, and find the status code with the lowest count. Since the unit to which the status codes being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_status_code' column in the 'Customers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers'].\n\n<3> SQL Generation: The query requires the status code with the least number of customers, so we should select the 'customer_status_code' column in the 'Customers' table.\n\nSQL query: SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;",
        "question": "Which city does has most number of customers?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Operation: The query requires the city that has the most number of customers, so we should apply the 'count' operation to the 'customer_id' column in the 'Customers' table and find the city with the highest count. Since the unit to which the customers being counted in the query belong is the city, we should apply the 'group by' operation to the 'city' column in the 'Addresses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Customers' and 'Addresses', we need to use tables ['Customers', 'Addresses'].\n\n<3> SQL Generation: The query requires the city that has the most number of customers, so we should select the 'city' column in the 'Addresses' table and the count of the 'customer_id' column in the 'Customers' table.\n\nSQL query: SELECT city FROM Addresses JOIN Customers ON Addresses.address_id = Customers.customer_address_id GROUP BY city ORDER BY COUNT(Customers.customer_id) DESC LIMIT 1",
        "predict": "SELECT city FROM Addresses JOIN Customers ON Addresses.address_id = Customers.customer_address_id GROUP BY city ORDER BY COUNT(Customers.customer_id) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;",
        "question": "What is the city with the most customers?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Operation: The query requires the city with the most customers, so we should apply the 'count' operation to the 'Customers' table for the 'customer_id' column, and find the city with the highest count. Since the unit to which the customers being counted in the query belong is the city, we should apply the 'group by' operation to the 'city' column in the 'Addresses' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Customers' and 'Addresses', we need to use tables ['Customers', 'Addresses'].\n\n<3> SQL Generation: The query requires the city with the most customers, so we should select the 'city' column in the 'Addresses' table and count the 'customer_id' column in the 'Customers' table.\n\nSQL query: SELECT city FROM Addresses JOIN Customers ON Addresses.address_id = Customers.customer_address_id GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT city FROM Addresses JOIN Customers ON Addresses.address_id = Customers.customer_address_id GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id and detail of the vehicle used in lessons for most of the times?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Operation: The query requires the id and detail of the vehicle used in lessons for the most number of times, so we should apply the 'count' operation to the 'vehicle_id' column in the 'Lessons' table, and find the vehicle with the highest count. Since the unit to which the vehicles being counted in the query belong is the vehicle, we should apply the 'group by' operation to the 'vehicle_id' column in the 'Lessons' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Vehicles'].\n\n<3> SQL Generation: The query requires the id and detail of the vehicle used in lessons for the most number of times, so we should select the 'vehicle_id' column and the 'vehicle_details' column in the 'Vehicles' table.\n\nSQL query: SELECT vehicle_id, vehicle_details FROM Vehicles WHERE vehicle_id = (SELECT vehicle_id FROM Lessons GROUP BY vehicle_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT vehicle_id, vehicle_details FROM Vehicles WHERE vehicle_id = (SELECT vehicle_id FROM Lessons GROUP BY vehicle_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1",
        "question": "Which building has most faculty members?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the building that has the most faculty members, so we should apply the 'count' operation to the 'FacID' column in the 'Faculty_Participates_in' table, and find the building with the highest count. Since the unit to which the faculty members being counted in the query belong is the building, we should apply the 'group by' operation to the 'Building' column in the 'Faculty' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Faculty', 'Faculty_Participates_in'].\n\n<3> SQL Generation: The query requires the building that has the most faculty members, so we should select the 'Building' column in the 'Faculty' table and the count of the 'FacID' column in the 'Faculty_Participates_in' table.\n\nSQL query: SELECT Building FROM Faculty GROUP BY Building ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Building FROM Faculty GROUP BY Building ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the building that has the largest number of faculty members.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the building that has the largest number of faculty members, so we should apply the 'count' operation to the 'FacID' column in the 'Faculty_Participates_in' table, and find the building with the highest count. Since the unit to which the faculty members being counted in the query belong is the building, we should apply the 'group by' operation to the 'Building' column in the 'Faculty' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Faculty_Participates_in' and 'Faculty', we need to use tables ['Faculty_Participates_in', 'Faculty'].\n\n<3> SQL Generation: The query requires the building that has the largest number of faculty members, so we should select the 'Building' column in the 'Faculty' table and count the 'FacID' column in the 'Faculty_Participates_in' table.\n\nSQL query: SELECT Building FROM Faculty GROUP BY Building ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT Building FROM Faculty GROUP BY Building ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT rank FROM Faculty GROUP BY rank ORDER BY count(*) ASC LIMIT 1",
        "question": "Which rank has the smallest number of faculty members?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the rank with the smallest number of faculty members, so we should apply the 'count' operation to the 'FacID' column in the 'Faculty_Participates_in' table, and find the rank with the lowest count. Since the unit to which the faculty members being counted in the query belong is the rank, we should apply the 'group by' operation to the 'Rank' column in the 'Faculty' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Faculty', 'Faculty_Participates_in'].\n\n<3> SQL Generation: The query requires the rank with the smallest number of faculty members, so we should select the 'Rank' column in the 'Faculty' table and the count of the 'FacID' column in the 'Faculty_Participates_in' table.\n\nSQL query: SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT rank FROM Faculty GROUP BY rank ORDER BY count(*) ASC LIMIT 1",
        "question": "Find the faculty rank that has the least members.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the faculty rank that has the least members, so we should apply the 'count' operation to the 'FacID' column in the 'Faculty_Participates_in' table, and find the rank with the lowest count. Since the unit to which the faculty members being counted in the query belong is the rank, we should apply the 'group by' operation to the 'Rank' column in the 'Faculty' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Faculty_Participates_in' and 'Faculty', we need to use tables ['Faculty', 'Faculty_Participates_in'].\n\n<3> SQL Generation: The query requires the faculty rank that has the least members, so we should select the 'Rank' column in the 'Faculty' table and count the 'FacID' column in the 'Faculty_Participates_in' table.\n\nSQL query: SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1",
        "predict": "SELECT Rank FROM Faculty GROUP BY Rank ORDER BY COUNT(*) ASC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT  T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the first and last name of the faculty participating in the most activities?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the first and last name of the faculty participating in the most activities, so we should apply the 'count' operation to the 'Faculty_Participates_in' table for the 'FacID' column, and find the faculty member with the highest count. Since the unit to which the activities being counted in the query belong is the faculty member, we should apply the 'group by' operation to the 'FacID' column in the 'Faculty_Participates_in' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Faculty'].\n\n<3> SQL Generation: The query requires the first and last name of the faculty participating in the most activities, so we should select the 'Fname' and 'Lname' columns in the 'Faculty' table.\n\nSQL query: SELECT Fname, Lname FROM Faculty WHERE FacID = (SELECT FacID FROM Faculty_Participates_in GROUP BY FacID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Fname, Lname FROM Faculty WHERE FacID = (SELECT FacID FROM Faculty_Participates_in GROUP BY FacID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT  T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the first and last name of the faculty who is involved in the largest number of activities.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the first and last name of the faculty who is involved in the largest number of activities, so we should apply the 'count' operation to the 'actid' column in the 'Faculty_Participates_in' table, and find the faculty with the highest count. Since the unit to which the activities being counted in the query belong is the faculty, we should apply the 'group by' operation to the 'FacID' column in the 'Faculty_Participates_in' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Faculty'].\n\n<3> SQL Generation: The query requires the first and last name of the faculty who is involved in the largest number of activities, so we should select the 'Fname' and 'Lname' columns in the 'Faculty' table.\n\nSQL query: SELECT Fname, Lname FROM Faculty WHERE FacID = (SELECT FacID FROM Faculty_Participates_in GROUP BY FacID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Fname, Lname FROM Faculty WHERE FacID = (SELECT FacID FROM Faculty_Participates_in GROUP BY FacID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT T1.activity_name FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the activity that has the most faculty members involved in?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the name of the activity that has the most faculty members involved in, so we should apply the 'count' operation to the 'Faculty_Participates_in' table for the 'actid' column, and find the activity with the highest count. Since the unit to which the faculty members being counted in the query belong is the activity, we should apply the 'group by' operation to the 'actid' column in the 'Faculty_Participates_in' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Activity'].\n\n<3> SQL Generation: The query requires the name of the activity that has the most faculty members involved in, so we should select the 'activity_name' column in the 'Activity' table.\n\nSQL query: SELECT activity_name FROM Activity WHERE actid = (SELECT actid FROM Faculty_Participates_in GROUP BY actid ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT activity_name FROM Activity WHERE actid = (SELECT actid FROM Faculty_Participates_in GROUP BY actid ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT T1.activity_name FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID ORDER BY count(*) DESC LIMIT 1",
        "question": "Which activity has the most faculty members participating in? Find the activity name.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the activity with the most faculty members participating in, so we should apply the 'count' operation to the 'Faculty_Participates_in' table for the 'actid' column, and find the activity with the highest count. Since the unit to which the faculty members being counted in the query belong is the activity, we should apply the 'group by' operation to the 'actid' column in the 'Faculty_Participates_in' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'Faculty_Participates_in' and 'Activity', we need to use tables ['Faculty_Participates_in', 'Activity'].\n\n<3> SQL Generation: The query requires the activity with the most faculty members participating in, so we should select the 'activity_name' column in the 'Activity' table.\n\nSQL query: SELECT activity_name FROM Activity WHERE actid = (SELECT actid FROM Faculty_Participates_in GROUP BY actid ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT activity_name FROM Activity WHERE actid = (SELECT actid FROM Faculty_Participates_in GROUP BY actid ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT T1.fname ,  T1.lname FROM Student AS T1 JOIN Participates_in AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the first and last name of the student participating in the most activities?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the first and last name of the student participating in the most activities, so we should apply the 'count' operation to the 'Participates_in' table for the 'stuid' column, and find the student with the highest count. Since the unit to which the activities being counted in the query belong is the student, we should apply the 'group by' operation to the 'stuid' column in the 'Participates_in' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Student'] and ['Participates_in'].\n\n<3> SQL Generation: The query requires the first and last name of the student participating in the most activities, so we should select the 'Fname' and 'Lname' columns in the 'Student' table.\n\nSQL query: SELECT Fname, Lname FROM Student WHERE StuID = (SELECT StuID FROM Participates_in GROUP BY StuID ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Fname, Lname FROM Student WHERE StuID = (SELECT StuID FROM Participates_in GROUP BY StuID ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT T1.fname ,  T1.lname FROM Student AS T1 JOIN Participates_in AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1",
        "question": "Tell me the first and last name of the student who has the most activities.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the first and last name of the student who has the most activities, so we should apply the 'count' operation to the 'actid' column in the 'Participates_in' table, and find the student with the highest count. Since the unit to which the activities being counted in the query belong is the student, we should apply the 'group by' operation to the 'stuid' column in the 'Participates_in' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Student', 'Participates_in'].\n\n<3> SQL Generation: The query requires the first and last name of the student who has the most activities, so we should select the 'Fname' and 'Lname' columns in the 'Student' table.\n\nSQL query: SELECT Fname, Lname FROM Student WHERE StuID = (SELECT stuid FROM Participates_in GROUP BY stuid ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT Fname, Lname FROM Student WHERE StuID = (SELECT stuid FROM Participates_in GROUP BY stuid ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT T1.activity_name FROM Activity AS T1 JOIN Participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the activity with the most students?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the name of the activity with the most students, so we should apply the 'count' operation to the 'actid' column in the 'Participates_in' table, and find the activity with the highest count. Since the unit to which the students being counted in the query belong is the activity, we should apply the 'group by' operation to the 'actid' column in the 'Participates_in' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Activity'].\n\n<3> SQL Generation: The query requires the name of the activity with the most students, so we should select the 'activity_name' column in the 'Activity' table.\n\nSQL query: SELECT activity_name FROM Activity WHERE actid = (SELECT actid FROM Participates_in GROUP BY actid ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT activity_name FROM Activity WHERE actid = (SELECT actid FROM Participates_in GROUP BY actid ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT T1.activity_name FROM Activity AS T1 JOIN Participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the activity that has the largest number of student participants.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Operation: The query requires the name of the activity that has the largest number of student participants, so we should apply the 'count' operation to the 'actid' column in the 'Participates_in' table, and find the activity with the highest count. Since the unit to which the participants being counted in the query belong is the activity, we should apply the 'group by' operation to the 'actid' column in the 'Participates_in' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Activity', 'Participates_in'].\n\n<3> SQL Generation: The query requires the name of the activity that has the largest number of student participants, so we should select the 'activity_name' column in the 'Activity' table.\n\nSQL query: SELECT activity_name FROM Activity WHERE actid = (SELECT actid FROM Participates_in GROUP BY actid ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT activity_name FROM Activity WHERE actid = (SELECT actid FROM Participates_in GROUP BY actid ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1",
        "question": "Which countries has the most number of airlines?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the countries with the most number of airlines, so we should apply the 'count' operation to the 'alid' column in the 'airlines' table, and find the countries with the highest count. Since the unit to which the airlines being counted in the query belong is the country, we should apply the 'group by' operation to the 'country' column in the 'airlines' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'airlines'.\n\n<3> SQL Generation: The query requires the countries with the most number of airlines, so we should select the 'country' column in the 'airlines' table.\n\nSQL query: SELECT country FROM airlines GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT country FROM airlines GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the country with the most number of home airlines?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the name of the country with the most number of home airlines, so we should apply the 'count' operation to the 'alid' column in the 'airlines' table, and find the country with the highest count. Since the unit to which the home airlines being counted in the query belong is the country, we should apply the 'group by' operation to the 'country' column in the 'airlines' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'airlines'.\n\n<3> SQL Generation: The query requires the name of the country with the most number of home airlines, so we should select the 'country' column in the 'airlines' table.\n\nSQL query: SELECT country FROM airlines GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT country FROM airlines GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT country FROM airlines WHERE active  =  'Y' GROUP BY country ORDER BY count(*) DESC LIMIT 1",
        "question": "Which countries has the most number of airlines whose active status is 'Y'?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the countries that have the most number of airlines whose active status is 'Y', so we should apply the 'count' operation to the 'alid' column in the 'airlines' table, and find the countries with the highest count. Since the unit to which the airlines being counted in the query belong is the country, we should apply the 'group by' operation to the 'country' column in the 'airlines' table. We also need to filter the airlines with an active status of 'Y' in the 'airlines' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'airlines'.\n\n<3> SQL Generation: The query requires the countries that have the most number of airlines whose active status is 'Y', so we should select the 'country' column in the 'airlines' table.\n\nSQL query: SELECT country FROM airlines WHERE active = 'Y' GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT country FROM airlines WHERE active = 'Y' GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) ,  country FROM airports GROUP BY country ORDER BY count(*) DESC",
        "question": "How many airports are there per country? Order the countries by decreasing number of airports.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the number of airports per country, so we should apply the 'count' operation to the 'apid' column in the 'airports' table, and it does not need sorting. Since the unit to which the airports being counted in the query belong is the country and only table 'airports' has the column 'country', so we should apply the 'group by' operation to the 'country' column in the 'airports' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['airports'].\n\n<3> SQL Generation: The query requires the number of airports per country, so we should select the 'country' column in the 'airports' table and count the 'apid' column in the 'airports' table.\n\nSQL query: SELECT country, COUNT(apid) FROM airports GROUP BY country ORDER BY COUNT(apid) DESC",
        "predict": "SELECT country, COUNT(apid) FROM airports GROUP BY country ORDER BY COUNT(apid) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) ,  country FROM airports GROUP BY country ORDER BY count(*) DESC",
        "question": "What is the number of airports per country, ordered from most to least?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the number of airports per country, ordered from most to least, so we should apply the 'count' operation to the 'apid' column in the 'airports' table, and sort it in descending order. Since the unit to which the airports being counted in the query belong is the country and only table 'airports' has the column 'country', so we should apply the 'group by' operation to the 'country' column in the 'airports' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['airports'].\n\n<3> SQL Generation: The query requires the number of airports per country, ordered from most to least, so we should select the 'country' column in the 'airports' table and count the 'apid' column in the 'airports' table.\n\nSQL query: SELECT country, COUNT(apid) FROM airports GROUP BY country ORDER BY COUNT(apid) DESC",
        "predict": "SELECT country, COUNT(apid) FROM airports GROUP BY country ORDER BY COUNT(apid) DESC",
        "hardness": "extra"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) ,  city FROM airports WHERE country  =  'United States' GROUP BY city ORDER BY count(*) DESC",
        "question": "How many airports are there per city in the United States? Order the cities by decreasing number of airports.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the number of airports per city in the United States, so we should apply the 'count' operation to the 'apid' column in the 'airports' table, and it does not need sorting. Since the unit to which the airports being counted in the query belong is the city and only table 'airports' has the column 'city', so we should apply the 'group by' operation to the 'city' column in the 'airports' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table 'airports'.\n\n<3> SQL Generation: The query requires the number of airports per city in the United States, so we should select the 'city' column in the 'airports' table and count the 'apid' column in the 'airports' table. We also need to filter the airports in the United States.\n\nSQL query: SELECT city, COUNT(*) FROM airports WHERE country = 'United States' GROUP BY city ORDER BY COUNT(*) DESC",
        "predict": "SELECT city, COUNT(*) FROM airports WHERE country = 'United States' GROUP BY city ORDER BY COUNT(*) DESC",
        "hardness": "hard"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) ,  city FROM airports WHERE country  =  'United States' GROUP BY city ORDER BY count(*) DESC",
        "question": "How many airports are there per city in the US ordered from most to least?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the number of airports per city in the US, so we should apply the 'count' operation to the 'apid' column in the 'airports' table, and sort it in descending order. Since the unit to which the airports being counted in the query belong is the city and only table 'airports' has the column 'city', so we should apply the 'group by' operation to the 'city' column in the 'airports' table. We also need to filter the airports in the US, which can be done by checking the 'country' column in the 'airports' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['airports'].\n\n<3> SQL Generation: The query requires the number of airports per city in the US, so we should select the 'city' column in the 'airports' table and count the 'apid' column in the 'airports' table. We also need to filter the airports in the US by adding a WHERE clause.\n\nSQL query: SELECT city, COUNT(apid) FROM airports WHERE country = 'US' GROUP BY city ORDER BY COUNT(apid) DESC",
        "predict": "SELECT city, COUNT(apid) FROM airports WHERE country = 'US' GROUP BY city ORDER BY COUNT(apid) DESC",
        "hardness": "hard"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of airline which runs the most number of routes.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the name of the airline that runs the most number of routes, so we should apply the 'count' operation to the 'alid' column in the 'routes' table, and find the airline with the highest count. Since the unit to which the routes being counted in the query belong is the airline, we should apply the 'group by' operation to the 'alid' column in the 'routes' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use tables ['routes', 'airlines'].\n\n<3> SQL Generation: The query requires the name of the airline that runs the most number of routes, so we should select the 'name' column in the 'airlines' table and the 'alid' column in the 'routes' table.\n\nSQL query: SELECT name FROM airlines WHERE alid = (SELECT alid FROM routes GROUP BY alid ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT name FROM airlines WHERE alid = (SELECT alid FROM routes GROUP BY alid ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the airline with the most routes?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the name of the airline with the most routes, so we should apply the 'count' operation to the 'alid' column in the 'routes' table, and find the airline with the highest count. Since the unit to which the routes being counted in the query belong is the airline, we should apply the 'group by' operation to the 'alid' column in the 'routes' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use tables ['routes', 'airlines'].\n\n<3> SQL Generation: The query requires the name of the airline with the most routes, so we should select the 'name' column in the 'airlines' table.\n\nSQL query: SELECT name FROM airlines WHERE alid = (SELECT alid FROM routes GROUP BY alid ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT name FROM airlines WHERE alid = (SELECT alid FROM routes GROUP BY alid ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the busiest source airport that runs most number of routes in China.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the busiest source airport that runs the most number of routes in China, so we should apply the 'count' operation to the 'routes' table for the 'src_apid' column, and find the source airport with the highest count. Since the unit to which the routes being counted in the query belong is the source airport, we should apply the 'group by' operation to the 'src_apid' column in the 'routes' table. We also need to filter the routes in China, which can be done by joining the 'routes' table with the 'airports' table and filtering on the 'country' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'routes' and 'airports', we need to use tables ['routes', 'airports'].\n\n<3> SQL Generation: The query requires the busiest source airport that runs the most number of routes in China, so we should select the 'name' column in the 'airports' table and the 'src_apid' column in the 'routes' table. We also need to filter the routes in China by adding a WHERE clause.\n\nSQL query: SELECT T2.name FROM routes AS T1 JOIN airports AS T2 ON T1.src_apid = T2.apid WHERE T2.country = 'China' GROUP BY T1.src_apid ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.name FROM routes AS T1 JOIN airports AS T2 ON T1.src_apid = T2.apid WHERE T2.country = 'China' GROUP BY T1.src_apid ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the busiest destination airport that runs most number of routes in China.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the busiest destination airport that runs the most number of routes in China, so we should apply the 'count' operation to the 'dst_apid' column in the 'routes' table, and find the destination airport with the highest count. Since the unit to which the routes being counted in the query belong is the destination airport, we should apply the 'group by' operation to the 'dst_apid' column in the 'routes' table. We also need to filter the airports in China, which can be done by checking the 'country' column in the 'airports' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'routes' and 'airports', we need to use tables ['routes', 'airports'].\n\n<3> SQL Generation: The query requires the busiest destination airport that runs the most number of routes in China, so we should select the 'name' column in the 'airports' table and the 'dst_apid' column in the 'routes' table. We also need to filter the airports in China by adding a condition in the WHERE clause.\n\nSQL query: SELECT T2.name FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid = T2.apid WHERE T2.country = 'China' GROUP BY T1.dst_apid ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.name FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid = T2.apid WHERE T2.country = 'China' GROUP BY T1.dst_apid ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the airport that is the destination of the most number of routes that start in China?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Operation: The query requires the name of the airport that is the destination of the most number of routes that start in China, so we should apply the 'count' operation to the 'dst_apid' column in the 'routes' table, and find the airport with the highest count. Since the unit to which the routes being counted in the query belong is the airport, we should apply the 'group by' operation to the 'dst_apid' column in the 'routes' table. We also need to filter the routes that start in China, which can be done by joining the 'routes' table with the 'airports' table and filtering on the 'country' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'routes' and 'airports', we need to use tables ['routes', 'airports'].\n\n<3> SQL Generation: The query requires the name of the airport that is the destination of the most number of routes that start in China, so we should select the 'name' column in the 'airports' table. We also need to join the 'routes' table with the 'airports' table and filter on the 'country' column to only include routes that start in China.\n\nSQL query: SELECT T2.name FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid = T2.apid WHERE T1.src_apid IN (SELECT apid FROM airports WHERE country = 'China') GROUP BY T1.dst_apid ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT T2.name FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid = T2.apid WHERE T1.src_apid IN (SELECT apid FROM airports WHERE country = 'China') GROUP BY T1.dst_apid ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the customer who has the most orders?",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the customer who has the most orders, so we should apply the 'count' operation to the 'Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers', 'Orders'].\n\n<3> SQL Generation: The query requires the name of the customer who has the most orders, so we should select the 'customer_name' column in the 'Customers' table and the 'customer_id' column in the 'Orders' table.\n\nSQL query: SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which customer made the most orders? Find the customer name.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the customer who made the most orders, so we should apply the 'count' operation to the 'Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers', 'Orders'].\n\n<3> SQL Generation: The query requires the customer who made the most orders, so we should select the 'customer_name' column in the 'Customers' table and the 'customer_id' column in the 'Orders' table.\n\nSQL query: SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.customer_id FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the customer id of the customer who has the most orders?",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the customer id of the customer who has the most orders, so we should apply the 'count' operation to the 'Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Orders'].\n\n<3> SQL Generation: The query requires the customer id of the customer who has the most orders, so we should select the 'customer_id' column in the 'Orders' table.\n\nSQL query: SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.customer_id FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the id of the customer who made the most orders.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the id of the customer who made the most orders, so we should apply the 'count' operation to the 'Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Orders'].\n\n<3> SQL Generation: The query requires the id of the customer who made the most orders, so we should select the 'customer_id' column in the 'Orders' table.\n\nSQL query: SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.order_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id GROUP BY T1.order_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id of the order which has the most items?",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the id of the order which has the most items, so we should apply the 'count' operation to the 'order_item_id' column in the 'Order_Items' table, and find the order with the highest count. Since the unit to which the items being counted in the query belong is the order, we should apply the 'group by' operation to the 'order_id' column in the 'Order_Items' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Order_Items'].\n\n<3> SQL Generation: The query requires the id of the order which has the most items, so we should select the 'order_id' column in the 'Order_Items' table.\n\nSQL query: SELECT order_id FROM Order_Items GROUP BY order_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT order_id FROM Order_Items GROUP BY order_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.order_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id GROUP BY T1.order_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which order deals with the most items? Return the order id.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the order that deals with the most items, so we should apply the 'count' operation to the 'order_item_id' column in the 'Order_Items' table, and find the order with the highest count. Since the unit to which the items being counted in the query belong is the order, we should apply the 'group by' operation to the 'order_id' column in the 'Order_Items' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Order_Items'].\n\n<3> SQL Generation: The query requires the order that deals with the most items, so we should select the 'order_id' column in the 'Order_Items' table.\n\nSQL query: SELECT order_id FROM Order_Items GROUP BY order_id ORDER BY COUNT(*) DESC LIMIT 1",
        "predict": "SELECT order_id FROM Order_Items GROUP BY order_id ORDER BY COUNT(*) DESC LIMIT 1",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the customer who has the largest number of orders?",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the customer who has the largest number of orders, so we should apply the 'count' operation to the 'Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers', 'Orders'].\n\n<3> SQL Generation: The query requires the name of the customer who has the largest number of orders, so we should select the 'customer_name' column in the 'Customers' table and the 'customer_id' column in the 'Orders' table.\n\nSQL query: SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name of the customer who made the most orders.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Operation: The query requires the name of the customer who made the most orders, so we should apply the 'count' operation to the 'Orders' table for the 'customer_id' column, and find the customer with the highest count. Since the unit to which the orders being counted in the query belong is the customer, we should apply the 'group by' operation to the 'customer_id' column in the 'Orders' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Customers', 'Orders'].\n\n<3> SQL Generation: The query requires the name of the customer who made the most orders, so we should select the 'customer_name' column in the 'Customers' table and the 'customer_id' column in the 'Orders' table.\n\nSQL query: SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT customer_name FROM Customers WHERE customer_id = (SELECT customer_id FROM Orders GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT T1.id ,  T1.name ,  T1.nationality FROM architect AS T1 JOIN mill AS T2 ON T1.id  =  T2.architect_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id, name and nationality of the architect who built most mills?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Operation: The query requires the id, name, and nationality of the architect who built the most mills, so we should apply the 'count' operation to the 'mill' table for the 'architect_id' column, and find the architect with the highest count. Since the unit to which the mills being counted in the query belong is the architect, we should apply the 'group by' operation to the 'architect_id' column in the 'mill' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use tables ['architect', 'mill'].\n\n<3> SQL Generation: The query requires the id, name, and nationality of the architect who built the most mills, so we should select the 'id', 'name', and 'nationality' columns in the 'architect' table.\n\nSQL query: SELECT id, name, nationality FROM architect WHERE id = (SELECT architect_id FROM mill GROUP BY architect_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "predict": "SELECT id, name, nationality FROM architect WHERE id = (SELECT architect_id FROM mill GROUP BY architect_id ORDER BY COUNT(*) DESC LIMIT 1)",
        "hardness": "extra"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT TYPE ,  count(*) FROM mill GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most common mill type, and how many are there?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Operation: The query requires the most common mill type and the count of mills for each type, so we should apply the 'count' operation to the 'type' column in the 'mill' table and find the mill type with the highest count. Since the unit to which the mill types being counted in the query belong is the mill, we should apply the 'group by' operation to the 'type' column in the 'mill' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['mill'].\n\n<3> SQL Generation: The query requires the most common mill type and the count of mills for each type, so we should select the 'type' column in the 'mill' table and count the 'id' column in the 'mill' table.\n\nSQL query: SELECT type, COUNT(id) FROM mill GROUP BY type ORDER BY COUNT(id) DESC LIMIT 1",
        "predict": "SELECT type, COUNT(id) FROM mill GROUP BY type ORDER BY COUNT(id) DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "farm",
        "gold": "SELECT Status FROM city WHERE Population  >  1500 INTERSECT SELECT Status FROM city WHERE Population  <  500",
        "question": "Show the status shared by cities with population bigger than 1500 and smaller than 500.",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the statuses of cities with a population bigger than 1500; 2. what are the statuses of cities with a population smaller than 500.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'city'. To complete the second subproblem, we also need to use table 'city'.\n\n<3> Operation: Use 'where' to filter using column 'population' in table 'city'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT status FROM city WHERE population  >  1500 INTERSECT SELECT status FROM city WHERE population  <  500",
        "predict": "SELECT status FROM city WHERE population  >  1500 INTERSECT SELECT status FROM city WHERE population  <  500",
        "hardness": "hard"
    },
    {
        "db_id": "farm",
        "gold": "SELECT Status FROM city WHERE Population  >  1500 INTERSECT SELECT Status FROM city WHERE Population  <  500",
        "question": "Which statuses correspond to both cities that have a population over 1500 and cities that have a population lower than 500?",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the statuses of cities that have a population over 1500; 2. what are the statuses of cities that have a population lower than 500.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'city'. To complete the second subproblem, we also need to use table 'city'.\n\n<3> Operation: Use 'where' to filter using column 'population' in table 'city'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT status FROM city WHERE population > 1500 INTERSECT SELECT status FROM city WHERE population < 500",
        "predict": "SELECT status FROM city WHERE population > 1500 INTERSECT SELECT status FROM city WHERE population < 500",
        "hardness": "hard"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT course_id FROM student_course_registrations WHERE student_id = 121 UNION SELECT course_id FROM student_course_attendance WHERE student_id = 121",
        "question": "Find the id of courses which are registered or attended by student whose id is 121?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the courses registered by student with id 121; 2. what are the courses attended by student with id 121.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Student_Course_Registrations']. To complete the second subproblem, we need to use tables ['Student_Course_Attendance'].\n\n<3> Operation: For both subproblems, we need to filter using the column 'student_id' in the respective tables.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT course_id FROM student_course_registrations WHERE student_id  =  121 UNION SELECT course_id FROM student_course_attendance WHERE student_id  =  121",
        "predict": "SELECT course_id FROM student_course_registrations WHERE student_id  =  121 UNION SELECT course_id FROM student_course_attendance WHERE student_id  =  121",
        "hardness": "hard"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT course_id FROM student_course_registrations WHERE student_id = 121 UNION SELECT course_id FROM student_course_attendance WHERE student_id = 121",
        "question": "What are the ids of the courses that are registered or attended by the student whose id is 121?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the ids of the courses that are registered by the student whose id is 121; 2. what are the ids of the courses that are attended by the student whose id is 121.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Student_Course_Registrations']. To complete the second subproblem, we need to use tables ['Student_Course_Attendance'].\n\n<3> Operation: For both subproblems, we need to filter using the column 'student_id' in the respective tables.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT course_id FROM Student_Course_Registrations WHERE student_id  =  121 UNION SELECT course_id FROM Student_Course_Attendance WHERE student_id  =  121",
        "predict": "SELECT course_id FROM Student_Course_Registrations WHERE student_id  =  121 UNION SELECT course_id FROM Student_Course_Attendance WHERE student_id  =  121",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT id FROM station WHERE city  =  \"San Francisco\" INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  10",
        "question": "What are the ids of stations that are located in San Francisco and have average bike availability above 10.",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the ids of stations that are located in San Francisco; 2. what are the ids of stations that have average bike availability above 10.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'station'. To complete the second subproblem, we need to use tables 'station' and 'status'.\n\n<3> Operation: Due to the need for calculating the average bike availability for different stations, we need to perform a 'GROUP BY' operation on the column 'station_id', filter by performing 'HAVING AVG()' on the column 'bikes_available'. \n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T1.city  =  \"San Francisco\" INTERSECT SELECT T2.station_id FROM status AS T2 GROUP BY T2.station_id HAVING avg(bikes_available)  >  10",
        "predict": "SELECT T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T1.city  =  \"San Francisco\" INTERSECT SELECT T2.station_id FROM status AS T2 GROUP BY T2.station_id HAVING avg(bikes_available)  >  10",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT id FROM station WHERE lat  >  37.4 EXCEPT SELECT station_id FROM status GROUP BY station_id HAVING min(bikes_available)  <  7",
        "question": "What are the ids of stations that have latitude above 37.4 and never had bike availability below 7?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the ids of stations that have latitude above 37.4; 2. what are the ids of stations that never had bike availability below 7.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'station'. To complete the second subproblem, we need to use tables 'station' and 'status'.\n\n<3> Operation: Use 'where' to filter using column 'lat' in table 'station'. Use 'not exists' to filter out stations that had bike availability below 7 in table 'status'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.id FROM station AS T1 WHERE T1.lat  >  37.4 INTERSECT SELECT T1.station_id FROM status AS T1 WHERE NOT EXISTS (SELECT * FROM status AS T2 WHERE T1.station_id  =  T2.station_id AND T2.bikes_available  <  7)",
        "predict": "SELECT T1.id FROM station AS T1 WHERE T1.lat  >  37.4 INTERSECT SELECT T1.station_id FROM status AS T1 WHERE NOT EXISTS (SELECT * FROM status AS T2 WHERE T1.station_id  =  T2.station_id AND T2.bikes_available  <  7)",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  10 EXCEPT SELECT name FROM station WHERE city  =  \"San Jose\"",
        "question": "What are names of stations that have average bike availability above 10 and are not located in San Jose city?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are names of stations that have average bike availability above 10; 2. what are names of stations that are not located in San Jose city.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['station', 'status']. To complete the second subproblem, we need to use table ['station'].\n\n<3> Operation: Due to the need for calculating the average bike availability for different stations, we need to perform a 'GROUP BY' operation on the column 'station_id', filter by perform 'HAVING AVG()' on the column 'bikes_available'. \n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  10 INTERSECT SELECT name FROM station WHERE city  !=  \"San Jose\"",
        "predict": "SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  10 INTERSECT SELECT name FROM station WHERE city  !=  \"San Jose\"",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT name FROM station WHERE city  =  \"Palo Alto\" EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  100",
        "question": "What are the names of stations that are located in Palo Alto city but have never been the ending point of trips more than 100 times?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of stations that are located in Palo Alto city; 2. what are the names of stations that have never been the ending point of trips more than 100 times.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'station'. To complete the second subproblem, we need to use tables ['station', 'trip'].\n\n<3> Operation: Use 'where' to filter using column 'city' in table 'station'. For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'end_station_id' in table 'trip' and filter by performing 'HAVING COUNT()' on the column 'end_station_id'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT name FROM station WHERE city  =  \"Palo Alto\" EXCEPT SELECT T1.name FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id HAVING count(*)  >  100",
        "predict": "SELECT name FROM station WHERE city  =  \"Palo Alto\" EXCEPT SELECT T1.name FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id HAVING count(*)  >  100",
        "hardness": "hard"
    },
    {
        "db_id": "book_2",
        "gold": "SELECT Publisher FROM publication WHERE Price  >  10000000 INTERSECT SELECT Publisher FROM publication WHERE Price  <  5000000",
        "question": "Show the publishers that have publications with price higher than 10000000 and publications with price lower than 5000000.",
        "fields": "Table book, columns = [*,Book_ID,Title,Issues,Writer]\nTable publication, columns = [*,Publication_ID,Book_ID,Publisher,Publication_Date,Price]\n",
        "foreign_keys": "Foreign_keys = [publication.Book_ID = book.Book_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the publishers that have publications with price higher than 10000000; 2. what are the publishers that have publications with price lower than 5000000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['publication', 'book'].\n\n<3> Operation: Use 'where' to filter using column 'Price' in table 'publication'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Publisher FROM publication AS T1 JOIN book AS T2 ON T1.Book_ID  =  T2.Book_ID WHERE T1.Price  >  10000000 INTERSECT SELECT T1.Publisher FROM publication AS T1 JOIN book AS T2 ON T1.Book_ID  =  T2.Book_ID WHERE T1.Price  <  5000000",
        "predict": "SELECT T1.Publisher FROM publication AS T1 JOIN book AS T2 ON T1.Book_ID  =  T2.Book_ID WHERE T1.Price  >  10000000 INTERSECT SELECT T1.Publisher FROM publication AS T1 JOIN book AS T2 ON T1.Book_ID  =  T2.Book_ID WHERE T1.Price  <  5000000",
        "hardness": "hard"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT eid FROM Employee EXCEPT SELECT eid FROM Certificate",
        "question": "Show ids for all employees who don't have a certificate.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of employees who have certificates; 2. what are the ids of all employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['employee', 'certificate']. To complete the second subproblem, we only need to use the table 'employee'.\n\n<3> Operation: Use 'where' to filter out the employees who have certificates.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT eid FROM employee EXCEPT SELECT eid FROM certificate",
        "predict": "SELECT eid FROM employee EXCEPT SELECT eid FROM certificate",
        "hardness": "hard"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT eid FROM Employee EXCEPT SELECT eid FROM Certificate",
        "question": "What are the ids of all employees that don't have certificates?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of all employees; 2. what are the ids of employees that have certificates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'employee'. To complete the second subproblem, we need to use tables ['employee', 'certificate'].\n\n<3> Operation: Use 'where' to filter using column 'eid' in table 'certificate'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT eid FROM employee EXCEPT SELECT eid FROM certificate",
        "predict": "SELECT eid FROM employee EXCEPT SELECT eid FROM certificate",
        "hardness": "hard"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\" INTERSECT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Airbus A340-300\"",
        "question": "Show names for all employees who have certificates on both Boeing 737-800 and Airbus A340-300.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of employees who have certificates on Boeing 737-800; 2. what are the names of employees who have certificates on Airbus A340-300.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'employee' and 'aircraft'. Since table 'employee' and table 'aircraft' do not have a direct foreign key connection, we need to use tables ['employee', 'certificate', 'aircraft']. To complete the second subproblem, we need to use tables ['employee', 'certificate', 'aircraft'] in the same reason.\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'aircraft'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\" INTERSECT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Airbus A340-300\"",
        "predict": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\" INTERSECT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Airbus A340-300\"",
        "hardness": "extra"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\" INTERSECT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Airbus A340-300\"",
        "question": "What are the names of all employees who can fly both the Boeing 737-800 and the Airbus A340-300?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of employees who can fly the Boeing 737-800; 2. what are the names of employees who can fly the Airbus A340-300.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['employee', 'certificate', 'aircraft']. To complete the second subproblem, we also need to use tables ['employee', 'certificate', 'aircraft'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'aircraft'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.name = \"Boeing 737-800\" INTERSECT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.name = \"Airbus A340-300\"",
        "predict": "SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.name = \"Boeing 737-800\" INTERSECT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.name = \"Airbus A340-300\"",
        "hardness": "extra"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\"",
        "question": "Show names for all employees who do not have certificate of Boeing 737-800.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all employees; 2. what are the names of employees who have a certificate of Boeing 737-800.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'employee'. To complete the second subproblem, we need to use tables ['employee', 'certificate', 'aircraft'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'aircraft'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT name FROM employee EXCEPT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid  =  T2.eid JOIN aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\"",
        "predict": "SELECT name FROM employee EXCEPT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid  =  T2.eid JOIN aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\"",
        "hardness": "hard"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\"",
        "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all employees; 2. what are the names of employees who are certified to fly Boeing 737-800s.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'employee'. To complete the second subproblem, we need to use tables ['employee', 'certificate', 'aircraft'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'aircraft'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT name FROM employee EXCEPT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid  =  T2.eid JOIN aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\"",
        "predict": "SELECT name FROM employee EXCEPT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid  =  T2.eid JOIN aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  \"Boeing 737-800\"",
        "hardness": "hard"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy",
        "question": "What are the student ids of students who don't have any allergies?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the student ids of all students; 2. what are the student ids of students who have allergies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Student'. To complete the second subproblem, we need to use tables ['Student', 'Has_Allergy', 'Allergy_Type'].\n\n<3> Operation: Use 'where' to filter using column 'Allergy' in table 'Has_Allergy'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT StuID FROM Student EXCEPT SELECT t1.StuID FROM Student AS t1 JOIN Has_Allergy AS t2 ON t1.StuID  =  t2.StuID JOIN Allergy_Type AS t3 ON t2.Allergy  =  t3.Allergy",
        "predict": "SELECT StuID FROM Student EXCEPT SELECT t1.StuID FROM Student AS t1 JOIN Has_Allergy AS t2 ON t1.StuID  =  t2.StuID JOIN Allergy_Type AS t3 ON t2.Allergy  =  t3.Allergy",
        "hardness": "hard"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Movies' EXCEPT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Music'",
        "question": "Find the name of tracks which are in Movies playlist but not in music playlist.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of tracks in the Movies playlist; 2. what are the names of tracks in the Music playlist.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['tracks', 'playlist_tracks', 'playlists']. To complete the second subproblem, we also need to use tables ['tracks', 'playlist_tracks', 'playlists'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'playlists'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Movies\" EXCEPT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Music\"",
        "predict": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Movies\" EXCEPT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Music\"",
        "hardness": "extra"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Movies' EXCEPT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Music'",
        "question": "What are the names of all tracks that are on the Movies playlist but not in the music playlist?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all tracks that are on the Movies playlist; 2. what are the names of all tracks that are on the Music playlist.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['tracks', 'playlist_tracks', 'playlists']. To complete the second subproblem, we need to use tables ['tracks', 'playlist_tracks', 'playlists'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'playlists'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Movies\" EXCEPT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Music\"",
        "predict": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Movies\" EXCEPT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Music\"",
        "hardness": "extra"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Movies' INTERSECT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Music'",
        "question": "Find the name of tracks which are in both Movies and music playlists.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the tracks in the Movies playlist; 2. what are the tracks in the Music playlist.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['tracks', 'playlist_tracks', 'playlists']. To complete the second subproblem, we also need to use tables ['tracks', 'playlist_tracks', 'playlists'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'playlists'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Movies\" INTERSECT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Music\"",
        "predict": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Movies\" INTERSECT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Music\"",
        "hardness": "extra"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Movies' INTERSECT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  'Music'",
        "question": "What are the names of all the tracks that are in both the Movies and music playlists?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of all the tracks in the Movies playlist; 2. what are the names of all the tracks in the Music playlist.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['tracks', 'playlist_tracks', 'playlists']. To complete the second subproblem, we also need to use tables ['tracks', 'playlist_tracks', 'playlists'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'playlists'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Movies\" INTERSECT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Music\"",
        "predict": "SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Movies\" INTERSECT SELECT T1.name FROM tracks AS T1 JOIN playlist_tracks AS T2 ON T1.id  =  T2.track_id JOIN playlists AS T3 ON T2.playlist_id  =  T3.id WHERE T3.name  =  \"Music\"",
        "hardness": "extra"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id",
        "question": "Show the first names and last names of customers without any account.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the first names and last names of all customers; 2. what are the first names and last names of customers with accounts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Customers'. To complete the second subproblem, we need to use tables ['Customers', 'Accounts'].\n\n<3> Operation: Use 'where' to filter using column 'customer_id' in table 'Accounts'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT customer_first_name, customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name, T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id = T2.customer_id",
        "predict": "SELECT customer_first_name, customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name, T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id = T2.customer_id",
        "hardness": "extra"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id",
        "question": "What are the full names of customers who do not have any accounts?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the full names of all customers; 2. what are the full names of customers who have accounts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Customers']. To complete the second subproblem, we need to use tables ['Customers', 'Accounts'].\n\n<3> Operation: Use 'where' to filter using column 'customer_id' in table 'Accounts'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT customer_first_name, customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name, T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id = T2.customer_id",
        "predict": "SELECT customer_first_name, customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name, T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id = T2.customer_id",
        "hardness": "extra"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name FROM track EXCEPT SELECT T2.name FROM race AS T1 JOIN track AS T2 ON T1.track_id  =  T2.track_id WHERE T1.class  =  'GT'",
        "question": "What are the names for tracks without a race in class 'GT'.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all tracks; 2. what are the names of tracks with a race in class 'GT'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'track'. To complete the second subproblem, we need to use tables 'track' and 'race'.\n\n<3> Operation: Use 'where' to filter using column 'Class' in table 'race'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Name FROM track EXCEPT SELECT T1.Name FROM track AS T1 JOIN race AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T2.Class  =  'GT'",
        "predict": "SELECT Name FROM track EXCEPT SELECT T1.Name FROM track AS T1 JOIN race AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T2.Class  =  'GT'",
        "hardness": "hard"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name FROM track EXCEPT SELECT T2.name FROM race AS T1 JOIN track AS T2 ON T1.track_id  =  T2.track_id WHERE T1.class  =  'GT'",
        "question": "Give the names of tracks that do not have a race in the class 'GT'.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all tracks; 2. what are the names of tracks that have a race in the class 'GT'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'track'. To complete the second subproblem, we need to use tables ['race', 'track'].\n\n<3> Operation: Use 'where' to filter using column 'Class' in table 'race'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Name FROM track EXCEPT SELECT T2.Name FROM race AS T1 JOIN track AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T1.Class  =  'GT'",
        "predict": "SELECT Name FROM track EXCEPT SELECT T2.Name FROM race AS T1 JOIN track AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T1.Class  =  'GT'",
        "hardness": "hard"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT LOCATION FROM track WHERE seating  >  90000 INTERSECT SELECT LOCATION FROM track WHERE seating  <  70000",
        "question": "Find the locations where have both tracks with more than 90000 seats and tracks with less than 70000 seats.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the locations where have tracks with more than 90000 seats; 2. what are the locations where have tracks with less than 70000 seats.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['race', 'track']. To complete the second subproblem, we also need to use tables ['race', 'track'].\n\n<3> Operation: Use 'where' to filter using column 'Seating' in table 'track'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T2.Location FROM race AS T1 JOIN track AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T2.Seating  >  90000 INTERSECT SELECT T2.Location FROM race AS T1 JOIN track AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T2.Seating  <  70000",
        "predict": "SELECT T2.Location FROM race AS T1 JOIN track AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T2.Seating  >  90000 INTERSECT SELECT T2.Location FROM race AS T1 JOIN track AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T2.Seating  <  70000",
        "hardness": "hard"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT LOCATION FROM track WHERE seating  >  90000 INTERSECT SELECT LOCATION FROM track WHERE seating  <  70000",
        "question": "What are the locations that have both tracks with more than 90000 seats, and tracks with fewer than 70000 seats?",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the locations that have tracks with more than 90000 seats; 2. what are the locations that have tracks with fewer than 70000 seats.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['race', 'track'].\n\n<3> Operation: Use 'where' to filter using column 'Seating' in table 'track'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T2.Location FROM race AS T1 JOIN track AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T2.Seating  >  90000 INTERSECT SELECT T2.Location FROM race AS T1 JOIN track AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T2.Seating  <  70000",
        "predict": "SELECT T2.Location FROM race AS T1 JOIN track AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T2.Seating  >  90000 INTERSECT SELECT T2.Location FROM race AS T1 JOIN track AS T2 ON T1.Track_ID  =  T2.Track_ID WHERE T2.Seating  <  70000",
        "hardness": "hard"
    },
    {
        "db_id": "coffee_shop",
        "gold": "SELECT address FROM member WHERE age  <  30 INTERSECT SELECT address FROM member WHERE age  >  40",
        "question": "Which address has both members younger than 30 and members older than 40?",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the addresses of members younger than 30; 2. what are the addresses of members older than 40.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['member']. To complete the second subproblem, we also need to use tables ['member'].\n\n<3> Operation: Use 'where' to filter using column 'Age' in table 'member'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Address FROM member AS T1 WHERE T1.Age  <  30 INTERSECT SELECT T1.Address FROM member AS T1 WHERE T1.Age  >  40",
        "predict": "SELECT T1.Address FROM member AS T1 WHERE T1.Age  <  30 INTERSECT SELECT T1.Address FROM member AS T1 WHERE T1.Age  >  40",
        "hardness": "hard"
    },
    {
        "db_id": "coffee_shop",
        "gold": "SELECT membership_card FROM member WHERE address  =  'Hartford' INTERSECT SELECT membership_card FROM member WHERE address  =  'Waterbury'",
        "question": "What is the membership card held by both members living in Hartford and ones living in Waterbury address?",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what is the membership card held by members living in Hartford; 2. what is the membership card held by members living in Waterbury.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['member']. To complete the second subproblem, we also need to use table ['member'].\n\n<3> Operation: Use 'where' to filter using column 'Address' in table 'member'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT membership_card FROM member WHERE Address  =  \"Hartford\" INTERSECT SELECT membership_card FROM member WHERE Address  =  \"Waterbury\"",
        "predict": "SELECT membership_card FROM member WHERE Address  =  \"Hartford\" INTERSECT SELECT membership_card FROM member WHERE Address  =  \"Waterbury\"",
        "hardness": "hard"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT LastName FROM CUSTOMER EXCEPT SELECT T1.LastName FROM CUSTOMER AS T1 JOIN Invoice AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T2.total  >  20",
        "question": "Find all the customer last names that do not have invoice totals larger than 20.",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the customer last names; 2. what are the customer last names that have invoice totals larger than 20.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Customer']. To complete the second subproblem, we need to use tables ['Customer', 'Invoice'].\n\n<3> Operation: Use 'where' to filter using column 'Total' in table 'Invoice'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT LastName FROM Customer EXCEPT SELECT T1.LastName FROM Customer AS T1 JOIN Invoice AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T2.Total  >  20",
        "predict": "SELECT LastName FROM Customer EXCEPT SELECT T1.LastName FROM Customer AS T1 JOIN Invoice AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T2.Total  >  20",
        "hardness": "hard"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT LastName FROM CUSTOMER EXCEPT SELECT T1.LastName FROM CUSTOMER AS T1 JOIN Invoice AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T2.total  >  20",
        "question": "What are the last names of customers without invoice totals exceeding 20?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the last names of all customers; 2. what are the last names of customers with invoice totals exceeding 20.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Customer']. To complete the second subproblem, we need to use tables ['Customer', 'Invoice'].\n\n<3> Operation: Use 'where' to filter using column 'Total' in table 'Invoice'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT LastName FROM Customer EXCEPT SELECT T1.LastName FROM Customer AS T1 JOIN Invoice AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T2.Total  >  20",
        "predict": "SELECT LastName FROM Customer EXCEPT SELECT T1.LastName FROM Customer AS T1 JOIN Invoice AS T2 ON T1.CustomerId  =  T2.CustomerId WHERE T2.Total  >  20",
        "hardness": "hard"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT Name FROM ARTIST EXCEPT SELECT T2.Name FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId",
        "question": "Find the names of artists that do not have any albums.",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all artists; 2. what are the names of artists that have albums.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Artist']. To complete the second subproblem, we need to use tables ['Artist', 'Album'].\n\n<3> Operation: Use 'where' to filter using column 'ArtistId' in table 'Album'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Name FROM Artist EXCEPT SELECT T1.Name FROM Artist AS T1 JOIN Album AS T2 ON T1.ArtistId  =  T2.ArtistId",
        "predict": "SELECT Name FROM Artist EXCEPT SELECT T1.Name FROM Artist AS T1 JOIN Album AS T2 ON T1.ArtistId  =  T2.ArtistId",
        "hardness": "hard"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT Name FROM ARTIST EXCEPT SELECT T2.Name FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId",
        "question": "What are the names of artists who have not released any albums?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all artists; 2. what are the names of artists who have released albums.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Artist']. To complete the second subproblem, we need to use tables ['Artist', 'Album'].\n\n<3> Operation: Use 'where' to filter using column 'ArtistId' in table 'Album'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Name FROM Artist EXCEPT SELECT T1.Name FROM Artist AS T1 JOIN Album AS T2 ON T1.ArtistId  =  T2.ArtistId",
        "predict": "SELECT Name FROM Artist EXCEPT SELECT T1.Name FROM Artist AS T1 JOIN Album AS T2 ON T1.ArtistId  =  T2.ArtistId",
        "hardness": "hard"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreID  =  T3.GenreID WHERE T3.Name  =  'Reggae' INTERSECT SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreID  =  T3.GenreID WHERE T3.Name  =  'Rock'",
        "question": "What are the album titles for albums containing both 'Reggae' and 'Rock' genre tracks?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the album titles for albums containing 'Reggae' genre tracks; 2. what are the album titles for albums containing 'Rock' genre tracks.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Album', 'Track', 'Genre']. To complete the second subproblem, we also need to use tables ['Album', 'Track', 'Genre'].\n\n<3> Operation: Use 'where' to filter using column 'Name' in table 'Genre'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreId  =  T3.GenreId WHERE T3.Name  =  \"Reggae\" INTERSECT SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreId  =  T3.GenreId WHERE T3.Name  =  \"Rock\"",
        "predict": "SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreId  =  T3.GenreId WHERE T3.Name  =  \"Reggae\" INTERSECT SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreId  =  T3.GenreId WHERE T3.Name  =  \"Rock\"",
        "hardness": "extra"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreID  =  T3.GenreID WHERE T3.Name  =  'Reggae' INTERSECT SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreID  =  T3.GenreID WHERE T3.Name  =  'Rock'",
        "question": "Find the titles of albums that contain tracks of both the Reggae and Rock genres.",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the titles of albums that contain tracks of the Reggae genre; 2. what are the titles of albums that contain tracks of the Rock genre.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Album', 'Track', 'Genre']. To complete the second subproblem, we also need to use tables ['Album', 'Track', 'Genre'].\n\n<3> Operation: Use 'where' to filter using column 'Name' in table 'Genre'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreId  =  T3.GenreId WHERE T3.Name  =  \"Reggae\" INTERSECT SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreId  =  T3.GenreId WHERE T3.Name  =  \"Rock\"",
        "predict": "SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreId  =  T3.GenreId WHERE T3.Name  =  \"Reggae\" INTERSECT SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreId  =  T3.GenreId WHERE T3.Name  =  \"Rock\"",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN first_notification_of_loss AS t2 ON t1.customer_id  =  t2.customer_id",
        "question": "Find the names of users who do not have a first notification of loss record.",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all users; 2. what are the names of users who have a first notification of loss record.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Customers']. To complete the second subproblem, we need to use tables ['Customers', 'First_Notification_of_Loss'].\n\n<3> Operation: Use 'where' to filter using column 'FNOL_ID' in table 'First_Notification_of_Loss'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Customer_name FROM Customers EXCEPT SELECT t1.Customer_name FROM Customers AS t1 JOIN First_Notification_of_Loss AS t2 ON t1.Customer_ID  =  t2.Customer_ID WHERE t2.FNOL_ID IS NOT NULL",
        "predict": "SELECT Customer_name FROM Customers EXCEPT SELECT t1.Customer_name FROM Customers AS t1 JOIN First_Notification_of_Loss AS t2 ON t1.Customer_ID  =  t2.Customer_ID WHERE t2.FNOL_ID IS NOT NULL",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN first_notification_of_loss AS t2 ON t1.customer_id  =  t2.customer_id",
        "question": "Which customers do not have a first notification of loss record? Give me the customer names.",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the customer names who have a first notification of loss record; 2. what are the customer names who do not have a first notification of loss record.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Customers', 'Customers_Policies', 'First_Notification_of_Loss']. To complete the second subproblem, we need to use table ['Customers'].\n\n<3> Operation: Use 'where' to filter using column 'Customer_ID' in table 'First_Notification_of_Loss'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id JOIN first_notification_of_loss AS t3 ON t2.customer_id  =  t3.customer_id WHERE t3.customer_id IS NOT NULL",
        "predict": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id JOIN first_notification_of_loss AS t3 ON t2.customer_id  =  t3.customer_id WHERE t3.customer_id IS NOT NULL",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT t1.customer_name FROM customers AS t1 JOIN first_notification_of_loss AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id WHERE t3.service_name  =  \"Close a policy\" INTERSECT SELECT t1.customer_name FROM customers AS t1 JOIN first_notification_of_loss AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id WHERE t3.service_name  =  \"New policy application\"",
        "question": "Find the names of customers who have used both the service \"Close a policy\" and the service \"New policy application\".",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of customers who have used the service \"Close a policy\"; 2. what are the names of customers who have used the service \"New policy application\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Customers', 'Customers_Policies', 'First_Notification_of_Loss', 'Services']. To complete the second subproblem, we need to use tables ['Customers', 'Customers_Policies', 'First_Notification_of_Loss', 'Services'].\n\n<3> Operation: Use 'where' to filter using column 'Service_name' in table 'Services'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Customer_name FROM Customers AS T1 JOIN Customers_Policies AS T2 ON T1.Customer_ID  =  T2.Customer_ID JOIN First_Notification_of_Loss AS T3 ON T2.Customer_ID  =  T3.Customer_ID AND T2.Policy_ID  =  T3.Policy_ID JOIN Services AS T4 ON T3.Service_ID  =  T4.Service_ID WHERE T4.Service_name  =  \"Close a policy\" INTERSECT SELECT T1.Customer_name FROM Customers AS T1 JOIN Customers_Policies AS T2 ON T1.Customer_ID  =  T2.Customer_ID JOIN First_Notification_of_Loss AS T3 ON T2.Customer_ID  =  T3.Customer_ID AND T2.Policy_ID  =  T3.Policy_ID JOIN Services AS T4 ON T3.Service_ID  =  T4.Service_ID WHERE T4.Service_name  =  \"New policy application\"",
        "predict": "SELECT T1.Customer_name FROM Customers AS T1 JOIN Customers_Policies AS T2 ON T1.Customer_ID  =  T2.Customer_ID JOIN First_Notification_of_Loss AS T3 ON T2.Customer_ID  =  T3.Customer_ID AND T2.Policy_ID  =  T3.Policy_ID JOIN Services AS T4 ON T3.Service_ID  =  T4.Service_ID WHERE T4.Service_name  =  \"Close a policy\" INTERSECT SELECT T1.Customer_name FROM Customers AS T1 JOIN Customers_Policies AS T2 ON T1.Customer_ID  =  T2.Customer_ID JOIN First_Notification_of_Loss AS T3 ON T2.Customer_ID  =  T3.Customer_ID AND T2.Policy_ID  =  T3.Policy_ID JOIN Services AS T4 ON T3.Service_ID  =  T4.Service_ID WHERE T4.Service_name  =  \"New policy application\"",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT t1.customer_name FROM customers AS t1 JOIN first_notification_of_loss AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id WHERE t3.service_name  =  \"Close a policy\" INTERSECT SELECT t1.customer_name FROM customers AS t1 JOIN first_notification_of_loss AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id WHERE t3.service_name  =  \"New policy application\"",
        "question": "Which customers have used both the service named \"Close a policy\" and the service named \"Upgrade a policy\"? Give me the customer names.",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. which customers have used the service named \"Close a policy\"; 2. which customers have used the service named \"Upgrade a policy\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Customers', 'Customers_Policies', 'First_Notification_of_Loss', 'Services']. To complete the second subproblem, we also need to use tables ['Customers', 'Customers_Policies', 'First_Notification_of_Loss', 'Services'].\n\n<3> Operation: Use 'where' to filter using column 'Service_name' in table 'Services'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Customer_name FROM Customers AS T1 JOIN Customers_Policies AS T2 ON T1.Customer_ID  =  T2.Customer_ID JOIN First_Notification_of_Loss AS T3 ON T2.Customer_ID  =  T3.Customer_ID AND T2.Policy_ID  =  T3.Policy_ID JOIN Services AS T4 ON T3.Service_ID  =  T4.Service_ID WHERE T4.Service_name  =  \"Close a policy\" INTERSECT SELECT T1.Customer_name FROM Customers AS T1 JOIN Customers_Policies AS T2 ON T1.Customer_ID  =  T2.Customer_ID JOIN First_Notification_of_Loss AS T3 ON T2.Customer_ID  =  T3.Customer_ID AND T2.Policy_ID  =  T3.Policy_ID JOIN Services AS T4 ON T3.Service_ID  =  T4.Service_ID WHERE T4.Service_name  =  \"Upgrade a policy\"",
        "predict": "SELECT T1.Customer_name FROM Customers AS T1 JOIN Customers_Policies AS T2 ON T1.Customer_ID  =  T2.Customer_ID JOIN First_Notification_of_Loss AS T3 ON T2.Customer_ID  =  T3.Customer_ID AND T2.Policy_ID  =  T3.Policy_ID JOIN Services AS T4 ON T3.Service_ID  =  T4.Service_ID WHERE T4.Service_name  =  \"Close a policy\" INTERSECT SELECT T1.Customer_name FROM Customers AS T1 JOIN Customers_Policies AS T2 ON T1.Customer_ID  =  T2.Customer_ID JOIN First_Notification_of_Loss AS T3 ON T2.Customer_ID  =  T3.Customer_ID AND T2.Policy_ID  =  T3.Policy_ID JOIN Services AS T4 ON T3.Service_ID  =  T4.Service_ID WHERE T4.Service_name  =  \"Upgrade a policy\"",
        "hardness": "extra"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'",
        "question": "List the medicine name and trade name which can both interact as 'inhibitor' and 'activitor' with enzymes.",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the medicine names and trade names that can interact as 'inhibitor' with enzymes; 2. what are the medicine names and trade names that can interact as 'activator' with enzymes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['medicine', 'enzyme', 'medicine_enzyme_interaction']. To complete the second subproblem, we need to use tables ['medicine', 'enzyme', 'medicine_enzyme_interaction'].\n\n<3> Operation: Use 'where' to filter using column 'interaction_type' in table 'medicine_enzyme_interaction'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name, T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.medicine_id JOIN enzyme AS T3 ON T3.id = T2.enzyme_id WHERE T2.interaction_type = 'inhibitor' INTERSECT SELECT T1.name, T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.medicine_id JOIN enzyme AS T3 ON T3.id = T2.enzyme_id WHERE T2.interaction_type = 'activator'",
        "predict": "SELECT T1.name, T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.medicine_id JOIN enzyme AS T3 ON T3.id = T2.enzyme_id WHERE T2.interaction_type = 'inhibitor' INTERSECT SELECT T1.name, T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.medicine_id JOIN enzyme AS T3 ON T3.id = T2.enzyme_id WHERE T2.interaction_type = 'activator'",
        "hardness": "extra"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'",
        "question": "Show the medicine names and trade names that cannot interact with the enzyme with product 'Heme'.",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the medicine names and trade names; 2. what are the medicine names and trade names that interact with the enzyme with product 'Heme'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'medicine'. To complete the second subproblem, we need to use tables ['medicine', 'medicine_enzyme_interaction', 'enzyme'].\n\n<3> Operation: Use 'where' to filter using column 'product' in table 'enzyme'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT name, trade_name FROM medicine EXCEPT SELECT T1.name, T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.medicine_id JOIN enzyme AS T3 ON T2.enzyme_id = T3.id WHERE T3.product = 'Heme'",
        "predict": "SELECT name, trade_name FROM medicine EXCEPT SELECT T1.name, T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.medicine_id JOIN enzyme AS T3 ON T2.enzyme_id = T3.id WHERE T3.product = 'Heme'",
        "hardness": "extra"
    },
    {
        "db_id": "phone_1",
        "gold": "SELECT model_name FROM chip_model EXCEPT SELECT chip_model FROM phone WHERE Accreditation_type  =  'Full'",
        "question": "Find the names of the chip models that are not used by any phone with full accreditation type.",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all chip models; 2. what are the names of chip models that are used by phones with full accreditation type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['chip_model']. To complete the second subproblem, we need to use tables ['chip_model', 'phone'].\n\n<3> Operation: Use 'where' to filter using column 'Accreditation_type' in table 'phone'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Model_name FROM chip_model EXCEPT SELECT T1.Model_name FROM chip_model AS T1 JOIN phone AS T2 ON T1.Model_name  =  T2.chip_model WHERE T2.Accreditation_type  =  \"full\"",
        "predict": "SELECT Model_name FROM chip_model EXCEPT SELECT T1.Model_name FROM chip_model AS T1 JOIN phone AS T2 ON T1.Model_name  =  T2.chip_model WHERE T2.Accreditation_type  =  \"full\"",
        "hardness": "hard"
    },
    {
        "db_id": "phone_1",
        "gold": "SELECT t1.pixels FROM screen_mode AS t1 JOIN phone AS t2 ON t1.Graphics_mode  =  t2.screen_mode WHERE t2.Accreditation_type  =  'Provisional' INTERSECT SELECT t1.pixels FROM screen_mode AS t1 JOIN phone AS t2 ON t1.Graphics_mode  =  t2.screen_mode WHERE t2.Accreditation_type  =  'Full'",
        "question": "Find the pixels of the screen modes that are used by both phones with full accreditation types and phones with Provisional accreditation types.",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the pixels of the screen modes used by phones with full accreditation types; 2. what are the pixels of the screen modes used by phones with Provisional accreditation types.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['phone', 'screen_mode']. To complete the second subproblem, we need to use tables ['phone', 'screen_mode'].\n\n<3> Operation: Use 'where' to filter using column 'Accreditation_type' in table 'phone'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T2.Pixels FROM phone AS T1 JOIN screen_mode AS T2 ON T1.screen_mode  =  T2.Graphics_mode WHERE T1.Accreditation_type  =  \"full\" INTERSECT SELECT T2.Pixels FROM phone AS T1 JOIN screen_mode AS T2 ON T1.screen_mode  =  T2.Graphics_mode WHERE T1.Accreditation_type  =  \"Provisional\"",
        "predict": "SELECT T2.Pixels FROM phone AS T1 JOIN screen_mode AS T2 ON T1.screen_mode  =  T2.Graphics_mode WHERE T1.Accreditation_type  =  \"full\" INTERSECT SELECT T2.Pixels FROM phone AS T1 JOIN screen_mode AS T2 ON T1.screen_mode  =  T2.Graphics_mode WHERE T1.Accreditation_type  =  \"Provisional\"",
        "hardness": "extra"
    },
    {
        "db_id": "match_season",
        "gold": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  \"Forward\" INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  \"Defender\"",
        "question": "What are the names of countries that have both players with position forward and players with position defender?",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of countries that have players with position forward; 2. what are the names of countries that have players with position defender.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'match_season']. To complete the second subproblem, we also need to use tables ['country', 'match_season'].\n\n<3> Operation: Use 'where' to filter using column 'Position' in table 'match_season'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  \"forward\" INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  \"defender\"",
        "predict": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  \"forward\" INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  \"defender\"",
        "hardness": "extra"
    },
    {
        "db_id": "climbing",
        "gold": "SELECT Country FROM mountain WHERE Height  >  5600 INTERSECT SELECT Country FROM mountain WHERE Height  <  5200",
        "question": "Show the countries that have mountains with height more than 5600 stories and mountains with height less than 5200.",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the countries that have mountains with height more than 5600 stories; 2. what are the countries that have mountains with height less than 5200 stories.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['mountain']. To complete the second subproblem, we need to use tables ['mountain'].\n\n<3> Operation: Use 'where' to filter using column 'Height' in table 'mountain'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT DISTINCT T1.Country FROM mountain AS T1 WHERE T1.Height  >  5600 INTERSECT SELECT DISTINCT T1.Country FROM mountain AS T1 WHERE T1.Height  <  5200",
        "predict": "SELECT DISTINCT T1.Country FROM mountain AS T1 WHERE T1.Height  >  5600 INTERSECT SELECT DISTINCT T1.Country FROM mountain AS T1 WHERE T1.Height  <  5200",
        "hardness": "hard"
    },
    {
        "db_id": "climbing",
        "gold": "SELECT Country FROM mountain WHERE Height  >  5600 INTERSECT SELECT Country FROM mountain WHERE Height  <  5200",
        "question": "What are the countries that have both mountains that are higher than 5600 and lower than 5200?",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the countries that have mountains higher than 5600; 2. what are the countries that have mountains lower than 5200.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['climber', 'mountain'].\n\n<3> Operation: Use 'where' to filter using column 'Height' in table 'mountain'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Country FROM mountain AS T1 WHERE T1.Height  >  5600 INTERSECT SELECT T1.Country FROM mountain AS T1 WHERE T1.Height  <  5200",
        "predict": "SELECT T1.Country FROM mountain AS T1 WHERE T1.Height  >  5600 INTERSECT SELECT T1.Country FROM mountain AS T1 WHERE T1.Height  <  5200",
        "hardness": "hard"
    },
    {
        "db_id": "body_builder",
        "gold": "SELECT Name ,  birth_place FROM people EXCEPT SELECT T1.Name ,  T1.birth_place FROM people AS T1 JOIN body_builder AS T2 ON T1.people_id  =  T2.people_id",
        "question": "List the names and origins of people who are not body builders.",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all people; 2. what are the names of people who are body builders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'people'. To complete the second subproblem, we need to use tables ['people', 'body_builder'].\n\n<3> Operation: Use 'where' to filter out the people who are body builders.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT name, birth_place FROM people EXCEPT SELECT t1.name, t1.birth_place FROM people AS t1 JOIN body_builder AS t2 ON t1.people_id = t2.people_id",
        "predict": "SELECT name, birth_place FROM people EXCEPT SELECT t1.name, t1.birth_place FROM people AS t1 JOIN body_builder AS t2 ON t1.people_id = t2.people_id",
        "hardness": "extra"
    },
    {
        "db_id": "election_representative",
        "gold": "SELECT Party FROM representative WHERE State  =  \"New York\" INTERSECT SELECT Party FROM representative WHERE State  =  \"Pennsylvania\"",
        "question": "Show the parties that have both representatives in New York state and representatives in Pennsylvania state.",
        "fields": "Table election, columns = [*,Election_ID,Representative_ID,Date,Votes,Vote_Percent,Seats,Place]\nTable representative, columns = [*,Representative_ID,Name,State,Party,Lifespan]\n",
        "foreign_keys": "Foreign_keys = [election.Representative_ID = representative.Representative_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the parties that have representatives in New York state; 2. what are the parties that have representatives in Pennsylvania state.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['election', 'representative']. To complete the second subproblem, we need to use tables ['election', 'representative'].\n\n<3> Operation: Use 'where' to filter using column 'State' in table 'representative'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Party FROM representative AS T1 JOIN election AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE T1.State  =  \"New York\" INTERSECT SELECT T1.Party FROM representative AS T1 JOIN election AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE T1.State  =  \"Pennsylvania\"",
        "predict": "SELECT T1.Party FROM representative AS T1 JOIN election AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE T1.State  =  \"New York\" INTERSECT SELECT T1.Party FROM representative AS T1 JOIN election AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE T1.State  =  \"Pennsylvania\"",
        "hardness": "hard"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  \"Confirmed\" INTERSECT SELECT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  \"Provisional\"",
        "question": "Show the apartment numbers of apartments with bookings that have status code both \"Provisional\" and \"Confirmed\"",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the apartment numbers of apartments with bookings that have status code \"Provisional\"; 2. what are the apartment numbers of apartments with bookings that have status code \"Confirmed\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Apartments', 'Apartment_Bookings']. To complete the second subproblem, we need to use tables ['Apartments', 'Apartment_Bookings'].\n\n<3> Operation: Use 'where' to filter using column 'booking_status_code' in table 'Apartment_Bookings'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.apt_number FROM Apartments AS T1 JOIN Apartment_Bookings AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.booking_status_code  =  \"Provisional\" INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN Apartment_Bookings AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.booking_status_code  =  \"Confirmed\"",
        "predict": "SELECT T1.apt_number FROM Apartments AS T1 JOIN Apartment_Bookings AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.booking_status_code  =  \"Provisional\" INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN Apartment_Bookings AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.booking_status_code  =  \"Confirmed\"",
        "hardness": "extra"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  \"Confirmed\" INTERSECT SELECT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  \"Provisional\"",
        "question": "Which apartments have bookings with both status codes \"Provisional\" and \"Confirmed\"? Give me the apartment numbers.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. which apartments have bookings with status code \"Provisional\"; 2. which apartments have bookings with status code \"Confirmed\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Apartments', 'Apartment_Bookings'].\n\n<3> Operation: Use 'where' to filter using column 'booking_status_code' in table 'Apartment_Bookings'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT apt_number FROM Apartments AS T1 JOIN Apartment_Bookings AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.booking_status_code  =  \"Provisional\" INTERSECT SELECT apt_number FROM Apartments AS T1 JOIN Apartment_Bookings AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.booking_status_code  =  \"Confirmed\"",
        "predict": "SELECT apt_number FROM Apartments AS T1 JOIN Apartment_Bookings AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.booking_status_code  =  \"Provisional\" INTERSECT SELECT apt_number FROM Apartments AS T1 JOIN Apartment_Bookings AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.booking_status_code  =  \"Confirmed\"",
        "hardness": "extra"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1",
        "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the apartment numbers of apartments with unit status availability of 0; 2. what are the apartment numbers of apartments with unit status availability of 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Apartments', 'View_Unit_Status'].\n\n<3> Operation: Use 'where' to filter using column 'available_yn' in table 'View_Unit_Status'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1",
        "predict": "SELECT apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1",
        "hardness": "extra"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1",
        "question": "Which apartments have unit status availability of both 0 and 1? Return their apartment numbers.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. which apartments have unit status availability of 0; 2. which apartments have unit status availability of 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Apartments', 'View_Unit_Status'].\n\n<3> Operation: Use 'where' to filter using column 'available_yn' in table 'View_Unit_Status'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1",
        "predict": "SELECT apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1",
        "hardness": "extra"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT T2.name FROM game AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.id JOIN injury_accident AS T3 ON T1.id  =  T3.game_id WHERE T3.player  =  'Walter Samuel' INTERSECT SELECT T2.name FROM game AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.id JOIN injury_accident AS T3 ON T1.id  =  T3.game_id WHERE T3.player  =  'Thiago Motta'",
        "question": "List the name of the stadium where both the player 'Walter Samuel' and the player 'Thiago Motta' got injured.",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what is the name of the stadium where the player 'Walter Samuel' got injured; 2. what is the name of the stadium where the player 'Thiago Motta' got injured.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['game', 'injury_accident', 'stadium'].\n\n<3> Operation: Use 'where' to filter using column 'Player' in table 'injury_accident'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T3.name FROM game AS T1 JOIN injury_accident AS T2 ON T1.id  =  T2.game_id JOIN stadium AS T3 ON T1.stadium_id  =  T3.id WHERE T2.Player  =  'Walter Samuel' INTERSECT SELECT T3.name FROM game AS T1 JOIN injury_accident AS T2 ON T1.id  =  T2.game_id JOIN stadium AS T3 ON T1.stadium_id  =  T3.id WHERE T2.Player  =  'Thiago Motta'",
        "predict": "SELECT T3.name FROM game AS T1 JOIN injury_accident AS T2 ON T1.id  =  T2.game_id JOIN stadium AS T3 ON T1.stadium_id  =  T3.id WHERE T2.Player  =  'Walter Samuel' INTERSECT SELECT T3.name FROM game AS T1 JOIN injury_accident AS T2 ON T1.id  =  T2.game_id JOIN stadium AS T3 ON T1.stadium_id  =  T3.id WHERE T2.Player  =  'Thiago Motta'",
        "hardness": "extra"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT name ,  average_attendance ,  total_attendance FROM stadium EXCEPT SELECT T2.name ,  T2.average_attendance ,  T2.total_attendance FROM game AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.id JOIN injury_accident AS T3 ON T1.id  =  T3.game_id",
        "question": "Show the name, average attendance, total attendance for stadiums where no accidents happened.",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names, average attendance, and total attendance for all stadiums; 2. what are the names, average attendance, and total attendance for stadiums where accidents happened.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'stadium'. To complete the second subproblem, we need to use tables ['stadium', 'game', 'injury_accident'].\n\n<3> Operation: Use 'where' to filter out stadiums where accidents happened by checking if there are any records in the 'injury_accident' table for each stadium.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT name, average_attendance, total_attendance FROM stadium EXCEPT SELECT T1.name, T1.average_attendance, T1.total_attendance FROM stadium AS T1 JOIN game AS T2 ON T1.id = T2.stadium_id JOIN injury_accident AS T3 ON T2.id = T3.game_id",
        "predict": "SELECT name, average_attendance, total_attendance FROM stadium EXCEPT SELECT T1.name, T1.average_attendance, T1.total_attendance FROM stadium AS T1 JOIN game AS T2 ON T1.id = T2.stadium_id JOIN injury_accident AS T3 ON T2.id = T3.game_id",
        "hardness": "extra"
    },
    {
        "db_id": "performance_attendance",
        "gold": "SELECT LOCATION FROM performance WHERE Attendance  >  2000 INTERSECT SELECT LOCATION FROM performance WHERE Attendance  <  1000",
        "question": "Show the locations that have both performances with more than 2000 attendees and performances with less than 1000 attendees.",
        "fields": "Table member, columns = [*,Member_ID,Name,Nationality,Role]\nTable member_attendance, columns = [*,Member_ID,Performance_ID,Num_of_Pieces]\nTable performance, columns = [*,Performance_ID,Date,Host,Location,Attendance]\n",
        "foreign_keys": "Foreign_keys = [member_attendance.Performance_ID = performance.Performance_ID,member_attendance.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the locations that have performances with more than 2000 attendees; 2. what are the locations that have performances with less than 1000 attendees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['performance', 'member_attendance']. To complete the second subproblem, we need to use tables ['performance', 'member_attendance'].\n\n<3> Operation: Use 'where' to filter using column 'Attendance' in table 'performance'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Location FROM performance AS T1 JOIN member_attendance AS T2 ON T1.Performance_ID  =  T2.Performance_ID WHERE T1.Attendance  >  2000 INTERSECT SELECT T1.Location FROM performance AS T1 JOIN member_attendance AS T2 ON T1.Performance_ID  =  T2.Performance_ID WHERE T1.Attendance  <  1000",
        "predict": "SELECT T1.Location FROM performance AS T1 JOIN member_attendance AS T2 ON T1.Performance_ID  =  T2.Performance_ID WHERE T1.Attendance  >  2000 INTERSECT SELECT T1.Location FROM performance AS T1 JOIN member_attendance AS T2 ON T1.Performance_ID  =  T2.Performance_ID WHERE T1.Attendance  <  1000",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT title FROM course WHERE dept_name  =  'Statistics' INTERSECT SELECT title FROM course WHERE dept_name  =  'Psychology'",
        "question": "Find the title of course that is provided by both Statistics and Psychology departments.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the titles of courses provided by the Statistics department; 2. what are the titles of courses provided by the Psychology department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['course', 'department']. To complete the second subproblem, we also need to use tables ['course', 'department'].\n\n<3> Operation: Use 'where' to filter using column 'dept_name' in table 'department'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Statistics\" INTERSECT SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Psychology\"",
        "predict": "SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Statistics\" INTERSECT SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Psychology\"",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT title FROM course WHERE dept_name  =  'Statistics' INTERSECT SELECT title FROM course WHERE dept_name  =  'Psychology'",
        "question": "What is the title of a course that is listed in both the Statistics and Psychology departments?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the titles of courses listed in the Statistics department; 2. what are the titles of courses listed in the Psychology department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['course', 'department']. To complete the second subproblem, we also need to use tables ['course', 'department'].\n\n<3> Operation: Use 'where' to filter using column 'dept_name' in table 'department'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Statistics\" INTERSECT SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Psychology\"",
        "predict": "SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Statistics\" INTERSECT SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Psychology\"",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'",
        "question": "Find the title of course that is provided by Statistics but not Psychology departments.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the titles of courses provided by the Statistics department; 2. what are the titles of courses provided by the Psychology department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['course', 'department']. To complete the second subproblem, we also need to use tables ['course', 'department'].\n\n<3> Operation: Use 'where' to filter using column 'dept_name' in table 'course'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Statistics\" EXCEPT SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Psychology\"",
        "predict": "SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Statistics\" EXCEPT SELECT T1.title FROM course AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name WHERE T2.dept_name  =  \"Psychology\"",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'",
        "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the titles of courses that are in the Statistics department; 2. what are the titles of courses that are in the Psychology department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['course', 'department']. To complete the second subproblem, we also need to use tables ['course', 'department'].\n\n<3> Operation: Use 'where' to filter using column 'dept_name' in table 'course'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT title FROM course WHERE dept_name  =  \"Statistics\" EXCEPT SELECT title FROM course WHERE dept_name  =  \"Psychology\"",
        "predict": "SELECT title FROM course WHERE dept_name  =  \"Statistics\" EXCEPT SELECT title FROM course WHERE dept_name  =  \"Psychology\"",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT id FROM teaches WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT id FROM teaches WHERE semester  =  'Spring' AND YEAR  =  2010",
        "question": "Find the id of instructors who taught a class in Fall 2009 but not in Spring 2010.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of instructors who taught a class in Fall 2009; 2. what are the ids of instructors who taught a class in Spring 2010.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['instructor', 'teaches', 'section']. To complete the second subproblem, we also need to use tables ['instructor', 'teaches', 'section'].\n\n<3> Operation: Use 'where' to filter using column 'semester' and 'year' in table 'section'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.ID FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID JOIN section AS T3 ON T2.course_id  =  T3.course_id AND T2.sec_id  =  T3.sec_id AND T2.semester  =  T3.semester AND T2.year  =  T3.year WHERE T3.semester  =  \"Fall\" AND T3.year  =  2009 EXCEPT SELECT T1.ID FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID JOIN section AS T3 ON T2.course_id  =  T3.course_id AND T2.sec_id  =  T3.sec_id AND T2.semester  =  T3.semester AND T2.year  =  T3.year WHERE T3.semester  =  \"Spring\" AND T3.year  =  2010",
        "predict": "SELECT T1.ID FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID JOIN section AS T3 ON T2.course_id  =  T3.course_id AND T2.sec_id  =  T3.sec_id AND T2.semester  =  T3.semester AND T2.year  =  T3.year WHERE T3.semester  =  \"Fall\" AND T3.year  =  2009 EXCEPT SELECT T1.ID FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID JOIN section AS T3 ON T2.course_id  =  T3.course_id AND T2.sec_id  =  T3.sec_id AND T2.semester  =  T3.semester AND T2.year  =  T3.year WHERE T3.semester  =  \"Spring\" AND T3.year  =  2010",
        "hardness": "extra"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT id FROM teaches WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT id FROM teaches WHERE semester  =  'Spring' AND YEAR  =  2010",
        "question": "What are the ids of instructors who taught in the Fall of 2009 but not in the Spring of 2010?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of instructors who taught in the Fall of 2009; 2. what are the ids of instructors who taught in the Spring of 2010.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['instructor', 'teaches', 'section']. To complete the second subproblem, we also need to use tables ['instructor', 'teaches', 'section'].\n\n<3> Operation: Use 'where' to filter using column 'semester' and 'year' in table 'section'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.ID FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID JOIN section AS T3 ON T2.course_id  =  T3.course_id AND T2.sec_id  =  T3.sec_id AND T2.semester  =  T3.semester AND T2.year  =  T3.year WHERE T3.semester  =  \"Fall\" AND T3.year  =  2009 EXCEPT SELECT T1.ID FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID JOIN section AS T3 ON T2.course_id  =  T3.course_id AND T2.sec_id  =  T3.sec_id AND T2.semester  =  T3.semester AND T2.year  =  T3.year WHERE T3.semester  =  \"Spring\" AND T3.year  =  2010",
        "predict": "SELECT T1.ID FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID JOIN section AS T3 ON T2.course_id  =  T3.course_id AND T2.sec_id  =  T3.sec_id AND T2.semester  =  T3.semester AND T2.year  =  T3.year WHERE T3.semester  =  \"Fall\" AND T3.year  =  2009 EXCEPT SELECT T1.ID FROM instructor AS T1 JOIN teaches AS T2 ON T1.ID  =  T2.ID JOIN section AS T3 ON T2.course_id  =  T3.course_id AND T2.sec_id  =  T3.sec_id AND T2.semester  =  T3.semester AND T2.year  =  T3.year WHERE T3.semester  =  \"Spring\" AND T3.year  =  2010",
        "hardness": "extra"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT course_id FROM course EXCEPT SELECT course_id FROM prereq",
        "question": "Find the id of the courses that do not have any prerequisite?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of all courses; 2. what are the ids of courses that have prerequisites.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['course']. To complete the second subproblem, we need to use tables ['course', 'prereq'].\n\n<3> Operation: Use 'where' to filter using column 'prereq_id' in table 'prereq'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT course_id FROM course EXCEPT SELECT t1.course_id FROM course AS t1 JOIN prereq AS t2 ON t1.course_id  =  t2.course_id WHERE t2.prereq_id IS NOT NULL",
        "predict": "SELECT course_id FROM course EXCEPT SELECT t1.course_id FROM course AS t1 JOIN prereq AS t2 ON t1.course_id  =  t2.course_id WHERE t2.prereq_id IS NOT NULL",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT course_id FROM course EXCEPT SELECT course_id FROM prereq",
        "question": "What are the ids of courses without prerequisites?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of all courses; 2. what are the ids of courses that have prerequisites.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'course'. To complete the second subproblem, we need to use tables 'course' and 'prereq'.\n\n<3> Operation: Use 'where' to filter using column 'course_id' in table 'prereq'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT course_id FROM course EXCEPT SELECT t1.course_id FROM course AS t1 JOIN prereq AS t2 ON t1.course_id  =  t2.course_id",
        "predict": "SELECT course_id FROM course EXCEPT SELECT t1.course_id FROM course AS t1 JOIN prereq AS t2 ON t1.course_id  =  t2.course_id",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT id FROM instructor EXCEPT SELECT id FROM teaches",
        "question": "Find the id of instructors who didn't teach any courses?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of all instructors; 2. what are the ids of instructors who taught courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['instructor']. To complete the second subproblem, we need to use tables ['instructor', 'teaches'].\n\n<3> Operation: Use 'where' to filter using column 'ID' in table 'teaches'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT ID FROM instructor EXCEPT SELECT ID FROM teaches",
        "predict": "SELECT ID FROM instructor EXCEPT SELECT ID FROM teaches",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT id FROM instructor EXCEPT SELECT id FROM teaches",
        "question": "What are the ids of instructors who didnt' teach?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of all instructors; 2. what are the ids of instructors who taught.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'instructor'. To complete the second subproblem, we need to use tables ['instructor', 'teaches'].\n\n<3> Operation: Use 'where' to filter using column 'ID' in table 'teaches'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT ID FROM instructor EXCEPT SELECT t1.ID FROM instructor AS t1 JOIN teaches AS t2 ON t1.ID  =  t2.ID",
        "predict": "SELECT ID FROM instructor EXCEPT SELECT t1.ID FROM instructor AS t1 JOIN teaches AS t2 ON t1.ID  =  t2.ID",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 UNION SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010",
        "question": "What are the ids for courses in the Fall of 2009 or the Spring of 2010?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the ids for courses in the Fall of 2009; 2. what are the ids for courses in the Spring of 2010.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use the table 'section'.\n\n<3> Operation: Use 'where' to filter using columns 'semester' and 'year' in table 'section'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT course_id FROM section WHERE semester  =  \"Fall\" AND year  =  2009 UNION SELECT course_id FROM section WHERE semester  =  \"Spring\" AND year  =  2010",
        "predict": "SELECT course_id FROM section WHERE semester  =  \"Fall\" AND year  =  2009 UNION SELECT course_id FROM section WHERE semester  =  \"Spring\" AND year  =  2010",
        "hardness": "extra"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 INTERSECT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010",
        "question": "Find courses that ran in Fall 2009 and in Spring 2010.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the courses that ran in Fall 2009; 2. what are the courses that ran in Spring 2010.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['course', 'section'].\n\n<3> Operation: Use 'where' to filter using columns 'semester' and 'year' in table 'section'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.course_id, T1.title FROM course AS T1 JOIN section AS T2 ON T1.course_id = T2.course_id WHERE T2.semester = 'Fall' AND T2.year = 2009 INTERSECT SELECT T1.course_id, T1.title FROM course AS T1 JOIN section AS T2 ON T1.course_id = T2.course_id WHERE T2.semester = 'Spring' AND T2.year = 2010",
        "predict": "SELECT T1.course_id, T1.title FROM course AS T1 JOIN section AS T2 ON T1.course_id = T2.course_id WHERE T2.semester = 'Fall' AND T2.year = 2009 INTERSECT SELECT T1.course_id, T1.title FROM course AS T1 JOIN section AS T2 ON T1.course_id = T2.course_id WHERE T2.semester = 'Spring' AND T2.year = 2010",
        "hardness": "extra"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 INTERSECT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010",
        "question": "What are the ids for courses that were offered in both Fall of 2009 and Spring of 2010?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the ids for courses that were offered in Fall of 2009; 2. what are the ids for courses that were offered in Spring of 2010.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['course', 'section']. To complete the second subproblem, we also need to use tables ['course', 'section'].\n\n<3> Operation: Use 'where' to filter using columns 'semester' and 'year' in table 'section'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.course_id FROM course AS T1 JOIN section AS T2 ON T1.course_id  =  T2.course_id WHERE T2.semester  =  \"Fall\" AND T2.year  =  2009 INTERSECT SELECT T1.course_id FROM course AS T1 JOIN section AS T2 ON T1.course_id  =  T2.course_id WHERE T2.semester  =  \"Spring\" AND T2.year  =  2010",
        "predict": "SELECT T1.course_id FROM course AS T1 JOIN section AS T2 ON T1.course_id  =  T2.course_id WHERE T2.semester  =  \"Fall\" AND T2.year  =  2009 INTERSECT SELECT T1.course_id FROM course AS T1 JOIN section AS T2 ON T1.course_id  =  T2.course_id WHERE T2.semester  =  \"Spring\" AND T2.year  =  2010",
        "hardness": "extra"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010",
        "question": "What are the ids of courses offered in Fall of 2009 but not in Spring of 2010?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of courses offered in Fall of 2009; 2. what are the ids of courses offered in Spring of 2010.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['section']. To complete the second subproblem, we also need to use table ['section'].\n\n<3> Operation: Use 'where' to filter using columns 'semester' and 'year' in table 'section'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT course_id FROM section WHERE semester  =  \"Fall\" AND year  =  2009 EXCEPT SELECT course_id FROM section WHERE semester  =  \"Spring\" AND year  =  2010",
        "predict": "SELECT course_id FROM section WHERE semester  =  \"Fall\" AND year  =  2009 EXCEPT SELECT course_id FROM section WHERE semester  =  \"Spring\" AND year  =  2010",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_and_eClaims",
        "gold": "SELECT customer_details FROM customers EXCEPT SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id",
        "question": "Find the names of customers who have no policies associated.",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all customers; 2. what are the names of customers who have policies associated.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Customers']. To complete the second subproblem, we need to use tables ['Customers', 'Policies'].\n\n<3> Operation: Use 'where' to filter using column 'Customer_ID' in table 'Policies'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Customer_Details FROM Customers EXCEPT SELECT t1.Customer_Details FROM Customers AS t1 JOIN Policies AS t2 ON t1.Customer_ID  =  t2.Customer_ID",
        "predict": "SELECT Customer_Details FROM Customers EXCEPT SELECT t1.Customer_Details FROM Customers AS t1 JOIN Policies AS t2 ON t1.Customer_ID  =  t2.Customer_ID",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_and_eClaims",
        "gold": "SELECT customer_details FROM customers EXCEPT SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id",
        "question": "What are the names of customers who do not have any policies?",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all customers; 2. what are the names of customers who have policies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Customers']. To complete the second subproblem, we need to use tables ['Customers', 'Policies'].\n\n<3> Operation: Use 'where' to filter using column 'Customer_ID' in table 'Policies'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Customer_Details FROM Customers EXCEPT SELECT t1.Customer_Details FROM Customers AS t1 JOIN Policies AS t2 ON t1.Customer_ID  =  t2.Customer_ID",
        "predict": "SELECT Customer_Details FROM Customers EXCEPT SELECT t1.Customer_Details FROM Customers AS t1 JOIN Policies AS t2 ON t1.Customer_ID  =  t2.Customer_ID",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_and_eClaims",
        "gold": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff",
        "question": "Find the names of all the customers and staff members.",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the names of all the customers; 2. what are the names of all the staff members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Customers']. To complete the second subproblem, we need to use table ['Staff'].\n\n<3> Operation: No specific operation is required for this query.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Customer_Details FROM Customers UNION SELECT Staff_Details FROM Staff",
        "predict": "SELECT Customer_Details FROM Customers UNION SELECT Staff_Details FROM Staff",
        "hardness": "hard"
    },
    {
        "db_id": "insurance_and_eClaims",
        "gold": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff",
        "question": "What are the names of the customers and staff members?",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query does not emphasize any specific set operations, so we can decompose the question into one subproblem: what are the names of the customers and staff members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the subproblem, we need to use tables ['Customers', 'Staff'].\n\n<3> Operation: No specific operations are required for this query.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Customer_Details AS name FROM Customers UNION SELECT Staff_Details AS name FROM Staff",
        "predict": "SELECT Customer_Details AS name FROM Customers UNION SELECT Staff_Details AS name FROM Staff",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT customer_id FROM Customers EXCEPT SELECT customer_id FROM Accounts",
        "question": "Show customer ids who don't have an account.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the customer ids who have accounts; 2. what are all the customer ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Customers', 'Accounts']. To complete the second subproblem, we need to use table ['Customers'].\n\n<3> Operation: Use 'where' to filter using column 'customer_id' in table 'Accounts'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT customer_id FROM customers EXCEPT SELECT customer_id FROM accounts",
        "predict": "SELECT customer_id FROM customers EXCEPT SELECT customer_id FROM accounts",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT customer_id FROM Customers EXCEPT SELECT customer_id FROM Accounts",
        "question": "What are the customer ids for customers who do not have an account?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the customer ids for all customers; 2. what are the customer ids for customers who have an account.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Customers'. To complete the second subproblem, we need to use tables ['Customers', 'Accounts'].\n\n<3> Operation: Use 'where' to filter using column 'customer_id' in table 'Accounts'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT customer_id FROM customers EXCEPT SELECT customer_id FROM accounts",
        "predict": "SELECT customer_id FROM customers EXCEPT SELECT customer_id FROM accounts",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT product_name FROM Products EXCEPT SELECT T1.product_name FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id",
        "question": "Show all product names without an order.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are all the product names; 2. what are the product names that have an order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Products'. To complete the second subproblem, we need to use tables ['Products', 'Order_Items', 'Orders'].\n\n<3> Operation: Use 'where' to filter using column 'product_id' in table 'Order_Items'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT product_name FROM products EXCEPT SELECT t1.product_name FROM products AS t1 JOIN order_items AS t2 ON t1.product_id  =  t2.product_id JOIN orders AS t3 ON t2.order_id  =  t3.order_id",
        "predict": "SELECT product_name FROM products EXCEPT SELECT t1.product_name FROM products AS t1 JOIN order_items AS t2 ON t1.product_id  =  t2.product_id JOIN orders AS t3 ON t2.order_id  =  t3.order_id",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT product_name FROM Products EXCEPT SELECT T1.product_name FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id",
        "question": "What are the names of products that have never been ordered?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the product names that have been ordered; 2. what are all the product names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Products', 'Order_Items']. To complete the second subproblem, we need to use table ['Products'].\n\n<3> Operation: Use 'where' to filter using column 'product_id' in table 'Order_Items'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT product_name FROM products EXCEPT SELECT t1.product_name FROM products AS t1 JOIN order_items AS t2 ON t1.product_id  =  t2.product_id",
        "predict": "SELECT product_name FROM products EXCEPT SELECT t1.product_name FROM products AS t1 JOIN order_items AS t2 ON t1.product_id  =  t2.product_id",
        "hardness": "hard"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT country FROM people WHERE age  <  25 INTERSECT SELECT country FROM people WHERE age  >  30",
        "question": "Show the country where people older than 30 and younger than 25 are from.",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the countries of people older than 30; 2. what are the countries of people younger than 25.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use table 'people'.\n\n<3> Operation: Use 'where' to filter using column 'Age' in table 'people'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT DISTINCT Country FROM people WHERE Age > 30 INTERSECT SELECT DISTINCT Country FROM people WHERE Age < 25",
        "predict": "SELECT DISTINCT Country FROM people WHERE Age > 30 INTERSECT SELECT DISTINCT Country FROM people WHERE Age < 25",
        "hardness": "hard"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT name FROM church EXCEPT SELECT T1.name FROM church AS T1 JOIN wedding AS T2 ON T1.church_id  =  T2.church_id WHERE T2.year  =  2015",
        "question": "Show all church names except for those that had a wedding in year 2015.",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are all the church names; 2. what are the church names that had a wedding in year 2015.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'church'. To complete the second subproblem, we need to use tables 'church' and 'wedding'.\n\n<3> Operation: Use 'where' to filter using column 'Year' in table 'wedding'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Name FROM church EXCEPT SELECT T1.Name FROM church AS T1 JOIN wedding AS T2 ON T1.Church_ID  =  T2.Church_ID WHERE T2.Year  =  2015",
        "predict": "SELECT Name FROM church EXCEPT SELECT T1.Name FROM church AS T1 JOIN wedding AS T2 ON T1.Church_ID  =  T2.Church_ID WHERE T2.Year  =  2015",
        "hardness": "hard"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT name FROM artist EXCEPT SELECT T2.name FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id WHERE T1.year  =  2004",
        "question": "Show all artist names who didn't have an exhibition in 2004.",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the artist names who had an exhibition in 2004; 2. what are all the artist names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['artist', 'exhibition']. To complete the second subproblem, we need to use table ['artist'].\n\n<3> Operation: Use 'where' to filter using column 'Year' in table 'exhibition'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT name FROM artist EXCEPT SELECT T1.name FROM artist AS T1 JOIN exhibition AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Year  =  2004",
        "predict": "SELECT name FROM artist EXCEPT SELECT T1.name FROM artist AS T1 JOIN exhibition AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Year  =  2004",
        "hardness": "hard"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT name FROM artist EXCEPT SELECT T2.name FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id WHERE T1.year  =  2004",
        "question": "What are the names of artists who did not have an exhibition in 2004?",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all artists; 2. what are the names of artists who had an exhibition in 2004.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'artist'. To complete the second subproblem, we need to use tables ['artist', 'exhibition'].\n\n<3> Operation: Use 'where' to filter using column 'Year' in table 'exhibition'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Name FROM artist EXCEPT SELECT T1.Name FROM artist AS T1 JOIN exhibition AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Year  =  2004",
        "predict": "SELECT Name FROM artist EXCEPT SELECT T1.Name FROM artist AS T1 JOIN exhibition AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Year  =  2004",
        "hardness": "hard"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT T2.theme FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  <  100 INTERSECT SELECT T2.theme FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  >  500",
        "question": "Show the theme for exhibitions with both records of an attendance below 100 and above 500.",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the themes of exhibitions with attendance below 100; 2. what are the themes of exhibitions with attendance above 500.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['exhibition', 'exhibition_record']. To complete the second subproblem, we need to use tables ['exhibition', 'exhibition_record'].\n\n<3> Operation: Use 'where' to filter using column 'Attendance' in table 'exhibition_record'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Theme FROM exhibition AS T1 JOIN exhibition_record AS T2 ON T1.Exhibition_ID  =  T2.Exhibition_ID WHERE T2.Attendance  <  100 INTERSECT SELECT T1.Theme FROM exhibition AS T1 JOIN exhibition_record AS T2 ON T1.Exhibition_ID  =  T2.Exhibition_ID WHERE T2.Attendance  >  500",
        "predict": "SELECT T1.Theme FROM exhibition AS T1 JOIN exhibition_record AS T2 ON T1.Exhibition_ID  =  T2.Exhibition_ID WHERE T2.Attendance  <  100 INTERSECT SELECT T1.Theme FROM exhibition AS T1 JOIN exhibition_record AS T2 ON T1.Exhibition_ID  =  T2.Exhibition_ID WHERE T2.Attendance  >  500",
        "hardness": "extra"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT T2.theme FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  <  100 INTERSECT SELECT T2.theme FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  >  500",
        "question": "Which themes have had corresponding exhibitions that have had attendance both below 100 and above 500?",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the themes of exhibitions that have had attendance below 100; 2. what are the themes of exhibitions that have had attendance above 500.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['exhibition', 'exhibition_record'].\n\n<3> Operation: Use 'where' to filter using column 'Attendance' in table 'exhibition_record'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Theme FROM exhibition AS T1 JOIN exhibition_record AS T2 ON T1.Exhibition_ID  =  T2.Exhibition_ID WHERE T2.Attendance  <  100 INTERSECT SELECT T1.Theme FROM exhibition AS T1 JOIN exhibition_record AS T2 ON T1.Exhibition_ID  =  T2.Exhibition_ID WHERE T2.Attendance  >  500",
        "predict": "SELECT T1.Theme FROM exhibition AS T1 JOIN exhibition_record AS T2 ON T1.Exhibition_ID  =  T2.Exhibition_ID WHERE T2.Attendance  <  100 INTERSECT SELECT T1.Theme FROM exhibition AS T1 JOIN exhibition_record AS T2 ON T1.Exhibition_ID  =  T2.Exhibition_ID WHERE T2.Attendance  >  500",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  >  8 INTERSECT SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  <  5",
        "question": "Find the titles of items that received both a rating higher than 8 and a rating below 5.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the titles of items that received a rating higher than 8; 2. what are the titles of items that received a rating below 5.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['item', 'review']. To complete the second subproblem, we need to use tables ['item', 'review'].\n\n<3> Operation: Use 'where' to filter using column 'rating' in table 'review'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  >  8 INTERSECT SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  <  5",
        "predict": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  >  8 INTERSECT SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  <  5",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rank  >  3 INTERSECT SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id HAVING avg(T2.rating)  >  5",
        "question": "Find the names of items whose rank is higher than 3 and whose average rating is above 5.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of items whose rank is higher than 3; 2. what are the names of items whose average rating is above 5.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['item', 'review']. To complete the second subproblem, we need to use tables ['item', 'review'].\n\n<3> Operation: Use 'where' to filter using column 'rank' in table 'review'. Use 'group by' and 'having avg()' to filter using column 'rating' in table 'review'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rank  >  3 INTERSECT SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id HAVING avg(rating)  >  5",
        "predict": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rank  >  3 INTERSECT SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id HAVING avg(rating)  >  5",
        "hardness": "extra"
    },
    {
        "db_id": "riding_club",
        "gold": "SELECT Residence FROM player WHERE gender  =  \"M\" INTERSECT SELECT Residence FROM player WHERE gender  =  \"F\"",
        "question": "Show the residences that have both a player of gender \"M\" and a player of gender \"F\".",
        "fields": "Table club, columns = [*,Club_ID,Club_name,Region,Start_year]\nTable coach, columns = [*,Coach_ID,Coach_name,Gender,Club_ID,Rank]\nTable match_result, columns = [*,Rank,Club_ID,Gold,Big_Silver,Small_Silver,Bronze,Points]\nTable player, columns = [*,Player_ID,Sponsor_name,Player_name,Gender,Residence,Occupation,Votes,Rank]\nTable player_coach, columns = [*,Player_ID,Coach_ID,Starting_year]\n",
        "foreign_keys": "Foreign_keys = [coach.Club_ID = club.Club_ID,player_coach.Coach_ID = coach.Coach_ID,player_coach.Player_ID = player.Player_ID,match_result.Club_ID = club.Club_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the residences of players of gender \"M\"; 2. what are the residences of players of gender \"F\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use table 'player'.\n\n<3> Operation: Use 'where' to filter using column 'gender' in table 'player'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT residence FROM player WHERE gender  =  \"M\" INTERSECT SELECT residence FROM player WHERE gender  =  \"F\"",
        "predict": "SELECT residence FROM player WHERE gender  =  \"M\" INTERSECT SELECT residence FROM player WHERE gender  =  \"F\"",
        "hardness": "hard"
    },
    {
        "db_id": "gymnast",
        "gold": "SELECT DISTINCT Hometown FROM people EXCEPT SELECT DISTINCT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID",
        "question": "List the distinct hometowns that are not associated with any gymnast.",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the distinct hometowns of all people; 2. what are the distinct hometowns of gymnasts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'people'. To complete the second subproblem, we need to use tables ['gymnast', 'people'].\n\n<3> Operation: Use 'where' to filter using column 'Gymnast_ID' in table 'gymnast'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT DISTINCT hometown FROM people EXCEPT SELECT t1.hometown FROM people AS t1 JOIN gymnast AS t2 ON t1.people_id  =  t2.gymnast_id",
        "predict": "SELECT DISTINCT hometown FROM people EXCEPT SELECT t1.hometown FROM people AS t1 JOIN gymnast AS t2 ON t1.people_id  =  t2.gymnast_id",
        "hardness": "hard"
    },
    {
        "db_id": "gymnast",
        "gold": "SELECT DISTINCT Hometown FROM people EXCEPT SELECT DISTINCT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID",
        "question": "From which hometowns did no gymnasts come from?",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the hometowns of all gymnasts; 2. what are the hometowns of gymnasts that did not come from any hometown.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'people'. To complete the second subproblem, we need to use tables ['people', 'gymnast'].\n\n<3> Operation: Use 'where' to filter using column 'Hometown' in table 'people'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Hometown FROM people EXCEPT SELECT Hometown FROM people JOIN gymnast ON people.People_ID  =  gymnast.Gymnast_ID",
        "predict": "SELECT Hometown FROM people EXCEPT SELECT Hometown FROM people JOIN gymnast ON people.People_ID  =  gymnast.Gymnast_ID",
        "hardness": "hard"
    },
    {
        "db_id": "gymnast",
        "gold": "SELECT Hometown FROM people WHERE Age  >  23 INTERSECT SELECT Hometown FROM people WHERE Age  <  20",
        "question": "Show the hometowns shared by people older than 23 and younger than 20.",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the hometowns of people older than 23; 2. what are the hometowns of people younger than 20.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['people'].\n\n<3> Operation: Use 'where' to filter using column 'Age' in table 'people'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Hometown FROM people AS T1 WHERE T1.Age  >  23 INTERSECT SELECT T1.Hometown FROM people AS T1 WHERE T1.Age  <  20",
        "predict": "SELECT T1.Hometown FROM people AS T1 WHERE T1.Age  >  23 INTERSECT SELECT T1.Hometown FROM people AS T1 WHERE T1.Age  <  20",
        "hardness": "hard"
    },
    {
        "db_id": "gymnast",
        "gold": "SELECT Hometown FROM people WHERE Age  >  23 INTERSECT SELECT Hometown FROM people WHERE Age  <  20",
        "question": "From which hometowns did both people older than 23 and younger than 20 come from?",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the hometowns of people older than 23; 2. what are the hometowns of people younger than 20.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['people'].\n\n<3> Operation: Use 'where' to filter using column 'Age' in table 'people'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT hometown FROM people WHERE age > 23 INTERSECT SELECT hometown FROM people WHERE age < 20",
        "predict": "SELECT hometown FROM people WHERE age > 23 INTERSECT SELECT hometown FROM people WHERE age < 20",
        "hardness": "hard"
    },
    {
        "db_id": "small_bank_1",
        "gold": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT avg(balance) FROM checking) INTERSECT SELECT T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM savings)",
        "question": "Find the names of accounts whose checking balance is above the average checking balance, but savings balance is below the average savings balance.",
        "fields": "Table ACCOUNTS, columns = [*,custid,name]\nTable CHECKING, columns = [*,custid,balance]\nTable SAVINGS, columns = [*,custid,balance]\n",
        "foreign_keys": "Foreign_keys = [SAVINGS.custid = ACCOUNTS.custid,CHECKING.custid = ACCOUNTS.custid]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of accounts whose checking balance is above the average checking balance; 2. what are the names of accounts whose savings balance is below the average savings balance.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['ACCOUNTS', 'CHECKING']. To complete the second subproblem, we need to use tables ['ACCOUNTS', 'SAVINGS'].\n\n<3> Operation: Use 'where' to filter using column 'balance' in tables 'CHECKING' and 'SAVINGS'. Calculate the average checking balance and average savings balance separately.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM ACCOUNTS AS T1 JOIN CHECKING AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT AVG(balance) FROM CHECKING) INTERSECT SELECT T1.name FROM ACCOUNTS AS T1 JOIN SAVINGS AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT AVG(balance) FROM SAVINGS)",
        "predict": "SELECT T1.name FROM ACCOUNTS AS T1 JOIN CHECKING AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT AVG(balance) FROM CHECKING) INTERSECT SELECT T1.name FROM ACCOUNTS AS T1 JOIN SAVINGS AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT AVG(balance) FROM SAVINGS)",
        "hardness": "extra"
    },
    {
        "db_id": "small_bank_1",
        "gold": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT avg(balance) FROM checking) INTERSECT SELECT T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM savings)",
        "question": "What are the names of accounts with checking balances greater than the average checking balance and savings balances below the average savings balance?",
        "fields": "Table ACCOUNTS, columns = [*,custid,name]\nTable CHECKING, columns = [*,custid,balance]\nTable SAVINGS, columns = [*,custid,balance]\n",
        "foreign_keys": "Foreign_keys = [SAVINGS.custid = ACCOUNTS.custid,CHECKING.custid = ACCOUNTS.custid]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of accounts with checking balances greater than the average checking balance; 2. what are the names of accounts with savings balances below the average savings balance.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['ACCOUNTS', 'CHECKING']. To complete the second subproblem, we need to use tables ['ACCOUNTS', 'SAVINGS'].\n\n<3> Operation: For both subproblems, we need to calculate the average balance for each account type and then filter the accounts based on the conditions.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM ACCOUNTS AS T1 JOIN CHECKING AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT AVG(balance) FROM CHECKING) INTERSECT SELECT T1.name FROM ACCOUNTS AS T1 JOIN SAVINGS AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT AVG(balance) FROM SAVINGS)",
        "predict": "SELECT T1.name FROM ACCOUNTS AS T1 JOIN CHECKING AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT AVG(balance) FROM CHECKING) INTERSECT SELECT T1.name FROM ACCOUNTS AS T1 JOIN SAVINGS AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT AVG(balance) FROM SAVINGS)",
        "hardness": "extra"
    },
    {
        "db_id": "browser_web",
        "gold": "SELECT T3.name FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T1.name  =  'CACHEbox' INTERSECT SELECT T3.name FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T1.name  =  'Fasterfox'",
        "question": "List the names of the browser that are compatible with both 'CACHEbox' and 'Fasterfox'.",
        "fields": "Table Web_client_accelerator, columns = [*,id,name,Operating_system,Client,Connection]\nTable accelerator_compatible_browser, columns = [*,accelerator_id,browser_id,compatible_since_year]\nTable browser, columns = [*,id,name,market_share]\n",
        "foreign_keys": "Foreign_keys = [accelerator_compatible_browser.browser_id = browser.id,accelerator_compatible_browser.accelerator_id = Web_client_accelerator.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of browsers that are compatible with 'CACHEbox'; 2. what are the names of browsers that are compatible with 'Fasterfox'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['browser', 'accelerator_compatible_browser', 'Web_client_accelerator']. To complete the second subproblem, we need to use tables ['browser', 'accelerator_compatible_browser', 'Web_client_accelerator'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'Web_client_accelerator'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM browser AS T1 JOIN accelerator_compatible_browser AS T2 ON T1.id  =  T2.browser_id JOIN web_client_accelerator AS T3 ON T3.id  =  T2.accelerator_id WHERE T3.name  =  \"CACHEbox\" INTERSECT SELECT T1.name FROM browser AS T1 JOIN accelerator_compatible_browser AS T2 ON T1.id  =  T2.browser_id JOIN web_client_accelerator AS T3 ON T3.id  =  T2.accelerator_id WHERE T3.name  =  \"Fasterfox\"",
        "predict": "SELECT T1.name FROM browser AS T1 JOIN accelerator_compatible_browser AS T2 ON T1.id  =  T2.browser_id JOIN web_client_accelerator AS T3 ON T3.id  =  T2.accelerator_id WHERE T3.name  =  \"CACHEbox\" INTERSECT SELECT T1.name FROM browser AS T1 JOIN accelerator_compatible_browser AS T2 ON T1.id  =  T2.browser_id JOIN web_client_accelerator AS T3 ON T3.id  =  T2.accelerator_id WHERE T3.name  =  \"Fasterfox\"",
        "hardness": "extra"
    },
    {
        "db_id": "browser_web",
        "gold": "SELECT name ,  operating_system FROM web_client_accelerator EXCEPT SELECT T1.name ,  T1.operating_system FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T3.name  =  'Opera'",
        "question": "Show the accelerator names and supporting operating systems that are not compatible with the browser named 'Opera'.",
        "fields": "Table Web_client_accelerator, columns = [*,id,name,Operating_system,Client,Connection]\nTable accelerator_compatible_browser, columns = [*,accelerator_id,browser_id,compatible_since_year]\nTable browser, columns = [*,id,name,market_share]\n",
        "foreign_keys": "Foreign_keys = [accelerator_compatible_browser.browser_id = browser.id,accelerator_compatible_browser.accelerator_id = Web_client_accelerator.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the accelerator names and supporting operating systems; 2. what are the accelerator names and supporting operating systems that are compatible with the browser named 'Opera'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Web_client_accelerator'. To complete the second subproblem, we need to use tables ['Web_client_accelerator', 'accelerator_compatible_browser', 'browser'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'browser'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name ,  T1.Operating_system FROM web_client_accelerator AS T1 EXCEPT SELECT T1.name ,  T1.Operating_system FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T1.id  =  T2.accelerator_id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T3.name  =  'Opera'",
        "predict": "SELECT T1.name ,  T1.Operating_system FROM web_client_accelerator AS T1 EXCEPT SELECT T1.name ,  T1.Operating_system FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T1.id  =  T2.accelerator_id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T3.name  =  'Opera'",
        "hardness": "extra"
    },
    {
        "db_id": "school_finance",
        "gold": "SELECT T1.donator_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  'Glenn' INTERSECT SELECT T1.donator_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  'Triton'",
        "question": "Show the names of donors who donated to both school \"Glenn\" and \"Triton.\"",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of donors who donated to school \"Glenn\"; 2. what are the names of donors who donated to school \"Triton\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['endowment', 'school']. To complete the second subproblem, we also need to use tables ['endowment', 'school'].\n\n<3> Operation: Use 'where' to filter using column 'School_name' in table 'school'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.donator_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Glenn\" INTERSECT SELECT T1.donator_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Triton\"",
        "predict": "SELECT T1.donator_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Glenn\" INTERSECT SELECT T1.donator_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Triton\"",
        "hardness": "extra"
    },
    {
        "db_id": "school_finance",
        "gold": "SELECT donator_name FROM endowment EXCEPT SELECT donator_name FROM endowment WHERE amount  <  9",
        "question": "Show the names of all the donors except those whose donation amount less than 9.",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all the donors; 2. what are the names of donors whose donation amount is less than 9.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['endowment']. To complete the second subproblem, we need to use tables ['endowment'].\n\n<3> Operation: Use 'where' to filter using column 'amount' in table 'endowment'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT donator_name FROM endowment EXCEPT SELECT donator_name FROM endowment WHERE amount  <  9",
        "predict": "SELECT donator_name FROM endowment EXCEPT SELECT donator_name FROM endowment WHERE amount  <  9",
        "hardness": "hard"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT name FROM building EXCEPT SELECT T1.name FROM building AS T1 JOIN institution AS T2 ON T1.building_id  =  T2.building_id WHERE T2.founded  =  2003",
        "question": "Show the names of buildings except for those having an institution founded in 2003.",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all buildings; 2. what are the names of buildings that have an institution founded in 2003.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'building'. To complete the second subproblem, we need to use tables ['building', 'Institution'].\n\n<3> Operation: Use 'where' to filter using column 'Founded' in table 'Institution'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Name FROM building EXCEPT SELECT T1.Name FROM building AS T1 JOIN Institution AS T2 ON T1.building_id  =  T2.building_id WHERE T2.Founded  =  2003",
        "predict": "SELECT Name FROM building EXCEPT SELECT T1.Name FROM building AS T1 JOIN Institution AS T2 ON T1.building_id  =  T2.building_id WHERE T2.Founded  =  2003",
        "hardness": "hard"
    },
    {
        "db_id": "cinema",
        "gold": "SELECT LOCATION FROM cinema WHERE openning_year  =  2010 INTERSECT SELECT LOCATION FROM cinema WHERE openning_year  =  2011",
        "question": "Show all the locations where some cinemas were opened in both year 2010 and year 2011.",
        "fields": "Table cinema, columns = [*,Cinema_ID,Name,Openning_year,Capacity,Location]\nTable film, columns = [*,Film_ID,Rank_in_series,Number_in_season,Title,Directed_by,Original_air_date,Production_code]\nTable schedule, columns = [*,Cinema_ID,Film_ID,Date,Show_times_per_day,Price]\n",
        "foreign_keys": "Foreign_keys = [schedule.Cinema_ID = cinema.Cinema_ID,schedule.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the locations where cinemas were opened in year 2010; 2. what are the locations where cinemas were opened in year 2011.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['cinema']. To complete the second subproblem, we also need to use tables ['cinema'].\n\n<3> Operation: Use 'where' to filter using column 'Openning_year' in table 'cinema'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT location FROM cinema WHERE Openning_year  =  2010 INTERSECT SELECT location FROM cinema WHERE Openning_year  =  2011",
        "predict": "SELECT location FROM cinema WHERE Openning_year  =  2010 INTERSECT SELECT location FROM cinema WHERE Openning_year  =  2011",
        "hardness": "hard"
    },
    {
        "db_id": "products_for_hire",
        "gold": "SELECT T1.coupon_amount FROM Discount_Coupons AS T1 JOIN customers AS T2 ON T1.coupon_id  =  T2.coupon_id WHERE T2.good_or_bad_customer  =  'good' INTERSECT SELECT T1.coupon_amount FROM Discount_Coupons AS T1 JOIN customers AS T2 ON T1.coupon_id  =  T2.coupon_id WHERE T2.good_or_bad_customer  =  'bad'",
        "question": "What are the coupon amount of the coupons owned by both good and bad customers?",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the coupon amounts of the coupons owned by good customers; 2. what are the coupon amounts of the coupons owned by bad customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Customers', 'Discount_Coupons'] and filter by the column 'good_or_bad_customer'. To complete the second subproblem, we need to use tables ['Customers', 'Discount_Coupons'] and filter by the column 'good_or_bad_customer'.\n\n<3> Operation: Use 'where' to filter using column 'good_or_bad_customer' in table 'Customers'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T2.coupon_amount FROM Customers AS T1 JOIN Discount_Coupons AS T2 ON T1.coupon_id  =  T2.coupon_id WHERE T1.good_or_bad_customer  =  'good' INTERSECT SELECT T2.coupon_amount FROM Customers AS T1 JOIN Discount_Coupons AS T2 ON T1.coupon_id  =  T2.coupon_id WHERE T1.good_or_bad_customer  =  'bad'",
        "predict": "SELECT T2.coupon_amount FROM Customers AS T1 JOIN Discount_Coupons AS T2 ON T1.coupon_id  =  T2.coupon_id WHERE T1.good_or_bad_customer  =  'good' INTERSECT SELECT T2.coupon_amount FROM Customers AS T1 JOIN Discount_Coupons AS T2 ON T1.coupon_id  =  T2.coupon_id WHERE T1.good_or_bad_customer  =  'bad'",
        "hardness": "extra"
    },
    {
        "db_id": "phone_market",
        "gold": "SELECT Carrier FROM phone WHERE Memory_in_G  <  32 INTERSECT SELECT Carrier FROM phone WHERE Memory_in_G  >  64",
        "question": "Show the carriers that have both phones with memory smaller than 32 and phones with memory bigger than 64.",
        "fields": "Table market, columns = [*,Market_ID,District,Num_of_employees,Num_of_shops,Ranking]\nTable phone, columns = [*,Name,Phone_ID,Memory_in_G,Carrier,Price]\nTable phone_market, columns = [*,Market_ID,Phone_ID,Num_of_stock]\n",
        "foreign_keys": "Foreign_keys = [phone_market.Phone_ID = phone.Phone_ID,phone_market.Market_ID = market.Market_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the carriers that have phones with memory smaller than 32; 2. what are the carriers that have phones with memory bigger than 64.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['phone', 'phone_market', 'market']. To complete the second subproblem, we also need to use tables ['phone', 'phone_market', 'market'].\n\n<3> Operation: Use 'where' to filter using column 'Memory_in_G' in table 'phone'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Carrier FROM phone AS T1 JOIN phone_market AS T2 ON T1.Phone_ID  =  T2.Phone_ID JOIN market AS T3 ON T2.Market_ID  =  T3.Market_ID WHERE T1.Memory_in_G  <  32 INTERSECT SELECT T1.Carrier FROM phone AS T1 JOIN phone_market AS T2 ON T1.Phone_ID  =  T2.Phone_ID JOIN market AS T3 ON T2.Market_ID  =  T3.Market_ID WHERE T1.Memory_in_G  >  64",
        "predict": "SELECT T1.Carrier FROM phone AS T1 JOIN phone_market AS T2 ON T1.Phone_ID  =  T2.Phone_ID JOIN market AS T3 ON T2.Market_ID  =  T3.Market_ID WHERE T1.Memory_in_G  <  32 INTERSECT SELECT T1.Carrier FROM phone AS T1 JOIN phone_market AS T2 ON T1.Phone_ID  =  T2.Phone_ID JOIN market AS T3 ON T2.Market_ID  =  T3.Market_ID WHERE T1.Memory_in_G  >  64",
        "hardness": "hard"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT headquarters FROM company WHERE main_industry  =  'Banking' INTERSECT SELECT headquarters FROM company WHERE main_industry  =  'Oil and gas'",
        "question": "Show all headquarters with both a company in banking industry and a company in Oil and gas.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the headquarters of companies in the banking industry; 2. what are the headquarters of companies in the oil and gas industry.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['company']. To complete the second subproblem, we need to use tables ['company'].\n\n<3> Operation: Use 'where' to filter using column 'Main_Industry' in table 'company'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Headquarters FROM company WHERE Main_Industry  =  \"banking\" INTERSECT SELECT Headquarters FROM company WHERE Main_Industry  =  \"Oil and gas\"",
        "predict": "SELECT Headquarters FROM company WHERE Main_Industry  =  \"banking\" INTERSECT SELECT Headquarters FROM company WHERE Main_Industry  =  \"Oil and gas\"",
        "hardness": "hard"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT headquarters FROM company WHERE main_industry  =  'Banking' INTERSECT SELECT headquarters FROM company WHERE main_industry  =  'Oil and gas'",
        "question": "What are the headquarters that have both a company in the banking and 'oil and gas' industries?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the headquarters of companies in the banking industry; 2. what are the headquarters of companies in the 'oil and gas' industry.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['company']. To complete the second subproblem, we need to use tables ['company'].\n\n<3> Operation: Use 'where' to filter using column 'Main_Industry' in table 'company'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Headquarters FROM company AS T1 WHERE T1.Main_Industry  =  \"banking\" INTERSECT SELECT T1.Headquarters FROM company AS T1 WHERE T1.Main_Industry  =  \"oil and gas\"",
        "predict": "SELECT T1.Headquarters FROM company AS T1 WHERE T1.Main_Industry  =  \"banking\" INTERSECT SELECT T1.Headquarters FROM company AS T1 WHERE T1.Main_Industry  =  \"oil and gas\"",
        "hardness": "hard"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT headquarters FROM company EXCEPT SELECT headquarters FROM company WHERE main_industry  =  'Banking'",
        "question": "Show all headquarters without a company in banking industry.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the headquarters of all companies; 2. what are the headquarters of companies in the banking industry.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'company'. To complete the second subproblem, we need to use tables ['company'].\n\n<3> Operation: Use 'where' to filter using column 'Main_Industry' in table 'company'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Headquarters FROM company EXCEPT SELECT Headquarters FROM company WHERE Main_Industry  =  \"banking\"",
        "predict": "SELECT Headquarters FROM company EXCEPT SELECT Headquarters FROM company WHERE Main_Industry  =  \"banking\"",
        "hardness": "hard"
    },
    {
        "db_id": "party_people",
        "gold": "SELECT member_name FROM member WHERE party_id  =  3 INTERSECT SELECT member_name FROM member WHERE party_id  =  1",
        "question": "Show the member names which are in both the party with id 3 and the party with id 1.",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the member names in the party with id 3; 2. what are the member names in the party with id 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['member', 'party']. To complete the second subproblem, we also need to use tables ['member', 'party'].\n\n<3> Operation: Use 'where' to filter using column 'Party_ID' in table 'party'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Member_Name FROM member AS T1 JOIN party AS T2 ON T1.Party_ID  =  T2.Party_ID WHERE T2.Party_ID  =  3 INTERSECT SELECT T1.Member_Name FROM member AS T1 JOIN party AS T2 ON T1.Party_ID  =  T2.Party_ID WHERE T2.Party_ID  =  1",
        "predict": "SELECT T1.Member_Name FROM member AS T1 JOIN party AS T2 ON T1.Party_ID  =  T2.Party_ID WHERE T2.Party_ID  =  3 INTERSECT SELECT T1.Member_Name FROM member AS T1 JOIN party AS T2 ON T1.Party_ID  =  T2.Party_ID WHERE T2.Party_ID  =  1",
        "hardness": "hard"
    },
    {
        "db_id": "party_people",
        "gold": "SELECT member_name FROM member WHERE party_id  =  3 INTERSECT SELECT member_name FROM member WHERE party_id  =  1",
        "question": "Which member names are shared among members in the party with the id 3 and the party with the id 1?",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the member names in the party with id 3; 2. what are the member names in the party with id 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['member', 'party'].\n\n<3> Operation: Use 'where' to filter using column 'Party_ID' in table 'member'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Member_Name FROM member AS T1 JOIN party AS T2 ON T1.Party_ID  =  T2.Party_ID WHERE T2.Party_ID  =  3 INTERSECT SELECT T1.Member_Name FROM member AS T1 JOIN party AS T2 ON T1.Party_ID  =  T2.Party_ID WHERE T2.Party_ID  =  1",
        "predict": "SELECT T1.Member_Name FROM member AS T1 JOIN party AS T2 ON T1.Party_ID  =  T2.Party_ID WHERE T2.Party_ID  =  3 INTERSECT SELECT T1.Member_Name FROM member AS T1 JOIN party AS T2 ON T1.Party_ID  =  T2.Party_ID WHERE T2.Party_ID  =  1",
        "hardness": "hard"
    },
    {
        "db_id": "party_people",
        "gold": "SELECT member_name FROM member EXCEPT SELECT T1.member_name FROM member AS T1 JOIN party_events AS T2 ON T1.member_id  =  T2.member_in_charge_id",
        "question": "Show all member names who are not in charge of any event.",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all members; 2. what are the names of members who are in charge of any event.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['member']. To complete the second subproblem, we need to use tables ['member', 'party_events'].\n\n<3> Operation: Use 'where' to filter using column 'Member_in_charge_ID' in table 'party_events'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Member_Name FROM member EXCEPT SELECT t1.Member_Name FROM member AS t1 JOIN party_events AS t2 ON t1.Member_ID  =  t2.Member_in_charge_ID",
        "predict": "SELECT Member_Name FROM member EXCEPT SELECT t1.Member_Name FROM member AS t1 JOIN party_events AS t2 ON t1.Member_ID  =  t2.Member_in_charge_ID",
        "hardness": "hard"
    },
    {
        "db_id": "party_people",
        "gold": "SELECT member_name FROM member EXCEPT SELECT T1.member_name FROM member AS T1 JOIN party_events AS T2 ON T1.member_id  =  T2.member_in_charge_id",
        "question": "What are the names of members who are not in charge of any events?",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all members; 2. what are the names of members who are in charge of any events.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['member']. To complete the second subproblem, we need to use tables ['member', 'party_events'].\n\n<3> Operation: Use 'where' to filter using column 'Member_in_charge_ID' in table 'party_events'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Member_Name FROM member EXCEPT SELECT t1.Member_Name FROM member AS t1 JOIN party_events AS t2 ON t1.Member_ID  =  t2.Member_in_charge_ID",
        "predict": "SELECT Member_Name FROM member EXCEPT SELECT t1.Member_Name FROM member AS t1 JOIN party_events AS t2 ON t1.Member_ID  =  t2.Member_in_charge_ID",
        "hardness": "hard"
    },
    {
        "db_id": "pilot_record",
        "gold": "SELECT POSITION FROM pilot WHERE Join_Year < 2000 INTERSECT SELECT POSITION FROM pilot WHERE Join_Year > 2005",
        "question": "Show the pilot positions that have both pilots joining after year 2005 and pilots joining before 2000.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Order_Year,Manufacturer,Model,Fleet_Series,Powertrain,Fuel_Propulsion]\nTable pilot, columns = [*,Pilot_ID,Pilot_name,Rank,Age,Nationality,Position,Join_Year,Team]\nTable pilot_record, columns = [*,Record_ID,Pilot_ID,Aircraft_ID,Date]\n",
        "foreign_keys": "Foreign_keys = [pilot_record.Aircraft_ID = aircraft.Aircraft_ID,pilot_record.Pilot_ID = pilot.Pilot_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the pilot positions of pilots joining after year 2005; 2. what are the pilot positions of pilots joining before year 2000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['pilot']. To complete the second subproblem, we also need to use tables ['pilot'].\n\n<3> Operation: Use 'where' to filter using column 'Join_Year' in table 'pilot'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Position FROM pilot WHERE Join_Year > 2005 INTERSECT SELECT Position FROM pilot WHERE Join_Year < 2000",
        "predict": "SELECT Position FROM pilot WHERE Join_Year > 2005 INTERSECT SELECT Position FROM pilot WHERE Join_Year < 2000",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Control_Systems",
        "gold": "SELECT employee_name FROM Employees EXCEPT SELECT Employees.employee_name FROM Employees JOIN Circulation_History ON Circulation_History.employee_id = Employees.employee_id",
        "question": "List the employees who have not showed up in any circulation history of documents. List the employee's name.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Circulation_History, columns = [*,document_id,draft_number,copy_number,employee_id]\nTable Document_Drafts, columns = [*,document_id,draft_number,draft_details]\nTable Documents, columns = [*,document_id,document_status_code,document_type_code,shipping_agent_code,receipt_date,receipt_number,other_details]\nTable Documents_Mailed, columns = [*,document_id,mailed_to_address_id,mailing_date]\nTable Draft_Copies, columns = [*,document_id,draft_number,copy_number]\nTable Employees, columns = [*,employee_id,role_code,employee_name,other_details]\nTable Ref_Document_Status, columns = [*,document_status_code,document_status_description]\nTable Ref_Document_Types, columns = [*,document_type_code,document_type_description]\nTable Ref_Shipping_Agents, columns = [*,shipping_agent_code,shipping_agent_name,shipping_agent_description]\nTable Roles, columns = [*,role_code,role_description]\n",
        "foreign_keys": "Foreign_keys = [Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code,Documents.document_status_code = Ref_Document_Status.document_status_code,Documents.document_type_code = Ref_Document_Types.document_type_code,Employees.role_code = Roles.role_code,Document_Drafts.document_id = Documents.document_id,Draft_Copies.document_id = Document_Drafts.document_id,Draft_Copies.draft_number = Document_Drafts.draft_number,Circulation_History.employee_id = Employees.employee_id,Circulation_History.document_id = Draft_Copies.document_id,Circulation_History.draft_number = Draft_Copies.draft_number,Circulation_History.copy_number = Draft_Copies.copy_number,Documents_Mailed.mailed_to_address_id = Addresses.address_id,Documents_Mailed.document_id = Documents.document_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the employees who have showed up in circulation history of documents; 2. what are the employees who have not showed up in circulation history of documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Employees', 'Circulation_History']. To complete the second subproblem, we need to use table ['Employees'].\n\n<3> Operation: Use 'where' to filter using column 'employee_id' in table 'Circulation_History'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT employee_name FROM employees EXCEPT SELECT t1.employee_name FROM employees AS t1 JOIN circulation_history AS t2 ON t1.employee_id  =  t2.employee_id",
        "predict": "SELECT employee_name FROM employees EXCEPT SELECT t1.employee_name FROM employees AS t1 JOIN circulation_history AS t2 ON t1.employee_id  =  t2.employee_id",
        "hardness": "hard"
    },
    {
        "db_id": "local_govt_in_alabama",
        "gold": "SELECT T1.service_type_code FROM services AS T1 JOIN EVENTS AS T2 ON T1.service_id  =  T2.service_id WHERE T2.event_details  =  'Success' INTERSECT SELECT T1.service_type_code FROM services AS T1 JOIN EVENTS AS T2 ON T1.service_id  =  T2.service_id WHERE T2.event_details  =  'Fail'",
        "question": "Which services type had both successful and failure event details?",
        "fields": "Table Events, columns = [*,Event_ID,Service_ID,Event_Details]\nTable Participants, columns = [*,Participant_ID,Participant_Type_Code,Participant_Details]\nTable Participants_in_Events, columns = [*,Event_ID,Participant_ID]\nTable Services, columns = [*,Service_ID,Service_Type_Code]\n",
        "foreign_keys": "Foreign_keys = [Events.Service_ID = Services.Service_ID,Participants_in_Events.Event_ID = Events.Event_ID,Participants_in_Events.Participant_ID = Participants.Participant_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the service types that had successful event details; 2. what are the service types that had failure event details.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Services', 'Events'].\n\n<3> Operation: Use 'where' to filter using column 'Event_Details' in table 'Events'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Service_Type_Code FROM Services AS T1 JOIN Events AS T2 ON T1.Service_ID  =  T2.Service_ID WHERE T2.Event_Details  =  \"successful\" INTERSECT SELECT T1.Service_Type_Code FROM Services AS T1 JOIN Events AS T2 ON T1.Service_ID  =  T2.Service_ID WHERE T2.Event_Details  =  \"failure\"",
        "predict": "SELECT T1.Service_Type_Code FROM Services AS T1 JOIN Events AS T2 ON T1.Service_ID  =  T2.Service_ID WHERE T2.Event_Details  =  \"successful\" INTERSECT SELECT T1.Service_Type_Code FROM Services AS T1 JOIN Events AS T2 ON T1.Service_ID  =  T2.Service_ID WHERE T2.Event_Details  =  \"failure\"",
        "hardness": "extra"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = \"Australian Grand Prix\" INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = \"Chinese Grand Prix\"",
        "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the ids and forenames of drivers who participated in the races with the name Australian Grand Prix; 2. what are the ids and forenames of drivers who participated in the races with the name Chinese Grand Prix.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['drivers', 'races', 'results']. To complete the second subproblem, we also need to use tables ['drivers', 'races', 'results'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'races'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.driverId, T1.forename FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Australian Grand Prix\" INTERSECT SELECT T1.driverId, T1.forename FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Chinese Grand Prix\"",
        "predict": "SELECT T1.driverId, T1.forename FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Australian Grand Prix\" INTERSECT SELECT T1.driverId, T1.forename FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Chinese Grand Prix\"",
        "hardness": "extra"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = \"Australian Grand Prix\" INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = \"Chinese Grand Prix\"",
        "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what is the id and first name of all the drivers who participated in the Australian Grand Prix; 2. what is the id and first name of all the drivers who participated in the Chinese Grand Prix.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['drivers', 'results', 'races']. To complete the second subproblem, we also need to use tables ['drivers', 'results', 'races'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'races'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.driverId, T1.forename FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Australian Grand Prix\" INTERSECT SELECT T1.driverId, T1.forename FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Chinese Grand Prix\"",
        "predict": "SELECT T1.driverId, T1.forename FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Australian Grand Prix\" INTERSECT SELECT T1.driverId, T1.forename FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Chinese Grand Prix\"",
        "hardness": "extra"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = \"Australian Grand Prix\" EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = \"Chinese Grand Prix\"",
        "question": "What are the forenames and surnames of drivers who participated in the races named Australian Grand Prix but not the races named Chinese Grand Prix?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the forenames and surnames of drivers who participated in the races named Australian Grand Prix; 2. what are the forenames and surnames of drivers who participated in the races named Chinese Grand Prix.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['drivers', 'races']. To complete the second subproblem, we also need to use tables ['drivers', 'races'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'races'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.forename ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid JOIN races AS T3 ON T2.raceid  =  T3.raceid WHERE T3.name  =  \"Australian Grand Prix\" EXCEPT SELECT T1.forename ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid JOIN races AS T3 ON T2.raceid  =  T3.raceid WHERE T3.name  =  \"Chinese Grand Prix\"",
        "predict": "SELECT T1.forename ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid JOIN races AS T3 ON T2.raceid  =  T3.raceid WHERE T3.name  =  \"Australian Grand Prix\" EXCEPT SELECT T1.forename ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid JOIN races AS T3 ON T2.raceid  =  T3.raceid WHERE T3.name  =  \"Chinese Grand Prix\"",
        "hardness": "extra"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = \"Australian Grand Prix\" EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = \"Chinese Grand Prix\"",
        "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the first and last names of all drivers who participated in the Australian Grand Prix; 2. what are the first and last names of all drivers who participated in the Chinese Grand Prix.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['drivers', 'results', 'races']. To complete the second subproblem, we also need to use tables ['drivers', 'results', 'races'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'races'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.forename, T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Australian Grand Prix\" EXCEPT SELECT T1.forename, T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Chinese Grand Prix\"",
        "predict": "SELECT T1.forename, T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Australian Grand Prix\" EXCEPT SELECT T1.forename, T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = \"Chinese Grand Prix\"",
        "hardness": "extra"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T1.forename ,  T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  8 UNION SELECT T1.forename ,  T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "question": "What are the drivers' first, last names and id who had more than 8 pit stops or participated in more than 5 race results?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the drivers' first, last names, and id who had more than 8 pit stops; 2. what are the drivers' first, last names, and id who participated in more than 5 race results.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['drivers', 'pitStops']. To complete the second subproblem, we need to use tables ['drivers', 'results'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'driverId' and filter by performing 'HAVING COUNT()' on the column 'stop'. For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'driverId' and filter by performing 'HAVING COUNT()' on the column 'raceId'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.forename ,  T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  8 UNION SELECT T1.forename ,  T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "predict": "SELECT T1.forename ,  T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  8 UNION SELECT T1.forename ,  T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "hardness": "extra"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T1.forename ,  T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  8 UNION SELECT T1.forename ,  T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "question": "What are the drivers' first names,last names, and ids for all those that had more than 8 stops or participated in more than 5 races?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the drivers' first names, last names, and ids who had more than 8 stops; 2. what are the drivers' first names, last names, and ids who participated in more than 5 races.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['drivers', 'pitStops']. To complete the second subproblem, we need to use tables ['drivers', 'results'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'driverId' and filter by performing 'HAVING COUNT()' on the column 'stop'. For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'driverId' and filter by performing 'HAVING COUNT()' on the column 'raceId'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.forename, T1.surname, T1.driverId FROM drivers AS T1 JOIN pitStops AS T2 ON T1.driverId = T2.driverId GROUP BY T1.driverId HAVING COUNT(*) > 8 UNION SELECT T1.forename, T1.surname, T1.driverId FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId GROUP BY T1.driverId HAVING COUNT(*) > 5",
        "predict": "SELECT T1.forename, T1.surname, T1.driverId FROM drivers AS T1 JOIN pitStops AS T2 ON T1.driverId = T2.driverId GROUP BY T1.driverId HAVING COUNT(*) > 8 UNION SELECT T1.forename, T1.surname, T1.driverId FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId GROUP BY T1.driverId HAVING COUNT(*) > 5",
        "hardness": "extra"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  =  11 INTERSECT SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "question": "What are the drivers' last names and id who had 11 pit stops and participated in more than 5 race results?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the drivers' last names and id who had 11 pit stops; 2. what are the drivers' last names and id who participated in more than 5 race results.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['drivers', 'pitStops']. To complete the second subproblem, we need to use tables ['drivers', 'results'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'driverId' and filter by performing 'HAVING COUNT()' on the column 'stop'. For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'driverId' and filter by performing 'HAVING COUNT()' on the column 'raceId'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  =  11 INTERSECT SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "predict": "SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  =  11 INTERSECT SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "hardness": "extra"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  =  11 INTERSECT SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "question": "What are the last names and ids of all drivers who had 11 pit stops and participated in more than 5 races?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the last names and ids of all drivers who had 11 pit stops; 2. what are the last names and ids of all drivers who participated in more than 5 races.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['drivers', 'pitStops']. To complete the second subproblem, we need to use tables ['drivers', 'results'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'driverId' and filter by performing 'HAVING COUNT()' on the column 'stop'. For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'driverId' and filter by performing 'HAVING COUNT()' on the column 'raceId'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  =  11 INTERSECT SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "predict": "SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN pitstops AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  =  11 INTERSECT SELECT T1.surname ,  T1.driverid FROM drivers AS T1 JOIN results AS T2 ON T1.driverid  =  T2.driverid GROUP BY T1.driverid HAVING count(*)  >  5",
        "hardness": "extra"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Starting_Year FROM technician WHERE Team  =  \"CLE\" INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  \"CWS\"",
        "question": "Show the starting years shared by technicians from team \"CLE\" and \"CWS\".",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the starting years of technicians from team \"CLE\"; 2. what are the starting years of technicians from team \"CWS\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use table 'technician'.\n\n<3> Operation: Use 'where' to filter using column 'Team' in table 'technician'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Starting_Year FROM technician AS T1 WHERE T1.Team  =  \"CLE\" INTERSECT SELECT T1.Starting_Year FROM technician AS T1 WHERE T1.Team  =  \"CWS\"",
        "predict": "SELECT T1.Starting_Year FROM technician AS T1 WHERE T1.Team  =  \"CLE\" INTERSECT SELECT T1.Starting_Year FROM technician AS T1 WHERE T1.Team  =  \"CWS\"",
        "hardness": "hard"
    },
    {
        "db_id": "entrepreneur",
        "gold": "SELECT Investor FROM entrepreneur WHERE Money_Requested  >  140000 INTERSECT SELECT Investor FROM entrepreneur WHERE Money_Requested  <  120000",
        "question": "Show the investors shared by entrepreneurs that requested more than 140000 and entrepreneurs that requested less than 120000.",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the investors shared by entrepreneurs that requested more than 140000; 2. what are the investors shared by entrepreneurs that requested less than 120000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['entrepreneur', 'people'].\n\n<3> Operation: Use 'where' to filter using column 'Money_Requested' in table 'entrepreneur'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Investor FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Money_Requested  >  140000 INTERSECT SELECT T1.Investor FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Money_Requested  <  120000",
        "predict": "SELECT T1.Investor FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Money_Requested  >  140000 INTERSECT SELECT T1.Investor FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Money_Requested  <  120000",
        "hardness": "hard"
    },
    {
        "db_id": "entrepreneur",
        "gold": "SELECT Investor FROM entrepreneur WHERE Money_Requested  >  140000 INTERSECT SELECT Investor FROM entrepreneur WHERE Money_Requested  <  120000",
        "question": "What are the investors who have invested in both entrepreneurs who requested more than 140000 and entrepreneurs who requested less than 120000?",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the investors who have invested in entrepreneurs who requested more than 140000; 2. what are the investors who have invested in entrepreneurs who requested less than 120000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['entrepreneur', 'people']. To complete the second subproblem, we need to use tables ['entrepreneur', 'people'].\n\n<3> Operation: Use 'where' to filter using column 'Money_Requested' in table 'entrepreneur'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Investor FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Money_Requested  >  140000 INTERSECT SELECT T1.Investor FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Money_Requested  <  120000",
        "predict": "SELECT T1.Investor FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Money_Requested  >  140000 INTERSECT SELECT T1.Investor FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Money_Requested  <  120000",
        "hardness": "hard"
    },
    {
        "db_id": "perpetrator",
        "gold": "SELECT Country FROM perpetrator WHERE Injured  >  50 INTERSECT SELECT Country FROM perpetrator WHERE Injured  <  20",
        "question": "Show the countries that have both perpetrators with injures more than 50 and perpetrators with injures smaller than 20.",
        "fields": "Table people, columns = [*,People_ID,Name,Height,Weight,Home Town]\nTable perpetrator, columns = [*,Perpetrator_ID,People_ID,Date,Year,Location,Country,Killed,Injured]\n",
        "foreign_keys": "Foreign_keys = [perpetrator.People_ID = people.People_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the countries that have perpetrators with injuries more than 50; 2. what are the countries that have perpetrators with injuries smaller than 20.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['perpetrator', 'people'].\n\n<3> Operation: Use 'where' to filter using column 'Injured' in table 'perpetrator'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Country FROM perpetrator AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Injured  >  50 INTERSECT SELECT T1.Country FROM perpetrator AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Injured  <  20",
        "predict": "SELECT T1.Country FROM perpetrator AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Injured  >  50 INTERSECT SELECT T1.Country FROM perpetrator AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Injured  <  20",
        "hardness": "hard"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE LOCATION  =  \"Northridge\" AND county  =  \"Los Angeles\" UNION SELECT campus FROM campuses WHERE LOCATION  =  \"San Francisco\" AND county  =  \"San Francisco\"",
        "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the names of the campuses that are in Northridge, Los Angeles; 2. what are the names of the campuses that are in San Francisco, San Francisco.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use table 'Campuses'.\n\n<3> Operation: Use 'where' to filter using column 'Location' in table 'Campuses'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Campus FROM Campuses WHERE Location  =  \"Northridge, Los Angeles\" UNION SELECT Campus FROM Campuses WHERE Location  =  \"San Francisco, San Francisco\"",
        "predict": "SELECT Campus FROM Campuses WHERE Location  =  \"Northridge, Los Angeles\" UNION SELECT Campus FROM Campuses WHERE Location  =  \"San Francisco, San Francisco\"",
        "hardness": "extra"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE LOCATION  =  \"Northridge\" AND county  =  \"Los Angeles\" UNION SELECT campus FROM campuses WHERE LOCATION  =  \"San Francisco\" AND county  =  \"San Francisco\"",
        "question": "What campuses are located in Northridge, Los Angeles or in San Francisco, San Francisco?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what campuses are located in Northridge, Los Angeles; 2. what campuses are located in San Francisco, San Francisco.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use table 'Campuses'.\n\n<3> Operation: Use 'where' to filter using column 'Location' in table 'Campuses'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Campus FROM Campuses WHERE Location  =  \"Northridge, Los Angeles\" UNION SELECT Campus FROM Campuses WHERE Location  =  \"San Francisco, San Francisco\"",
        "predict": "SELECT Campus FROM Campuses WHERE Location  =  \"Northridge, Los Angeles\" UNION SELECT Campus FROM Campuses WHERE Location  =  \"San Francisco, San Francisco\"",
        "hardness": "extra"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT name FROM Reviewer UNION SELECT title FROM Movie",
        "question": "What are the names of all the reviewers and movie names?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes retrieving information from multiple tables, so we can decompose the question into two subproblems: 1. what are the names of all the reviewers; 2. what are the movie names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Reviewer'. To complete the second subproblem, we need to use table 'Movie'.\n\n<3> Operation: No specific operation is required for this query.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT name FROM Reviewer UNION SELECT title FROM Movie",
        "predict": "SELECT name FROM Reviewer UNION SELECT title FROM Movie",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT title FROM Movie EXCEPT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Chris Jackson'",
        "question": "Find the titles of all movies not reviewed by Chris Jackson.",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the titles of all movies; 2. what are the titles of movies reviewed by Chris Jackson.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Movie'. To complete the second subproblem, we need to use tables 'Movie' and 'Rating'.\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'Reviewer'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT title FROM Movie EXCEPT SELECT T1.title FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T2.rID  =  T3.rID WHERE T3.name  =  \"Chris Jackson\"",
        "predict": "SELECT title FROM Movie EXCEPT SELECT T1.title FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T2.rID  =  T3.rID WHERE T3.name  =  \"Chris Jackson\"",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT title FROM Movie EXCEPT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Chris Jackson'",
        "question": "What are the titles of all movies that were not reviewed by Chris Jackson?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the titles of all movies; 2. what are the titles of movies that were reviewed by Chris Jackson.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Movie'. To complete the second subproblem, we need to use tables ['Movie', 'Rating', 'Reviewer'].\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'Reviewer'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT title FROM Movie EXCEPT SELECT T1.title FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T2.rID  =  T3.rID WHERE T3.name  =  \"Chris Jackson\"",
        "predict": "SELECT title FROM Movie EXCEPT SELECT T1.title FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T2.rID  =  T3.rID WHERE T3.name  =  \"Chris Jackson\"",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT rID FROM Rating EXCEPT SELECT rID FROM Rating WHERE stars  =  4",
        "question": "find the ids of reviewers who did not give 4 star.",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of reviewers who gave 4 stars; 2. what are the ids of all reviewers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Rating', 'Reviewer']. To complete the second subproblem, we need to use table ['Reviewer'].\n\n<3> Operation: Use 'where' to filter using column 'stars' in table 'Rating'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT rID FROM Reviewer WHERE rID NOT IN (SELECT rID FROM Rating WHERE stars = 4)",
        "predict": "SELECT rID FROM Reviewer WHERE rID NOT IN (SELECT rID FROM Rating WHERE stars = 4)",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT rID FROM Rating EXCEPT SELECT rID FROM Rating WHERE stars  =  4",
        "question": "What are the ids of all reviewers who did not give 4 stars?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of all reviewers; 2. what are the ids of reviewers who gave 4 stars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Reviewer'. To complete the second subproblem, we need to use tables 'Reviewer' and 'Rating'.\n\n<3> Operation: Use 'where' to filter using column 'stars' in table 'Rating'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT rID FROM Reviewer EXCEPT SELECT rID FROM Rating WHERE stars  =  4",
        "predict": "SELECT rID FROM Reviewer EXCEPT SELECT rID FROM Rating WHERE stars  =  4",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4",
        "question": "What are the names of reviewers who had rated 3 star and 4 star?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of reviewers who had rated 3 star; 2. what are the names of reviewers who had rated 4 star.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Reviewer', 'Rating'].\n\n<3> Operation: Use 'where' to filter using column 'stars' in table 'Rating'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE T2.stars  =  3 INTERSECT SELECT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE T2.stars  =  4",
        "predict": "SELECT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE T2.stars  =  3 INTERSECT SELECT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE T2.stars  =  4",
        "hardness": "extra"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4",
        "question": "What are the names of movies that get 3 star and 4 star?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of movies that get 3 stars; 2. what are the names of movies that get 4 stars.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Movie', 'Rating'].\n\n<3> Operation: Use 'where' to filter using column 'stars' in table 'Rating'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT title FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  =  3 INTERSECT SELECT title FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  =  4",
        "predict": "SELECT title FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  =  3 INTERSECT SELECT title FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  =  4",
        "hardness": "extra"
    },
    {
        "db_id": "local_govt_mdm",
        "gold": "SELECT cmi_cross_ref_id FROM cmi_cross_references EXCEPT SELECT cmi_cross_ref_id FROM parking_fines",
        "question": "Which cmi cross reference id is not related to any parking taxes?",
        "fields": "Table Benefits_Overpayments, columns = [*,council_tax_id,cmi_cross_ref_id]\nTable Business_Rates, columns = [*,business_rates_id,cmi_cross_ref_id]\nTable CMI_Cross_References, columns = [*,cmi_cross_ref_id,master_customer_id,source_system_code]\nTable Council_Tax, columns = [*,council_tax_id,cmi_cross_ref_id]\nTable Customer_Master_Index, columns = [*,master_customer_id,cmi_details]\nTable Electoral_Register, columns = [*,electoral_register_id,cmi_cross_ref_id]\nTable Parking_Fines, columns = [*,council_tax_id,cmi_cross_ref_id]\nTable Rent_Arrears, columns = [*,council_tax_id,cmi_cross_ref_id]\n",
        "foreign_keys": "Foreign_keys = [CMI_Cross_References.master_customer_id = Customer_Master_Index.master_customer_id,Council_Tax.cmi_cross_ref_id = CMI_Cross_References.cmi_cross_ref_id,Business_Rates.cmi_cross_ref_id = CMI_Cross_References.cmi_cross_ref_id,Benefits_Overpayments.cmi_cross_ref_id = CMI_Cross_References.cmi_cross_ref_id,Parking_Fines.cmi_cross_ref_id = CMI_Cross_References.cmi_cross_ref_id,Rent_Arrears.cmi_cross_ref_id = CMI_Cross_References.cmi_cross_ref_id,Electoral_Register.cmi_cross_ref_id = CMI_Cross_References.cmi_cross_ref_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the cmi cross reference ids related to parking taxes; 2. what are the cmi cross reference ids that are not related to any parking taxes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Parking_Fines']. To complete the second subproblem, we need to use tables ['CMI_Cross_References', 'Parking_Fines'].\n\n<3> Operation: Use 'where' to filter using column 'cmi_cross_ref_id' in table 'Parking_Fines'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT cmi_cross_ref_id FROM CMI_Cross_References EXCEPT SELECT cmi_cross_ref_id FROM Parking_Fines",
        "predict": "SELECT cmi_cross_ref_id FROM CMI_Cross_References EXCEPT SELECT cmi_cross_ref_id FROM Parking_Fines",
        "hardness": "hard"
    },
    {
        "db_id": "party_host",
        "gold": "SELECT Nationality FROM HOST WHERE Age  >  45 INTERSECT SELECT Nationality FROM HOST WHERE Age  <  35",
        "question": "Show the nations that have both hosts older than 45 and hosts younger than 35.",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the nations that have hosts older than 45; 2. what are the nations that have hosts younger than 35.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['host', 'party_host'].\n\n<3> Operation: Use 'where' to filter using column 'Age' in table 'host'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Nationality FROM host AS T1 JOIN party_host AS T2 ON T1.Host_ID  =  T2.Host_ID WHERE T1.Age  >  45 INTERSECT SELECT T1.Nationality FROM host AS T1 JOIN party_host AS T2 ON T1.Host_ID  =  T2.Host_ID WHERE T1.Age  <  35",
        "predict": "SELECT T1.Nationality FROM host AS T1 JOIN party_host AS T2 ON T1.Host_ID  =  T2.Host_ID WHERE T1.Age  >  45 INTERSECT SELECT T1.Nationality FROM host AS T1 JOIN party_host AS T2 ON T1.Host_ID  =  T2.Host_ID WHERE T1.Age  <  35",
        "hardness": "hard"
    },
    {
        "db_id": "party_host",
        "gold": "SELECT Nationality FROM HOST WHERE Age  >  45 INTERSECT SELECT Nationality FROM HOST WHERE Age  <  35",
        "question": "Which nations have both hosts of age above 45 and hosts of age below 35?",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the nations of hosts who are above 45 years old; 2. what are the nations of hosts who are below 35 years old.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['host']. To complete the second subproblem, we need to use tables ['host'].\n\n<3> Operation: Use 'where' to filter using column 'Age' in table 'host'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Nationality FROM host AS T1 WHERE T1.Age  >  45 INTERSECT SELECT T1.Nationality FROM host AS T1 WHERE T1.Age  <  35",
        "predict": "SELECT T1.Nationality FROM host AS T1 WHERE T1.Age  >  45 INTERSECT SELECT T1.Nationality FROM host AS T1 WHERE T1.Age  <  35",
        "hardness": "hard"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT T1.name FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id HAVING count(*)  >=  2 INTERSECT SELECT T1.name FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id HAVING sum(T2.number_city_affected)  >=  10",
        "question": "Show storm name with at least two regions and 10 cities affected.",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the storm names with at least two regions; 2. what are the storm names with at least 10 cities affected.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['storm', 'affected_region', 'region']. To complete the second subproblem, we need to use tables ['storm', 'affected_region'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'Storm_ID' in the table 'affected_region' and filter by performing 'HAVING COUNT()' on the column 'Region_id'. For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'Storm_ID' in the table 'affected_region' and filter by performing 'HAVING SUM()' on the column 'Number_city_affected'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id GROUP BY T1.Storm_ID HAVING count(*)  >=  2 INTERSECT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID GROUP BY T1.Storm_ID HAVING sum(T2.Number_city_affected)  >=  10",
        "predict": "SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id GROUP BY T1.Storm_ID HAVING count(*)  >=  2 INTERSECT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID GROUP BY T1.Storm_ID HAVING sum(T2.Number_city_affected)  >=  10",
        "hardness": "extra"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT T1.name FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id HAVING count(*)  >=  2 INTERSECT SELECT T1.name FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id HAVING sum(T2.number_city_affected)  >=  10",
        "question": "What are the names of storms that both affected two or more regions and affected a total of 10 or more cities?",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of storms that affected two or more regions; 2. what are the names of storms that affected a total of 10 or more cities.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['storm', 'affected_region', 'region']. To complete the second subproblem, we need to use tables ['storm', 'affected_region'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'Storm_ID' in the table 'affected_region' and filter by performing 'HAVING COUNT()' on the column 'Region_id'. For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'Storm_ID' in the table 'affected_region' and filter by performing 'HAVING SUM()' on the column 'Number_city_affected'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id GROUP BY T1.Storm_ID HAVING count(*)  >=  2 INTERSECT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID GROUP BY T1.Storm_ID HAVING sum(T2.Number_city_affected)  >=  10",
        "predict": "SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id GROUP BY T1.Storm_ID HAVING count(*)  >=  2 INTERSECT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID GROUP BY T1.Storm_ID HAVING sum(T2.Number_city_affected)  >=  10",
        "hardness": "extra"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT name FROM storm EXCEPT SELECT T1.name FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id HAVING count(*)  >=  2",
        "question": "Show all storm names except for those with at least two affected regions.",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are all the storm names; 2. what are the storm names with at least two affected regions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'storm'. To complete the second subproblem, we need to use tables ['storm', 'affected_region'].\n\n<3> Operation: Use 'GROUP BY' operation on the column 'Storm_ID' and filter by performing 'HAVING COUNT()' on the column 'Region_id'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Name FROM storm EXCEPT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID GROUP BY T1.Storm_ID HAVING count(*)  >=  2",
        "predict": "SELECT Name FROM storm EXCEPT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID GROUP BY T1.Storm_ID HAVING count(*)  >=  2",
        "hardness": "hard"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT name FROM storm EXCEPT SELECT T1.name FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id HAVING count(*)  >=  2",
        "question": "What are the names of storms that did not affect two or more regions?",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all storms; 2. what are the names of storms that affected two or more regions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'storm'. To complete the second subproblem, we need to use tables ['storm', 'affected_region'].\n\n<3> Operation: For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'Storm_ID' and filter by performing 'HAVING COUNT()' on the column 'Region_id'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Name FROM storm EXCEPT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID GROUP BY T1.Storm_ID HAVING count(*)  >=  2",
        "predict": "SELECT Name FROM storm EXCEPT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID GROUP BY T1.Storm_ID HAVING count(*)  >=  2",
        "hardness": "hard"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT T3.Name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T2.Region_name  =  'Afghanistan' INTERSECT SELECT T3.Name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T2.Region_name  =  'Albania'",
        "question": "Find the name of the storm that affected both Afghanistan and Albania regions.",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what is the name of the storm that affected Afghanistan region; 2. what is the name of the storm that affected Albania region.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['storm', 'affected_region', 'region'].\n\n<3> Operation: Use 'where' to filter using column 'Region_name' in table 'region'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id WHERE T3.Region_name  =  \"Afghanistan\" INTERSECT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id WHERE T3.Region_name  =  \"Albania\"",
        "predict": "SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id WHERE T3.Region_name  =  \"Afghanistan\" INTERSECT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id WHERE T3.Region_name  =  \"Albania\"",
        "hardness": "extra"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT T3.Name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T2.Region_name  =  'Afghanistan' INTERSECT SELECT T3.Name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T2.Region_name  =  'Albania'",
        "question": "What are the names of the storms that affected both the regions of Afghanistan and Albania?",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of storms that affected the region of Afghanistan; 2. what are the names of storms that affected the region of Albania.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['storm', 'affected_region', 'region'].\n\n<3> Operation: Use 'where' to filter using column 'Region_name' in table 'region'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id WHERE T3.Region_name  =  \"Afghanistan\" INTERSECT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id WHERE T3.Region_name  =  \"Albania\"",
        "predict": "SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id WHERE T3.Region_name  =  \"Afghanistan\" INTERSECT SELECT T1.Name FROM storm AS T1 JOIN affected_region AS T2 ON T1.Storm_ID  =  T2.Storm_ID JOIN region AS T3 ON T2.Region_id  =  T3.Region_id WHERE T3.Region_name  =  \"Albania\"",
        "hardness": "extra"
    },
    {
        "db_id": "election",
        "gold": "SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Democratic\" INTERSECT SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Liberal\"",
        "question": "Which committees have delegates from both democratic party and liberal party?",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the committees that have delegates from the democratic party; 2. what are the committees that have delegates from the liberal party.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['election', 'party']. To complete the second subproblem, we need to use tables ['election', 'party'].\n\n<3> Operation: Use 'where' to filter using column 'Party' in table 'election'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Democratic\" INTERSECT SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Liberal\"",
        "predict": "SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Democratic\" INTERSECT SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Liberal\"",
        "hardness": "extra"
    },
    {
        "db_id": "election",
        "gold": "SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Democratic\" INTERSECT SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Liberal\"",
        "question": "Find the committees that have delegates both from from the democratic party and the liberal party.",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the committees that have delegates from the democratic party; 2. what are the committees that have delegates from the liberal party.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['election', 'party']. To complete the second subproblem, we need to use tables ['election', 'party'].\n\n<3> Operation: Use 'where' to filter using column 'Party' in table 'election'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Democratic\" INTERSECT SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Liberal\"",
        "predict": "SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Democratic\" INTERSECT SELECT T1.Committee FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID WHERE T2.Party  =  \"Liberal\"",
        "hardness": "extra"
    },
    {
        "db_id": "news_report",
        "gold": "SELECT Nationality FROM journalist WHERE Years_working  >  10 INTERSECT SELECT Nationality FROM journalist WHERE Years_working  <  3",
        "question": "Show the nations that have both journalists with more than 10 years of working and journalists with less than 3 years of working.",
        "fields": "Table event, columns = [*,Event_ID,Date,Venue,Name,Event_Attendance]\nTable journalist, columns = [*,journalist_ID,Name,Nationality,Age,Years_working]\nTable news_report, columns = [*,journalist_ID,Event_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [news_report.Event_ID = event.Event_ID,news_report.journalist_ID = journalist.journalist_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the nations that have journalists with more than 10 years of working; 2. what are the nations that have journalists with less than 3 years of working.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['journalist']. To complete the second subproblem, we need to use tables ['journalist'].\n\n<3> Operation: Use 'where' to filter using column 'Years_working' in table 'journalist'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.Nationality FROM journalist AS T1 WHERE T1.Years_working  >  10 INTERSECT SELECT T1.Nationality FROM journalist AS T1 WHERE T1.Years_working  <  3",
        "predict": "SELECT T1.Nationality FROM journalist AS T1 WHERE T1.Years_working  >  10 INTERSECT SELECT T1.Nationality FROM journalist AS T1 WHERE T1.Years_working  <  3",
        "hardness": "hard"
    },
    {
        "db_id": "customer_deliveries",
        "gold": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'",
        "question": "Find the names of customers who are not living in the state of California.",
        "fields": "Table Actual_Order_Products, columns = [*,actual_order_id,product_id]\nTable Actual_Orders, columns = [*,actual_order_id,order_status_code,regular_order_id,actual_order_date]\nTable Addresses, columns = [*,address_id,address_details,city,zip_postcode,state_province_county,country]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,address_type,date_to]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,date_became_customer]\nTable Delivery_Route_Locations, columns = [*,location_code,route_id,location_address_id,location_name]\nTable Delivery_Routes, columns = [*,route_id,route_name,other_route_details]\nTable Employees, columns = [*,employee_id,employee_address_id,employee_name,employee_phone]\nTable Order_Deliveries, columns = [*,location_code,actual_order_id,delivery_status_code,driver_employee_id,truck_id,delivery_date]\nTable Products, columns = [*,product_id,product_name,product_price,product_description]\nTable Regular_Order_Products, columns = [*,regular_order_id,product_id]\nTable Regular_Orders, columns = [*,regular_order_id,distributer_id]\nTable Trucks, columns = [*,truck_id,truck_licence_number,truck_details]\n",
        "foreign_keys": "Foreign_keys = [Regular_Orders.distributer_id = Customers.customer_id,Regular_Order_Products.regular_order_id = Regular_Orders.regular_order_id,Regular_Order_Products.product_id = Products.product_id,Actual_Orders.regular_order_id = Regular_Orders.regular_order_id,Actual_Order_Products.actual_order_id = Actual_Orders.actual_order_id,Actual_Order_Products.product_id = Products.product_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Delivery_Route_Locations.route_id = Delivery_Routes.route_id,Delivery_Route_Locations.location_address_id = Addresses.address_id,Employees.employee_address_id = Addresses.address_id,Order_Deliveries.driver_employee_id = Employees.employee_id,Order_Deliveries.location_code = Delivery_Route_Locations.location_code,Order_Deliveries.actual_order_id = Actual_Orders.actual_order_id,Order_Deliveries.truck_id = Trucks.truck_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all customers; 2. what are the names of customers who are living in the state of California.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Customers']. To complete the second subproblem, we need to use tables ['Customers', 'Customer_Addresses', 'Addresses'].\n\n<3> Operation: Use 'where' to filter using column 'state_province_county' in table 'Addresses'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'",
        "predict": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'",
        "hardness": "hard"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT title ,  film_id FROM film WHERE rental_rate  =  0.99 INTERSECT SELECT T1.title ,  T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id HAVING count(*)  <  3",
        "question": "What are the title and id of the film which has a rental rate of 0.99 and an inventory of below 3?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the titles and ids of films with a rental rate of 0.99; 2. what are the titles and ids of films with an inventory below 3.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['film']. To complete the second subproblem, we need to use tables ['film', 'inventory'].\n\n<3> Operation: Use 'where' to filter using column 'rental_rate' in table 'film'. Use 'where' to filter using column 'film_id' in table 'inventory' and perform 'HAVING COUNT()' on the column 'inventory_id'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.title ,  T1.film_id FROM film AS T1 WHERE T1.rental_rate  =  0.99 INTERSECT SELECT T1.title ,  T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id HAVING count(*)  <  3",
        "predict": "SELECT T1.title ,  T1.film_id FROM film AS T1 WHERE T1.rental_rate  =  0.99 INTERSECT SELECT T1.title ,  T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id HAVING count(*)  <  3",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT payment_date FROM payment WHERE amount  >  10 UNION SELECT T1.payment_date FROM payment AS T1 JOIN staff AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.first_name  =  'Elsa'",
        "question": "What are the payment dates for any payments that have an amount greater than 10 or were handled by a staff member with the first name Elsa?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the payment dates for payments that have an amount greater than 10; 2. what are the payment dates for payments that were handled by a staff member with the first name Elsa.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['payment']. To complete the second subproblem, we need to use tables ['payment', 'staff'].\n\n<3> Operation: For both subproblems, we need to filter using the 'amount' column in table 'payment' for the first subproblem, and the 'first_name' column in table 'staff' for the second subproblem.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT payment_date FROM payment WHERE amount  >  10 UNION SELECT payment_date FROM payment JOIN staff ON payment.staff_id  =  staff.staff_id WHERE staff.first_name  =  'Elsa'",
        "predict": "SELECT payment_date FROM payment WHERE amount  >  10 UNION SELECT payment_date FROM payment JOIN staff ON payment.staff_id  =  staff.staff_id WHERE staff.first_name  =  'Elsa'",
        "hardness": "hard"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT title FROM film WHERE LENGTH  >  100 OR rating  =  'PG' EXCEPT SELECT title FROM film WHERE replacement_cost  >  200",
        "question": "Find all the films longer than 100 minutes, or rated PG, except those who cost more than 200 for replacement. List the titles.",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union and difference set logic, so we can decompose the question into three subproblems: 1. what are the films longer than 100 minutes; 2. what are the films rated PG; 3. what are the films that cost more than 200 for replacement.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['film']. To complete the second subproblem, we need to use table ['film']. To complete the third subproblem, we need to use table ['film'].\n\n<3> Operation: Use 'where' to filter using column 'length' in table 'film'. Use 'where' to filter using column 'rating' in table 'film'. Use 'where' to filter using column 'replacement_cost' in table 'film'.\n\n<4> SQL Generation: Use 'union' and 'except' operations to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT title FROM film WHERE length  >  100 UNION SELECT title FROM film WHERE rating  =  \"PG\" EXCEPT SELECT title FROM film WHERE replacement_cost  >  200",
        "predict": "SELECT title FROM film WHERE length  >  100 UNION SELECT title FROM film WHERE rating  =  \"PG\" EXCEPT SELECT title FROM film WHERE replacement_cost  >  200",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT title FROM film WHERE LENGTH  >  100 OR rating  =  'PG' EXCEPT SELECT title FROM film WHERE replacement_cost  >  200",
        "question": "What are the titles of films that are either longer than 100 minutes or rated PG other than those that cost more than 200 to replace?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union and difference set logic, so we can decompose the question into three subproblems: 1. what are the titles of films that are longer than 100 minutes; 2. what are the titles of films that are rated PG; 3. what are the titles of films that cost more than 200 to replace.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['film']. To complete the second subproblem, we need to use table ['film']. To complete the third subproblem, we need to use table ['film'].\n\n<3> Operation: For the first subproblem, we need to filter using the column 'length' in table 'film'. For the second subproblem, we need to filter using the column 'rating' in table 'film'. For the third subproblem, we need to filter using the column 'replacement_cost' in table 'film'.\n\n<4> SQL Generation: Use 'union' and 'except' operations to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT title FROM film WHERE length  >  100 UNION SELECT title FROM film WHERE rating  =  \"PG\" EXCEPT SELECT title FROM film WHERE replacement_cost  >  200",
        "predict": "SELECT title FROM film WHERE length  >  100 UNION SELECT title FROM film WHERE rating  =  \"PG\" EXCEPT SELECT title FROM film WHERE replacement_cost  >  200",
        "hardness": "extra"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name FROM customer WHERE acc_type  =  'saving' INTERSECT SELECT cust_name FROM customer WHERE acc_type  =  'checking'",
        "question": "Find the name of customers who have both saving and checking account types.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of customers who have a saving account type; 2. what are the names of customers who have a checking account type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['customer']. To complete the second subproblem, we also need to use tables ['customer'].\n\n<3> Operation: Use 'where' to filter using column 'acc_type' in table 'customer'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT cust_name FROM customer WHERE acc_type  =  \"saving\" INTERSECT SELECT cust_name FROM customer WHERE acc_type  =  \"checking\"",
        "predict": "SELECT cust_name FROM customer WHERE acc_type  =  \"saving\" INTERSECT SELECT cust_name FROM customer WHERE acc_type  =  \"checking\"",
        "hardness": "hard"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name FROM customer WHERE acc_type  =  'saving' INTERSECT SELECT cust_name FROM customer WHERE acc_type  =  'checking'",
        "question": "What are the names of customers who have both savings and checking accounts?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of customers who have savings accounts; 2. what are the names of customers who have checking accounts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['customer'] and ['bank']. To complete the second subproblem, we also need to use tables ['customer'] and ['bank'].\n\n<3> Operation: Use 'where' to filter using column 'acc_type' in table 'customer'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.cust_name FROM customer AS T1 JOIN bank AS T2 ON T1.branch_ID  =  T2.branch_ID WHERE T1.acc_type  =  \"savings\" INTERSECT SELECT T1.cust_name FROM customer AS T1 JOIN bank AS T2 ON T1.branch_ID  =  T2.branch_ID WHERE T1.acc_type  =  \"checking\"",
        "predict": "SELECT T1.cust_name FROM customer AS T1 JOIN bank AS T2 ON T1.branch_ID  =  T2.branch_ID WHERE T1.acc_type  =  \"savings\" INTERSECT SELECT T1.cust_name FROM customer AS T1 JOIN bank AS T2 ON T1.branch_ID  =  T2.branch_ID WHERE T1.acc_type  =  \"checking\"",
        "hardness": "hard"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type  =  'saving'",
        "question": "Find the name of customers who do not have an saving account.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all customers; 2. what are the names of customers who have a saving account.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['customer']. To complete the second subproblem, we need to use tables ['customer'].\n\n<3> Operation: Use 'where' to filter using column 'acc_type' in table 'customer'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type  =  \"saving\"",
        "predict": "SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type  =  \"saving\"",
        "hardness": "hard"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type  =  'saving'",
        "question": "What are the names of customers who do not have saving accounts?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all customers; 2. what are the names of customers who have saving accounts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'customer'. To complete the second subproblem, we need to use tables ['customer', 'bank'].\n\n<3> Operation: Use 'where' to filter using column 'acc_type' in table 'customer'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT cust_name FROM customer EXCEPT SELECT t1.cust_name FROM customer AS t1 JOIN bank AS t2 ON t1.branch_ID  =  t2.branch_ID WHERE t1.acc_type  =  'saving'",
        "predict": "SELECT cust_name FROM customer EXCEPT SELECT t1.cust_name FROM customer AS t1 JOIN bank AS t2 ON t1.branch_ID  =  t2.branch_ID WHERE t1.acc_type  =  'saving'",
        "hardness": "hard"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name FROM customer EXCEPT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE T2.loan_type  =  'Mortgages'",
        "question": "Find the name of customers who do not have a loan with a type of Mortgages.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all customers; 2. what are the names of customers who have a loan with a type of Mortgages.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'customer'. To complete the second subproblem, we need to use tables ['customer', 'loan'].\n\n<3> Operation: Use 'where' to filter using column 'loan_type' in table 'loan'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT cust_name FROM customer EXCEPT SELECT t1.cust_name FROM customer AS t1 JOIN loan AS t2 ON t1.cust_ID  =  t2.cust_ID WHERE t2.loan_type  =  'Mortgages'",
        "predict": "SELECT cust_name FROM customer EXCEPT SELECT t1.cust_name FROM customer AS t1 JOIN loan AS t2 ON t1.cust_ID  =  t2.cust_ID WHERE t2.loan_type  =  'Mortgages'",
        "hardness": "hard"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name FROM customer EXCEPT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE T2.loan_type  =  'Mortgages'",
        "question": "What are the names of customers who have not taken a Mortage loan?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all customers; 2. what are the names of customers who have taken a Mortgage loan.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'customer'. To complete the second subproblem, we need to use tables ['customer', 'loan'].\n\n<3> Operation: Use 'where' to filter using column 'loan_type' in table 'loan'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT cust_name FROM customer EXCEPT SELECT t1.cust_name FROM customer AS t1 JOIN loan AS t2 ON t1.cust_ID  =  t2.cust_ID WHERE t2.loan_type  =  \"Mortgage\"",
        "predict": "SELECT cust_name FROM customer EXCEPT SELECT t1.cust_name FROM customer AS t1 JOIN loan AS t2 ON t1.cust_ID  =  t2.cust_ID WHERE t2.loan_type  =  \"Mortgage\"",
        "hardness": "hard"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE loan_type  =  'Mortgages' INTERSECT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE loan_type  =  'Auto'",
        "question": "Find the name of customers who have loans of both Mortgages and Auto.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of customers who have loans of Mortgages; 2. what are the names of customers who have loans of Auto.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['customer', 'loan']. To complete the second subproblem, we need to use tables ['customer', 'loan'].\n\n<3> Operation: Use 'where' to filter using column 'loan_type' in table 'loan'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_ID  =  T2.cust_ID WHERE T2.loan_type  =  \"Mortgages\" INTERSECT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_ID  =  T2.cust_ID WHERE T2.loan_type  =  \"Auto\"",
        "predict": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_ID  =  T2.cust_ID WHERE T2.loan_type  =  \"Mortgages\" INTERSECT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_ID  =  T2.cust_ID WHERE T2.loan_type  =  \"Auto\"",
        "hardness": "extra"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE loan_type  =  'Mortgages' INTERSECT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE loan_type  =  'Auto'",
        "question": "What are the names of customers who have taken both Mortgage and Auto loans?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of customers who have taken Mortgage loans; 2. what are the names of customers who have taken Auto loans.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['customer', 'loan']. To complete the second subproblem, we also need to use tables ['customer', 'loan'].\n\n<3> Operation: Use 'where' to filter using column 'loan_type' in table 'loan'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_ID  =  T2.cust_ID WHERE T2.loan_type  =  \"Mortgage\" INTERSECT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_ID  =  T2.cust_ID WHERE T2.loan_type  =  \"Auto\"",
        "predict": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_ID  =  T2.cust_ID WHERE T2.loan_type  =  \"Mortgage\" INTERSECT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_ID  =  T2.cust_ID WHERE T2.loan_type  =  \"Auto\"",
        "hardness": "extra"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT last_name FROM Teachers EXCEPT SELECT T1.last_name FROM Teachers AS T1 JOIN Detention AS T2 ON T1.teacher_id  =  T2.teacher_id",
        "question": "Find the last names of teachers who are not involved in any detention.",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the last names of all teachers; 2. what are the last names of teachers who are involved in detention.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Teachers']. To complete the second subproblem, we need to use tables ['Teachers', 'Detention'].\n\n<3> Operation: Use 'where' to filter using column 'teacher_id' in table 'Detention'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT last_name FROM teachers EXCEPT SELECT t1.last_name FROM teachers AS t1 JOIN detention AS t2 ON t1.teacher_id  =  t2.teacher_id",
        "predict": "SELECT last_name FROM teachers EXCEPT SELECT t1.last_name FROM teachers AS t1 JOIN detention AS t2 ON t1.teacher_id  =  t2.teacher_id",
        "hardness": "hard"
    },
    {
        "db_id": "assets_maintenance",
        "gold": "SELECT T1.company_id ,  T1.company_name FROM Third_Party_Companies AS T1 JOIN Maintenance_Engineers AS T2 ON T1.company_id  =  T2.company_id GROUP BY T1.company_id HAVING count(*)  >=  2 UNION SELECT T3.company_id ,  T3.company_name FROM Third_Party_Companies AS T3 JOIN Maintenance_Contracts AS T4 ON T3.company_id  =  T4.maintenance_contract_company_id GROUP BY T3.company_id HAVING count(*)  >=  2",
        "question": "Which third party companies have at least 2 maintenance engineers or have at least 2 maintenance contracts? List the company id and name.",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. which third party companies have at least 2 maintenance engineers; 2. which third party companies have at least 2 maintenance contracts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Third_Party_Companies', 'Maintenance_Engineers']. To complete the second subproblem, we need to use tables ['Third_Party_Companies', 'Maintenance_Contracts'].\n\n<3> Operation: For both subproblems, we need to perform a 'GROUP BY' operation on the column 'company_id' and filter by performing 'HAVING COUNT()' on the respective columns ('engineer_id' for the first subproblem and 'maintenance_contract_id' for the second subproblem).\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.company_id, T1.company_name FROM Third_Party_Companies AS T1 JOIN Maintenance_Engineers AS T2 ON T1.company_id = T2.company_id GROUP BY T1.company_id HAVING COUNT(*) >= 2 UNION SELECT T1.company_id, T1.company_name FROM Third_Party_Companies AS T1 JOIN Maintenance_Contracts AS T2 ON T1.company_id = T2.maintenance_contract_company_id GROUP BY T1.company_id HAVING COUNT(*) >= 2",
        "predict": "SELECT T1.company_id, T1.company_name FROM Third_Party_Companies AS T1 JOIN Maintenance_Engineers AS T2 ON T1.company_id = T2.company_id GROUP BY T1.company_id HAVING COUNT(*) >= 2 UNION SELECT T1.company_id, T1.company_name FROM Third_Party_Companies AS T1 JOIN Maintenance_Contracts AS T2 ON T1.company_id = T2.maintenance_contract_company_id GROUP BY T1.company_id HAVING COUNT(*) >= 2",
        "hardness": "extra"
    },
    {
        "db_id": "assets_maintenance",
        "gold": "SELECT T1.staff_name ,  T1.staff_id FROM Staff AS T1 JOIN Fault_Log AS T2 ON T1.staff_id  =  T2.recorded_by_staff_id EXCEPT SELECT T3.staff_name ,  T3.staff_id FROM Staff AS T3 JOIN Engineer_Visits AS T4 ON T3.staff_id  =  T4.contact_staff_id",
        "question": "What is the name and id of the staff who recorded the fault log but has not contacted any visiting engineers?",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what is the name and id of the staff who recorded the fault log; 2. what is the name and id of the staff who has contacted visiting engineers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Staff', 'Fault_Log']. To complete the second subproblem, we need to use tables ['Staff', 'Engineer_Visits'].\n\n<3> Operation: Use 'where' to filter using column 'recorded_by_staff_id' in table 'Fault_Log'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.staff_name ,  T1.staff_id FROM staff AS T1 JOIN fault_log AS T2 ON T1.staff_id  =  T2.recorded_by_staff_id EXCEPT SELECT T1.staff_name ,  T1.staff_id FROM staff AS T1 JOIN engineer_visits AS T2 ON T1.staff_id  =  T2.contact_staff_id",
        "predict": "SELECT T1.staff_name ,  T1.staff_id FROM staff AS T1 JOIN fault_log AS T2 ON T1.staff_id  =  T2.recorded_by_staff_id EXCEPT SELECT T1.staff_name ,  T1.staff_id FROM staff AS T1 JOIN engineer_visits AS T2 ON T1.staff_id  =  T2.contact_staff_id",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'",
        "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what is the first name of the professor who is teaching CIS-220; 2. what is the first name of the professor who is teaching QM-261.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['PROFESSOR', 'EMPLOYEE', 'CLASS', 'COURSE'].\n\n<3> Operation: Use 'where' to filter using column 'CRS_CODE' in table 'COURSE'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T2.EMP_FNAME FROM PROFESSOR AS T1 JOIN EMPLOYEE AS T2 ON T1.EMP_NUM  =  T2.EMP_NUM JOIN CLASS AS T3 ON T1.EMP_NUM  =  T3.PROF_NUM JOIN COURSE AS T4 ON T3.CRS_CODE  =  T4.CRS_CODE WHERE T4.CRS_CODE  =  \"CIS-220\" INTERSECT SELECT T2.EMP_FNAME FROM PROFESSOR AS T1 JOIN EMPLOYEE AS T2 ON T1.EMP_NUM  =  T2.EMP_NUM JOIN CLASS AS T3 ON T1.EMP_NUM  =  T3.PROF_NUM JOIN COURSE AS T4 ON T3.CRS_CODE  =  T4.CRS_CODE WHERE T4.CRS_CODE  =  \"QM-261\"",
        "predict": "SELECT T2.EMP_FNAME FROM PROFESSOR AS T1 JOIN EMPLOYEE AS T2 ON T1.EMP_NUM  =  T2.EMP_NUM JOIN CLASS AS T3 ON T1.EMP_NUM  =  T3.PROF_NUM JOIN COURSE AS T4 ON T3.CRS_CODE  =  T4.CRS_CODE WHERE T4.CRS_CODE  =  \"CIS-220\" INTERSECT SELECT T2.EMP_FNAME FROM PROFESSOR AS T1 JOIN EMPLOYEE AS T2 ON T1.EMP_NUM  =  T2.EMP_NUM JOIN CLASS AS T3 ON T1.EMP_NUM  =  T3.PROF_NUM JOIN COURSE AS T4 ON T3.CRS_CODE  =  T4.CRS_CODE WHERE T4.CRS_CODE  =  \"QM-261\"",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'",
        "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the first names of students who are taking classes from the accounting department; 2. what are the first names of students who are taking classes from the Computer Info. Systems department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['STUDENT', 'ENROLL', 'CLASS', 'COURSE', 'DEPARTMENT']. To complete the second subproblem, we also need to use tables ['STUDENT', 'ENROLL', 'CLASS', 'COURSE', 'DEPARTMENT'].\n\n<3> Operation: Use 'where' to filter using column 'DEPT_NAME' in table 'DEPARTMENT'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.STU_FNAME FROM STUDENT AS T1 JOIN ENROLL AS T2 ON T1.STU_NUM  =  T2.STU_NUM JOIN CLASS AS T3 ON T2.CLASS_CODE  =  T3.CLASS_CODE JOIN COURSE AS T4 ON T3.CRS_CODE  =  T4.CRS_CODE JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE  =  T5.DEPT_CODE WHERE T5.DEPT_NAME  =  \"accounting\" INTERSECT SELECT T1.STU_FNAME FROM STUDENT AS T1 JOIN ENROLL AS T2 ON T1.STU_NUM  =  T2.STU_NUM JOIN CLASS AS T3 ON T2.CLASS_CODE  =  T3.CLASS_CODE JOIN COURSE AS T4 ON T3.CRS_CODE  =  T4.CRS_CODE JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE  =  T5.DEPT_CODE WHERE T5.DEPT_NAME  =  \"Computer Info. Systems\"",
        "predict": "SELECT T1.STU_FNAME FROM STUDENT AS T1 JOIN ENROLL AS T2 ON T1.STU_NUM  =  T2.STU_NUM JOIN CLASS AS T3 ON T2.CLASS_CODE  =  T3.CLASS_CODE JOIN COURSE AS T4 ON T3.CRS_CODE  =  T4.CRS_CODE JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE  =  T5.DEPT_CODE WHERE T5.DEPT_NAME  =  \"accounting\" INTERSECT SELECT T1.STU_FNAME FROM STUDENT AS T1 JOIN ENROLL AS T2 ON T1.STU_NUM  =  T2.STU_NUM JOIN CLASS AS T3 ON T2.CLASS_CODE  =  T3.CLASS_CODE JOIN COURSE AS T4 ON T3.CRS_CODE  =  T4.CRS_CODE JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE  =  T5.DEPT_CODE WHERE T5.DEPT_NAME  =  \"Computer Info. Systems\"",
        "hardness": "extra"
    },
    {
        "db_id": "sports_competition",
        "gold": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10",
        "question": "What are the positions with both players having more than 20 points and less than 10 points.",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the positions with players having more than 20 points; 2. what are the positions with players having less than 10 points.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['player']. To complete the second subproblem, we also need to use tables ['player'].\n\n<3> Operation: Use 'where' to filter using column 'Points' in table 'player'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT position FROM player WHERE Points  >  20 INTERSECT SELECT position FROM player WHERE Points  <  10",
        "predict": "SELECT position FROM player WHERE Points  >  20 INTERSECT SELECT position FROM player WHERE Points  <  10",
        "hardness": "hard"
    },
    {
        "db_id": "sports_competition",
        "gold": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10",
        "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the positions of players that have more than 20 points; 2. what are the positions of players that have less than 10 points.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['player'].\n\n<3> Operation: Use 'where' to filter using column 'Points' in table 'player'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT position FROM player WHERE points  >  20 INTERSECT SELECT position FROM player WHERE points  <  10",
        "predict": "SELECT position FROM player WHERE points  >  20 INTERSECT SELECT position FROM player WHERE points  <  10",
        "hardness": "hard"
    },
    {
        "db_id": "manufacturer",
        "gold": "SELECT t3.name FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID  =  t2.Furniture_ID JOIN manufacturer AS t3 ON t2.manufacturer_id  =  t3.manufacturer_id WHERE t1.num_of_component  <  6 INTERSECT SELECT t3.name FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID  =  t2.Furniture_ID JOIN manufacturer AS t3 ON t2.manufacturer_id  =  t3.manufacturer_id WHERE t1.num_of_component  >  10",
        "question": "Find the name of the company that produces both furnitures with less than 6 components and furnitures with more than 10 components.",
        "fields": "Table furniture, columns = [*,Furniture_ID,Name,Num_of_Component,Market_Rate]\nTable furniture_manufacte, columns = [*,Manufacturer_ID,Furniture_ID,Price_in_Dollar]\nTable manufacturer, columns = [*,Manufacturer_ID,Open_Year,Name,Num_of_Factories,Num_of_Shops]\n",
        "foreign_keys": "Foreign_keys = [furniture_manufacte.Furniture_ID = furniture.Furniture_ID,furniture_manufacte.Manufacturer_ID = manufacturer.Manufacturer_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of companies that produce furnitures with less than 6 components; 2. what are the names of companies that produce furnitures with more than 10 components.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['manufacturer', 'furniture', 'furniture_manufacte']. To complete the second subproblem, we also need to use tables ['manufacturer', 'furniture', 'furniture_manufacte'].\n\n<3> Operation: Use 'where' to filter using column 'Num_of_Component' in table 'furniture'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T3.Name FROM manufacturer AS T3 JOIN furniture_manufacte AS T2 ON T3.Manufacturer_ID  =  T2.Manufacturer_ID JOIN furniture AS T1 ON T1.Furniture_ID  =  T2.Furniture_ID WHERE T1.Num_of_Component  <  6 INTERSECT SELECT T3.Name FROM manufacturer AS T3 JOIN furniture_manufacte AS T2 ON T3.Manufacturer_ID  =  T2.Manufacturer_ID JOIN furniture AS T1 ON T1.Furniture_ID  =  T2.Furniture_ID WHERE T1.Num_of_Component  >  10",
        "predict": "SELECT T3.Name FROM manufacturer AS T3 JOIN furniture_manufacte AS T2 ON T3.Manufacturer_ID  =  T2.Manufacturer_ID JOIN furniture AS T1 ON T1.Furniture_ID  =  T2.Furniture_ID WHERE T1.Num_of_Component  <  6 INTERSECT SELECT T3.Name FROM manufacturer AS T3 JOIN furniture_manufacte AS T2 ON T3.Manufacturer_ID  =  T2.Manufacturer_ID JOIN furniture AS T1 ON T1.Furniture_ID  =  T2.Furniture_ID WHERE T1.Num_of_Component  >  10",
        "hardness": "extra"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT artist_name FROM song WHERE languages  =  \"english\"",
        "question": "Find the names of the artists who are from UK and have produced English songs.",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of artists who are from the UK; 2. what are the names of artists who have produced English songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'artist'. To complete the second subproblem, we need to use tables ['artist', 'song'].\n\n<3> Operation: Use 'where' to filter using column 'country' in table 'artist' and column 'languages' in table 'song'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT artist_name FROM song WHERE languages  =  \"English\"",
        "predict": "SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT artist_name FROM song WHERE languages  =  \"English\"",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT artist_name FROM song WHERE languages  =  \"english\"",
        "question": "What are the names of the artists that are from the UK and sang songs in English?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of the artists that are from the UK; 2. what are the names of the artists that sang songs in English.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'artist'. To complete the second subproblem, we need to use tables ['artist', 'song'].\n\n<3> Operation: Use 'where' to filter using column 'country' in table 'artist' for the first subproblem. Use 'where' to filter using column 'languages' in table 'song' for the second subproblem.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT artist_name FROM song WHERE languages  =  \"English\"",
        "predict": "SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT artist_name FROM song WHERE languages  =  \"English\"",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT f_id FROM files WHERE formats  =  \"mp4\" INTERSECT SELECT f_id FROM song WHERE resolution  <  1000",
        "question": "Find the id of songs that are available in mp4 format and have resolution lower than 1000.",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the ids of songs that are available in mp4 format; 2. what are the ids of songs that have resolution lower than 1000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['files', 'song']. To complete the second subproblem, we need to use table ['song'].\n\n<3> Operation: Use 'where' to filter using column 'formats' in table 'files' and column 'resolution' in table 'song'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T2.f_id FROM files AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name AND T1.f_id  =  T2.f_id WHERE T1.formats  =  \"mp4\" INTERSECT SELECT f_id FROM song WHERE resolution  <  1000",
        "predict": "SELECT T2.f_id FROM files AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name AND T1.f_id  =  T2.f_id WHERE T1.formats  =  \"mp4\" INTERSECT SELECT f_id FROM song WHERE resolution  <  1000",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT f_id FROM files WHERE formats  =  \"mp4\" UNION SELECT f_id FROM song WHERE resolution  >  720",
        "question": "What are the ids of songs that are available in either mp4 format or have resolution above 720?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the ids of songs that are available in mp4 format; 2. what are the ids of songs that have resolution above 720.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['files']. To complete the second subproblem, we need to use tables ['song'].\n\n<3> Operation: For the first subproblem, we need to filter using column 'formats' in table 'files'. For the second subproblem, we need to filter using column 'resolution' in table 'song'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.f_id FROM files AS T1 WHERE T1.formats  =  \"mp4\" UNION SELECT T1.f_id FROM song AS T1 WHERE T1.resolution  >  720",
        "predict": "SELECT T1.f_id FROM files AS T1 WHERE T1.formats  =  \"mp4\" UNION SELECT T1.f_id FROM song AS T1 WHERE T1.resolution  >  720",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.formats  =  \"mp3\" INTERSECT SELECT song_name FROM song WHERE resolution  <  1000",
        "question": "Return the names of songs for which format is mp3 and resolution is below 1000.",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of songs for which format is mp3; 2. what are the names of songs for which resolution is below 1000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['song', 'files']. To complete the second subproblem, we need to use table ['song'].\n\n<3> Operation: Use 'where' to filter using column 'formats' and 'resolution' in table 'files' and 'song' respectively.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.song_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id WHERE T2.formats  =  \"mp3\" INTERSECT SELECT T1.song_name FROM song AS T1 WHERE T1.resolution  <  1000",
        "predict": "SELECT T1.song_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id WHERE T2.formats  =  \"mp3\" INTERSECT SELECT T1.song_name FROM song AS T1 WHERE T1.resolution  <  1000",
        "hardness": "extra"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.formats  =  \"mp3\" INTERSECT SELECT song_name FROM song WHERE resolution  <  1000",
        "question": "What are the names of all songs that are in mp3 format and have a resolution lower than 1000?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of all songs that are in mp3 format; 2. what are the names of all songs that have a resolution lower than 1000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['song', 'files']. To complete the second subproblem, we need to use table ['song'].\n\n<3> Operation: Use 'where' to filter using column 'formats' in table 'files' for the first subproblem. Use 'where' to filter using column 'resolution' in table 'song' for the second subproblem.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.song_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id WHERE T2.formats  =  \"mp3\" INTERSECT SELECT song_name FROM song WHERE resolution  <  1000",
        "predict": "SELECT T1.song_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id WHERE T2.formats  =  \"mp3\" INTERSECT SELECT song_name FROM song WHERE resolution  <  1000",
        "hardness": "extra"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  \"english\"",
        "question": "Return the names of singers who are from UK and released an English song.",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of singers who are from the UK; 2. what are the names of singers who released an English song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'artist'. To complete the second subproblem, we need to use tables ['artist', 'song'].\n\n<3> Operation: Use 'where' to filter using column 'country' in table 'artist' and column 'languages' in table 'song'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT artist_name FROM artist WHERE country  =  'UK' INTERSECT SELECT artist_name FROM song WHERE languages  =  'English'",
        "predict": "SELECT artist_name FROM artist WHERE country  =  'UK' INTERSECT SELECT artist_name FROM song WHERE languages  =  'English'",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  \"english\"",
        "question": "What are the names of all singers that are from the UK and released a song in English?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of all singers that are from the UK; 2. what are the names of singers who released a song in English.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'artist'. To complete the second subproblem, we need to use tables ['artist', 'song'].\n\n<3> Operation: Use 'where' to filter using column 'country' in table 'artist' and column 'languages' in table 'song'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT artist_name FROM song WHERE languages  =  \"English\"",
        "predict": "SELECT artist_name FROM artist WHERE country  =  \"UK\" INTERSECT SELECT artist_name FROM song WHERE languages  =  \"English\"",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT DISTINCT artist_name FROM artist WHERE country  =  \"Bangladesh\" EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating  >  7",
        "question": "What are the names of the different artists from Bangladesh who never received a rating higher than a 7?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all artists from Bangladesh; 2. what are the names of artists from Bangladesh who never received a rating higher than a 7.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['artist']. To complete the second subproblem, we need to use tables ['artist', 'song'].\n\n<3> Operation: Use 'where' to filter using column 'country' in table 'artist' and column 'rating' in table 'song'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT artist_name FROM artist WHERE country  =  \"Bangladesh\" EXCEPT SELECT t1.artist_name FROM artist AS t1 JOIN song AS t2 ON t1.artist_name  =  t2.artist_name WHERE t2.rating  >  7",
        "predict": "SELECT artist_name FROM artist WHERE country  =  \"Bangladesh\" EXCEPT SELECT t1.artist_name FROM artist AS t1 JOIN song AS t2 ON t1.artist_name  =  t2.artist_name WHERE t2.rating  >  7",
        "hardness": "hard"
    },
    {
        "db_id": "department_management",
        "gold": "SELECT T3.born_state FROM department AS T1 JOIN management AS T2 ON T1.department_id  =  T2.department_id JOIN head AS T3 ON T2.head_id  =  T3.head_id WHERE T1.name  =  'Treasury' INTERSECT SELECT T3.born_state FROM department AS T1 JOIN management AS T2 ON T1.department_id  =  T2.department_id JOIN head AS T3 ON T2.head_id  =  T3.head_id WHERE T1.name  =  'Homeland Security'",
        "question": "List the states where both the secretary of 'Treasury' department and the secretary of 'Homeland Security' were born.",
        "fields": "Table department, columns = [*,Department_ID,Name,Creation,Ranking,Budget_in_Billions,Num_Employees]\nTable head, columns = [*,head_ID,name,born_state,age]\nTable management, columns = [*,department_ID,head_ID,temporary_acting]\n",
        "foreign_keys": "Foreign_keys = [management.head_ID = head.head_ID,management.department_ID = department.Department_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what is the state where the secretary of 'Treasury' department was born; 2. what is the state where the secretary of 'Homeland Security' department was born.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['department', 'management', 'head'].\n\n<3> Operation: Use 'where' to filter using column 'Name' in table 'department'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T3.born_state FROM department AS T1 JOIN management AS T2 ON T1.Department_ID = T2.department_ID JOIN head AS T3 ON T2.head_ID = T3.head_ID WHERE T1.Name = \"Treasury\" INTERSECT SELECT T3.born_state FROM department AS T1 JOIN management AS T2 ON T1.Department_ID = T2.department_ID JOIN head AS T3 ON T2.head_ID = T3.head_ID WHERE T1.Name = \"Homeland Security\"",
        "predict": "SELECT T3.born_state FROM department AS T1 JOIN management AS T2 ON T1.Department_ID = T2.department_ID JOIN head AS T3 ON T2.head_ID = T3.head_ID WHERE T1.Name = \"Treasury\" INTERSECT SELECT T3.born_state FROM department AS T1 JOIN management AS T2 ON T1.Department_ID = T2.department_ID JOIN head AS T3 ON T2.head_ID = T3.head_ID WHERE T1.Name = \"Homeland Security\"",
        "hardness": "extra"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT student_id FROM student_course_registrations UNION SELECT student_id FROM student_course_attendance",
        "question": "What are the id of students who registered courses or attended courses?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the id of students who registered courses; 2. what are the id of students who attended courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Students', 'Student_Course_Registrations']. To complete the second subproblem, we need to use tables ['Students', 'Student_Course_Attendance'].\n\n<3> Operation: No specific operation is needed for this query except for the basic 'SELECT' operation.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT student_id FROM Student_Course_Registrations UNION SELECT student_id FROM Student_Course_Attendance",
        "predict": "SELECT student_id FROM Student_Course_Registrations UNION SELECT student_id FROM Student_Course_Attendance",
        "hardness": "hard"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT student_id FROM student_course_registrations UNION SELECT student_id FROM student_course_attendance",
        "question": "What are the ids of the students who either registered or attended a course?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the ids of the students who registered a course; 2. what are the ids of the students who attended a course.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Students', 'Student_Course_Registrations']. To complete the second subproblem, we need to use tables ['Students', 'Student_Course_Attendance'].\n\n<3> Operation: For both subproblems, we need to select the 'student_id' column from the respective tables.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT student_id FROM student_course_registrations UNION SELECT student_id FROM student_course_attendance",
        "predict": "SELECT student_id FROM student_course_registrations UNION SELECT student_id FROM student_course_attendance",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT id FROM station WHERE city  =  \"San Francisco\" INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  10",
        "question": "What are the ids of the stations in San Francisco that normally have more than 10 bikes available?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query can be solved in a single step, so we don't need to decompose it further.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we need to use tables ['station', 'status'].\n\n<3> Operation: We need to perform a 'GROUP BY' operation on the column 'station_id' and filter by performing 'HAVING AVG()' on the column 'bikes_available'. Additionally, we need to use 'WHERE' to filter using column 'city' in table 'station'.\n\n<4> SQL Generation: Generate the final SQL statement based on the operations and schema linking.\n\nSQL query: SELECT T1.id FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id WHERE T1.city = \"San Francisco\" GROUP BY T2.station_id HAVING AVG(T2.bikes_available) > 10",
        "predict": "SELECT T1.id FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id WHERE T1.city = \"San Francisco\" GROUP BY T2.station_id HAVING AVG(T2.bikes_available) > 10",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE \"12/%\"",
        "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the names and ids of stations that had more than 14 bikes available on average; 2. what are the names and ids of stations that were installed in December.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['station', 'status']. To complete the second subproblem, we need to use table ['station'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'station_id' and filter by performing 'HAVING AVG()' on the column 'bikes_available'. For the second subproblem, we need to use 'LIKE' to filter using month number on the column 'installation_date'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name, T1.id FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available) > 14 UNION SELECT name, id FROM station WHERE installation_date LIKE '12/%'",
        "predict": "SELECT T1.name, T1.id FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available) > 14 UNION SELECT name, id FROM station WHERE installation_date LIKE '12/%'",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE \"12/%\"",
        "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the names and ids of all stations that have more than 14 bikes available on average; 2. what are the names and ids of all stations that had bikes installed in December.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['station', 'status']. To complete the second subproblem, we need to use table ['station'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'station_id' and filter by performing 'HAVING AVG()' on the column 'bikes_available'. For the second subproblem, we need to use 'LIKE' to filter using month number on the column 'installation_date'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name, T1.id FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id GROUP BY T1.id HAVING avg(T2.bikes_available) > 14 UNION SELECT name, id FROM station WHERE installation_date LIKE '12/%'",
        "predict": "SELECT T1.name, T1.id FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id GROUP BY T1.id HAVING avg(T2.bikes_available) > 14 UNION SELECT name, id FROM station WHERE installation_date LIKE '12/%'",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT id FROM station WHERE lat  >  37.4 EXCEPT SELECT station_id FROM status GROUP BY station_id HAVING min(bikes_available)  <  7",
        "question": "What are the ids of all stations that have a latitude above 37.4 and have never had less than 7 bikes available?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the ids of all stations that have a latitude above 37.4; 2. what are the ids of all stations that have never had less than 7 bikes available.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['station']. To complete the second subproblem, we need to use tables ['station', 'status'].\n\n<3> Operation: For the first subproblem, we need to filter using 'where' to extract records where 'lat' is above 37.4. For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'station_id' and filter by performing 'HAVING MIN()' on the column 'bikes_available'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT id FROM station WHERE lat > 37.4 INTERSECT SELECT T1.id FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id GROUP BY T1.id HAVING MIN(T2.bikes_available) >= 7",
        "predict": "SELECT id FROM station WHERE lat > 37.4 INTERSECT SELECT T1.id FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id GROUP BY T1.id HAVING MIN(T2.bikes_available) >= 7",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  10 EXCEPT SELECT name FROM station WHERE city  =  \"San Jose\"",
        "question": "What are the names of all stations that have more than 10 bikes available and are not located in San Jose?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of all stations that have more than 10 bikes available; 2. what are the names of all stations that are not located in San Jose city.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['station', 'status']. To complete the second subproblem, we need to use table ['station'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'station_id' and filter by performing 'HAVING COUNT()' on the column 'bikes_available'. For the second subproblem, we need to use 'where' to filter using column 'city' in table 'station'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available) > 10 INTERSECT SELECT name FROM station WHERE city != \"San Jose\"",
        "predict": "SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available) > 10 INTERSECT SELECT name FROM station WHERE city != \"San Jose\"",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70",
        "question": "Find all the zip codes in which the max dew point have never reached 70.",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are all the zip codes; 2. what are the zip codes in which the max dew point has reached 70.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['weather']. To complete the second subproblem, we need to use table ['weather'].\n\n<3> Operation: Use 'where' to filter using column 'max_dew_point_f' in table 'weather'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f >= 70",
        "predict": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f >= 70",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70",
        "question": "What are all the different zip codes that have a maximum dew point that was always below 70?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are all the different zip codes; 2. what are the zip codes that have a maximum dew point above or equal to 70.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['weather']. To complete the second subproblem, we need to use table ['weather'] as well.\n\n<3> Operation: Use 'where' to filter using column 'max_dew_point_f' in table 'weather'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f >= 70",
        "predict": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f >= 70",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100",
        "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the zip codes where the average mean humidity is below 70; 2. what are the zip codes where at least 100 trips took place.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['weather']. To complete the second subproblem, we need to use table ['trip'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'zip_code' and filter by performing 'HAVING AVG()' on the column 'mean_humidity'. For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'zip_code' and filter by performing 'HAVING COUNT()' on the column 'id'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT zip_code FROM weather GROUP BY zip_code HAVING AVG(mean_humidity) < 70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING COUNT(id) >= 100",
        "predict": "SELECT zip_code FROM weather GROUP BY zip_code HAVING AVG(mean_humidity) < 70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING COUNT(id) >= 100",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100",
        "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the zip codes that have an average mean humidity below 70; 2. what are the zip codes that had at least 100 trips come through there.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['weather']. To complete the second subproblem, we need to use tables ['trip'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'zip_code' and filter by performing 'HAVING AVG()' on the column 'mean_humidity'. For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'zip_code' and filter by performing 'HAVING COUNT()' on the column 'id'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity) < 70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*) >= 100",
        "predict": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity) < 70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*) >= 100",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT name FROM station WHERE city  =  \"Palo Alto\" EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  100",
        "question": "What are the names of the stations that are located in Palo Alto but have never been the ending point of the trips",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of stations that are located in Palo Alto; 2. what are the names of stations that have been the ending point of the trips.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['station']. To complete the second subproblem, we need to use tables ['station', 'trip'].\n\n<3> Operation: Use 'where' to filter using column 'city' in table 'station' for the first subproblem. For the second subproblem, use 'where' to filter using column 'end_station_name' in table 'trip'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT name FROM station WHERE city = 'Palo Alto' EXCEPT SELECT end_station_name FROM trip",
        "predict": "SELECT name FROM station WHERE city = 'Palo Alto' EXCEPT SELECT end_station_name FROM trip",
        "hardness": "hard"
    },
    {
        "db_id": "musical",
        "gold": "SELECT Nominee FROM musical WHERE Award  =  \"Tony Award\" INTERSECT SELECT Nominee FROM musical WHERE Award  =  \"Drama Desk Award\"",
        "question": "Show the nominees that have nominated musicals for both \"Tony Award\" and \"Drama Desk Award\".",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the nominees that have nominated musicals for \"Tony Award\"; 2. what are the nominees that have nominated musicals for \"Drama Desk Award\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'musical'. To complete the second subproblem, we need to use table 'musical' in the same reason.\n\n<3> Operation: Use 'where' to filter using column 'Award' in table 'musical'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Nominee FROM musical WHERE Award = \"Tony Award\" INTERSECT SELECT Nominee FROM musical WHERE Award = \"Drama Desk Award\"",
        "predict": "SELECT Nominee FROM musical WHERE Award = \"Tony Award\" INTERSECT SELECT Nominee FROM musical WHERE Award = \"Drama Desk Award\"",
        "hardness": "hard"
    },
    {
        "db_id": "musical",
        "gold": "SELECT Nominee FROM musical WHERE Award  =  \"Tony Award\" INTERSECT SELECT Nominee FROM musical WHERE Award  =  \"Drama Desk Award\"",
        "question": "Who are the nominees who have been nominated for both a Tony Award and a Drama Desk Award?",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. who are the nominees who have been nominated for a Tony Award; 2. who are the nominees who have been nominated for a Drama Desk Award.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use table ['musical'].\n\n<3> Operation: Use 'where' to filter using column 'Award' in table 'musical'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Nominee FROM musical WHERE Award = \"Tony Award\" INTERSECT SELECT Nominee FROM musical WHERE Award = \"Drama Desk Award\"",
        "predict": "SELECT Nominee FROM musical WHERE Award = \"Tony Award\" INTERSECT SELECT Nominee FROM musical WHERE Award = \"Drama Desk Award\"",
        "hardness": "hard"
    },
    {
        "db_id": "twitter_1",
        "gold": "SELECT T2.f1 FROM user_profiles AS T1 JOIN follows AS T2 ON T1.uid  =  T2.f2 WHERE T1.name  =  \"Mary\" INTERSECT SELECT T2.f1 FROM user_profiles AS T1 JOIN follows AS T2 ON T1.uid  =  T2.f2 WHERE T1.name  =  \"Susan\"",
        "question": "Find the id of users who are followed by Mary and Susan.",
        "fields": "Table follows, columns = [*,f1,f2]\nTable tweets, columns = [*,id,uid,text,createdate]\nTable user_profiles, columns = [*,uid,name,email,partitionid,followers]\n",
        "foreign_keys": "Foreign_keys = [follows.f2 = user_profiles.uid,follows.f1 = user_profiles.uid,tweets.uid = user_profiles.uid]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the ids of users who are followed by Mary; 2. what are the ids of users who are followed by Susan.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['user_profiles', 'follows']. To complete the second subproblem, we need to use tables ['user_profiles', 'follows'] in the same reason.\n\n<3> Operation: Use 'where' to filter using column 'name' in table 'user_profiles'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T2.f2 FROM user_profiles AS T1 JOIN follows AS T2 ON T1.uid = T2.f2 WHERE T1.name = \"Mary\" INTERSECT SELECT T2.f2 FROM user_profiles AS T1 JOIN follows AS T2 ON T1.uid = T2.f2 WHERE T1.name = \"Susan\"",
        "predict": "SELECT T2.f2 FROM user_profiles AS T1 JOIN follows AS T2 ON T1.uid = T2.f2 WHERE T1.name = \"Mary\" INTERSECT SELECT T2.f2 FROM user_profiles AS T1 JOIN follows AS T2 ON T1.uid = T2.f2 WHERE T1.name = \"Susan\"",
        "hardness": "extra"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy",
        "question": "Which students are unaffected by allergies?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all students; 2. what are the names of students who have allergies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Student']. To complete the second subproblem, we need to use tables ['Student', 'Has_Allergy'].\n\n<3> Operation: Use 'where' to filter using column 'StuID' in table 'Has_Allergy'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT StuID FROM Student EXCEPT SELECT T1.StuID FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.StuID = T2.StuID",
        "predict": "SELECT StuID FROM Student EXCEPT SELECT T1.StuID FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.StuID = T2.StuID",
        "hardness": "hard"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  \"Milk\" INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  \"Cat\")",
        "question": "What are the last names and ages of the students who are allergic to milk and cat?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the last names and ages of the students who are allergic to milk; 2. what are the last names and ages of the students who are allergic to cat.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Student', 'Has_Allergy', 'Allergy_Type']. To complete the second subproblem, we need to use tables ['Student', 'Has_Allergy', 'Allergy_Type'].\n\n<3> Operation: For both subproblems, we need to perform a 'JOIN' operation on the column 'StuID' in table 'Student' and 'Has_Allergy', and then filter using column 'Allergy' in table 'Allergy_Type'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.LName , T1.Age FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.StuID = T2.StuID JOIN Allergy_Type AS T3 ON T2.Allergy = T3.Allergy WHERE T3.AllergyType = \"Milk\" INTERSECT SELECT T1.LName , T1.Age FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.StuID = T2.StuID JOIN Allergy_Type AS T3 ON T2.Allergy = T3.Allergy WHERE T3.AllergyType = \"Cat\"",
        "predict": "SELECT T1.LName , T1.Age FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.StuID = T2.StuID JOIN Allergy_Type AS T3 ON T2.Allergy = T3.Allergy WHERE T3.AllergyType = \"Milk\" INTERSECT SELECT T1.LName , T1.Age FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.StuID = T2.StuID JOIN Allergy_Type AS T3 ON T2.Allergy = T3.Allergy WHERE T3.AllergyType = \"Cat\"",
        "hardness": "extra"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\" INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"animal\")",
        "question": "Find the average age of the students who have allergies with food and animal types.",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into three subproblems: 1. what is the id of students who have allergies with food types; 2. what is the id of students who have allergies with animal types; 3. calculate the intersection of the results of two sub problems, and then calculate the average age for the corresponding students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Student', 'Has_Allergy', 'Allergy_Type']. To complete the second subproblem, we need to use tables ['Student', 'Has_Allergy', 'Allergy_Type'] in the same reason. To complete the third subproblem, we need to use table ['Student'].\n\n<3> Operation: Use 'where' to filter using column 'AllergyType' in table 'Allergy_Type'. Then, use 'where' to filter using column 'StuID' in table 'Student' and use 'avg' to calculate average age.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of first two subproblems to form the StuID selection. Use 'avg' operation to calculate average age of selected students.\n\nSQL query: SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'animal')",
        "predict": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'animal')",
        "hardness": "hard"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\" INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"animal\")",
        "question": "How old are the students with allergies to food and animal types on average?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what is the id of students who have allergies with food types; 2. what is the id of students who have allergies with animal types; 3. calculate the intersection of the results of two subproblems, and then calculate the average age for the corresponding students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Student', 'Has_Allergy', 'Allergy_Type']. To complete the second subproblem, we need to use tables ['Student', 'Has_Allergy', 'Allergy_Type'] in the same reason. To complete the third subproblem, we need to use table ['Student'].\n\n<3> Operation: Use 'where' to filter using column 'AllergyType' in table 'Allergy_Type'. Then, use 'where' to filter using column 'StuID' in table 'Student' and use 'avg' to calculate average age.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of first two subproblems to form the StuID selection. Use 'avg' operation to calculate average age of selected students.\n\nSQL query: SELECT AVG(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'animal')",
        "predict": "SELECT AVG(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'animal')",
        "hardness": "hard"
    },
    {
        "db_id": "journal_committee",
        "gold": "SELECT date ,  theme ,  sales FROM journal EXCEPT SELECT T1.date ,  T1.theme ,  T1.sales FROM journal AS T1 JOIN journal_committee AS T2 ON T1.journal_ID  =  T2.journal_ID",
        "question": "List the date, theme and sales of the journal which did not have any of the listed editors serving on committee.",
        "fields": "Table editor, columns = [*,Editor_ID,Name,Age]\nTable journal, columns = [*,Journal_ID,Date,Theme,Sales]\nTable journal_committee, columns = [*,Editor_ID,Journal_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [journal_committee.Journal_ID = journal.Journal_ID,journal_committee.Editor_ID = editor.Editor_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the date, theme, and sales of all journals; 2. what are the date, theme, and sales of journals which had any of the listed editors serving on the committee.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['journal']. To complete the second subproblem, we need to use tables ['journal', 'journal_committee'].\n\n<3> Operation: Use 'where' to filter using column 'Journal_ID' in table 'journal_committee'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Date, Theme, Sales FROM journal EXCEPT SELECT T1.Date, T1.Theme, T1.Sales FROM journal AS T1 JOIN journal_committee AS T2 ON T1.Journal_ID = T2.Journal_ID",
        "predict": "SELECT Date, Theme, Sales FROM journal EXCEPT SELECT T1.Date, T1.Theme, T1.Sales FROM journal AS T1 JOIN journal_committee AS T2 ON T1.Journal_ID = T2.Journal_ID",
        "hardness": "extra"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  \"Credit\"",
        "question": "Show the customer ids and firstname without a credit card.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the customer ids and first names of all customers; 2. what are the customer ids and first names of customers with a credit card (card type is Credit).\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Customers']. To complete the second subproblem, we need to use tables ['Customers', 'Customers_Cards'].\n\n<3> Operation: Use 'where' to filter using column 'card_id' in table 'Customers_Cards'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT customer_id, customer_first_name FROM Customers EXCEPT SELECT T1.customer_id, T1.customer_first_name FROM Customers AS T1 JOIN Customers_Cards AS T2 ON T1.customer_id = T2.customer_id WHERE T2.card_type_code = 'Credit'",
        "predict": "SELECT customer_id, customer_first_name FROM Customers EXCEPT SELECT T1.customer_id, T1.customer_first_name FROM Customers AS T1 JOIN Customers_Cards AS T2 ON T1.customer_id = T2.customer_id WHERE T2.card_type_code = 'Credit'",
        "hardness": "extra"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  \"Credit\"",
        "question": "What are the ids and first names of customers who do not hold a credit card?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids and first names of all customers; 2. what are the ids and first names of customers who hold a credit card (card type Credit).\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Customers']. To complete the second subproblem, we need to use tables ['Customers', 'Customers_Cards'].\n\n<3> Operation: Use 'where' to filter using column 'card_type_code' in table 'Customers_Cards'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT customer_id, customer_first_name FROM Customers EXCEPT SELECT T1.customer_id, T1.customer_first_name FROM Customers AS T1 JOIN Customers_Cards AS T2 ON T1.customer_id = T2.customer_id WHERE T2.card_type_code = 'Credit'",
        "predict": "SELECT customer_id, customer_first_name FROM Customers EXCEPT SELECT T1.customer_id, T1.customer_first_name FROM Customers AS T1 JOIN Customers_Cards AS T2 ON T1.customer_id = T2.customer_id WHERE T2.card_type_code = 'Credit'",
        "hardness": "extra"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 UNION SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010",
        "question": "Find courses that ran in Fall 2009 or in Spring 2010.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the courses that ran in Fall 2009; 2. what are the courses that ran in Spring 2010.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['course', 'section']. To complete the second subproblem, we need to use tables ['course', 'section'] in the same reason.\n\n<3> Operation: Use 'where' to filter using column 'semester' and 'year' in table 'section'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.course_id FROM course AS T1 JOIN section AS T2 ON T1.course_id = T2.course_id WHERE T2.semester = 'Fall' AND T2.year = 2009 UNION SELECT T1.course_id FROM course AS T1 JOIN section AS T2 ON T1.course_id = T2.course_id WHERE T2.semester = 'Spring' AND T2.year = 2010",
        "predict": "SELECT T1.course_id FROM course AS T1 JOIN section AS T2 ON T1.course_id = T2.course_id WHERE T2.semester = 'Fall' AND T2.year = 2009 UNION SELECT T1.course_id FROM course AS T1 JOIN section AS T2 ON T1.course_id = T2.course_id WHERE T2.semester = 'Spring' AND T2.year = 2010",
        "hardness": "extra"
    },
    {
        "db_id": "cinema",
        "gold": "SELECT LOCATION FROM cinema EXCEPT SELECT LOCATION FROM cinema WHERE capacity  >  800",
        "question": "Show all the locations where no cinema has capacity over 800.",
        "fields": "Table cinema, columns = [*,Cinema_ID,Name,Openning_year,Capacity,Location]\nTable film, columns = [*,Film_ID,Rank_in_series,Number_in_season,Title,Directed_by,Original_air_date,Production_code]\nTable schedule, columns = [*,Cinema_ID,Film_ID,Date,Show_times_per_day,Price]\n",
        "foreign_keys": "Foreign_keys = [schedule.Cinema_ID = cinema.Cinema_ID,schedule.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are all the locations of cinemas; 2. what are the locations of cinemas that have a capacity over 800.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['cinema']. To complete the second subproblem, we need to use table ['cinema'].\n\n<3> Operation: Use 'where' to filter using column 'Capacity' in table 'cinema'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Location FROM cinema EXCEPT SELECT Location FROM cinema WHERE Capacity > 800",
        "predict": "SELECT Location FROM cinema EXCEPT SELECT Location FROM cinema WHERE Capacity > 800",
        "hardness": "hard"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT title ,  film_id FROM film WHERE rental_rate  =  0.99 INTERSECT SELECT T1.title ,  T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id HAVING count(*)  <  3",
        "question": "Which film is rented at a fee of 0.99 and has less than 3 in the inventory? List the film title and id.",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the film title and id that are rented at a fee of 0.99; 2. what are the film title and id that have less than 3 in the inventory.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['film', 'rental', 'payment']. To complete the second subproblem, we need to use tables ['film', 'inventory'].\n\n<3> Operation: For the first subproblem, use 'where' to filter using column 'amount' in table 'payment'. For the second subproblem, perform a 'GROUP BY' operation on the column 'film_id' and filter by performing 'HAVING COUNT()' on the column 'inventory_id'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.title, T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id = T2.film_id JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id JOIN payment AS T4 ON T3.rental_id = T4.rental_id WHERE T4.amount = 0.99 INTERSECT SELECT T1.title, T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id = T2.film_id GROUP BY T1.film_id HAVING COUNT(T2.inventory_id)",
        "predict": "SELECT T1.title, T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id = T2.film_id JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id JOIN payment AS T4 ON T3.rental_id = T4.rental_id WHERE T4.amount = 0.99 INTERSECT SELECT T1.title, T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id = T2.film_id GROUP BY T1.film_id HAVING COUNT(T2.inventory_id)",
        "hardness": "extra"
    },
    {
        "db_id": "sports_competition",
        "gold": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'",
        "question": "Find the countries that have never participated in any competition with Friendly type.",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the countries that have participated in any competition; 2. what are the countries that have participated in competitions with Friendly type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['competition']. To complete the second subproblem, we need to use tables ['competition'].\n\n<3> Operation: Use 'where' to filter using column 'Competition_type' in table 'competition'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT Country FROM competition EXCEPT SELECT Country FROM competition WHERE Competition_type = 'Friendly'",
        "predict": "SELECT Country FROM competition EXCEPT SELECT Country FROM competition WHERE Competition_type = 'Friendly'",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE \"4:%\" UNION SELECT song_name FROM song WHERE languages  =  \"english\"",
        "question": "List the names of all songs that have 4 minute duration or are in English.",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the names of all songs that have 4-minute duration; 2. what are the names of all songs that are in English.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['song', 'files']. To complete the second subproblem, we need to use table ['song'].\n\n<3> Operation: Use 'where' to filter using column 'duration' in table 'files' for the first subproblem, and column 'languages' in table 'song' for the second subproblem. The duration of music is formatted in 'XX:YY', so we can use 'LIKE' to filter.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\nSQL query: SELECT T1.song_name FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id WHERE T2.duration LIKE '4:%' UNION SELECT song_name FROM song WHERE languages = \"english\"",
        "predict": "SELECT T1.song_name FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id WHERE T2.duration LIKE '4:%' UNION SELECT song_name FROM song WHERE languages = \"english\"",
        "hardness": "extra"
    },
    {
        "db_id": "department_management",
        "gold": "SELECT count(*) FROM department WHERE department_id NOT IN (SELECT department_id FROM management);",
        "question": "How many departments are led by heads who are not mentioned?",
        "fields": "Table department, columns = [*,Department_ID,Name,Creation,Ranking,Budget_in_Billions,Num_Employees]\nTable head, columns = [*,head_ID,name,born_state,age]\nTable management, columns = [*,department_ID,head_ID,temporary_acting]\n",
        "foreign_keys": "Foreign_keys = [management.head_ID = head.head_ID,management.department_ID = department.Department_ID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of departments that are led by heads who are not mentioned. We need to filter departments based on the heads mentioned in the 'head' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the department_ID from the 'department' table and filter based on the head_ID mentioned in the 'head' table.\n\n<3> SQL Generation: Use 'where' to filter departments based on the head_ID mentioned in the 'head' table and count the number of departments.\n\nSQL query: SELECT count(*) FROM department WHERE department_id NOT IN (SELECT department_id FROM management);",
        "predict": "SELECT count(*) FROM department WHERE department_id NOT IN (SELECT department_id FROM management);",
        "hardness": "extra"
    },
    {
        "db_id": "farm",
        "gold": "SELECT Hosts FROM farm_competition WHERE Theme !=  'Aliens'",
        "question": "Return the hosts of competitions for which the theme is not Aliens?",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on column 'theme', so we should apply the 'where' to column 'theme' and then return the hosts of selected competition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'farm_competition' has columns 'Theme' and 'Hosts', we only need table 'farm_competition'.\n\n<3> SQL Generation: Directly write the sql using 'where'.\n\nSQL query: SELECT Hosts FROM farm_competition WHERE Theme !=  'Aliens'",
        "predict": "SELECT Hosts FROM farm_competition WHERE Theme !=  'Aliens'",
        "hardness": "easy"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "question": "What are the  ids of every student who has never attended a course?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the ids of all students. Secondly, we need to filter out the students who have attended a course. Finally, we need to return the ids of the remaining students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from table 'Students' and filter it based on the student_id in table 'Student_Course_Attendance'.\n\n<3> SQL Generation: Use 'where' to filter out the student_ids that appear in the 'Student_Course_Attendance' table, and then select the remaining student_ids.\n\nSQL query: SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "predict": "SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "hardness": "hard"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"English\"",
        "question": "How many students are attending English courses?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the course_id for English courses. Secondly, we need to count the number of students attending those courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'Courses' where course_name = 'English'. In the second step, we need to count the number of students from table 'Student_Course_Attendance' where course_id matches the course_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the course_id for English courses, and then use 'count' to count the number of students attending those courses.\n\nSQL query: SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"English\"",
        "predict": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"English\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "question": "How many courses do the student whose id is 171 attend?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with id 171. Secondly, we need to count the number of courses that the student attends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select student_id from table 'Students' where student_id = 171. In the second step, we need to count the number of courses from table 'Student_Course_Attendance' where student_id = 171.\n\n<3> SQL Generation: Use 'where' to find the student with id 171, and then use 'count' to count the number of courses that the student attends.\n\nSQL query: SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "predict": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "hardness": "medium"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "question": "How many courses does the student with id 171 actually attend?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the courses that the student with id 171 is registered for. Secondly, we need to count the number of courses that the student actually attends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'Student_Course_Registrations' where student_id = 171. In the second step, we need to count the number of rows in table 'Student_Course_Attendance' where student_id = 171 and course_id is in the list of courses obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the courses that the student with id 171 is registered for, and then use 'where' and 'count' to count the number of courses that the student actually attends.\n\nSQL query: SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "predict": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "hardness": "medium"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT name FROM station WHERE lat  <  37.5",
        "question": "What are the names of stations that have latitude lower than 37.5?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on stations with latitude lower than 37.5. We need to select the names of these stations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'station' table and the 'name' column.\n\n<3> SQL Generation: Use 'where' to filter stations with latitude lower than 37.5 and select their names.\n\nSQL query: SELECT name FROM station WHERE lat  <  37.5",
        "predict": "SELECT name FROM station WHERE lat  <  37.5",
        "hardness": "easy"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT COUNT(*) FROM station WHERE city  =  \"Mountain View\"",
        "question": "How many stations does Mountain View city has?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of stations in Mountain View city.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'station' table and the 'city' column.\n\n<3> SQL Generation: Use 'where' to filter stations in Mountain View city and then use 'count' to calculate the number of stations.\n\nSQL query: SELECT COUNT(*) FROM station WHERE city  =  \"Mountain View\"",
        "predict": "SELECT COUNT(*) FROM station WHERE city  =  \"Mountain View\"",
        "hardness": "easy"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8",
        "question": "What is the number of days that had an average humity above 50 and an average visibility above 8?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter days with an average humidity above 50. Secondly, we need to filter days with an average visibility above 8. Finally, we need to count the number of days that meet both conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'weather' table for this query.\n\n<3> SQL Generation: Use 'where' to filter days with an average humidity above 50 and an average visibility above 8, and then use 'count' to calculate the number of days that meet both conditions.\n\nSQL query: SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8",
        "predict": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8",
        "hardness": "medium"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT T1.lat ,  T1.long ,  T1.city FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id ORDER BY T2.duration LIMIT 1",
        "question": "What is the latitude, longitude, and city of the station from which the trip with smallest duration started?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the trip with the smallest duration. Secondly, we need to identify the station from which this trip started. Finally, we need to retrieve the latitude, longitude, and city of this station.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the minimum duration from table 'trip'. In the second step, we need to filter the trip with the minimum duration and retrieve the start_station_id. In the final step, we need to select the latitude, longitude, and city from table 'station' based on the start_station_id.\n\n<3> SQL Generation: Use 'where' to find the trip with the smallest duration, and then use 'where' to filter the start_station_id and select the corresponding latitude, longitude, and city.\n\nSQL query: SELECT T1.lat ,  T1.long ,  T1.city FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id ORDER BY T2.duration LIMIT 1",
        "predict": "SELECT T1.lat ,  T1.long ,  T1.city FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id ORDER BY T2.duration LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "question": "What is the average bike availability in stations that are not located in Palo Alto?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires calculating the average bike availability in stations that are not located in Palo Alto. Firstly, we need to identify the stations located in Palo Alto. Secondly, we need to filter stations that are not located in Palo Alto. Finally, we calculate the average bike availability in the remaining stations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'station' and 'status' tables. \n\n<3> SQL Generation: Use 'where' to filter stations located in Palo Alto, and then use 'not in' to filter stations that are not located in Palo Alto. Finally, calculate the average bike availability in the remaining stations.\n\nSQL query: SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "predict": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "question": "What is the average bike availablility for stations not in Palo Alto?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on stations that are not in Palo Alto. Firstly, we need to identify the stations located in Palo Alto. Secondly, we need to calculate the average bike availability for stations that are not in Palo Alto.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'station' where city = 'Palo Alto'. In the second step, we need to select bikes_available from table 'status' and filter by station_id.\n\n<3> SQL Generation: Use 'where' to filter stations in Palo Alto, and then use 'not in' to filter stations that are not in Palo Alto. Finally, calculate the average bike availability for the selected stations.\n\nSQL query: SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "predict": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != \"San Francisco\"",
        "question": "How many trips did not end in San Francisco?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on trips that did not end in San Francisco. Firstly, we need to identify the stations located in San Francisco. Secondly, we need to filter trips based on their end_station_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'station' where city = 'San Francisco'. In the second step, we need to select id from table 'trip' and filter by end_station_id.\n\n<3> SQL Generation: Use 'where' to filter stations in San Francisco, and then use 'not in' to filter trips that did not end in San Francisco.\n\nSQL query: SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != \"San Francisco\"",
        "predict": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != \"San Francisco\"",
        "hardness": "medium"
    },
    {
        "db_id": "book_2",
        "gold": "SELECT Title FROM book WHERE Writer != \"Elaine Lee\"",
        "question": "What are the titles of the books whose writer is not \"Elaine Lee\"?",
        "fields": "Table book, columns = [*,Book_ID,Title,Issues,Writer]\nTable publication, columns = [*,Publication_ID,Book_ID,Publisher,Publication_Date,Price]\n",
        "foreign_keys": "Foreign_keys = [publication.Book_ID = book.Book_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the writer column in the book table. We need to select the titles of the books that have a writer different from \"Elaine Lee\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the book table for this query.\n\n<3> SQL Generation: Use the 'where' clause to filter the books where the writer is not \"Elaine Lee\" and select the titles of those books.\n\nSQL query: SELECT Title FROM book WHERE Writer != \"Elaine Lee\"",
        "predict": "SELECT Title FROM book WHERE Writer != \"Elaine Lee\"",
        "hardness": "easy"
    },
    {
        "db_id": "book_2",
        "gold": "SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication)",
        "question": "List the titles of books that are not published.",
        "fields": "Table book, columns = [*,Book_ID,Title,Issues,Writer]\nTable publication, columns = [*,Publication_ID,Book_ID,Publisher,Publication_Date,Price]\n",
        "foreign_keys": "Foreign_keys = [publication.Book_ID = book.Book_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on books that are not published. We need to select the titles of these books.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'book' table.\n\n<3> SQL Generation: Use 'where' to filter books that are not published and select their titles.\n\nSQL query: SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication)",
        "predict": "SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication)",
        "hardness": "hard"
    },
    {
        "db_id": "musical",
        "gold": "SELECT Name FROM actor WHERE Age != 20",
        "question": "What are the names of actors who are not 20 years old?",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the age of actors. We need to select the names of actors who are not 20 years old.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'actor' table.\n\n<3> SQL Generation: Use 'where' to filter actors who are not 20 years old and select their names.\n\nSQL query: SELECT Name FROM actor WHERE Age != 20",
        "predict": "SELECT Name FROM actor WHERE Age != 20",
        "hardness": "easy"
    },
    {
        "db_id": "musical",
        "gold": "SELECT DISTINCT Nominee FROM musical WHERE Award != \"Tony Award\"",
        "question": "Return the different nominees of musicals that have an award that is not the Tony Award.",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on musicals that have an award that is not the Tony Award. Firstly, we need to identify the musicals with awards. Secondly, we need to filter the nominees of those musicals.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Musical_ID from table 'musical' where Award is not the Tony Award. In the second step, we need to filter the nominees from table 'musical'.\n\n<3> SQL Generation: Use 'where' to filter musicals with awards that are not the Tony Award, and then select the different nominees from those musicals.\n\nSQL query: SELECT DISTINCT Nominee FROM musical WHERE Award != \"Tony Award\"",
        "predict": "SELECT DISTINCT Nominee FROM musical WHERE Award != \"Tony Award\"",
        "hardness": "easy"
    },
    {
        "db_id": "musical",
        "gold": "SELECT Name FROM musical WHERE Musical_ID NOT IN (SELECT Musical_ID FROM actor)",
        "question": "List the name of musicals that do not have actors.",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding musicals that do not have actors. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'musical' table for this query.\n\n<3> SQL Generation: Use 'where' to filter musicals that do not have actors.\n\nSQL query: SELECT Name FROM musical WHERE Musical_ID NOT IN (SELECT Musical_ID FROM actor)",
        "predict": "SELECT Name FROM musical WHERE Musical_ID NOT IN (SELECT Musical_ID FROM actor)",
        "hardness": "hard"
    },
    {
        "db_id": "twitter_1",
        "gold": "SELECT name ,  email FROM user_profiles WHERE followers  >  1000",
        "question": "Find the name and email of the users who have more than 1000 followers.",
        "fields": "Table follows, columns = [*,f1,f2]\nTable tweets, columns = [*,id,uid,text,createdate]\nTable user_profiles, columns = [*,uid,name,email,partitionid,followers]\n",
        "foreign_keys": "Foreign_keys = [follows.f2 = user_profiles.uid,follows.f1 = user_profiles.uid,tweets.uid = user_profiles.uid]\n",
        "reasoning": "<1> Decomposition: We need to filter users based on the number of followers they have, specifically those with more than 1000 followers. Then, we need to retrieve their name and email.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select name and email from table 'user_profiles' and filter by the number of followers.\n\n<3> SQL Generation: Use 'where' to filter users with more than 1000 followers, and then select their name and email.\n\nSQL query: SELECT name ,  email FROM user_profiles WHERE followers  >  1000",
        "predict": "SELECT name ,  email FROM user_profiles WHERE followers  >  1000",
        "hardness": "medium"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT aid FROM Aircraft WHERE distance  >  1000",
        "question": "Show ids for all aircrafts with more than 1000 distance.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on aircrafts with more than 1000 distance. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter on the 'distance' column, we only need the 'aircraft' table.\n\n<3> SQL Generation: Use 'where' to filter aircrafts with more than 1000 distance.\n\nSQL query: SELECT aid FROM Aircraft WHERE distance  >  1000",
        "predict": "SELECT aid FROM Aircraft WHERE distance  >  1000",
        "hardness": "easy"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000",
        "question": "What is the number of employees that have a salary between 100000 and 200000?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on employees with a salary between 100000 and 200000. We need to select employees based on their salary.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'employee' table for this query.\n\n<3> SQL Generation: Use 'where' to filter employees based on their salary range and count the number of employees that meet the condition.\n\nSQL query: SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000",
        "predict": "SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000",
        "hardness": "easy"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT name FROM Employee WHERE salary  >  (SELECT avg(salary) FROM Employee)",
        "question": "What are the names of all employees who have a salary higher than average?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average salary of all employees. Secondly, we need to filter employees based on their salary being higher than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'employee' table for this query, we can directly use it.\n\n<3> SQL Generation: Use 'avg' to calculate the average salary of all employees, and then use 'where' to filter employees with a salary higher than the average.\n\nSQL query: SELECT name FROM Employee WHERE salary  >  (SELECT avg(salary) FROM Employee)",
        "predict": "SELECT name FROM Employee WHERE salary  >  (SELECT avg(salary) FROM Employee)",
        "hardness": "hard"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "question": "Show me the departure date and arrival date for all flights from Los Angeles to Honolulu.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter flights based on their origin and destination. Secondly, we need to select the departure date and arrival date for the filtered flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select departure_date and arrival_date from table 'flight' and filter by origin and destination.\n\n<3> SQL Generation: Use 'where' to filter flights from Los Angeles to Honolulu, and then select the departure date and arrival date.\n\nSQL query: SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "predict": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "hardness": "medium"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "question": "What are the departure and arrival dates of all flights from LA to Honolulu?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter flights based on their origin and destination. Secondly, we need to select the departure and arrival dates of the filtered flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select departure_date and arrival_date from table 'flight' and filter by origin = 'LA' and destination = 'Honolulu'.\n\n<3> SQL Generation: Use 'where' to filter flights with origin = 'LA' and destination = 'Honolulu', and then select the departure_date and arrival_date.\n\nSQL query: SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "predict": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "hardness": "medium"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT flno FROM Flight WHERE distance  >  2000",
        "question": "What are the numbers of all flights that can cover a distance of more than 2000?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on flights that can cover a distance of more than 2000. We need to select the flight numbers that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'flight' table for this query.\n\n<3> SQL Generation: Use 'where' to filter flights with a distance greater than 2000, and select the flight numbers.\n\nSQL query: SELECT flno FROM Flight WHERE distance  >  2000",
        "predict": "SELECT flno FROM Flight WHERE distance  >  2000",
        "hardness": "easy"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Student WHERE age  =  18",
        "question": "How many students are 18 years old?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of students who are 18 years old.\n\n<2> Schema Linking: In this step, we identify the table and column that should be used based on the first step. We need to use the 'Student' table and the 'Age' column.\n\n<3> SQL Generation: Use 'where' to filter students who are 18 years old and then use 'count' to calculate the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM Student WHERE age  =  18",
        "predict": "SELECT count(*) FROM Student WHERE age  =  18",
        "hardness": "easy"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT StuID FROM Student WHERE age  >  20",
        "question": "What are the student ids for students over 20 years old?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on students over 20 years old. We need to select the student ids for these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table.\n\n<3> SQL Generation: Use 'where' to filter students with age greater than 20 and select their student ids.\n\nSQL query: SELECT StuID FROM Student WHERE age  >  20",
        "predict": "SELECT StuID FROM Student WHERE age  >  20",
        "hardness": "easy"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Student WHERE city_code  =  \"HKG\" OR city_code  =  \"CHI\"",
        "question": "How many students live in HKG or CHI?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their city_code, selecting only those who live in HKG or CHI. Secondly, we need to count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table and the 'city_code' column.\n\n<3> SQL Generation: Use 'where' to filter students who live in HKG or CHI, and then use 'count' to count the number of selected students.\n\nSQL query: SELECT count(*) FROM Student WHERE city_code  =  \"HKG\" OR city_code  =  \"CHI\"",
        "predict": "SELECT count(*) FROM Student WHERE city_code  =  \"HKG\" OR city_code  =  \"CHI\"",
        "hardness": "medium"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  \"Cat\"",
        "question": "How many students have cat allergies?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: We need to filter students based on their allergies, specifically cat allergies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from the table 'Has_Allergy' where Allergy is 'cat'.\n\n<3> SQL Generation: Use 'where' to filter students with cat allergies and count them.\n\nSQL query: SELECT count(*) FROM Has_allergy WHERE Allergy  =  \"Cat\"",
        "predict": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  \"Cat\"",
        "hardness": "easy"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.first_name ,  T1.last_name FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id ORDER BY T2.invoice_date DESC LIMIT 5;",
        "question": "What are the first and last names of the 5 customers who purchased something most recently?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the most recent purchase date. Secondly, we need to find the customers who made purchases on that date. Finally, we need to select the first and last names of those customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first and last names from the 'customers' table and filter by the most recent purchase date from the 'invoices' table.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the most recent purchase date from the 'invoices' table. Then, join the 'invoices' and 'customers' tables on the 'customer_id' column and filter by the most recent purchase date. Finally, select the first and last names of the customers.\n\nSQL query: SELECT T1.first_name ,  T1.last_name FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id ORDER BY T2.invoice_date DESC LIMIT 5;",
        "predict": "SELECT T1.first_name ,  T1.last_name FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id ORDER BY T2.invoice_date DESC LIMIT 5;",
        "hardness": "hard"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM albums AS T1 JOIN artists AS T2 ON  T1.artist_id = T2.id WHERE T2.name = \"Billy Cobham\";",
        "question": "How many albums has Billy Cobam released?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the artist_id of Billy Cobam. Secondly, we need to count the number of albums released by Billy Cobam based on his artist_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'artists' where name = 'Billy Cobam'. In the second step, we need to count the number of albums from table 'albums' where artist_id matches the artist_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the artist_id of Billy Cobam, and then use 'count' to count the number of albums where artist_id matches the artist_id found in the first step.\n\nSQL query: SELECT count(*) FROM albums AS T1 JOIN artists AS T2 ON  T1.artist_id = T2.id WHERE T2.name = \"Billy Cobham\";",
        "predict": "SELECT count(*) FROM albums AS T1 JOIN artists AS T2 ON  T1.artist_id = T2.id WHERE T2.name = \"Billy Cobham\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "question": "What is Astrid Gruber's email and phone number?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: We need to find the email and phone number of Astrid Gruber.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select email and phone from table 'customers' where first_name = 'Astrid' and last_name = 'Gruber'.\n\n<3> SQL Generation: Use 'where' to filter customers with first_name = 'Astrid' and last_name = 'Gruber', and then select email and phone.\n\nSQL query: SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "predict": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "question": "What is the email and phone number of Astrid Gruber the customer?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with the name 'Astrid Gruber'. Secondly, we need to retrieve their email and phone number.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select email and phone from table 'customers' where first_name = 'Astrid' and last_name = 'Gruber'.\n\n<3> SQL Generation: Use 'where' to find the customer with the name 'Astrid Gruber', and then select their email and phone number.\n\nSQL query: SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "predict": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers WHERE city = \"Prague\";",
        "question": "How many customers live in Prague city?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of customers who live in Prague city.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of customers from the 'customers' table where the city is Prague.\n\n<3> SQL Generation: Use 'where' to filter customers who live in Prague city and count them.\n\nSQL query: SELECT count(*) FROM customers WHERE city = \"Prague\";",
        "predict": "SELECT count(*) FROM customers WHERE city = \"Prague\";",
        "hardness": "easy"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "question": "How many customers in state of CA?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of customers in the state of CA.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of customers from the 'customers' table where the state is CA.\n\n<3> SQL Generation: Use 'where' to filter customers in the state of CA and count them.\n\nSQL query: SELECT count(*) FROM customers WHERE state = \"CA\";",
        "predict": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "hardness": "easy"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "question": "How many customers are from California?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: We need to count the number of customers who are from California.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'customers' table and the 'state' column.\n\n<3> SQL Generation: Use 'where' to filter customers from California and count them.\n\nSQL query: SELECT count(*) FROM customers WHERE state = \"CA\";",
        "predict": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "hardness": "easy"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT country FROM customers WHERE first_name = \"Roberto\" AND last_name = \"Almeida\";",
        "question": "In which country does Roberto Almeida?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: We need to find the country of Roberto Almeida. To do this, we need to identify the customer with the name \"Roberto Almeida\" and retrieve their country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the country from the customers table where the first_name is \"Roberto\" and the last_name is \"Almeida\".\n\n<3> SQL Generation: Use 'where' to filter the customers table based on the first_name and last_name, and then select the country.\n\nSQL query: SELECT country FROM customers WHERE first_name = \"Roberto\" AND last_name = \"Almeida\";",
        "predict": "SELECT country FROM customers WHERE first_name = \"Roberto\" AND last_name = \"Almeida\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM employees AS T1 JOIN customers AS T2 ON T2.support_rep_id = T1.id WHERE T1.first_name = \"Steve\" AND T1.last_name = \"Johnson\";",
        "question": "How many customers does Steve Johnson support?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the support_rep_id of Steve Johnson. Secondly, we need to count the number of customers with the support_rep_id found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'employees' where first_name = 'Steve' and last_name = 'Johnson'. In the second step, we need to count the number of customers with support_rep_id from table 'customers'.\n\n<3> SQL Generation: Use 'where' to find the support_rep_id of Steve Johnson, and then use 'count' to count the number of customers with the support_rep_id found in the first step.\n\nSQL query: SELECT count(*) FROM employees AS T1 JOIN customers AS T2 ON T2.support_rep_id = T1.id WHERE T1.first_name = \"Steve\" AND T1.last_name = \"Johnson\";",
        "predict": "SELECT count(*) FROM employees AS T1 JOIN customers AS T2 ON T2.support_rep_id = T1.id WHERE T1.first_name = \"Steve\" AND T1.last_name = \"Johnson\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT address FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "question": "What is the address of employee Nancy Edwards?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the address of employee Nancy Edwards.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the address from the 'employees' table where the first name is 'Nancy' and the last name is 'Edwards'.\n\n<3> SQL Generation: Use 'where' to filter the rows where the first name is 'Nancy' and the last name is 'Edwards', and then select the address.\n\nSQL query: SELECT address FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "predict": "SELECT address FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT phone FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "question": "What is employee Nancy Edwards's phone number?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the phone number of employee Nancy Edwards.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the phone number from the 'employees' table where the first name is 'Nancy' and the last name is 'Edwards'.\n\n<3> SQL Generation: Use 'where' to filter the rows where the first name is 'Nancy' and the last name is 'Edwards', and then select the phone number.\n\nSQL query: SELECT phone FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "predict": "SELECT phone FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "question": "How many orders does Luca Mancini have in his invoices?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of Luca Mancini. Secondly, we need to count the number of orders in his invoices.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'customers' where first_name = 'Luca' and last_name = 'Mancini'. In the second step, we need to count the number of invoices where customer_id is the value found in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id of Luca Mancini, and then use 'where' to count the number of invoices where customer_id is the value found in the first step.\n\nSQL query: SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "predict": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "hardness": "medium"
    },
    {
        "db_id": "journal_committee",
        "gold": "SELECT Name FROM editor WHERE editor_id NOT IN (SELECT editor_id FROM journal_committee)",
        "question": "List the names of editors that are not on any journal committee.",
        "fields": "Table editor, columns = [*,Editor_ID,Name,Age]\nTable journal, columns = [*,Journal_ID,Date,Theme,Sales]\nTable journal_committee, columns = [*,Editor_ID,Journal_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [journal_committee.Journal_ID = journal.Journal_ID,journal_committee.Editor_ID = editor.Editor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on editors who are not on any journal committee. Firstly, we need to identify the editors who are on journal committees. Secondly, we need to filter out the editors who are on journal committees and return the remaining editors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter editors who are on journal committees, we only need the 'editor' and 'journal_committee' tables.\n\n<3> SQL Generation: We can use a subquery to select the editor IDs of editors who are on journal committees. Then, we can use 'not in' to filter out the editors who are on journal committees and select their names.\n\nSQL query: SELECT Name FROM editor WHERE editor_id NOT IN (SELECT editor_id FROM journal_committee)",
        "predict": "SELECT Name FROM editor WHERE editor_id NOT IN (SELECT editor_id FROM journal_committee)",
        "hardness": "hard"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "question": "Show the number of all customers without an account.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding customers without an account. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customers' and check if there is a corresponding entry in the 'Accounts' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Customers' and 'Accounts' tables on the 'customer_id' column. Then, we can filter the rows where the 'account_id' is null (indicating no account exists for that customer). Finally, we can count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "predict": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "question": "How many customers do not have an account?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding customers who do not have an account.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customers' and check if it exists in the 'account_id' column of table 'Accounts'.\n\n<3> SQL Generation: Use 'where' to filter customers who do not have an account and count them.\n\nSQL query: SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "predict": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "question": "What is the phone and email for customer with first name Aniyah and last name Feest?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id for the customer with first name Aniyah and last name Feest. Secondly, we need to retrieve the phone and email for that customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_first_name = 'Aniyah' and customer_last_name = 'Feest'. In the second step, we need to retrieve customer_phone and customer_email from table 'Customers' using the customer_id obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id for the customer with first name Aniyah and last name Feest, and then use 'select' to retrieve the phone and email for that customer.\n\nSQL query: SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "predict": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "hardness": "medium"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "question": "Return the phone and email of the customer with the first name Aniyah and last name Feest.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with the first name 'Aniyah' and last name 'Feest'. Secondly, we need to select the phone and email of the selected customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the phone and email of the customer, we only need the 'Customers' table.\n\n<3> SQL Generation: Use 'where' to filter customers with the first name 'Aniyah' and last name 'Feest', and then select the phone and email columns.\n\nSQL query: SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "predict": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "hardness": "medium"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "question": "How many cards does customer Art Turcotte have?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of customer Art Turcotte. Secondly, we need to count the number of cards associated with that customer_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_first_name = 'Art' and customer_last_name = 'Turcotte'. In the second step, we need to count the number of cards from table 'Customers_Cards' where customer_id matches the customer_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id of customer Art Turcotte, and then use 'count' to count the number of cards associated with that customer_id.\n\nSQL query: SELECT count(*) FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "predict": "SELECT count(*) FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "hardness": "medium"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers_cards WHERE card_type_code  =  \"Debit\"",
        "question": "How many debit cards do we have?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of debit cards. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the card_type_code from the Customers_Cards table.\n\n<3> SQL Generation: Use 'where' to filter the rows where card_type_code is 'debit' and count the number of rows.\n\nSQL query: SELECT count(*) FROM Customers_cards WHERE card_type_code  =  \"Debit\"",
        "predict": "SELECT count(*) FROM Customers_cards WHERE card_type_code  =  \"Debit\"",
        "hardness": "easy"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name ,  seating FROM track WHERE year_opened  >  2000 ORDER BY seating",
        "question": "What are the names and seatings for all tracks opened after 2000, ordered by seating?",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter tracks that were opened after 2000. Secondly, we need to select the names and seatings of these tracks. Finally, we need to order the results by seating.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'track' table for this query.\n\n<3> SQL Generation: Use 'where' to filter tracks that were opened after 2000, and then select the names and seatings of these tracks. Finally, order the results by seating.\n\nSQL query: SELECT name ,  seating FROM track WHERE year_opened  >  2000 ORDER BY seating",
        "predict": "SELECT name ,  seating FROM track WHERE year_opened  >  2000 ORDER BY seating",
        "hardness": "medium"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "question": "Show all track names that have had no races.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: We need to find the track names that have had no races.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'track' table.\n\n<3> SQL Generation: We can use a subquery to find the track IDs that have had races, and then select the track names that are not in that list.\n\nSQL query: SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "predict": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "hardness": "hard"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "question": "Return the names of tracks that have no had any races.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding tracks that have not had any races. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'track' table.\n\n<3> SQL Generation: We can use a subquery to find the track IDs that have had races, and then use a 'not in' clause to select tracks that are not in that list.\n\nSQL query: SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "predict": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "hardness": "hard"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT year_opened FROM track WHERE seating BETWEEN 4000 AND 5000",
        "question": "Show year where a track with a seating at least 5000 opened and a track with seating no more than 4000 opened.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find tracks with seating at least 5000 and tracks with seating no more than 4000. Secondly, we need to select the years when these tracks were opened.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Year_Opened column from the track table.\n\n<3> SQL Generation: Use 'where' to filter tracks with seating at least 5000 and tracks with seating no more than 4000, and then select the corresponding years.\n\nSQL query: SELECT year_opened FROM track WHERE seating BETWEEN 4000 AND 5000",
        "predict": "SELECT year_opened FROM track WHERE seating BETWEEN 4000 AND 5000",
        "hardness": "easy"
    },
    {
        "db_id": "coffee_shop",
        "gold": "SELECT shop_id ,  address FROM shop WHERE score  <  (SELECT avg(score) FROM shop)",
        "question": "Find the id and address of the shops whose score is below the average score.",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average score of all shops. Secondly, we need to filter shops based on their score being below the average score. Finally, we need to select the id and address of the filtered shops.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'shop' table for this query, we can directly use it.\n\n<3> SQL Generation: Use 'select' to calculate the average score of all shops. Then, use 'where' to filter shops with a score below the average score and select their id and address.\n\nSQL query: SELECT shop_id ,  address FROM shop WHERE score  <  (SELECT avg(score) FROM shop)",
        "predict": "SELECT shop_id ,  address FROM shop WHERE score  <  (SELECT avg(score) FROM shop)",
        "hardness": "extra"
    },
    {
        "db_id": "coffee_shop",
        "gold": "SELECT address ,  num_of_staff FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM happy_hour)",
        "question": "Find the address and staff number of the shops that do not have any happy hour.",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the shops that do not have any happy hour. Secondly, we need to select the address and staff number of those shops.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are only interested in the address and staff number of the shops, we only need the 'shop' table.\n\n<3> SQL Generation: Use 'where' to filter the shops that do not have any happy hour, and then select the address and staff number from the 'shop' table.\n\nSQL query: SELECT address ,  num_of_staff FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM happy_hour)",
        "predict": "SELECT address ,  num_of_staff FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM happy_hour)",
        "hardness": "extra"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT COUNT(*) FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId WHERE T2.Name  =  \"Metallica\"",
        "question": "Find the number of albums by the artist \"Metallica\".",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the artist_id of \"Metallica\" from table 'Artist'. Secondly, we need to count the number of albums with the artist_id found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select artist_id from table 'Artist' where name = \"Metallica\". In the second step, we need to count the number of albums from table 'Album' where artist_id is the value found in the first step.\n\n<3> SQL Generation: Use 'where' to find the artist_id of \"Metallica\", and then use 'where' to count the number of albums with the artist_id found in the first step.\n\nSQL query: SELECT COUNT(*) FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId WHERE T2.Name  =  \"Metallica\"",
        "predict": "SELECT COUNT(*) FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId WHERE T2.Name  =  \"Metallica\"",
        "hardness": "medium"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT COUNT(*) FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId WHERE T1.Name  =  \"AAC audio file\"",
        "question": "How many tracks are in the AAC audio file media type?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the media type with the name 'AAC audio file'. Secondly, we need to count the number of tracks that have this media type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for tracks with a specific media type, we need to select the 'MediaTypeId' from the 'MediaType' table. Then, we need to count the number of tracks that have this media type, so we need to select the 'TrackId' from the 'Track' table.\n\n<3> SQL Generation: Use 'where' to find the media type with the name 'AAC audio file', and then use 'where' to filter tracks with this media type and count them.\n\nSQL query: SELECT COUNT(*) FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId WHERE T1.Name  =  \"AAC audio file\"",
        "predict": "SELECT COUNT(*) FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId WHERE T1.Name  =  \"AAC audio file\"",
        "hardness": "medium"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM)",
        "question": "How many artists do not have any album?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the artists who do not have any albums. Secondly, we need to count the number of artists found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for artists who do not have any albums, we only need the 'Artist' table.\n\n<3> SQL Generation: Use 'left join' to combine the 'Artist' table with the 'Album' table on the 'ArtistId' column. Then, filter the rows where the 'AlbumId' is null (indicating that the artist does not have any albums). Finally, count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM)",
        "predict": "SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM)",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT count(*) FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "question": "How many policies are listed for the customer named \"Dayana Robel\"?",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with the name \"Dayana Robel\". Secondly, we need to count the number of policies listed for that customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Customer_ID from table 'Customers' where Customer_name = \"Dayana Robel\". In the second step, we need to count the number of policies listed for that customer in table 'Customers_Policies'.\n\n<3> SQL Generation: Use 'where' to find the customer with the name \"Dayana Robel\", and then use 'count' to count the number of policies listed for that customer.\n\nSQL query: SELECT count(*) FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "predict": "SELECT count(*) FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "hardness": "medium"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id  =  T3.id WHERE T3.name  =  'Amisulpride' AND T2.interaction_type  =  'inhibitor'",
        "question": "What are the names of the enzymes used in the medicine  Amisulpride that acts as inhibitors?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the medicine with the name 'Amisulpride'. Secondly, we need to find the enzymes that are used in this medicine and act as inhibitors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'medicine' where name = 'Amisulpride'. In the second step, we need to select name from table 'enzyme' based on the enzyme_id in table 'medicine_enzyme_interaction'.\n\n<3> SQL Generation: Use 'where' to find the medicine with the name 'Amisulpride', and then use 'join' to link the 'medicine_enzyme_interaction' and 'enzyme' tables based on the enzyme_id. Finally, filter the rows where the interaction_type is 'inhibitor' and select the enzyme names.\n\nSQL query: SELECT T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id  =  T3.id WHERE T3.name  =  'Amisulpride' AND T2.interaction_type  =  'inhibitor'",
        "predict": "SELECT T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id  =  T3.id WHERE T3.name  =  'Amisulpride' AND T2.interaction_type  =  'inhibitor'",
        "hardness": "hard"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT T1.interaction_type FROM medicine_enzyme_interaction AS T1 JOIN medicine AS T2 ON T1.medicine_id  =  T2.id JOIN enzyme AS T3 ON T1.enzyme_id  =  T3.id WHERE T3.name  =  'ALA synthase' AND T2.name  =  'Aripiprazole'",
        "question": "What is the interaction type of the enzyme named 'ALA synthase' and the medicine named 'Aripiprazole'?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the enzyme with the name 'ALA synthase'. Secondly, we need to find the medicine with the name 'Aripiprazole'. Finally, we need to find the interaction type between these two entities.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the interaction_type from the table 'medicine_enzyme_interaction' where enzyme_id corresponds to the enzyme with the name 'ALA synthase' and medicine_id corresponds to the medicine with the name 'Aripiprazole'.\n\n<3> SQL Generation: Use 'where' to find the enzyme with the name 'ALA synthase' and the medicine with the name 'Aripiprazole', and then use 'where' to filter the interaction_type between these two entities.\n\nSQL query: SELECT T1.interaction_type FROM medicine_enzyme_interaction AS T1 JOIN medicine AS T2 ON T1.medicine_id  =  T2.id JOIN enzyme AS T3 ON T1.enzyme_id  =  T3.id WHERE T3.name  =  'ALA synthase' AND T2.name  =  'Aripiprazole'",
        "predict": "SELECT T1.interaction_type FROM medicine_enzyme_interaction AS T1 JOIN medicine AS T2 ON T1.medicine_id  =  T2.id JOIN enzyme AS T3 ON T1.enzyme_id  =  T3.id WHERE T3.name  =  'ALA synthase' AND T2.name  =  'Aripiprazole'",
        "hardness": "hard"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );",
        "question": "How many enzymes do not have any interactions?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Decomposition: The query requires finding enzymes that do not have any interactions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select enzyme_id from table 'enzyme' and filter by enzyme_id in table 'medicine_enzyme_interaction'.\n\n<3> SQL Generation: Use 'where' to filter enzymes that do not have any interactions and count them.\n\nSQL query: SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );",
        "predict": "SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );",
        "hardness": "extra"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT founded FROM university WHERE affiliation != 'Public' ORDER BY founded DESC LIMIT 1",
        "question": "What is the founded year of the non public school that was founded most recently?",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter non-public schools. Secondly, we need to find the school with the most recent founded year among the filtered schools. Finally, we need to select the founded year of that school.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'university' table to filter non-public schools and select the founded year.\n\n<3> SQL Generation: Use 'where' to filter non-public schools, and then use 'order by' and 'desc' to select the school with the most recent founded year. Finally, select the founded year of that school.\n\nSQL query: SELECT founded FROM university WHERE affiliation != 'Public' ORDER BY founded DESC LIMIT 1",
        "predict": "SELECT founded FROM university WHERE affiliation != 'Public' ORDER BY founded DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "question": "How many schools do not participate in the basketball match?",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding schools that do not participate in the basketball match. We need to count the number of schools that do not have any entries in the basketball_match table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the university table to count the number of schools.\n\n<3> SQL Generation: We can use a left join between the university table and the basketball_match table, and then count the number of rows where the basketball_match columns are null.\n\nSQL query: SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "predict": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "hardness": "extra"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "question": "Count the number of universities that do not participate in the baketball match.",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of universities that do not participate in the basketball match. We need to filter out universities that do participate in the basketball match.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select School_ID from table 'university' and filter out School_ID from table 'basketball_match'.\n\n<3> SQL Generation: Use 'where' to filter out universities that participate in the basketball match, and then use 'count' to count the number of universities that do not participate.\n\nSQL query: SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "predict": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "hardness": "extra"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "question": "Find how many school locations have the word 'NY'.",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter school locations that have the word 'NY'. Secondly, we need to count the number of unique school locations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires information from the 'university' table, we only need to use the 'university' table.\n\n<3> SQL Generation: Use 'where' to filter school locations that have the word 'NY', and then use 'count' to count the number of unique school locations.\n\nSQL query: SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "predict": "SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "hardness": "medium"
    },
    {
        "db_id": "phone_1",
        "gold": "SELECT count(*) FROM phone WHERE Company_name = \"Nokia Corporation\";",
        "question": "How many phone hardware models are produced by the company named \"Nokia Corporation\"?",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter phone hardware models produced by the company named \"Nokia Corporation\". Secondly, we need to count the number of unique hardware models.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter by the company name in the 'phone' table, we only need the 'phone' table.\n\n<3> SQL Generation: Use 'where' to filter phone hardware models produced by the company named \"Nokia Corporation\", and then use 'count' to count the number of unique hardware models.\n\nSQL query: SELECT count(*) FROM phone WHERE Company_name = \"Nokia Corporation\";",
        "predict": "SELECT count(*) FROM phone WHERE Company_name = \"Nokia Corporation\";",
        "hardness": "easy"
    },
    {
        "db_id": "phone_1",
        "gold": "SELECT avg(RAM_MiB) FROM chip_model WHERE model_name NOT IN (SELECT chip_model FROM phone)",
        "question": "Find the average ram mib size of the chip models that are never used by any phone.",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the chip models that are never used by any phone. Secondly, we need to calculate the average RAM_MiB size of those chip models.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Model_name from table 'chip_model' where Model_name does not exist in the 'chip_model' column of table 'phone'. In the second step, we need to calculate the average RAM_MiB size from table 'chip_model'.\n\n<3> SQL Generation: Use 'where not exists' to find the chip models that are never used by any phone, and then use 'avg' to calculate the average RAM_MiB size of those chip models.\n\nSQL query: SELECT avg(RAM_MiB) FROM chip_model WHERE model_name NOT IN (SELECT chip_model FROM phone)",
        "predict": "SELECT avg(RAM_MiB) FROM chip_model WHERE model_name NOT IN (SELECT chip_model FROM phone)",
        "hardness": "extra"
    },
    {
        "db_id": "match_season",
        "gold": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "question": "What are the names of teams that do no have match season record?",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding teams that do not have match season records.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is about teams and match seasons, we need tables ['team', 'match_season'].\n\n<3> SQL Generation: We need to use a left join to combine the 'team' and 'match_season' tables on the 'Team_id' column. Then, we filter the rows where the 'Season' column is null (indicating no match season record). Finally, we select the 'Name' column from the 'team' table.\n\nSQL query: SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "predict": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "hardness": "hard"
    },
    {
        "db_id": "match_season",
        "gold": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "question": "Return the names of teams that have no match season record.",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding teams that have no match season record.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find teams that have no match season record, we only need the 'team' table.\n\n<3> SQL Generation: We can use a 'left join' to join the 'team' table with the 'match_season' table on the 'Team_id' column. Then, we can filter the rows where the 'match_season' columns are null, indicating that there is no match season record for that team. Finally, we can select the 'Name' column from the 'team' table.\n\nSQL query: SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "predict": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "hardness": "hard"
    },
    {
        "db_id": "climbing",
        "gold": "SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber)",
        "question": "What are the names of countains that no climber has climbed?",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the mountains that no climber has climbed. Secondly, we need to retrieve the names of those mountains.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Mountain_ID from table 'mountain' where there is no corresponding entry in the 'climber' table.\n\n<3> SQL Generation: Use 'where not exists' to find the mountains that no climber has climbed, and then select the names of those mountains.\n\nSQL query: SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber)",
        "predict": "SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber)",
        "hardness": "hard"
    },
    {
        "db_id": "climbing",
        "gold": "SELECT Name FROM mountain WHERE Height  >  5000 OR Prominence  >  1000",
        "question": "What are the names of mountains that have a height of over 5000 or a prominence of over 1000?",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on mountains with a height over 5000 or a prominence over 1000. We need to select the names of these mountains.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'mountain' table.\n\n<3> SQL Generation: Use 'where' to filter mountains with a height over 5000 or a prominence over 1000, and select their names.\n\nSQL query: SELECT Name FROM mountain WHERE Height  >  5000 OR Prominence  >  1000",
        "predict": "SELECT Name FROM mountain WHERE Height  >  5000 OR Prominence  >  1000",
        "hardness": "medium"
    },
    {
        "db_id": "body_builder",
        "gold": "SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Total  >  300",
        "question": "What are the names of body builders whose total score is higher than 300?",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on body builders whose total score is higher than 300. Firstly, we need to identify the body builders with a total score higher than 300. Secondly, we need to retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the total score is in the 'body_builder' table and the names are in the 'people' table, we need to use these two tables.\n\n<3> SQL Generation: Use 'where' to filter body builders with a total score higher than 300, and then select their names.\n\nSQL query: SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Total  >  300",
        "predict": "SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Total  >  300",
        "hardness": "medium"
    },
    {
        "db_id": "body_builder",
        "gold": "SELECT count(*) FROM people WHERE people_id NOT IN (SELECT People_ID FROM body_builder)",
        "question": "How many persons are not body builders?",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding persons who are not body builders. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find persons who are not body builders, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter out persons who are body builders and count the remaining persons.\n\nSQL query: SELECT count(*) FROM people WHERE people_id NOT IN (SELECT People_ID FROM body_builder)",
        "predict": "SELECT count(*) FROM people WHERE people_id NOT IN (SELECT People_ID FROM body_builder)",
        "hardness": "extra"
    },
    {
        "db_id": "election_representative",
        "gold": "SELECT T2.Name FROM election AS T1 JOIN representative AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE Votes  >  10000",
        "question": "What are the names of representatives with more than 10000 votes in election?",
        "fields": "Table election, columns = [*,Election_ID,Representative_ID,Date,Votes,Vote_Percent,Seats,Place]\nTable representative, columns = [*,Representative_ID,Name,State,Party,Lifespan]\n",
        "foreign_keys": "Foreign_keys = [election.Representative_ID = representative.Representative_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on representatives with more than 10000 votes in an election. Firstly, we need to identify the representatives who received more than 10000 votes. Secondly, we need to retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the filtering is based on the 'Votes' column in the 'election' table, we only need the 'election' table.\n\n<3> SQL Generation: Use 'where' to filter representatives with more than 10000 votes and select their names.\n\nSQL query: SELECT T2.Name FROM election AS T1 JOIN representative AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE Votes  >  10000",
        "predict": "SELECT T2.Name FROM election AS T1 JOIN representative AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE Votes  >  10000",
        "hardness": "medium"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "question": "How many apartments do not have any facility?",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding apartments that do not have any facility. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select apt_id from table 'Apartments' and apt_id from table 'Apartment_Facilities'.\n\n<3> SQL Generation: We can use a left join to combine the 'Apartments' table with the 'Apartment_Facilities' table on the apt_id column. Then, we can filter the rows where the facility_code is null, indicating that the apartment does not have any facility. Finally, we can count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "predict": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "hardness": "extra"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "question": "Find the number of apartments that have no facility.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding apartments that have no facility. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select apt_id from table 'Apartments' and filter by apt_id in table 'Apartment_Facilities'.\n\n<3> SQL Generation: We can use a left join to combine the 'Apartments' and 'Apartment_Facilities' tables on the 'apt_id' column. Then, we can filter the rows where the 'facility_code' is null (indicating no facility) and count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "predict": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "hardness": "extra"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT count(*) FROM game WHERE season  >  2007",
        "question": "How many games are held after season 2007?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on games held after season 2007. Firstly, we need to identify the games that have a season greater than 2007. Secondly, we need to count the number of games that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the filtering is based on the 'Season' column in the 'game' table, we only need the 'game' table.\n\n<3> SQL Generation: Use 'where' to filter games with a season greater than 2007, and then use 'count' to count the number of games that meet this condition.\n\nSQL query: SELECT count(*) FROM game WHERE season  >  2007",
        "predict": "SELECT count(*) FROM game WHERE season  >  2007",
        "hardness": "easy"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT player ,  number_of_matches ,  SOURCE FROM injury_accident WHERE injury != 'Knee problem'",
        "question": "What are the player name, number of matches, and information source for players who do not suffer from injury of 'Knee problem'?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter players who do not suffer from the injury of 'Knee problem'. Secondly, we need to select the player name, number of matches, and information source for the selected players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the injury information is stored in the 'injury_accident' table, we need to join the 'injury_accident' table with the 'game' table on the 'game_id' column. Then, we can filter the rows where the injury is not 'Knee problem' and select the player name, number of matches, and information source from the 'injury_accident' table.\n\n<3> SQL Generation: Use 'join' to link the 'injury_accident' and 'game' tables on the 'game_id' column. Then, use 'where' to filter the rows where the injury is not 'Knee problem'. Finally, select the player name, number of matches, and information source from the 'injury_accident' table.\n\nSQL query: SELECT player ,  number_of_matches ,  SOURCE FROM injury_accident WHERE injury != 'Knee problem'",
        "predict": "SELECT player ,  number_of_matches ,  SOURCE FROM injury_accident WHERE injury != 'Knee problem'",
        "hardness": "medium"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT count(DISTINCT T1.injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id  =  T2.id WHERE T2.season  >  2010",
        "question": "How many distinct kinds of injuries happened after season 2010?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter injuries that happened after season 2010. Secondly, we need to count the distinct kinds of injuries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter game_id from table 'injury_accident' based on the season from table 'game'. In the second step, we need to select distinct kinds of injuries from table 'injury_accident'.\n\n<3> SQL Generation: Use 'where' to filter injuries that happened after season 2010, and then use 'count' and 'distinct' to count the distinct kinds of injuries.\n\nSQL query: SELECT count(DISTINCT T1.injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id  =  T2.id WHERE T2.season  >  2010",
        "predict": "SELECT count(DISTINCT T1.injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id  =  T2.id WHERE T2.season  >  2010",
        "hardness": "medium"
    },
    {
        "db_id": "soccer_1",
        "gold": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  \"right\"",
        "question": "List the names of all players who have a crossing score higher than 90 and prefer their right foot.",
        "fields": "Table Country, columns = [*,id,name]\nTable League, columns = [*,id,country_id,name]\nTable Player, columns = [*,id,player_api_id,player_name,player_fifa_api_id,birthday,height,weight]\nTable Player_Attributes, columns = [*,id,player_fifa_api_id,player_api_id,date,overall_rating,potential,preferred_foot,attacking_work_rate,defensive_work_rate,crossing,finishing,heading_accuracy,short_passing,volleys,dribbling,curve,free_kick_accuracy,long_passing,ball_control,acceleration,sprint_speed,agility,reactions,balance,shot_power,jumping,stamina,strength,long_shots,aggression,interceptions,positioning,vision,penalties,marking,standing_tackle,sliding_tackle,gk_diving,gk_handling,gk_kicking,gk_positioning,gk_reflexes]\nTable Team, columns = [*,id,team_api_id,team_fifa_api_id,team_long_name,team_short_name]\nTable Team_Attributes, columns = [*,id,team_fifa_api_id,team_api_id,date,buildUpPlaySpeed,buildUpPlaySpeedClass,buildUpPlayDribbling,buildUpPlayDribblingClass,buildUpPlayPassing,buildUpPlayPassingClass,buildUpPlayPositioningClass,chanceCreationPassing,chanceCreationPassingClass,chanceCreationCrossing,chanceCreationCrossingClass,chanceCreationShooting,chanceCreationShootingClass,chanceCreationPositioningClass,defencePressure,defencePressureClass,defenceAggression,defenceAggressionClass,defenceTeamWidth,defenceTeamWidthClass,defenceDefenderLineClass]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "foreign_keys": "Foreign_keys = [Player_Attributes.player_api_id = Player.player_api_id,Player_Attributes.player_fifa_api_id = Player.player_fifa_api_id,League.country_id = Country.id,Team_Attributes.team_api_id = Team.team_api_id,Team_Attributes.team_fifa_api_id = Team.team_fifa_api_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter players based on their crossing score and preferred foot. Secondly, we need to select the names of the filtered players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select player_name from table 'Player' and filter based on crossing score from table 'Player_Attributes'.\n\n<3> SQL Generation: Use 'where' to filter players based on their crossing score and preferred foot, and then select the names of the filtered players.\n\nSQL query: SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  \"right\"",
        "predict": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  \"right\"",
        "hardness": "medium"
    },
    {
        "db_id": "performance_attendance",
        "gold": "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM member_attendance)",
        "question": "List the names of members who did not attend any performance.",
        "fields": "Table member, columns = [*,Member_ID,Name,Nationality,Role]\nTable member_attendance, columns = [*,Member_ID,Performance_ID,Num_of_Pieces]\nTable performance, columns = [*,Performance_ID,Date,Host,Location,Attendance]\n",
        "foreign_keys": "Foreign_keys = [member_attendance.Performance_ID = performance.Performance_ID,member_attendance.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding members who did not attend any performance. Firstly, we need to identify all members who attended performances. Secondly, we need to filter out members who attended performances and return the names of the remaining members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Member_ID from table 'member_attendance' and filter by Performance_ID. Then, we need to select Name from table 'member' and filter out the members who attended performances.\n\n<3> SQL Generation: Use 'where' to filter members who attended performances, and then use 'not in' to filter out those members and select their names.\n\nSQL query: SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM member_attendance)",
        "predict": "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM member_attendance)",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "question": "Count the number of rooms that are not in the Lamberton building.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of rooms that are not in the Lamberton building. We need to filter out the rooms in the Lamberton building and count the remaining rooms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the rooms from the 'classroom' table and filter by the building column.\n\n<3> SQL Generation: Use 'where' to filter out the rooms in the Lamberton building and count the remaining rooms.\n\nSQL query: SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "predict": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "hardness": "easy"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "question": "How many classrooms are not in Lamberton?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of classrooms that are not in Lamberton.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'classroom' table.\n\n<3> SQL Generation: Use 'where' to filter classrooms that are not in Lamberton and count them.\n\nSQL query: SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "predict": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "hardness": "easy"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT i_id FROM advisor AS T1 JOIN student AS T2 ON T1.s_id  =  T2.id WHERE T2.dept_name  =  'History'",
        "question": "Give id of the instructor who advises students in the History department.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the department with the name 'History'. Secondly, we need to find the instructor who advises students in that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dept_name from table 'department' where dept_name = 'History'. In the second step, we need to select i_ID from table 'advisor' where s_ID is the same as the ID of the students in the History department.\n\n<3> SQL Generation: Use 'where' to find the department with the name 'History', and then use 'where' to find the instructor who advises students in that department.\n\nSQL query: SELECT i_id FROM advisor AS T1 JOIN student AS T2 ON T1.s_id  =  T2.id WHERE T2.dept_name  =  'History'",
        "predict": "SELECT i_id FROM advisor AS T1 JOIN student AS T2 ON T1.s_id  =  T2.id WHERE T2.dept_name  =  'History'",
        "hardness": "medium"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester  =  'Spring')",
        "question": "What are the names of instructors who didn't teach courses in the Spring?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the instructors who taught courses in the Spring. Secondly, we need to filter out the instructors who didn't teach courses in the Spring and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select distinct ID from table 'teaches' where semester = 'Spring'. In the second step, we need to select name from table 'instructor' and filter out the instructors whose ID is not in the result of the first step.\n\n<3> SQL Generation: Use 'where' to find the instructors who taught courses in the Spring, and then use 'where' to filter out the instructors who didn't teach courses in the Spring and select their names.\n\nSQL query: SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester  =  'Spring')",
        "predict": "SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester  =  'Spring')",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE T2.course_id IN (SELECT T4.prereq_id FROM course AS T3 JOIN prereq AS T4 ON T3.course_id  =  T4.course_id WHERE T3.title  =  'International Finance')",
        "question": "Find the name of students who have taken the prerequisite course of the course with title International Finance.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the course_id of the course with title International Finance. Secondly, we need to find the prerequisite course_id for the course found in the first step. Thirdly, we need to find the names of students who have taken the prerequisite course.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'course' where title = 'International Finance'. In the second step, we need to select prereq_id from table 'prereq' where course_id is the value found in the first step. In the third step, we need to select name from table 'student' where ID is the value found in the second step.\n\n<3> SQL Generation: Use 'where' to find the course_id of the course with title International Finance. Then, use 'where' to find the prerequisite course_id for the course found in the first step. Finally, use 'where' to find the names of students who have taken the prerequisite course.\n\nSQL query: SELECT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE T2.course_id IN (SELECT T4.prereq_id FROM course AS T3 JOIN prereq AS T4 ON T3.course_id  =  T4.course_id WHERE T3.title  =  'International Finance')",
        "predict": "SELECT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE T2.course_id IN (SELECT T4.prereq_id FROM course AS T3 JOIN prereq AS T4 ON T3.course_id  =  T4.course_id WHERE T3.title  =  'International Finance')",
        "hardness": "extra"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "question": "Find the names of all instructors in Comp. Sci. department with salary > 80000.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter instructors based on their department and salary. Secondly, we need to select the names of the filtered instructors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter instructors based on their department, we need the 'instructor' and 'department' tables. We also need the 'salary' column from the 'instructor' table.\n\n<3> SQL Generation: Use 'where' to filter instructors in the Comp. Sci. department with a salary greater than 80000, and then select their names.\n\nSQL query: SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "predict": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "hardness": "medium"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "question": "What are the names of the instructors in the Comp. Sci. department who earn more than 80000?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter instructors based on their department and salary. Secondly, we need to select the names of the filtered instructors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ID and name from table 'instructor' where dept_name = 'Comp. Sci.' and salary > 80000.\n\n<3> SQL Generation: Use 'where' to filter instructors based on their department and salary, and then select their names.\n\nSQL query: SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "predict": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "hardness": "medium"
    },
    {
        "db_id": "debate",
        "gold": "SELECT Name FROM  people WHERE Age  =  35 OR Age  =  36",
        "question": "Show the names of people aged either 35 or 36.",
        "fields": "Table debate, columns = [*,Debate_ID,Date,Venue,Num_of_Audience]\nTable debate_people, columns = [*,Debate_ID,Affirmative,Negative,If_Affirmative_Win]\nTable people, columns = [*,People_ID,District,Name,Party,Age]\n",
        "foreign_keys": "Foreign_keys = [debate_people.Negative = people.People_ID,debate_people.Affirmative = people.People_ID,debate_people.Debate_ID = debate.Debate_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on people with age 35 or 36. We need to select the names of these people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter people with age 35 or 36 and select their names.\n\nSQL query: SELECT Name FROM  people WHERE Age  =  35 OR Age  =  36",
        "predict": "SELECT Name FROM  people WHERE Age  =  35 OR Age  =  36",
        "hardness": "medium"
    },
    {
        "db_id": "debate",
        "gold": "SELECT T3.Name FROM debate_people AS T1 JOIN debate AS T2 ON T1.Debate_ID  =  T2.Debate_ID JOIN people AS T3 ON T1.Affirmative  =  T3.People_ID WHERE T2.Num_of_Audience  >  200",
        "question": "Show the names of people that are on affirmative side of debates with number of audience bigger than 200.",
        "fields": "Table debate, columns = [*,Debate_ID,Date,Venue,Num_of_Audience]\nTable debate_people, columns = [*,Debate_ID,Affirmative,Negative,If_Affirmative_Win]\nTable people, columns = [*,People_ID,District,Name,Party,Age]\n",
        "foreign_keys": "Foreign_keys = [debate_people.Negative = people.People_ID,debate_people.Affirmative = people.People_ID,debate_people.Debate_ID = debate.Debate_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter debates with number of audience bigger than 200. Secondly, we need to find the names of people on the affirmative side of these debates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter Debate_ID from table 'debate' where Num_of_Audience > 200. In the second step, we need to select Name from table 'people' where People_ID is in the affirmative column of table 'debate_people'.\n\n<3> SQL Generation: Use 'where' to filter debates with number of audience bigger than 200, and then use 'where' and 'join' to select the names of people on the affirmative side of these debates.\n\nSQL query: SELECT T3.Name FROM debate_people AS T1 JOIN debate AS T2 ON T1.Debate_ID  =  T2.Debate_ID JOIN people AS T3 ON T1.Affirmative  =  T3.People_ID WHERE T2.Num_of_Audience  >  200",
        "predict": "SELECT T3.Name FROM debate_people AS T1 JOIN debate AS T2 ON T1.Debate_ID  =  T2.Debate_ID JOIN people AS T3 ON T1.Affirmative  =  T3.People_ID WHERE T2.Num_of_Audience  >  200",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "question": "How many customers don't have an account?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding customers who don't have an account.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customers' and check if it exists in table 'Accounts'.\n\n<3> SQL Generation: Use 'where' to filter customers who don't have an account and count them.\n\nSQL query: SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "predict": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT transaction_id FROM Financial_transactions WHERE transaction_amount  >  (SELECT avg(transaction_amount) FROM Financial_transactions)",
        "question": "What are the ids for transactions that have an amount greater than the average amount of a transaction?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average amount of a transaction. Secondly, we need to filter transactions with an amount greater than the average amount.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select transaction_amount from table 'Financial_Transactions'.\n\n<3> SQL Generation: Use 'where' to filter transactions with an amount greater than the average amount.\n\nSQL query: SELECT transaction_id FROM Financial_transactions WHERE transaction_amount  >  (SELECT avg(transaction_amount) FROM Financial_transactions)",
        "predict": "SELECT transaction_id FROM Financial_transactions WHERE transaction_amount  >  (SELECT avg(transaction_amount) FROM Financial_transactions)",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "question": "How many products were not included in any order?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the products that were included in orders. Secondly, we need to count the products that were not included in any order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Order_Items'. In the second step, we need to select product_id from table 'Products' and count them.\n\n<3> SQL Generation: Use 'distinct' to select unique product_id from table 'Order_Items', and then use 'where' to filter products that were not included in any order and count them.\n\nSQL query: SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "predict": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "question": "Count the number of products that were never ordered.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: We need to find the products that were never ordered. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select product_id from the 'Products' table and filter out the products that have corresponding entries in the 'Order_Items' table.\n\n<3> SQL Generation: We can use a left join between the 'Products' and 'Order_Items' tables and filter out the rows where the 'order_item_id' is null. Then, we can count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "predict": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "hardness": "extra"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT count(*) FROM Church WHERE Open_Date  <  1850",
        "question": "How many churches opened before 1850 are there?",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on churches that opened before 1850. We need to filter churches based on their open date and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'church' table and its 'Open_Date' column.\n\n<3> SQL Generation: Use 'where' to filter churches that opened before 1850 and count them.\n\nSQL query: SELECT count(*) FROM Church WHERE Open_Date  <  1850",
        "predict": "SELECT count(*) FROM Church WHERE Open_Date  <  1850",
        "hardness": "easy"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT count(*) FROM people WHERE is_male  =  'F' AND age  >  30",
        "question": "How many female people are older than 30 in our record?",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter people based on their gender and age. Secondly, we need to count the number of selected female people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'people' table to filter based on gender and age, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter people based on their gender and age, and then use 'count' to calculate the number of selected female people.\n\nSQL query: SELECT count(*) FROM people WHERE is_male  =  'F' AND age  >  30",
        "predict": "SELECT count(*) FROM people WHERE is_male  =  'F' AND age  >  30",
        "hardness": "medium"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT T2.name ,  T3.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id WHERE T1.year  >  2014",
        "question": "Show the pair of male and female names in all weddings after year 2014",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter weddings that happened after year 2014. Secondly, we need to find the names of the male and female participants in those weddings.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Church_ID from table 'wedding' where Year > 2014. In the second step, we need to select Male_ID and Female_ID from table 'wedding' and join them with table 'people' to get the corresponding names.\n\n<3> SQL Generation: Use 'where' to filter weddings that happened after year 2014, and then use 'join' to connect the Male_ID and Female_ID with the People_ID in table 'people' to get the names of the participants.\n\nSQL query: SELECT T2.name ,  T3.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id WHERE T1.year  >  2014",
        "predict": "SELECT T2.name ,  T3.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id WHERE T1.year  >  2014",
        "hardness": "hard"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT T4.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id JOIN church AS T4 ON T4.church_id  =  T1.church_id WHERE T2.age  >  30 OR T3.age  >  30",
        "question": "Show the church names for the weddings of all people older than 30.",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter people based on their age being older than 30. Secondly, we need to find the church names for the weddings of these people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter People_ID from table 'people' where Age > 30. In the second step, we need to select Church_ID from table 'wedding' and filter by Male_ID and Female_ID from the filtered people in the first step.\n\n<3> SQL Generation: Use 'where' to filter people with age older than 30, and then use 'join' to link the 'wedding' table with the filtered people based on Male_ID and Female_ID. Finally, select the church names from the 'church' table.\n\nSQL query: SELECT T4.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id JOIN church AS T4 ON T4.church_id  =  T1.church_id WHERE T2.age  >  30 OR T3.age  >  30",
        "predict": "SELECT T4.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id JOIN church AS T4 ON T4.church_id  =  T1.church_id WHERE T2.age  >  30 OR T3.age  >  30",
        "hardness": "extra"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR  =  2016",
        "question": "How many churches have a wedding in year 2016?",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter weddings based on the year 2016. Secondly, we need to count the number of unique churches that have weddings in that year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Church_ID from table 'wedding' where Year = 2016. Then, we need to count the number of unique Church_IDs.\n\n<3> SQL Generation: Use 'where' to filter weddings in the year 2016, and then use 'count' and 'distinct' to count the number of unique Church_IDs.\n\nSQL query: SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR  =  2016",
        "predict": "SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR  =  2016",
        "hardness": "easy"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT name ,  year_join FROM artist WHERE country != 'United States'",
        "question": "What are the names and year of joining for artists that do not have the country \"United States\"?",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter artists based on their country not being \"United States\". Secondly, we need to select the names and year of joining for the filtered artists.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'artist' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter artists based on their country not being \"United States\", and then select the names and year of joining for the filtered artists.\n\nSQL query: SELECT name ,  year_join FROM artist WHERE country != 'United States'",
        "predict": "SELECT name ,  year_join FROM artist WHERE country != 'United States'",
        "hardness": "medium"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "question": "How many artists are above age 46 and joined after 1990?",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter artists based on their age and year of joining. Secondly, we need to count the number of selected artists.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'artist' table to filter artists based on age and year of joining, we only need the 'artist' table.\n\n<3> SQL Generation: Use 'where' to filter artists based on age and year of joining, and then use 'count' to count the number of selected artists.\n\nSQL query: SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "predict": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "hardness": "medium"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "question": "Count the number of artists who are older than 46 and joined after 1990.",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter artists based on their age and year of joining. Secondly, we need to count the number of selected artists.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'artist' table to filter artists based on age and year of joining, we only need the 'artist' table.\n\n<3> SQL Generation: Use 'where' to filter artists based on age and year of joining, and then use 'count' to count the number of selected artists.\n\nSQL query: SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "predict": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "hardness": "medium"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "question": "Find the number of items that did not receive any review.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding items that did not receive any review. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find items that did not receive any review, we only need the 'item' and 'review' tables.\n\n<3> SQL Generation: We can use a left join to combine the 'item' and 'review' tables on the 'i_id' column. Then, we can filter the rows where the 'rating' column is null (indicating no review) and count the number of rows.\n\nSQL query: SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "predict": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "question": "Find the number of users who did not write any review.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Decomposition: We need to find the users who did not write any review. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select u_id from table 'useracct' and filter out the u_id values that appear in the 'review' table.\n\n<3> SQL Generation: We can use a left join to combine the 'useracct' and 'review' tables on the 'u_id' column. Then, we can filter out the rows where the 'i_id' column is null (indicating that the user did not write any review). Finally, we can count the number of distinct 'u_id' values.\n\nSQL query: SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "predict": "SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "question": "Find the number of items without any review.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Decomposition: We need to find the items that do not have any reviews.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'item' and 'review' tables.\n\n<3> SQL Generation: We can use a left join to combine the 'item' and 'review' tables on the 'i_id' column. Then, we can filter the rows where the 'review' table's 'i_id' is null, indicating that there are no reviews for that item. Finally, we can count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "predict": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "hardness": "extra"
    },
    {
        "db_id": "riding_club",
        "gold": "SELECT Player_name FROM player ORDER BY Votes ASC",
        "question": "List the names of players in ascending order of votes.",
        "fields": "Table club, columns = [*,Club_ID,Club_name,Region,Start_year]\nTable coach, columns = [*,Coach_ID,Coach_name,Gender,Club_ID,Rank]\nTable match_result, columns = [*,Rank,Club_ID,Gold,Big_Silver,Small_Silver,Bronze,Points]\nTable player, columns = [*,Player_ID,Sponsor_name,Player_name,Gender,Residence,Occupation,Votes,Rank]\nTable player_coach, columns = [*,Player_ID,Coach_ID,Starting_year]\n",
        "foreign_keys": "Foreign_keys = [coach.Club_ID = club.Club_ID,player_coach.Coach_ID = coach.Coach_ID,player_coach.Player_ID = player.Player_ID,match_result.Club_ID = club.Club_ID]\n",
        "reasoning": "<1> Decomposition: We need to retrieve the names of players and sort them in ascending order based on their votes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'player' table for this query.\n\n<3> SQL Generation: We can directly select the 'Player_name' column from the 'player' table and order the results by the 'Votes' column in ascending order.\n\nSQL query: SELECT Player_name FROM player ORDER BY Votes ASC",
        "predict": "SELECT Player_name FROM player ORDER BY Votes ASC",
        "hardness": "easy"
    },
    {
        "db_id": "gymnast",
        "gold": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T2.Hometown != \"Santo Domingo\"",
        "question": "What are the names of gymnasts whose hometown is not \"Santo Domingo\"?",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on gymnasts whose hometown is not \"Santo Domingo\". We need to select the names of these gymnasts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names from the 'people' table and filter based on the 'hometown' column. We also need to join the 'gymnast' table with the 'people' table using the 'Gymnast_ID' and 'People_ID' columns.\n\n<3> SQL Generation: Use 'where' to filter gymnasts whose hometown is not \"Santo Domingo\" and select their names.\n\nSQL query: SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T2.Hometown != \"Santo Domingo\"",
        "predict": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T2.Hometown != \"Santo Domingo\"",
        "hardness": "medium"
    },
    {
        "db_id": "small_bank_1",
        "gold": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)",
        "question": "What are the names of customers with checking balances lower than the average checking balance?",
        "fields": "Table ACCOUNTS, columns = [*,custid,name]\nTable CHECKING, columns = [*,custid,balance]\nTable SAVINGS, columns = [*,custid,balance]\n",
        "foreign_keys": "Foreign_keys = [SAVINGS.custid = ACCOUNTS.custid,CHECKING.custid = ACCOUNTS.custid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average checking balance. Secondly, we need to filter customers with checking balances lower than the average and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'ACCOUNTS' and 'CHECKING' tables.\n\n<3> SQL Generation: Use 'avg' to calculate the average checking balance, and then use 'where' to filter customers with checking balances lower than the average and select their names.\n\nSQL query: SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)",
        "predict": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)",
        "hardness": "extra"
    },
    {
        "db_id": "wrestler",
        "gold": "SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1",
        "question": "What is the name of the wrestler with the fewest days held?",
        "fields": "Table Elimination, columns = [*,Elimination_ID,Wrestler_ID,Team,Eliminated_By,Elimination_Move,Time]\nTable wrestler, columns = [*,Wrestler_ID,Name,Reign,Days_held,Location,Event]\n",
        "foreign_keys": "Foreign_keys = [Elimination.Wrestler_ID = wrestler.Wrestler_ID]\n",
        "reasoning": "<1> Decomposition: We need to find the wrestler with the fewest days held. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'wrestler' table.\n\n<3> SQL Generation: We can use the 'MIN' function to find the minimum value of 'Days_held' in the 'wrestler' table and then select the corresponding wrestler's name.\n\nSQL query: SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1",
        "predict": "SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1",
        "hardness": "medium"
    },
    {
        "db_id": "wrestler",
        "gold": "SELECT Name FROM wrestler WHERE Days_held  <  100",
        "question": "What are the names of wrestlers days held less than 100?",
        "fields": "Table Elimination, columns = [*,Elimination_ID,Wrestler_ID,Team,Eliminated_By,Elimination_Move,Time]\nTable wrestler, columns = [*,Wrestler_ID,Name,Reign,Days_held,Location,Event]\n",
        "foreign_keys": "Foreign_keys = [Elimination.Wrestler_ID = wrestler.Wrestler_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on wrestlers with days held less than 100. We need to select the names of these wrestlers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'wrestler' table.\n\n<3> SQL Generation: Use 'where' to filter wrestlers with days held less than 100 and select their names.\n\nSQL query: SELECT Name FROM wrestler WHERE Days_held  <  100",
        "predict": "SELECT Name FROM wrestler WHERE Days_held  <  100",
        "hardness": "easy"
    },
    {
        "db_id": "school_finance",
        "gold": "SELECT count(DISTINCT T1.donator_name) FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Glenn\"",
        "question": "How many donors have endowment for school named \"Glenn\"?",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the school with the name \"Glenn\". Secondly, we need to count the number of donors who have an endowment for that school.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select School_id from table 'School' where School_name = \"Glenn\". In the second step, we need to count the number of distinct donors from table 'endowment' where School_id matches the School_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the School_id for the school named \"Glenn\", and then use 'count' to count the number of distinct donors from the 'endowment' table where School_id matches the School_id found in the first step.\n\nSQL query: SELECT count(DISTINCT T1.donator_name) FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Glenn\"",
        "predict": "SELECT count(DISTINCT T1.donator_name) FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Glenn\"",
        "hardness": "medium"
    },
    {
        "db_id": "school_finance",
        "gold": "SELECT count(*) FROM budget WHERE budgeted  <  invested",
        "question": "How many budget record has a budget amount smaller than the invested amount?",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on budget records where the budget amount is smaller than the invested amount. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'budget' table for this query.\n\n<3> SQL Generation: Use 'where' to filter budget records where the budget amount is smaller than the invested amount, and then count the number of records that meet this condition.\n\nSQL query: SELECT count(*) FROM budget WHERE budgeted  <  invested",
        "predict": "SELECT count(*) FROM budget WHERE budgeted  <  invested",
        "hardness": "easy"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT name FROM building WHERE height_feet  >=  200 AND floors  >=  20",
        "question": "List the names of buildings with at least 200 feet of height and with at least 20 floors.",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on buildings with at least 200 feet of height and at least 20 floors. We need to select the names of these buildings.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'building' table.\n\n<3> SQL Generation: Use 'where' to filter buildings with at least 200 feet of height and at least 20 floors, and then select the names of these buildings.\n\nSQL query: SELECT name FROM building WHERE height_feet  >=  200 AND floors  >=  20",
        "predict": "SELECT name FROM building WHERE height_feet  >=  200 AND floors  >=  20",
        "hardness": "medium"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT TYPE FROM institution WHERE founded  >  1990 AND enrollment  >=  1000",
        "question": "Show the institution type with an institution founded after 1990 and an institution with at least 1000 enrollment.",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter institutions based on their founding year and enrollment. Secondly, we need to select the institution type for the filtered institutions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the institution type from table 'Institution' and filter by founding year and enrollment.\n\n<3> SQL Generation: Use 'where' to filter institutions founded after 1990 and with at least 1000 enrollment, and then select the institution type.\n\nSQL query: SELECT TYPE FROM institution WHERE founded  >  1990 AND enrollment  >=  1000",
        "predict": "SELECT TYPE FROM institution WHERE founded  >  1990 AND enrollment  >=  1000",
        "hardness": "medium"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id WHERE T1.founded  >  1880 OR T1.type  =  'Private'",
        "question": "How many proteins are associated with an institution founded after 1880 or an institution with type \"Private\"?",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter institutions founded after 1880. Secondly, we need to filter institutions with type \"Private\". Finally, we need to count the number of proteins associated with these filtered institutions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter Institution_id from table 'Institution' where Founded > 1880. In the second step, we need to filter Institution_id from table 'Institution' where Type = \"Private\". In the final step, we need to count the number of proteins associated with the filtered Institution_id.\n\n<3> SQL Generation: Use 'where' to filter institutions founded after 1880 and institutions with type \"Private\". Then, use 'where' to filter proteins associated with the filtered Institution_id and count them.\n\nSQL query: SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id WHERE T1.founded  >  1880 OR T1.type  =  'Private'",
        "predict": "SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id WHERE T1.founded  >  1880 OR T1.type  =  'Private'",
        "hardness": "hard"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT count(*) FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM protein)",
        "question": "How many institutions do not have an associated protein in our record?",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding institutions that do not have an associated protein in the record.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Institution_id from table 'Institution' and check if there is a corresponding Institution_id in table 'protein'.\n\n<3> SQL Generation: Use 'where' to filter institutions that do not have a corresponding Institution_id in the 'protein' table, and then count the number of institutions.\n\nSQL query: SELECT count(*) FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM protein)",
        "predict": "SELECT count(*) FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM protein)",
        "hardness": "extra"
    },
    {
        "db_id": "cinema",
        "gold": "SELECT title ,  directed_by FROM film WHERE film_id NOT IN (SELECT film_id FROM schedule)",
        "question": "What are the title and director of the films without any schedule?",
        "fields": "Table cinema, columns = [*,Cinema_ID,Name,Openning_year,Capacity,Location]\nTable film, columns = [*,Film_ID,Rank_in_series,Number_in_season,Title,Directed_by,Original_air_date,Production_code]\nTable schedule, columns = [*,Cinema_ID,Film_ID,Date,Show_times_per_day,Price]\n",
        "foreign_keys": "Foreign_keys = [schedule.Cinema_ID = cinema.Cinema_ID,schedule.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the films that do not have any schedule. Secondly, we need to select the title and director of those films.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'film' table to select the title and director.\n\n<3> SQL Generation: Use 'not in' to find the films that do not have any schedule, and then select the title and director from the 'film' table.\n\nSQL query: SELECT title ,  directed_by FROM film WHERE film_id NOT IN (SELECT film_id FROM schedule)",
        "predict": "SELECT title ,  directed_by FROM film WHERE film_id NOT IN (SELECT film_id FROM schedule)",
        "hardness": "extra"
    },
    {
        "db_id": "products_for_hire",
        "gold": "SELECT count(*) FROM Products_for_hire WHERE product_id NOT IN ( SELECT product_id FROM products_booked WHERE booked_amount  >  200 )",
        "question": "How many products are never booked with amount higher than 200?",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the products that are never booked with an amount higher than 200. Secondly, we need to count the number of such products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select product_id from table 'Products_for_Hire' where booked_amount <= 200 and then count the number of distinct product_ids.\n\n<3> SQL Generation: Use 'where' to filter products that are never booked with an amount higher than 200, and then use 'count' to count the number of distinct product_ids.\n\nSQL query: SELECT count(*) FROM Products_for_hire WHERE product_id NOT IN ( SELECT product_id FROM products_booked WHERE booked_amount  >  200 )",
        "predict": "SELECT count(*) FROM Products_for_hire WHERE product_id NOT IN ( SELECT product_id FROM products_booked WHERE booked_amount  >  200 )",
        "hardness": "extra"
    },
    {
        "db_id": "products_for_hire",
        "gold": "SELECT payment_date FROM payments WHERE amount_paid  >  300 OR payment_type_code  =  'Check'",
        "question": "What are the payment date of the payment with amount paid higher than 300 or with payment type is 'Check'",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter payments with amount paid higher than 300. Secondly, we need to filter payments with payment type 'Check'. Finally, we need to select the payment dates of the filtered payments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select payment_date from table 'Payments' and filter by amount_paid or payment_type_code.\n\n<3> SQL Generation: Use 'where' to filter payments with amount paid higher than 300 or with payment type 'Check', and then select the payment dates.\n\nSQL query: SELECT payment_date FROM payments WHERE amount_paid  >  300 OR payment_type_code  =  'Check'",
        "predict": "SELECT payment_date FROM payments WHERE amount_paid  >  300 OR payment_type_code  =  'Check'",
        "hardness": "medium"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "question": "Show the company name and the main industry for all companies whose headquarters are not from USA.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on companies whose headquarters are not from the USA. We need to select the company name and main industry for these companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select company name and main industry from table 'company' where headquarters is not from the USA.\n\n<3> SQL Generation: Use 'where' to filter companies whose headquarters are not from the USA, and then select the company name and main industry.\n\nSQL query: SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "predict": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "hardness": "medium"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "question": "What are the companies and main industries of all companies that are not headquartered in the United States?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on companies that are not headquartered in the United States. Firstly, we need to identify the companies that are not headquartered in the United States. Secondly, we need to select the company name and main industry of these companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'company' table, we only need to consider this table.\n\n<3> SQL Generation: Use 'where' to filter companies that are not headquartered in the United States, and then select the company name and main industry.\n\nSQL query: SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "predict": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "hardness": "medium"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT count(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005",
        "question": "How many gas station are opened between 2000 and 2005?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on gas stations that were opened between 2000 and 2005.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'gas_station' table.\n\n<3> SQL Generation: Use 'where' to filter gas stations that were opened between 2000 and 2005, and then count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005",
        "predict": "SELECT count(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005",
        "hardness": "easy"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "question": "Show company name and main industry without a gas station.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding companies without a gas station. We need to select the company name and main industry from the 'company' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'company' table.\n\n<3> SQL Generation: We can use a left join to combine the 'company' table with the 'station_company' table on the 'Company_ID' column. Then, we can filter the rows where the 'Station_ID' is null, indicating that the company does not have a gas station. Finally, we select the company name and main industry from the resulting rows.\n\nSQL query: SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "predict": "SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "hardness": "extra"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "question": "What are the main industries of the companies without gas stations and what are the companies?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies without gas stations. Secondly, we need to identify the main industries of these companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Company_ID from table 'company' where Company_ID does not exist in table 'station_company'. In the second step, we need to select Main_Industry and Company from table 'company' based on the Company_IDs found in the first step.\n\n<3> SQL Generation: Use 'where' and 'not in' to find the Company_IDs that do not exist in table 'station_company', and then select Main_Industry and Company based on these Company_IDs.\n\nSQL query: SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "predict": "SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "hardness": "extra"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT T3.location FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.market_value  >  100",
        "question": "What are the locations that have gas stations owned by a company with a market value greater than 100?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies with a market value greater than 100. Secondly, we need to filter gas stations based on their ownership by these companies and select their locations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Company_ID from table 'company' where Market_Value > 100. In the second step, we need to filter Station_ID and Location from table 'gas_station' based on the ownership by the selected companies.\n\n<3> SQL Generation: Use 'where' to find the companies with a market value greater than 100, and then use 'where' to filter gas stations owned by these companies and select their locations.\n\nSQL query: SELECT T3.location FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.market_value  >  100",
        "predict": "SELECT T3.location FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.market_value  >  100",
        "hardness": "hard"
    },
    {
        "db_id": "party_people",
        "gold": "SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "question": "Show names of parties that does not have any members.",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding parties that do not have any members. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select party_name from table 'party' and filter parties that do not have any members.\n\n<3> SQL Generation: Use 'where' and 'not exists' to filter parties that do not have any members.\n\nSQL query: SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "predict": "SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Control_Systems",
        "gold": "SELECT Ref_Document_Status.document_status_description FROM Ref_Document_Status JOIN Documents ON Documents.document_status_code = Ref_Document_Status.document_status_code WHERE Documents.document_id = 1;",
        "question": "What is the document status description of the document with id 1?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Circulation_History, columns = [*,document_id,draft_number,copy_number,employee_id]\nTable Document_Drafts, columns = [*,document_id,draft_number,draft_details]\nTable Documents, columns = [*,document_id,document_status_code,document_type_code,shipping_agent_code,receipt_date,receipt_number,other_details]\nTable Documents_Mailed, columns = [*,document_id,mailed_to_address_id,mailing_date]\nTable Draft_Copies, columns = [*,document_id,draft_number,copy_number]\nTable Employees, columns = [*,employee_id,role_code,employee_name,other_details]\nTable Ref_Document_Status, columns = [*,document_status_code,document_status_description]\nTable Ref_Document_Types, columns = [*,document_type_code,document_type_description]\nTable Ref_Shipping_Agents, columns = [*,shipping_agent_code,shipping_agent_name,shipping_agent_description]\nTable Roles, columns = [*,role_code,role_description]\n",
        "foreign_keys": "Foreign_keys = [Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code,Documents.document_status_code = Ref_Document_Status.document_status_code,Documents.document_type_code = Ref_Document_Types.document_type_code,Employees.role_code = Roles.role_code,Document_Drafts.document_id = Documents.document_id,Draft_Copies.document_id = Document_Drafts.document_id,Draft_Copies.draft_number = Document_Drafts.draft_number,Circulation_History.employee_id = Employees.employee_id,Circulation_History.document_id = Draft_Copies.document_id,Circulation_History.draft_number = Draft_Copies.draft_number,Circulation_History.copy_number = Draft_Copies.copy_number,Documents_Mailed.mailed_to_address_id = Addresses.address_id,Documents_Mailed.document_id = Documents.document_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the document status description of the document with id 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the document status description from the 'Ref_Document_Status' table based on the document id.\n\n<3> SQL Generation: Use 'where' to filter the document with id 1 and select the document status description.\n\nSQL query: SELECT Ref_Document_Status.document_status_description FROM Ref_Document_Status JOIN Documents ON Documents.document_status_code = Ref_Document_Status.document_status_code WHERE Documents.document_id = 1;",
        "predict": "SELECT Ref_Document_Status.document_status_description FROM Ref_Document_Status JOIN Documents ON Documents.document_status_code = Ref_Document_Status.document_status_code WHERE Documents.document_id = 1;",
        "hardness": "medium"
    },
    {
        "db_id": "company_1",
        "gold": "SELECT count(*) FROM dependent WHERE sex  =  'F'",
        "question": "how many female dependents are there?",
        "fields": "Table department, columns = [*,Dname,Dnumber,Mgr_ssn,Mgr_start_date]\nTable dependent, columns = [*,Essn,Dependent_name,Sex,Bdate,Relationship]\nTable dept_locations, columns = [*,Dnumber,Dlocation]\nTable employee, columns = [*,Fname,Minit,Lname,Ssn,Bdate,Address,Sex,Salary,Super_ssn,Dno]\nTable project, columns = [*,Pname,Pnumber,Plocation,Dnum]\nTable works_on, columns = [*,Essn,Pno,Hours]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of female dependents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is about dependents, we need the 'dependent' table.\n\n<3> SQL Generation: Use 'where' to filter dependents by sex and count the number of rows.\n\nSQL query: SELECT count(*) FROM dependent WHERE sex  =  'F'",
        "predict": "SELECT count(*) FROM dependent WHERE sex  =  'F'",
        "hardness": "easy"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT count(*) FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid WHERE T2.name = \"Australian Grand Prix\" AND YEAR = 2009",
        "question": "How many drivers were in the Australian Grand Prix held in 2009?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the raceId of the Australian Grand Prix held in 2009. Secondly, we need to count the number of drivers in that race.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select raceId from table 'races' where name = 'Australian Grand Prix' and year = 2009. In the second step, we need to count the distinct driverId from table 'results' where raceId matches the raceId found in the first step.\n\n<3> SQL Generation: Use 'where' to find the raceId of the Australian Grand Prix held in 2009, and then use 'count(distinct)' to count the number of drivers in that race.\n\nSQL query: SELECT count(*) FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid WHERE T2.name = \"Australian Grand Prix\" AND YEAR = 2009",
        "predict": "SELECT count(*) FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid WHERE T2.name = \"Australian Grand Prix\" AND YEAR = 2009",
        "hardness": "medium"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011",
        "question": "What are the names of races held between 2009 and 2011?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter races based on their years, selecting races held between 2009 and 2011. Secondly, we need to retrieve the names of the selected races.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'races' table and its 'name' column.\n\n<3> SQL Generation: Use 'where' to filter races based on their years, and then select the names of the selected races.\n\nSQL query: SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011",
        "predict": "SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011",
        "hardness": "easy"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT name FROM races WHERE TIME > \"12:00:00\" OR TIME < \"09:00:00\"",
        "question": "What are the names of all races that occurred after 12:00:00 or before 09:00:00?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on races that occurred after 12:00:00 or before 09:00:00. Firstly, we need to identify the races that occurred after 12:00:00. Secondly, we need to identify the races that occurred before 09:00:00. Finally, we need to combine the results from the two steps.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'races' table and the 'time' column.\n\n<3> SQL Generation: Use 'where' to filter races that occurred after 12:00:00 or before 09:00:00.\n\nSQL query: SELECT name FROM races WHERE TIME > \"12:00:00\" OR TIME < \"09:00:00\"",
        "predict": "SELECT name FROM races WHERE TIME > \"12:00:00\" OR TIME < \"09:00:00\"",
        "hardness": "medium"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the race with the name 'Monaco Grand Prix' in the year 2008. Secondly, we need to find the maximum fastest lap speed in that race.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select raceId from table 'races' where name = 'Monaco Grand Prix' and year = 2008. In the second step, we need to select the maximum fastest lap speed from table 'results' where raceId matches the raceId found in the first step.\n\n<3> SQL Generation: Use 'where' to find the race with the name 'Monaco Grand Prix' in the year 2008, and then use 'where' and 'max' to find the maximum fastest lap speed in that race.\n\nSQL query: SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "predict": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "hardness": "medium"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter races based on the race name 'Monaco Grand Prix' and the year '2008'. Secondly, we need to find the maximum fastest lap speed in the selected race.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select raceId from table 'races' where name = 'Monaco Grand Prix' and year = 2008. In the second step, we need to select the maximum fastest lap speed from table 'results' where raceId matches the selected raceId.\n\n<3> SQL Generation: Use 'where' to filter races based on the race name 'Monaco Grand Prix' and the year '2008', and then use 'where' and 'max' to find the maximum fastest lap speed in the selected race.\n\nSQL query: SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "predict": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "hardness": "medium"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "question": "List the name of technicians whose team is not \"NYY\".",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the 'team' column in the 'technician' table. We need to select the names of technicians whose team is not \"NYY\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'technician' table and its 'name' and 'team' columns, we can directly use this table.\n\n<3> SQL Generation: Use 'where' to filter technicians whose team is not \"NYY\" and select their names.\n\nSQL query: SELECT Name FROM technician WHERE Team != \"NYY\"",
        "predict": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "hardness": "easy"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "question": "What is the name of the technician whose team is not 'NYY'?",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the team of the technician. We need to find the technician whose team is not 'NYY' and retrieve their name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the technician's name and team, we can directly use the 'technician' table.\n\n<3> SQL Generation: Use 'where' to filter technicians whose team is not 'NYY' and select their names.\n\nSQL query: SELECT Name FROM technician WHERE Team != \"NYY\"",
        "predict": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "hardness": "easy"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment)",
        "question": "List the names of technicians who have not been assigned to repair machines.",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding technicians who have not been assigned to repair machines. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find technicians who have not been assigned to repair machines, we need to select the names of technicians from the 'technician' table.\n\n<3> SQL Generation: We can use a left join to combine the 'technician' table with the 'repair_assignment' table on the 'technician_id' column. Then, we can filter the rows where the 'Machine_ID' is null, indicating that the technician has not been assigned to repair machines.\n\nSQL query: SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment)",
        "predict": "SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment)",
        "hardness": "hard"
    },
    {
        "db_id": "entrepreneur",
        "gold": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)",
        "question": "What are the names of people who are not entrepreneurs?",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding people who are not entrepreneurs. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find people who are not entrepreneurs, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter out people who are entrepreneurs.\n\nSQL query: SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)",
        "predict": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)",
        "hardness": "hard"
    },
    {
        "db_id": "perpetrator",
        "gold": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)",
        "question": "List the names of people that are not perpetrators.",
        "fields": "Table people, columns = [*,People_ID,Name,Height,Weight,Home Town]\nTable perpetrator, columns = [*,Perpetrator_ID,People_ID,Date,Year,Location,Country,Killed,Injured]\n",
        "foreign_keys": "Foreign_keys = [perpetrator.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on people who are not perpetrators. We need to select the names of those people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter out the perpetrators and select their names.\n\nSQL query: SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)",
        "predict": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)",
        "hardness": "hard"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "question": "What campuses are located in the county of Los Angeles?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires finding campuses located in the county of Los Angeles. Firstly, we need to identify the campuses with the county name 'Los Angeles'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Id' column from the 'Campuses' table where the 'County' column is 'Los Angeles'.\n\n<3> SQL Generation: Use 'where' to filter campuses with the county name 'Los Angeles'.\n\nSQL query: SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "predict": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "hardness": "easy"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE YEAR  >=  1935 AND YEAR  <=  1939",
        "question": "Which campus was opened between 1935 and 1939?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires finding campuses that were opened between 1935 and 1939. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information about the campuses, we only need the 'Campuses' table.\n\n<3> SQL Generation: Use 'where' to filter campuses that were opened between 1935 and 1939.\n\nSQL query: SELECT campus FROM campuses WHERE YEAR  >=  1935 AND YEAR  <=  1939",
        "predict": "SELECT campus FROM campuses WHERE YEAR  >=  1935 AND YEAR  <=  1939",
        "hardness": "medium"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "question": "Find the count of universities whose campus fee is greater than the average campus fee.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average campus fee. Secondly, we need to count the number of universities whose campus fee is greater than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Campus' and 'CampusFee' columns from the 'csu_fees' table, we only need this table.\n\n<3> SQL Generation: Use 'select' and 'avg' to calculate the average campus fee, and then use 'where' to filter universities whose campus fee is greater than the average. Finally, use 'count' to count the number of universities.\n\nSQL query: SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "predict": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "hardness": "hard"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "question": "How many universities have a campus fee higher than average?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average campus fee. Secondly, we need to count the number of universities with a campus fee higher than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'csu_fees' table to calculate the average campus fee and count the number of universities.\n\n<3> SQL Generation: Use 'avg' to calculate the average campus fee, and then use 'where' to filter universities with a campus fee higher than the average. Finally, use 'count' to count the number of universities.\n\nSQL query: SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "predict": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "hardness": "hard"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "question": "Find the count of universities whose campus fee is greater than the average campus fee.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average campus fee. Secondly, we need to count the number of universities whose campus fee is greater than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Campus' and 'CampusFee' columns from the 'csu_fees' table, we only need this table.\n\n<3> SQL Generation: Use 'select avg' to calculate the average campus fee, and then use 'where' to filter universities whose campus fee is greater than the average. Finally, use 'count' to count the number of universities.\n\nSQL query: SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "predict": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "hardness": "hard"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM campuses WHERE county  =  \"Los Angeles\"",
        "question": "How many campuses are there in Los Angeles county?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of campuses in Los Angeles county.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the campuses from the 'Campuses' table where the county is 'Los Angeles'.\n\n<3> SQL Generation: Use 'where' to filter the campuses in Los Angeles county and count them.\n\nSQL query: SELECT count(*) FROM campuses WHERE county  =  \"Los Angeles\"",
        "predict": "SELECT count(*) FROM campuses WHERE county  =  \"Los Angeles\"",
        "hardness": "easy"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "question": "List the campuses in Los Angeles county.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on campuses in Los Angeles county. We need to select the campuses located in Los Angeles county.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Campus' column from the 'Campuses' table and filter by 'County' column where it is equal to 'Los Angeles'.\n\n<3> SQL Generation: Use 'where' to filter campuses in Los Angeles county.\n\nSQL query: SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "predict": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "hardness": "easy"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  \"San Francisco State University\" AND t2.year  =  2001",
        "question": "What are the degrees conferred in \"San Francisco State University\" in 2001.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the campus ID for \"San Francisco State University\". Secondly, we need to filter the degrees based on the campus ID and the year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the ID from the \"Campuses\" table where the campus name is \"San Francisco State University\". In the second step, we need to filter the degrees based on the campus ID and the year.\n\n<3> SQL Generation: Use 'where' to find the campus ID for \"San Francisco State University\", and then use 'where' to filter the degrees based on the campus ID and the year.\n\nSQL query: SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  \"San Francisco State University\" AND t2.year  =  2001",
        "predict": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  \"San Francisco State University\" AND t2.year  =  2001",
        "hardness": "medium"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004",
        "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter campuses based on the number of faculty lines. Secondly, we need to filter campuses based on the year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Campus from table 'faculty' and filter by the number of faculty lines. We also need to filter campuses based on the year from table 'Campuses'.\n\n<3> SQL Generation: Use 'where' to filter campuses based on the number of faculty lines and the year.\n\nSQL query: SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004",
        "predict": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004",
        "hardness": "medium"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT t1.campusfee FROM csu_fees AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t2.campus  =  \"San Francisco State University\" AND t1.year  =  2000",
        "question": "What is the campus fee of \"San Francisco State University\" in year 2000?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the campus ID of \"San Francisco State University\". Secondly, we need to filter the campus fee based on the campus ID and year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the ID from the \"Campuses\" table where the campus name is \"San Francisco State University\". In the second step, we need to select the campus fee from the \"csu_fees\" table based on the campus ID and year.\n\n<3> SQL Generation: Use 'where' to find the campus ID of \"San Francisco State University\", and then use 'where' to filter the campus fee based on the campus ID and year.\n\nSQL query: SELECT t1.campusfee FROM csu_fees AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t2.campus  =  \"San Francisco State University\" AND t1.year  =  2000",
        "predict": "SELECT t1.campusfee FROM csu_fees AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t2.campus  =  \"San Francisco State University\" AND t1.year  =  2000",
        "hardness": "medium"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT name FROM people WHERE height  >  200 OR height  <  190",
        "question": "find the names of people who are taller than 200 or lower than 190.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on people's height, so we should apply the 'where' condition to the 'Height' column and then return the names of selected people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'people' table to filter on height and retrieve names, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter people based on their height and select their names.\n\nSQL query: SELECT name FROM people WHERE height  >  200 OR height  <  190",
        "predict": "SELECT name FROM people WHERE height  >  200 OR height  <  190",
        "hardness": "medium"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "question": "what are the names of people who did not participate in the candidate election.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding the names of people who did not participate in the candidate election. Firstly, we need to identify the people who participated in the candidate election. Secondly, we need to filter out the names of people who did not participate.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'people' table to retrieve the names of people.\n\n<3> SQL Generation: Use 'not in' to filter out the people who participated in the candidate election and select their names.\n\nSQL query: SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "predict": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "hardness": "hard"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "question": "Give the names of people who did not participate in the candidate election.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding people who did not participate in the candidate election. Firstly, we need to identify the people who participated in the candidate election. Secondly, we need to select the names of people who did not participate.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select People_ID from table 'candidate'. In the second step, we need to select Name from table 'people' and filter by People_ID.\n\n<3> SQL Generation: Use 'where' to find the People_ID of people who participated in the candidate election, and then use 'not in' to select the names of people who did not participate.\n\nSQL query: SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "predict": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "question": "How many movies were made before 2000?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on movies made before 2000. We need to select movies based on their year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' table and the 'year' column.\n\n<3> SQL Generation: Use 'where' to filter movies made before 2000 and count them.\n\nSQL query: SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "predict": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "hardness": "easy"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "question": "How many movies were made before 2000?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on movies made before 2000. We need to select movies based on their year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' table and the 'year' column.\n\n<3> SQL Generation: Use 'where' to filter movies made before 2000 and count them.\n\nSQL query: SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "predict": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "hardness": "easy"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT count(*) FROM Rating WHERE stars  >  3",
        "question": "What is the total number of ratings that has more than 3 stars?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on ratings with more than 3 stars. We need to count the number of ratings that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rating' table for this query.\n\n<3> SQL Generation: Use 'where' to filter ratings with more than 3 stars, and then use 'count' to calculate the total number of ratings that meet this condition.\n\nSQL query: SELECT count(*) FROM Rating WHERE stars  >  3",
        "predict": "SELECT count(*) FROM Rating WHERE stars  >  3",
        "hardness": "easy"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT YEAR FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  >=  4 ORDER BY T1.year",
        "question": "In what years did a movie receive a 4 or 5 star rating, and list the years from oldest to most recently?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter movies that received a 4 or 5 star rating. Secondly, we need to list the years of these movies from oldest to most recently.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the year from table 'Movie' and filter by movies that have a 4 or 5 star rating in table 'Rating'.\n\n<3> SQL Generation: Use 'where' to filter movies that received a 4 or 5 star rating, and then use 'order by' to list the years from oldest to most recently.\n\nSQL query: SELECT DISTINCT YEAR FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  >=  4 ORDER BY T1.year",
        "predict": "SELECT DISTINCT YEAR FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  >=  4 ORDER BY T1.year",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT avg(T1.stars) ,  T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.year  =  (SELECT min(YEAR) FROM Movie)",
        "question": "For the oldest movie listed, what is its average rating and title?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the oldest movie listed. Secondly, we need to calculate the average rating for that movie. Finally, we need to retrieve the title of the movie.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the minimum year from the 'Movie' table and then join it with the 'Rating' table on the 'mID' column to calculate the average rating. We also need to retrieve the title from the 'Movie' table.\n\n<3> SQL Generation: Use 'where' to find the minimum year from the 'Movie' table. Then, join the 'Movie' and 'Rating' tables on the 'mID' column. Calculate the average rating using 'avg' and retrieve the title from the 'Movie' table.\n\nSQL query: SELECT avg(T1.stars) ,  T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.year  =  (SELECT min(YEAR) FROM Movie)",
        "predict": "SELECT avg(T1.stars) ,  T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.year  =  (SELECT min(YEAR) FROM Movie)",
        "hardness": "extra"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Sarah Martinez'",
        "question": "Find the names of all directors whose movies are rated by Sarah Martinez.",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the movies that are rated by Sarah Martinez. Secondly, we need to find the directors of those movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select mID from table 'Rating' where rID = (select rID from Reviewer where name = 'Sarah Martinez'). In the second step, we need to select director from table 'Movie' where mID is in the result of the first step.\n\n<3> SQL Generation: Use 'where' to find the rID of Sarah Martinez, and then use 'where' and 'in' to filter movies rated by her and select the directors.\n\nSQL query: SELECT DISTINCT T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Sarah Martinez'",
        "predict": "SELECT DISTINCT T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Sarah Martinez'",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT T3.name ,  T2.title ,  T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.director  =  T3.name",
        "question": "What are the different reviewer names, movie titles, and stars for every rating where the reviewer had the same name as the director?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the ratings where the reviewer had the same name as the director. Secondly, we need to retrieve the reviewer names, movie titles, and stars for those ratings.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the tables 'Rating', 'Reviewer', and 'Movie' on the corresponding foreign keys.\n\n<3> SQL Generation: Use 'join' to combine the tables based on the foreign key relationships. Then, use 'where' to filter the rows where the reviewer name is the same as the director's name. Finally, select the reviewer name, movie title, and stars from the resulting rows.\n\nSQL query: SELECT DISTINCT T3.name ,  T2.title ,  T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.director  =  T3.name",
        "predict": "SELECT DISTINCT T3.name ,  T2.title ,  T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.director  =  T3.name",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5",
        "question": "What are the titles of all movies that have between 3 and 5 stars?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on movies with a rating between 3 and 5 stars. We need to select the titles of these movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' and 'Rating' tables.\n\n<3> SQL Generation: We need to join the 'Movie' and 'Rating' tables on the 'mID' column. Then, we filter the rows where the 'stars' column is between 3 and 5. Finally, we select the 'title' column from the 'Movie' table.\n\nSQL query: SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5",
        "predict": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5",
        "hardness": "medium"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT title FROM Movie WHERE director  =  \"James Cameron\" OR YEAR   <  1980",
        "question": "What are the names of all movies made before 1980 or had James Cameron as the director?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter movies made before 1980. Secondly, we need to filter movies with James Cameron as the director. Finally, we need to select the names of the movies that meet either of these conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' table for this query.\n\n<3> SQL Generation: Use 'where' to filter movies made before 1980 or with James Cameron as the director, and then select the names of the movies.\n\nSQL query: SELECT title FROM Movie WHERE director  =  \"James Cameron\" OR YEAR   <  1980",
        "predict": "SELECT title FROM Movie WHERE director  =  \"James Cameron\" OR YEAR   <  1980",
        "hardness": "medium"
    },
    {
        "db_id": "county_public_safety",
        "gold": "SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population  >  20000)",
        "question": "Show the number of cities in counties that have a population more than 20000.",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on counties with a population more than 20000. Firstly, we need to identify the counties with a population more than 20000. Secondly, we need to count the number of cities in those counties.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select County_ID from table 'county_public_safety' where Population > 20000. In the second step, we need to count the number of cities from table 'city' where County_ID is in the selected County_IDs.\n\n<3> SQL Generation: Use 'where' to filter counties with a population more than 20000, and then use 'where' and 'count' to count the number of cities in those counties.\n\nSQL query: SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population  >  20000)",
        "predict": "SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population  >  20000)",
        "hardness": "hard"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT roomName FROM Rooms WHERE basePrice  <  160 AND beds =  2 AND decor  =  'modern';",
        "question": "What are the names of modern rooms that have a base price lower than $160 and two beds.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter rooms based on their decor, base price, and number of beds. Secondly, we need to select the names of the filtered rooms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rooms' table for this query.\n\n<3> SQL Generation: Use 'where' to filter rooms with decor = 'modern', base price < $160, and beds = 2. Then, select the room names.\n\nSQL query: SELECT roomName FROM Rooms WHERE basePrice  <  160 AND beds =  2 AND decor  =  'modern';",
        "predict": "SELECT roomName FROM Rooms WHERE basePrice  <  160 AND beds =  2 AND decor  =  'modern';",
        "hardness": "medium"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT roomName ,  RoomId FROM Rooms WHERE basePrice  >  160 AND maxOccupancy  >  2;",
        "question": "Find all the rooms that have a price higher than 160 and can accommodate more than 2 people. Report room names and ids.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter rooms based on their price being higher than 160 and their maximum occupancy being more than 2. Secondly, we need to select the room names and ids of the filtered rooms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rooms' table for this query.\n\n<3> SQL Generation: Use 'where' to filter rooms based on their price and maximum occupancy, and then select the room names and ids.\n\nSQL query: SELECT roomName ,  RoomId FROM Rooms WHERE basePrice  >  160 AND maxOccupancy  >  2;",
        "predict": "SELECT roomName ,  RoomId FROM Rooms WHERE basePrice  >  160 AND maxOccupancy  >  2;",
        "hardness": "medium"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT Adults FROM Reservations WHERE CheckIn  =  \"2010-10-23\" AND FirstName  =  \"CONRAD\" AND LastName  =  \"SELBIG\";",
        "question": "Find the number of adults for the room reserved and checked in by CONRAD SELBIG on Oct 23, 2010.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the reservation made by CONRAD SELBIG on Oct 23, 2010. Secondly, we need to retrieve the room reserved and checked in by CONRAD SELBIG. Finally, we need to find the number of adults for that room.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the reservation code from table 'Reservations' where LastName = 'SELBIG', FirstName = 'CONRAD', and CheckIn = '2010-10-23'. In the second step, we need to retrieve the room number from table 'Reservations' based on the reservation code. In the final step, we need to find the number of adults for that room from table 'Reservations'.\n\n<3> SQL Generation: Use 'where' to find the reservation made by CONRAD SELBIG on Oct 23, 2010. Then, retrieve the room number reserved and checked in by CONRAD SELBIG. Finally, find the number of adults for that room.\n\nSQL query: SELECT Adults FROM Reservations WHERE CheckIn  =  \"2010-10-23\" AND FirstName  =  \"CONRAD\" AND LastName  =  \"SELBIG\";",
        "predict": "SELECT Adults FROM Reservations WHERE CheckIn  =  \"2010-10-23\" AND FirstName  =  \"CONRAD\" AND LastName  =  \"SELBIG\";",
        "hardness": "medium"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;",
        "question": "List how many times the number of people in the room reached the maximum occupancy of the room. The number of people include adults and kids.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the total number of people (adults + kids) in each reservation. Secondly, we need to count the number of times the total number of people reached the maximum occupancy of the room.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Room' column from the 'Reservations' table and the 'maxOccupancy' column from the 'Rooms' table.\n\n<3> SQL Generation: We need to join the 'Reservations' and 'Rooms' tables on the 'Room' column. Then, we calculate the total number of people (adults + kids) in each reservation by summing the 'Adults' and 'Kids' columns. Finally, we count the number of times the total number of people reached the maximum occupancy of the room.\n\nSQL query: SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;",
        "predict": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;",
        "hardness": "medium"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT count(*) FROM rooms WHERE roomid NOT IN (SELECT DISTINCT room FROM reservations)",
        "question": "Find the number of rooms that do not have any reservation.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: We need to find the rooms that do not have any reservation.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rooms' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Rooms' table with the 'Reservations' table, and then filter the rows where the reservation code is null (indicating no reservation). Finally, we count the number of rooms that meet this condition.\n\nSQL query: SELECT count(*) FROM rooms WHERE roomid NOT IN (SELECT DISTINCT room FROM reservations)",
        "predict": "SELECT count(*) FROM rooms WHERE roomid NOT IN (SELECT DISTINCT room FROM reservations)",
        "hardness": "extra"
    },
    {
        "db_id": "party_host",
        "gold": "SELECT Name FROM HOST WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host)",
        "question": "List the names of hosts who did not serve as a host of any party in our record.",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding hosts who did not serve as a host of any party in the record. Firstly, we need to identify the hosts who served as hosts in the record. Secondly, we need to filter out the hosts who did not serve as hosts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Host_ID from table 'party_host' and filter by Host_ID in table 'host'.\n\n<3> SQL Generation: Use 'where' to select Host_ID from table 'party_host' and then use 'not in' to filter out the hosts who served as hosts.\n\nSQL query: SELECT Name FROM HOST WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host)",
        "predict": "SELECT Name FROM HOST WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host)",
        "hardness": "hard"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT avg(damage_millions_USD) ,  max(damage_millions_USD) FROM storm WHERE max_speed  >  1000",
        "question": "What is the average and maximum damage in millions for storms that had a max speed over 1000?",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter storms based on their maximum speed being over 1000. Secondly, we need to calculate the average and maximum damage in millions for the selected storms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'storm' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter storms with a maximum speed over 1000, and then use 'avg' and 'max' to calculate the average and maximum damage in millions for the selected storms.\n\nSQL query: SELECT avg(damage_millions_USD) ,  max(damage_millions_USD) FROM storm WHERE max_speed  >  1000",
        "predict": "SELECT avg(damage_millions_USD) ,  max(damage_millions_USD) FROM storm WHERE max_speed  >  1000",
        "hardness": "medium"
    },
    {
        "db_id": "election",
        "gold": "SELECT count(DISTINCT T2.Delegate) FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District WHERE T1.Population  >  50000",
        "question": "How many distinct delegates are from counties with population larger than 50000?",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter counties with population larger than 50000. Secondly, we need to count the distinct delegates from these counties.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select County_Id from table 'county' where Population > 50000. In the second step, we need to filter Counties_Represented from table 'election' and count the distinct delegates.\n\n<3> SQL Generation: Use 'where' to filter counties with population larger than 50000, and then use 'count(distinct)' to count the distinct delegates from these counties.\n\nSQL query: SELECT count(DISTINCT T2.Delegate) FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District WHERE T1.Population  >  50000",
        "predict": "SELECT count(DISTINCT T2.Delegate) FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District WHERE T1.Population  >  50000",
        "hardness": "medium"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major = 600;",
        "question": "Which student's age is older than 18 and is majoring in 600? List each student's first and last name.",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their age and major. Secondly, we need to select the first and last name of the selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table for this query.\n\n<3> SQL Generation: Use 'where' to filter students based on their age and major, and then select the first and last name of the selected students.\n\nSQL query: SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major = 600;",
        "predict": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major = 600;",
        "hardness": "medium"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major != 600 AND Sex = 'F';",
        "question": "List all female students age is older than 18 who is not majoring in 600. List students' first name and last name.",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their gender, age, and major. Secondly, we need to select the first name and last name of the filtered students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select LName and Fname from table 'Student' and filter by Sex, Age, and Major.\n\n<3> SQL Generation: Use 'where' to filter students based on their gender, age, and major, and then select their first name and last name.\n\nSQL query: SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major != 600 AND Sex = 'F';",
        "predict": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major != 600 AND Sex = 'F';",
        "hardness": "medium"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT count(*) FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "question": "How many times has the student Linda Smith visited Subway?",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name 'Linda Smith'. Secondly, we need to find the restaurant with the name 'Subway'. Finally, we need to count the number of times Linda Smith has visited Subway.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to select ResID from table 'Restaurant' where ResName = 'Subway'. In the final step, we need to count the number of rows in table 'Visits_Restaurant' where StuID matches Linda Smith's StuID and ResID matches Subway's ResID.\n\n<3> SQL Generation: Use 'where' to find the StuID of Linda Smith and the ResID of Subway, and then use 'where' to filter rows in 'Visits_Restaurant' where StuID matches Linda Smith's StuID and ResID matches Subway's ResID. Finally, count the number of rows that meet these conditions.\n\nSQL query: SELECT count(*) FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "predict": "SELECT count(*) FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "hardness": "hard"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT TIME FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "question": "When did Linda Smith visit Subway?",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the StuID of Linda Smith from table 'Student'. Secondly, we need to find the Time when Linda Smith visited Subway from table 'Visits_Restaurant'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to select Time from table 'Visits_Restaurant' where StuID is the StuID found in the first step and ResID is the ResID of Subway.\n\n<3> SQL Generation: Use 'where' to find the StuID of Linda Smith from table 'Student', and then use 'where' to find the Time when Linda Smith visited Subway from table 'Visits_Restaurant'.\n\nSQL query: SELECT TIME FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "predict": "SELECT TIME FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "hardness": "hard"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT DISTINCT t3.name FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t1.fname  =  \"Matthias\" AND t1.lname  =  \"Blume\"",
        "question": "What is the name of the institution that \"Matthias Blume\" belongs to?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the authID of \"Matthias Blume\" in table 'Authors'. Secondly, we need to find the instID associated with the authID in table 'Authorship'. Finally, we need to find the name of the institution associated with the instID in table 'Inst'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select authID from table 'Authors' where lname = 'Blume' and fname = 'Matthias'. In the second step, we need to select instID from table 'Authorship' where authID matches the value found in the first step. In the final step, we need to select name from table 'Inst' where instID matches the value found in the second step.\n\n<3> SQL Generation: Use 'where' to find the authID of \"Matthias Blume\" in table 'Authors', then use 'where' to find the instID associated with the authID in table 'Authorship', and finally use 'where' to find the name of the institution associated with the instID in table 'Inst'.\n\nSQL query: SELECT DISTINCT t3.name FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t1.fname  =  \"Matthias\" AND t1.lname  =  \"Blume\"",
        "predict": "SELECT DISTINCT t3.name FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t1.fname  =  \"Matthias\" AND t1.lname  =  \"Blume\"",
        "hardness": "hard"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT count(DISTINCT t1.title) FROM papers AS t1 JOIN authorship AS t2 ON t1.paperid  =  t2.paperid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"University of Pennsylvania\"",
        "question": "How many papers are written by authors from the institution \"University of Pennsylvania\"?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the institution with the name \"University of Pennsylvania\". Secondly, we need to filter authorship records based on the institution and count the number of papers written by those authors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select instID from table 'Inst' where name = \"University of Pennsylvania\". In the second step, we need to filter authID from table 'Authorship' based on the instID found in the first step and count the number of distinct paperIDs.\n\n<3> SQL Generation: Use 'where' to find the institution with the name \"University of Pennsylvania\", and then use 'where' to filter authorship records based on the institution and count the number of distinct paperIDs.\n\nSQL query: SELECT count(DISTINCT t1.title) FROM papers AS t1 JOIN authorship AS t2 ON t1.paperid  =  t2.paperid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"University of Pennsylvania\"",
        "predict": "SELECT count(DISTINCT t1.title) FROM papers AS t1 JOIN authorship AS t2 ON t1.paperid  =  t2.paperid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"University of Pennsylvania\"",
        "hardness": "hard"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid JOIN inst AS t4 ON t2.instid  =  t4.instid WHERE t4.country  =  \"USA\" AND t2.authorder  =  2 AND t1.lname  =  \"Turon\"",
        "question": "Which paper is published in an institution in \"USA\" and have \"Turon\" as its second author?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the institution with the country \"USA\". Secondly, we need to find the paper with \"Turon\" as its second author.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select instID from table 'Inst' where country = \"USA\". In the second step, we need to find the paperID from table 'Authorship' where authOrder = 2 and authID corresponds to \"Turon\".\n\n<3> SQL Generation: Use 'where' to find the institution with the country \"USA\", and then use 'join' to connect the tables 'Authorship', 'Authors', and 'Papers' based on the foreign key relationships. Finally, use 'where' to filter the rows where authOrder = 2 and the author's name is \"Turon\".\n\nSQL query: SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid JOIN inst AS t4 ON t2.instid  =  t4.instid WHERE t4.country  =  \"USA\" AND t2.authorder  =  2 AND t1.lname  =  \"Turon\"",
        "predict": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid JOIN inst AS t4 ON t2.instid  =  t4.instid WHERE t4.country  =  \"USA\" AND t2.authorder  =  2 AND t1.lname  =  \"Turon\"",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT count(*) FROM customer WHERE active = '1'",
        "question": "How many customers have an active value of 1?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of customers with an active value of 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'customer' table and the 'active' column.\n\n<3> SQL Generation: Use 'where' to filter customers with an active value of 1 and count them.\n\nSQL query: SELECT count(*) FROM customer WHERE active = '1'",
        "predict": "SELECT count(*) FROM customer WHERE active = '1'",
        "hardness": "easy"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name ,  acc_bal FROM customer WHERE cust_name LIKE '%a%'",
        "question": "Find the name and account balance of the customer whose name includes the letter a.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter customers whose name includes the letter 'a'. Secondly, we need to select the name and account balance of the filtered customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'customer' table, we only need to consider this table.\n\n<3> SQL Generation: Use 'where' to filter customers whose name includes the letter 'a', and then select the name and account balance of the filtered customers.\n\nSQL query: SELECT cust_name ,  acc_bal FROM customer WHERE cust_name LIKE '%a%'",
        "predict": "SELECT cust_name ,  acc_bal FROM customer WHERE cust_name LIKE '%a%'",
        "hardness": "medium"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1",
        "question": "What is the name of the customer with the worst credit score?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: We need to find the customer with the worst credit score.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the cust_name from the customer table.\n\n<3> SQL Generation: We can use the MIN function to find the minimum credit score and then select the cust_name of the customer with that score.\n\nSQL query: SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1",
        "predict": "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1",
        "hardness": "medium"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE amount  >  3000",
        "question": "What are the names of customers who have a loan of more than 3000 in amount?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on loans with an amount greater than 3000. We need to identify the customers who have these loans and retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of customers from the 'customer' table who have loans with an amount greater than 3000 from the 'loan' table.\n\n<3> SQL Generation: Use 'where' to filter loans with an amount greater than 3000, join the 'customer' and 'loan' tables on the 'cust_ID' column, and select the names of the customers.\n\nSQL query: SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE amount  >  3000",
        "predict": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE amount  >  3000",
        "hardness": "medium"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "question": "Find the average credit score of the customers who do not have any loan.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customers who do not have any loan. Secondly, we need to calculate the average credit score of those customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select cust_ID from table 'loan' and filter by cust_ID. In the second step, we need to select credit_score from table 'customer' and filter by cust_ID.\n\n<3> SQL Generation: Use 'where' to filter customers who do not have any loan, and then use 'avg' to calculate the average credit score of those customers.\n\nSQL query: SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "predict": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "hardness": "extra"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT count(*) FROM STUDENTS WHERE student_id NOT IN ( SELECT student_id FROM Behavior_Incident )",
        "question": "How many students are not involved in any behavior incident?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who are involved in behavior incidents. Secondly, we need to count the number of students who are not involved in any behavior incident.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from table 'Behavior_Incident'.\n\n<3> SQL Generation: Use 'where' to select student_id from table 'Behavior_Incident', and then use 'not in' to filter students who are not involved in any behavior incident and count them.\n\nSQL query: SELECT count(*) FROM STUDENTS WHERE student_id NOT IN ( SELECT student_id FROM Behavior_Incident )",
        "predict": "SELECT count(*) FROM STUDENTS WHERE student_id NOT IN ( SELECT student_id FROM Behavior_Incident )",
        "hardness": "extra"
    },
    {
        "db_id": "assets_maintenance",
        "gold": "SELECT first_name ,  last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits)",
        "question": "Which engineers have never visited to maintain the assets? List the engineer first name and last name.",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the engineers who have visited to maintain the assets. Secondly, we need to filter out the engineers who have never visited and list their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select engineer_id from table 'Engineer_Visits' and engineer_id from table 'Maintenance_Engineers'.\n\n<3> SQL Generation: Use 'where' to find the engineers who have visited to maintain the assets, and then use 'not in' to filter out the engineers who have never visited. Finally, select their first name and last name.\n\nSQL query: SELECT first_name ,  last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits)",
        "predict": "SELECT first_name ,  last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits)",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  \"ACCT-211\"",
        "question": "How many professors teach a class with the code ACCT-211?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the class with the code ACCT-211. Secondly, we need to find the professors who teach that class and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CLASS_CODE from table 'CLASS' where CRS_CODE = 'ACCT-211'. In the second step, we need to filter PROF_NUM from table 'CLASS'.\n\n<3> SQL Generation: Use 'where' to find the class with the code ACCT-211, and then use 'where' to filter professors who teach that class and count them.\n\nSQL query: SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  \"ACCT-211\"",
        "predict": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  \"ACCT-211\"",
        "hardness": "easy"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'",
        "question": "How many classes does the professor whose last name is Graztevski teach?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the professor with the last name 'Graztevski'. Secondly, we need to count the number of classes taught by this professor.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select EMP_NUM from table 'EMPLOYEE' where EMP_LNAME = 'Graztevski'. In the second step, we need to count CLASS_CODE from table 'CLASS' where PROF_NUM is the value found in the first step.\n\n<3> SQL Generation: Use 'where' to find the professor with the last name 'Graztevski', and then use 'where' to count the number of classes taught by this professor.\n\nSQL query: SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'",
        "predict": "SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'",
        "hardness": "medium"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "question": "How many courses are offered by the Computer Info. Systems department?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the department with the department name 'Computer Info. Systems'. Secondly, we need to count the number of courses offered by that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for courses offered by the 'Computer Info. Systems' department, we need to select courses from the 'COURSE' table where the department code matches the department code of the 'Computer Info. Systems' department.\n\n<3> SQL Generation: Use 'where' to filter the courses with the department code of the 'Computer Info. Systems' department, and then use 'count' to calculate the number of courses.\n\nSQL query: SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "predict": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "hardness": "medium"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "question": "How many courses does the department of Computer Information Systmes offer?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the department code for the department of Computer Information Systems. Secondly, we need to count the number of courses offered by that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select DEPT_CODE from table 'DEPARTMENT' where DEPT_NAME = 'Computer Information Systems'. In the second step, we need to count the number of courses from table 'COURSE' where DEPT_CODE matches the department code found in the first step.\n\n<3> SQL Generation: Use 'where' to find the department code for the department of Computer Information Systems, and then use 'where' to count the number of courses offered by that department.\n\nSQL query: SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "predict": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "hardness": "medium"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.'",
        "question": "How many professors do have a Ph.D. degree?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: We need to filter professors who have a Ph.D. degree.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select professors with a Ph.D. degree from the 'PROFESSOR' table.\n\n<3> SQL Generation: Use 'where' to filter professors with a Ph.D. degree and count them.\n\nSQL query: SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.'",
        "predict": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.'",
        "hardness": "easy"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT stu_fname ,  stu_gpa FROM student WHERE stu_gpa  <  (SELECT avg(stu_gpa) FROM student)",
        "question": "Find the first name and gpa of the students whose gpa is lower than the average gpa of all students.",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average gpa of all students. Secondly, we need to filter students whose gpa is lower than the average gpa and select their first name and gpa.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select gpa from table 'STUDENT' and calculate the average. Then, we need to filter gpa, first name from table 'STUDENT'.\n\n<3> SQL Generation: Use 'select avg(gpa)' to calculate the average gpa of all students. Then, use 'where' to filter students whose gpa is lower than the average gpa and select their first name and gpa.\n\nSQL query: SELECT stu_fname ,  stu_gpa FROM student WHERE stu_gpa  <  (SELECT avg(stu_gpa) FROM student)",
        "predict": "SELECT stu_fname ,  stu_gpa FROM student WHERE stu_gpa  <  (SELECT avg(stu_gpa) FROM student)",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'",
        "question": "Find the name of department that offers the class whose description has the word \"Statistics\".",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the class with the description containing the word \"Statistics\". Secondly, we need to find the department that offers this class.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CRS_CODE from table 'COURSE' where CRS_DESCRIPTION contains the word \"Statistics\". In the second step, we need to select DEPT_NAME from table 'DEPARTMENT' where DEPT_CODE matches the DEPT_CODE of the selected class.\n\n<3> SQL Generation: Use 'where' to find the class with the description containing the word \"Statistics\", and then use 'where' to find the department that offers this class.\n\nSQL query: SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'",
        "predict": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'",
        "hardness": "hard"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != \"null\" OR  department_id != 40",
        "question": "display all the information of employees whose salary is in the range of 8000 and 12000 and commission is not null or department number does not equal to 40.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter employees based on their salary range and commission. Secondly, we need to filter employees based on their department number.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select all columns from table 'employees' and filter based on salary and commission. We also need to filter based on department number from table 'departments'.\n\n<3> SQL Generation: Use 'where' to filter employees based on their salary range and commission, and use 'or' to filter employees based on their department number.\n\nSQL query: SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != \"null\" OR  department_id != 40",
        "predict": "SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != \"null\" OR  department_id != 40",
        "hardness": "medium"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT salary ,  manager_id FROM employees WHERE manager_id != \"null\"",
        "question": "What are the salaries and manager ids for employees who have managers?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: The query requires retrieving salaries and manager ids for employees who have managers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select salaries and manager ids from the 'employees' table.\n\n<3> SQL Generation: Use 'where' to filter employees who have managers and select their salaries and manager ids.\n\nSQL query: SELECT salary ,  manager_id FROM employees WHERE manager_id != \"null\"",
        "predict": "SELECT salary ,  manager_id FROM employees WHERE manager_id != \"null\"",
        "hardness": "medium"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000",
        "question": "What is all the job history info done by employees earning a salary greater than or equal to 12000?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter employees based on their salary being greater than or equal to 12000. Secondly, we need to retrieve the job history information for these employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select job history information from table 'job_history' and filter employees based on their salary from table 'employees'.\n\n<3> SQL Generation: Use 'where' to filter employees with salary greater than or equal to 12000, and then join the 'job_history' table on the 'EMPLOYEE_ID' column to retrieve the job history information for these employees.\n\nSQL query: SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000",
        "predict": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000",
        "hardness": "medium"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)",
        "question": "Find the employee id for all employees who earn more than the average salary.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average salary. Secondly, we need to filter employees based on their salary being higher than the average salary.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'employees' table for this query, we don't need to consider any foreign key relationships.\n\n<3> SQL Generation: Use 'select' to calculate the average salary from the 'employees' table. Then, use 'where' to filter employees whose salary is higher than the average salary.\n\nSQL query: SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)",
        "predict": "SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)",
        "hardness": "hard"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "question": "display all the information of those employees who did not have any job in the past.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find employees who did not have any job in the past. Secondly, we need to display all the information of those employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select employee_id from table 'job_history'. In the second step, we need to select all columns from table 'employees'.\n\n<3> SQL Generation: Use 'not in' to find employees who did not have any job in the past, and then select all columns from table 'employees'.\n\nSQL query: SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "predict": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "hardness": "hard"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "question": "What is all the information about employees who have never had a job in the past?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find employees who have never had a job in the past. Secondly, we need to retrieve all the information about those employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select all columns from table 'employees' and filter by employees who do not have any records in table 'job_history'.\n\n<3> SQL Generation: Use 'where' to filter employees who do not have any records in table 'job_history' and select all columns from table 'employees'.\n\nSQL query: SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "predict": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT DISTINCT T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.resolution  <  800",
        "question": "What are the file sizes and formats for all songs with a resolution lower than 800?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter songs based on their resolution being lower than 800. Secondly, we need to select the file sizes and formats for the filtered songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select file_size and formats from table 'files' for the filtered songs.\n\n<3> SQL Generation: Use 'where' to filter songs with resolution lower than 800, and then select file_size and formats from table 'files' for the filtered songs.\n\nSQL query: SELECT DISTINCT T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.resolution  <  800",
        "predict": "SELECT DISTINCT T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.resolution  <  800",
        "hardness": "medium"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT count(*) FROM artist WHERE country  =  \"Bangladesh\"",
        "question": "How many Bangladeshi artists are listed?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: We need to filter artists based on their country being Bangladesh.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'artist' table.\n\n<3> SQL Generation: Use 'where' to filter artists with country = 'Bangladesh' and count them.\n\nSQL query: SELECT count(*) FROM artist WHERE country  =  \"Bangladesh\"",
        "predict": "SELECT count(*) FROM artist WHERE country  =  \"Bangladesh\"",
        "hardness": "easy"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT g_name ,  rating FROM genre ORDER BY g_name",
        "question": "List the names of all genres in alphabetical oder, together with its ratings.",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: We need to select the names and ratings of all genres.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'genre' table.\n\n<3> SQL Generation: We can directly select the 'g_name' and 'rating' columns from the 'genre' table and order them by 'g_name' in alphabetical order.\n\nSQL query: SELECT g_name ,  rating FROM genre ORDER BY g_name",
        "predict": "SELECT g_name ,  rating FROM genre ORDER BY g_name",
        "hardness": "medium"
    },
    {
        "db_id": "baseball_1",
        "gold": "SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;",
        "question": "Compute the total salary that the player with first name Len and last name Barker received between 1985 to 1990.",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the player with first name Len and last name Barker. Secondly, we need to filter the salary of the player between 1985 to 1990 and compute the total.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select player_id from table 'player' where name_first = 'Len' and name_last = 'Barker'. In the second step, we need to filter salary from table 'salary' where player_id matches the player found in the first step and the year is between 1985 to 1990.\n\n<3> SQL Generation: Use 'where' to find the player with first name Len and last name Barker, and then use 'where' to filter the salary of the player between 1985 to 1990. Finally, compute the total salary.\n\nSQL query: SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;",
        "predict": "SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;",
        "hardness": "medium"
    },
    {
        "db_id": "mountain_photos",
        "gold": "SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos )",
        "question": "How many camera lenses are not used in taking any photos?",
        "fields": "Table camera_lens, columns = [*,id,brand,name,focal_length_mm,max_aperture]\nTable mountain, columns = [*,id,name,Height,Prominence,Range,Country]\nTable photos, columns = [*,id,camera_lens_id,mountain_id,color,name]\n",
        "foreign_keys": "Foreign_keys = [photos.mountain_id = mountain.id,photos.camera_lens_id = camera_lens.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the camera lenses that are not used in taking any photos. Secondly, we need to count the number of camera lenses found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'camera_lens' that do not have a corresponding entry in the 'camera_lens_id' column of table 'photos'. \n\n<3> SQL Generation: Use 'where' and 'not in' to find the camera lenses that are not used in taking any photos, and then use 'count' to count the number of camera lenses found.\n\nSQL query: SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos )",
        "predict": "SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos )",
        "hardness": "extra"
    },
    {
        "db_id": "mountain_photos",
        "gold": "SELECT count(DISTINCT T2.camera_lens_id) FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.country  =  'Ethiopia'",
        "question": "How many distinct kinds of camera lenses are used to take photos of mountains in the country 'Ethiopia'?",
        "fields": "Table camera_lens, columns = [*,id,brand,name,focal_length_mm,max_aperture]\nTable mountain, columns = [*,id,name,Height,Prominence,Range,Country]\nTable photos, columns = [*,id,camera_lens_id,mountain_id,color,name]\n",
        "foreign_keys": "Foreign_keys = [photos.mountain_id = mountain.id,photos.camera_lens_id = camera_lens.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter mountains based on the country 'Ethiopia'. Secondly, we need to find the distinct camera lenses used to take photos of these mountains and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'mountain' where country = 'Ethiopia'. In the second step, we need to join table 'photos' and 'camera_lens' on the 'mountain_id' and 'camera_lens_id' columns, and then select distinct camera_lens_id.\n\n<3> SQL Generation: Use 'where' to filter mountains in Ethiopia, join 'photos' and 'camera_lens' tables on the corresponding columns, select distinct camera_lens_id, and count them.\n\nSQL query: SELECT count(DISTINCT T2.camera_lens_id) FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.country  =  'Ethiopia'",
        "predict": "SELECT count(DISTINCT T2.camera_lens_id) FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.country  =  'Ethiopia'",
        "hardness": "medium"
    },
    {
        "db_id": "program_share",
        "gold": "SELECT name FROM program WHERE origin != 'Beijing'",
        "question": "Which programs' origins are not \"Beijing\"? Give me the program names.",
        "fields": "Table broadcast, columns = [*,Channel_ID,Program_ID,Time_of_day]\nTable broadcast_share, columns = [*,Channel_ID,Program_ID,Date,Share_in_percent]\nTable channel, columns = [*,Channel_ID,Name,Owner,Share_in_percent,Rating_in_percent]\nTable program, columns = [*,Program_ID,Name,Origin,Launch,Owner]\n",
        "foreign_keys": "Foreign_keys = [broadcast.Program_ID = program.Program_ID,broadcast.Channel_ID = channel.Channel_ID,broadcast_share.Program_ID = program.Program_ID,broadcast_share.Channel_ID = channel.Channel_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on programs whose origins are not \"Beijing\". We need to select the program names that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'program' table for this query.\n\n<3> SQL Generation: Use 'where' to filter programs whose origins are not \"Beijing\" and select the program names.\n\nSQL query: SELECT name FROM program WHERE origin != 'Beijing'",
        "predict": "SELECT name FROM program WHERE origin != 'Beijing'",
        "hardness": "easy"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name =  \"Cathrine\"",
        "question": "Return the addresses of the course authors or tutors whose personal name is \"Cathrine\".",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the personal name column in the Course_Authors_and_Tutors table. We need to select the addresses of the course authors or tutors whose personal name is \"Cathrine\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the Course_Authors_and_Tutors table.\n\n<3> SQL Generation: Use 'where' to filter the rows where the personal name is \"Cathrine\" and select the corresponding addresses.\n\nSQL query: SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name =  \"Cathrine\"",
        "predict": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name =  \"Cathrine\"",
        "hardness": "easy"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT count(*) FROM Student_Tests_Taken WHERE test_result  =  \"Fail\"",
        "question": "How many tests have result \"Fail\"?",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of tests with a result of \"Fail\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the test_result column from the Student_Tests_Taken table.\n\n<3> SQL Generation: Use 'where' to filter tests with a result of \"Fail\" and count them.\n\nSQL query: SELECT count(*) FROM Student_Tests_Taken WHERE test_result  =  \"Fail\"",
        "predict": "SELECT count(*) FROM Student_Tests_Taken WHERE test_result  =  \"Fail\"",
        "hardness": "easy"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.login_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  \"advanced database\"",
        "question": "Find the login name of the course author that teaches the course with name \"advanced database\".",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the course_id of the course with name \"advanced database\". Secondly, we need to find the author_id of the course author that teaches this course. Finally, we need to find the login name of the course author.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'Courses' where course_name = \"advanced database\". In the second step, we need to select author_id from table 'Courses' where course_id matches the course_id found in the first step. In the final step, we need to select login_name from table 'Course_Authors_and_Tutors' where author_id matches the author_id found in the second step.\n\n<3> SQL Generation: Use 'where' to find the course_id of the course with name \"advanced database\", and then use 'where' to find the author_id of the course author that teaches this course. Finally, use 'where' to find the login name of the course author.\n\nSQL query: SELECT T1.login_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  \"advanced database\"",
        "predict": "SELECT T1.login_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  \"advanced database\"",
        "hardness": "medium"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)",
        "question": "How many students did not have any course enrollment?",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding students who did not have any course enrollment. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from the 'Students' table and check if there are any corresponding entries in the 'Student_Course_Enrolment' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Students' table with the 'Student_Course_Enrolment' table on the 'student_id' column. Then, we can filter the rows where the 'course_id' is null (indicating no course enrollment) and count the number of students.\n\nSQL query: SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)",
        "predict": "SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)",
        "hardness": "extra"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT DISTINCT T1.name ,  T1.position FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.Brand  =  \"X\"",
        "question": "Which physicians prescribe a medication of brand X? Tell me the name and position of those physicians.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the physicians who prescribe a medication of brand X. Secondly, we need to retrieve the name and position of those physicians.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select physicians from table 'Physician' who prescribe a medication of brand X from table 'Prescribes'. We also need to retrieve the name and position of those physicians.\n\n<3> SQL Generation: Use 'where' to filter physicians who prescribe a medication of brand X, and then select the name and position of those physicians.\n\nSQL query: SELECT DISTINCT T1.name ,  T1.position FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.Brand  =  \"X\"",
        "predict": "SELECT DISTINCT T1.name ,  T1.position FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.Brand  =  \"X\"",
        "hardness": "hard"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1",
        "question": "List the names of departments where some physicians are primarily affiliated with.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the physicians who are primarily affiliated with some departments. Secondly, we need to list the names of those departments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select distinct Department from table 'Affiliated_With' where PrimaryAffiliation is not null. In the second step, we need to select Name from table 'Department' where DepartmentID matches the departments found in the first step.\n\n<3> SQL Generation: Use 'where' to filter the physicians who are primarily affiliated with some departments, and then use 'distinct' to select the departments. Finally, join the 'Department' table to get the names of those departments.\n\nSQL query: SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1",
        "predict": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1",
        "hardness": "medium"
    },
    {
        "db_id": "ship_mission",
        "gold": "SELECT Name FROM ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM mission)",
        "question": "What are the names of the ships that are not involved in any missions?",
        "fields": "Table mission, columns = [*,Mission_ID,Ship_ID,Code,Launched_Year,Location,Speed_knots,Fate]\nTable ship, columns = [*,Ship_ID,Name,Type,Nationality,Tonnage]\n",
        "foreign_keys": "Foreign_keys = [mission.Ship_ID = ship.Ship_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding ships that are not involved in any missions. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find ships that are not involved in any missions, we only need the 'ship' table.\n\n<3> SQL Generation: We can use a 'left join' to join the 'ship' table with the 'mission' table on the 'Ship_ID' column. Then, we can filter the rows where the 'Mission_ID' is null, indicating that the ship is not involved in any missions. Finally, we can select the 'Name' column from the resulting rows.\n\nSQL query: SELECT Name FROM ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM mission)",
        "predict": "SELECT Name FROM ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM mission)",
        "hardness": "hard"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "question": "Which students study under the teacher named OTHA MOYER? Give me the first and last names of the students.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name 'OTHA MOYER'. Secondly, we need to find the students who study under that teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no explicit foreign key relationship mentioned in the given information, we can assume that the 'Classroom' column in both tables can be used to link the tables.\n\n<3> SQL Generation: Use 'where' to find the teacher with the name 'OTHA MOYER', and then use 'where' to filter the students who study under that teacher and select their first and last names.\n\nSQL query: SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "predict": "SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "hardness": "extra"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT T2.firstname ,  T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"EVELINA\" AND T1.lastname  =  \"BROMLEY\"",
        "question": "Find the first and last name of all the teachers that teach EVELINA BROMLEY.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name 'EVELINA BROMLEY'. Secondly, we need to select the first and last name of the teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no foreign key relationship mentioned in the question, we only need the 'teachers' table.\n\n<3> SQL Generation: Use 'where' to filter the teacher with the name 'EVELINA BROMLEY', and then select the first and last name of the teacher.\n\nSQL query: SELECT T2.firstname ,  T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"EVELINA\" AND T1.lastname  =  \"BROMLEY\"",
        "predict": "SELECT T2.firstname ,  T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"EVELINA\" AND T1.lastname  =  \"BROMLEY\"",
        "hardness": "extra"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"LORIA\" AND T2.lastname  =  \"ONDERSMA\"",
        "question": "Count the number of students the teacher LORIA ONDERSMA teaches.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of students taught by a specific teacher. Firstly, we need to identify the teacher with the name \"LORIA ONDERSMA\". Secondly, we need to count the number of students in the teacher's classroom.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the teacher's name is in the 'teachers' table and the classroom information is in the 'list' table, we need to use both tables.\n\n<3> SQL Generation: Use 'where' to filter the teacher with the name \"LORIA ONDERSMA\" in the 'teachers' table. Then, join the 'teachers' and 'list' tables on the 'Classroom' column and count the number of students in the teacher's classroom.\n\nSQL query: SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"LORIA\" AND T2.lastname  =  \"ONDERSMA\"",
        "predict": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"LORIA\" AND T2.lastname  =  \"ONDERSMA\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"KAWA\" AND T2.lastname  =  \"GORDON\"",
        "question": "How many students does KAWA GORDON teaches?",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name \"KAWA GORDON\". Secondly, we need to count the number of students taught by that teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have the 'teachers' table, we need to select the rows where the 'LastName' is \"KAWA\" and the 'FirstName' is \"GORDON\".\n\n<3> SQL Generation: Use 'where' to filter the rows where 'LastName' is \"KAWA\" and 'FirstName' is \"GORDON\", and then count the number of rows.\n\nSQL query: SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"KAWA\" AND T2.lastname  =  \"GORDON\"",
        "predict": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"KAWA\" AND T2.lastname  =  \"GORDON\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"TARRING\" AND T2.lastname  =  \"LEIA\"",
        "question": "Find the number of students taught by TARRING LEIA.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name 'TARRING LEIA'. Secondly, we need to count the number of students taught by that teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the teacher's information from table 'teachers' where the first name is 'LEIA' and the last name is 'TARRING'. In the second step, we need to count the number of students from table 'list' where the classroom matches the classroom of the teacher found in the first step.\n\n<3> SQL Generation: Use 'where' to find the teacher with the name 'TARRING LEIA', and then use 'where' to filter students based on the teacher's classroom and count them.\n\nSQL query: SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"TARRING\" AND T2.lastname  =  \"LEIA\"",
        "predict": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"TARRING\" AND T2.lastname  =  \"LEIA\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "question": "How many teachers does the student named MADLOCK RAY have?",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name \"MADLOCK RAY\". Secondly, we need to count the number of teachers in the same classroom as the student.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no explicit foreign key relationship mentioned in the question, we can assume that the classroom column in both tables can be used to link the student and teacher.\n\n<3> SQL Generation: Use 'where' to find the student with the name \"MADLOCK RAY\", and then use 'where' to filter teachers in the same classroom and count them.\n\nSQL query: SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "predict": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "question": "Find the number of teachers who teach the student called MADLOCK RAY.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name 'MADLOCK RAY'. Secondly, we need to find the teachers who teach this student.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the student with the name 'MADLOCK RAY' from table 'list'. Then, we need to find the teachers who teach this student by matching the classroom.\n\n<3> SQL Generation: Use 'where' to find the student with the name 'MADLOCK RAY' and select the corresponding classroom. Then, use 'where' to find the teachers who teach this student by matching the classroom.\n\nSQL query: SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "predict": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT DISTINCT T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.grade  =  3 AND T2.firstname != \"COVIN\" AND T2.lastname != \"JEROME\"",
        "question": "Find the last names of the students in third grade that are not taught by COVIN JEROME.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students in third grade. Secondly, we need to filter out the students taught by COVIN JEROME. Finally, we need to select the last names of the remaining students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no explicit foreign key relationship mentioned in the question, we only need the 'list' table.\n\n<3> SQL Generation: Use 'where' to filter students in third grade and not taught by COVIN JEROME, and then select their last names.\n\nSQL query: SELECT DISTINCT T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.grade  =  3 AND T2.firstname != \"COVIN\" AND T2.lastname != \"JEROME\"",
        "predict": "SELECT DISTINCT T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.grade  =  3 AND T2.firstname != \"COVIN\" AND T2.lastname != \"JEROME\"",
        "hardness": "medium"
    },
    {
        "db_id": "company_employee",
        "gold": "SELECT count(*) FROM company WHERE Headquarters  =  'USA'",
        "question": "How many companies are headquartered in the US?",
        "fields": "Table company, columns = [*,Company_ID,Name,Headquarters,Industry,Sales_in_Billion,Profits_in_Billion,Assets_in_Billion,Market_Value_in_Billion]\nTable employment, columns = [*,Company_ID,People_ID,Year_working]\nTable people, columns = [*,People_ID,Age,Name,Nationality,Graduation_College]\n",
        "foreign_keys": "Foreign_keys = [employment.People_ID = people.People_ID,employment.Company_ID = company.Company_ID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of companies that are headquartered in the US.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information about the companies, we only need the 'company' table.\n\n<3> SQL Generation: Use 'where' to filter companies that are headquartered in the US, and then use 'count' to calculate the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM company WHERE Headquarters  =  'USA'",
        "predict": "SELECT count(*) FROM company WHERE Headquarters  =  'USA'",
        "hardness": "easy"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT TYPE FROM film_market_estimation WHERE YEAR  =  1995",
        "question": "Return the types of film market estimations in 1995.",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the year 1995, so we should apply the 'where' to column 'Year' and then return the types of film market estimations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'film_market_estimation' has column 'Type', we only need table 'film_market_estimation'.\n\n<3> SQL Generation: Directly write the sql using 'where'.\n\nSQL query: SELECT TYPE FROM film_market_estimation WHERE YEAR  =  1995",
        "predict": "SELECT TYPE FROM film_market_estimation WHERE YEAR  =  1995",
        "hardness": "easy"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000",
        "question": "What is the average number of cities of markets with low film market estimate bigger than 10000?",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter markets with low film market estimate bigger than 10000. Secondly, we need to calculate the average number of cities for these markets.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Market_ID from table 'film_market_estimation' where Low_Estimate > 10000. In the second step, we need to select Number_cities from table 'market' and calculate the average.\n\n<3> SQL Generation: Use 'where' to filter markets with low film market estimate bigger than 10000, and then use 'avg' to calculate the average number of cities.\n\nSQL query: SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000",
        "predict": "SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000",
        "hardness": "medium"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)",
        "question": "What are the titles of films that do not have a film market estimation?",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding films that do not have a film market estimation. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is about films and film market estimations, we need to use the tables 'film' and 'film_market_estimation'.\n\n<3> SQL Generation: We can use a left join to combine the 'film' and 'film_market_estimation' tables, and then filter the rows where the estimation ID is null (indicating that there is no film market estimation). Finally, we select the titles of the films that meet this condition.\n\nSQL query: SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)",
        "predict": "SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "gold": "SELECT count(*) FROM All_documents WHERE document_type_code  =  \"CV\" OR document_type_code  =  \"BK\"",
        "question": "How many documents have document type code CV or BK?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter documents based on their document type code, selecting documents with document type code 'CV' or 'BK'. Secondly, we need to count the number of selected documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter documents based on their document type code, we only need the 'All_Documents' table.\n\n<3> SQL Generation: Use 'where' to filter documents with document type code 'CV' or 'BK', and then use 'count' to count the number of selected documents.\n\nSQL query: SELECT count(*) FROM All_documents WHERE document_type_code  =  \"CV\" OR document_type_code  =  \"BK\"",
        "predict": "SELECT count(*) FROM All_documents WHERE document_type_code  =  \"CV\" OR document_type_code  =  \"BK\"",
        "hardness": "medium"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "question": "Find the number of members of club \"Pen and Paper Gaming\".",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Pen and Paper Gaming\". Secondly, we need to count the number of members in that club.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Pen and Paper Gaming\". In the second step, we need to count the number of rows in table 'Member_of_club' where ClubID matches the ClubID found in the first step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of the club \"Pen and Paper Gaming\", and then use 'count' to count the number of members in that club.\n\nSQL query: SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "question": "How many people have membership in the club \"Pen and Paper Gaming\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Pen and Paper Gaming\". Secondly, we need to count the number of people who have membership in that club.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Pen and Paper Gaming\". In the second step, we need to count the number of rows in table 'Member_of_club' where ClubID matches the ClubID found in the first step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of the club \"Pen and Paper Gaming\", and then use 'count' to count the number of rows in table 'Member_of_club' where ClubID matches the ClubID found in the first step.\n\nSQL query: SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Linda\" AND t3.lname  =  \"Smith\"",
        "question": "How many clubs does \"Linda Smith\" belong to?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the StuID of \"Linda Smith\" in table 'Student'. Secondly, we need to count the number of clubs that Linda Smith belongs to based on her StuID in table 'Member_of_club'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to count the number of rows in table 'Member_of_club' where StuID matches the StuID of Linda Smith.\n\n<3> SQL Generation: Use 'where' to find the StuID of Linda Smith in table 'Student', and then use 'where' to count the number of rows in table 'Member_of_club' where StuID matches the StuID of Linda Smith.\n\nSQL query: SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Linda\" AND t3.lname  =  \"Smith\"",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Linda\" AND t3.lname  =  \"Smith\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.sex  =  \"F\"",
        "question": "Find all the female members of club \"Bootup Baltimore\". Show the first name and last name.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Bootup Baltimore\". Secondly, we need to filter members based on their club and gender. Finally, we need to select the first name and last name of the female members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Bootup Baltimore\". In the second step, we need to filter StuID from table 'Member_of_club' where ClubID matches the value found in the first step. In the final step, we need to select Fname and LName from table 'Student' where StuID matches the values found in the second step and Sex is 'F'.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Bootup Baltimore\", then use 'where' to filter members based on their club and gender, and finally select the first name and last name of the female members.\n\nSQL query: SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.sex  =  \"F\"",
        "predict": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.sex  =  \"F\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t3.sex  =  \"M\"",
        "question": "What are the first name and last name of each male member in club \"Hopkins Student Enterprises\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter members based on their club name. Secondly, we need to select the first name and last name of male members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Hopkins Student Enterprises\". In the second step, we need to join table 'Member_of_club' and table 'Student' on StuID and filter by ClubID and Sex.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Hopkins Student Enterprises\", and then use 'join' to join 'Member_of_club' and 'Student' tables on StuID. Finally, filter by ClubID and Sex = 'M' and select the first name and last name.\n\nSQL query: SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t3.sex  =  \"M\"",
        "predict": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t3.sex  =  \"M\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT clublocation FROM club WHERE clubname  =  \"Pen and Paper Gaming\"",
        "question": "Where is the club \"Pen and Paper Gaming\" located?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires finding the location of the club \"Pen and Paper Gaming\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find the location of the club, we only need the 'Club' table.\n\n<3> SQL Generation: Use 'where' to filter the club with the name \"Pen and Paper Gaming\" and select its location.\n\nSQL query: SELECT clublocation FROM club WHERE clubname  =  \"Pen and Paper Gaming\"",
        "predict": "SELECT clublocation FROM club WHERE clubname  =  \"Pen and Paper Gaming\"",
        "hardness": "easy"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "question": "Who is the \"CTO\" of club \"Hopkins Student Enterprises\"? Show the first name and last name.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Hopkins Student Enterprises\". Secondly, we need to find the member of the club with the position \"CTO\" and retrieve their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Hopkins Student Enterprises\". In the second step, we need to select StuID from table 'Member_of_club' where ClubID matches the ClubID found in the first step and Position = \"CTO\". Finally, we need to retrieve the first name and last name of the student from table 'Student' using the StuID found in the second step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Hopkins Student Enterprises\", then use 'where' to find the StuID of the member with the position \"CTO\" in the club, and finally select the first name and last name of the student using the StuID.\n\nSQL query: SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "predict": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "question": "Find the first name and last name for the \"CTO\" of the club \"Hopkins Student Enterprises\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Hopkins Student Enterprises\". Secondly, we need to find the member of the club with the position \"CTO\" and retrieve their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Hopkins Student Enterprises\". In the second step, we need to select StuID from table 'Member_of_club' where ClubID matches the ClubID found in the first step and Position = \"CTO\". Finally, we need to retrieve the first name and last name from table 'Student' using the StuID found in the second step.\n\n<3> SQL Generation: Use 'where' to find the ClubID for the club \"Hopkins Student Enterprises\", and then use 'where' to find the StuID for the member with the position \"CTO\". Finally, join the 'Student' table to retrieve the first name and last name.\n\nSQL query: SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "predict": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  >  18",
        "question": "How many members of \"Bootup Baltimore\" are older than 18?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Bootup Baltimore\". Secondly, we need to filter members of that club who are older than 18. Finally, we need to count the number of members who meet these criteria.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Bootup Baltimore\". In the second step, we need to filter StuID from table 'Member_of_club' based on the ClubID obtained in the first step. In the third step, we need to filter Age from table 'Student' based on the StuID obtained in the second step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Bootup Baltimore\", then use 'where' to filter members of that club who are older than 18, and finally use 'count' to count the number of members who meet these criteria.\n\nSQL query: SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  >  18",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  >  18",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  <  18",
        "question": "How many members of club \"Bootup Baltimore\" are younger than 18?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter members of club \"Bootup Baltimore\" from table 'Member_of_club'. Secondly, we need to filter members who are younger than 18 based on their age from table 'Student'. Finally, we count the number of selected members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'Member_of_club' and table 'Student' have direct foreign keys, so we need tables ['Member_of_club', 'Student'].\n\n<3> SQL Generation: We need to join the 'Member_of_club' and 'Student' tables on the 'StuID' column. Then, we filter the rows where 'ClubName' is 'Bootup Baltimore' and 'Age' is less than 18. Finally, we count the number of rows that meet these conditions.\n\nSQL query: SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  <  18",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  <  18",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.city_code  =  \"BAL\"",
        "question": "Find the names of all the clubs that have at least a member from the city with city code \"BAL\".",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the city with city code \"BAL\". Secondly, we need to find the clubs that have at least one member from that city and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubLocation = \"BAL\". In the second step, we need to filter ClubID from table 'Member_of_club' and select the corresponding ClubName from table 'Club'.\n\n<3> SQL Generation: Use 'where' to find the ClubID of the clubs that have at least one member from the city with city code \"BAL\", and then use 'where' to filter the ClubName from table 'Club'.\n\nSQL query: SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.city_code  =  \"BAL\"",
        "predict": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.city_code  =  \"BAL\"",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )",
        "question": "List the project details of the projects which did not hire any staff for a researcher role.",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the projects that did not hire any staff for a researcher role. Secondly, we need to list the project details of those projects.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select project_id from table 'Projects' where there are no entries in table 'Project_Staff' with role_code = 'researcher' for that project_id. In the second step, we need to select project_details from table 'Projects' for the projects found in the first step.\n\n<3> SQL Generation: Use 'where not exists' to find the projects that did not hire any staff for a researcher role, and then select the project details for those projects.\n\nSQL query: SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )",
        "predict": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )",
        "hardness": "hard"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT count(*) FROM Person WHERE gender  =  'female'",
        "question": "How many females are in the network?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter the network based on gender, selecting only females. Secondly, we need to count the number of females in the network.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have one table 'Person' and the gender column is directly available in that table, we only need to use the 'Person' table.\n\n<3> SQL Generation: Use 'where' to filter the network based on gender, selecting only females. Then, use 'count' to count the number of females in the network.\n\nSQL query: SELECT count(*) FROM Person WHERE gender  =  'female'",
        "predict": "SELECT count(*) FROM Person WHERE gender  =  'female'",
        "hardness": "easy"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "question": "How old is the doctor named Zach?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: The query requires finding the age of a person named Zach who has the job title of doctor.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this case, we only need the 'Person' table.\n\n<3> SQL Generation: Use 'where' to filter the rows where the name is 'Zach' and the job is 'doctor', and then select the age.\n\nSQL query: SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "predict": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "hardness": "medium"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "question": "What is the age of the doctor named Zach?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: The query requires finding the age of a doctor named Zach.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires information from the 'Person' table, we only need to use that table.\n\n<3> SQL Generation: Use 'where' to filter the rows where the name is 'Zach' and the job is 'doctor', and then select the age.\n\nSQL query: SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "predict": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "hardness": "medium"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT count(*) FROM Person WHERE age  >  30 AND job  =  'engineer'",
        "question": "HOw many engineers are older than 30?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter candidates based on their job and age. Secondly, we need to count the number of selected engineers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have one table 'Person' and the query does not require any additional information, we only need table 'Person'.\n\n<3> SQL Generation: Use 'where' to filter engineers with age greater than 30, and then use 'count' to calculate the number of selected engineers.\n\nSQL query: SELECT count(*) FROM Person WHERE age  >  30 AND job  =  'engineer'",
        "predict": "SELECT count(*) FROM Person WHERE age  >  30 AND job  =  'engineer'",
        "hardness": "medium"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "question": "Find the female friends of Alice.",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Alice. Secondly, we need to filter the friends who are female.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select friend from table 'PersonFriend' where name = 'Alice'. In the second step, we need to filter the selected friends by their gender from table 'Person'.\n\n<3> SQL Generation: Use 'where' to find the friends of Alice, and then use 'where' to filter the friends who are female.\n\nSQL query: SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "predict": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "hardness": "medium"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "question": "What are all the friends of Alice who are female?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Alice. Secondly, we need to filter the friends who are female.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the friends from table 'PersonFriend' where name = 'Alice'. In the second step, we need to filter the friends who are female from table 'Person'.\n\n<3> SQL Generation: Use 'where' to find the friends of Alice, and then use 'where' to filter the friends who are female.\n\nSQL query: SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "predict": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "hardness": "medium"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)",
        "question": "Who has friends that are younger than the average age?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average age of all people. Secondly, we need to find people who have friends younger than the average age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we only need the 'age' column from the 'Person' table. In the second step, we need to join the 'Person' table with the 'PersonFriend' table on the 'name' column and filter based on the age of friends.\n\n<3> SQL Generation: Use 'avg' to calculate the average age from the 'Person' table. Then, join the 'Person' table with the 'PersonFriend' table on the 'name' column. Finally, filter the rows where the age of the friend is less than the average age.\n\nSQL query: SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)",
        "predict": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)",
        "hardness": "extra"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "question": "Who is the friend of Zach with longest year relationship?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Zach. Secondly, we need to filter the friends based on the longest year relationship.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select friend from table 'PersonFriend' where name = 'Zach'. In the second step, we need to filter friend and year from table 'PersonFriend'.\n\n<3> SQL Generation: Use 'where' to find the friends of Zach, and then use 'order by' and 'desc' to select the friend with the longest year relationship.\n\nSQL query: SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "predict": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "hardness": "extra"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name =  'Zach' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "question": "What is the age of the friend of Zach with longest year relationship?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friend of Zach. Secondly, we need to find the longest year relationship for each friend. Finally, we need to find the age of the friend with the longest year relationship.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the age from table 'Person' where the name is the friend of Zach.\n\n<3> SQL Generation: Use 'where' to find the friend of Zach, then use 'order by' and 'desc' to find the friend with the longest year relationship, and finally select the age of that friend.\n\nSQL query: SELECT T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name =  'Zach' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "predict": "SELECT T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name =  'Zach' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "hardness": "extra"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "question": "Find the name, age, and job title of persons who are friends with Alice for the longest years.",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Alice. Secondly, we need to calculate the number of years each person has been friends with Alice. Finally, we need to select the person with the longest friendship and retrieve their name, age, and job title.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the tables 'Person' and 'PersonFriend' to retrieve the necessary information.\n\n<3> SQL Generation: We need to join the 'Person' and 'PersonFriend' tables on the 'name' column. Then, we filter the rows where the friend is 'Alice'. Next, we group the rows by the person's name, age, and job title and calculate the maximum number of years using the 'MAX' function. Finally, we select the person with the longest friendship and retrieve their name, age, and job title.\n\nSQL query: SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "predict": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "hardness": "extra"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "question": "Find all the name of documents without any sections.",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the documents that do not have any sections. Secondly, we need to retrieve the names of those documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select document_code from table 'Documents' where there are no corresponding entries in table 'Document_Sections'. Then, we need to retrieve the document names from table 'Documents'.\n\n<3> SQL Generation: Use 'not exists' to find the documents that do not have any sections, and then select the document names.\n\nSQL query: SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "predict": "SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "hardness": "hard"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "question": "What are the names of documents that do not have any sections?",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the documents that do not have any sections. Secondly, we need to retrieve the names of those documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select document_code from table 'Documents' where there are no corresponding entries in table 'Document_Sections'. Then, we need to retrieve the document names from table 'Documents'.\n\n<3> SQL Generation: Use 'where' and 'not exists' to find the documents that do not have any sections, and then select the document names.\n\nSQL query: SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "predict": "SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "hardness": "hard"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT name FROM Companies ORDER BY Market_Value_billion DESC",
        "question": "Sort the company names in descending order of the company's market value.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Decomposition: We need to sort the company names based on their market value in descending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Companies' table for this query.\n\n<3> SQL Generation: Use 'order by' and 'desc' to sort the company names based on their market value in descending order.\n\nSQL query: SELECT name FROM Companies ORDER BY Market_Value_billion DESC",
        "predict": "SELECT name FROM Companies ORDER BY Market_Value_billion DESC",
        "hardness": "easy"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations)",
        "question": "List the names of buildings that have no company office.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Decomposition: We need to find the buildings that have no company office.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of buildings from the 'buildings' table where there is no corresponding entry in the 'Office_locations' table.\n\n<3> SQL Generation: We can use a left join to combine the 'buildings' and 'Office_locations' tables, and then filter the rows where the 'company_id' is null. Finally, we select the names of the buildings.\n\nSQL query: SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations)",
        "predict": "SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations)",
        "hardness": "hard"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT count(*) FROM Companies WHERE Industry  =  \"Banking\" OR Industry  =  \"Conglomerate\"",
        "question": "How many companies are in either \"Banking\" industry or \"Conglomerate\" industry?",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter companies based on their industry, selecting companies in the \"Banking\" industry or \"Conglomerate\" industry. Secondly, we need to count the number of selected companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Companies' table and the 'Industry' column.\n\n<3> SQL Generation: Use 'where' to filter companies in the \"Banking\" industry or \"Conglomerate\" industry, and then use 'count' to count the number of selected companies.\n\nSQL query: SELECT count(*) FROM Companies WHERE Industry  =  \"Banking\" OR Industry  =  \"Conglomerate\"",
        "predict": "SELECT count(*) FROM Companies WHERE Industry  =  \"Banking\" OR Industry  =  \"Conglomerate\"",
        "hardness": "medium"
    },
    {
        "db_id": "solvency_ii",
        "gold": "SELECT Product_Name FROM Products ORDER BY Product_Price ASC",
        "question": "List the name of products in ascending order of price.",
        "fields": "Table Addresses, columns = [*,Address_ID,address_details]\nTable Agreements, columns = [*,Document_ID,Event_ID]\nTable Assets, columns = [*,Asset_ID,Other_Details]\nTable Assets_in_Events, columns = [*,Asset_ID,Event_ID]\nTable Channels, columns = [*,Channel_ID,Other_Details]\nTable Events, columns = [*,Event_ID,Address_ID,Channel_ID,Event_Type_Code,Finance_ID,Location_ID]\nTable Finances, columns = [*,Finance_ID,Other_Details]\nTable Locations, columns = [*,Location_ID,Other_Details]\nTable Parties, columns = [*,Party_ID,Party_Details]\nTable Parties_in_Events, columns = [*,Party_ID,Event_ID,Role_Code]\nTable Products, columns = [*,Product_ID,Product_Type_Code,Product_Name,Product_Price]\nTable Products_in_Events, columns = [*,Product_in_Event_ID,Event_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [Events.Finance_ID = Finances.Finance_ID,Events.Address_ID = Addresses.Address_ID,Events.Location_ID = Locations.Location_ID,Products_in_Events.Product_ID = Products.Product_ID,Products_in_Events.Event_ID = Events.Event_ID,Parties_in_Events.Event_ID = Events.Event_ID,Parties_in_Events.Party_ID = Parties.Party_ID,Agreements.Event_ID = Events.Event_ID,Assets_in_Events.Event_ID = Events.Event_ID,Assets_in_Events.Event_ID = Events.Event_ID]\n",
        "reasoning": "<1> Decomposition: We need to retrieve the names of products and sort them in ascending order of price.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Products' table for this query.\n\n<3> SQL Generation: We can directly select the 'Product_Name' column from the 'Products' table and order the results by the 'Product_Price' column in ascending order.\n\nSQL query: SELECT Product_Name FROM Products ORDER BY Product_Price ASC",
        "predict": "SELECT Product_Name FROM Products ORDER BY Product_Price ASC",
        "hardness": "easy"
    },
    {
        "db_id": "entertainment_awards",
        "gold": "SELECT Name FROM artwork WHERE TYPE != \"Program Talent Show\"",
        "question": "List the name of artworks whose type is not \"Program Talent Show\".",
        "fields": "Table artwork, columns = [*,Artwork_ID,Type,Name]\nTable festival_detail, columns = [*,Festival_ID,Festival_Name,Chair_Name,Location,Year,Num_of_Audience]\nTable nomination, columns = [*,Artwork_ID,Festival_ID,Result]\n",
        "foreign_keys": "Foreign_keys = [nomination.Festival_ID = festival_detail.Festival_ID,nomination.Artwork_ID = artwork.Artwork_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the type of artwork, so we should apply the 'where' clause to the column 'Type' and then return the names of the selected artworks.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires the names of the artworks, we only need the 'artwork' table.\n\n<3> SQL Generation: Directly write the SQL query using 'where'.\n\nSQL query: SELECT Name FROM artwork WHERE TYPE != \"Program Talent Show\"",
        "predict": "SELECT Name FROM artwork WHERE TYPE != \"Program Talent Show\"",
        "hardness": "easy"
    },
    {
        "db_id": "entertainment_awards",
        "gold": "SELECT Name FROM Artwork WHERE Artwork_ID NOT IN (SELECT Artwork_ID FROM nomination)",
        "question": "List the name of artworks that are not nominated.",
        "fields": "Table artwork, columns = [*,Artwork_ID,Type,Name]\nTable festival_detail, columns = [*,Festival_ID,Festival_Name,Chair_Name,Location,Year,Num_of_Audience]\nTable nomination, columns = [*,Artwork_ID,Festival_ID,Result]\n",
        "foreign_keys": "Foreign_keys = [nomination.Festival_ID = festival_detail.Festival_ID,nomination.Artwork_ID = artwork.Artwork_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on artworks that are not nominated. We need to select the names of artworks that do not have corresponding entries in the 'nomination' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'artwork' table to select the names of artworks.\n\n<3> SQL Generation: Use 'where not exists' to filter artworks that do not have corresponding entries in the 'nomination' table and select their names.\n\nSQL query: SELECT Name FROM Artwork WHERE Artwork_ID NOT IN (SELECT Artwork_ID FROM nomination)",
        "predict": "SELECT Name FROM Artwork WHERE Artwork_ID NOT IN (SELECT Artwork_ID FROM nomination)",
        "hardness": "hard"
    },
    {
        "db_id": "customers_campaigns_ecommerce",
        "gold": "SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM mailshot_customers)",
        "question": "Show the name and phone of the customer without any mailshot.",
        "fields": "Table Customer_Addresses, columns = [*,customer_id,premise_id,date_address_from,address_type_code,date_address_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,shipping_method_code,order_placed_datetime,order_delivered_datetime,order_shipping_charges]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,customer_address,customer_login,customer_password]\nTable Mailshot_Campaigns, columns = [*,mailshot_id,product_category,mailshot_name,mailshot_start_date,mailshot_end_date]\nTable Mailshot_Customers, columns = [*,mailshot_id,customer_id,outcome_code,mailshot_customer_date]\nTable Order_Items, columns = [*,item_id,order_item_status_code,order_id,product_id,item_status_code,item_delivered_datetime,item_order_quantity]\nTable Premises, columns = [*,premise_id,premises_type,premise_details]\nTable Products, columns = [*,product_id,product_category,product_name]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.premise_id = Premises.premise_id,Customer_Orders.customer_id = Customers.customer_id,Mailshot_Customers.mailshot_id = Mailshot_Campaigns.mailshot_id,Mailshot_Customers.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customers who did not receive any mailshot. Secondly, we need to select the name and phone of those customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Mailshot_Customers' where outcome_code is not equal to 'Sent'. In the second step, we need to select customer_name and customer_phone from table 'Customers' based on the customer_id obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id from table 'Mailshot_Customers' where outcome_code is not equal to 'Sent', and then use 'where' to select the name and phone of those customers from table 'Customers'.\n\nSQL query: SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM mailshot_customers)",
        "predict": "SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM mailshot_customers)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_campaigns_ecommerce",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE shipping_method_code  =  'FedEx' AND order_status_code  =  'Paid'",
        "question": "Show the names of customers having an order with shipping method FedEx and order status Paid.",
        "fields": "Table Customer_Addresses, columns = [*,customer_id,premise_id,date_address_from,address_type_code,date_address_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,shipping_method_code,order_placed_datetime,order_delivered_datetime,order_shipping_charges]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,customer_address,customer_login,customer_password]\nTable Mailshot_Campaigns, columns = [*,mailshot_id,product_category,mailshot_name,mailshot_start_date,mailshot_end_date]\nTable Mailshot_Customers, columns = [*,mailshot_id,customer_id,outcome_code,mailshot_customer_date]\nTable Order_Items, columns = [*,item_id,order_item_status_code,order_id,product_id,item_status_code,item_delivered_datetime,item_order_quantity]\nTable Premises, columns = [*,premise_id,premises_type,premise_details]\nTable Products, columns = [*,product_id,product_category,product_name]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.premise_id = Premises.premise_id,Customer_Orders.customer_id = Customers.customer_id,Mailshot_Customers.mailshot_id = Mailshot_Campaigns.mailshot_id,Mailshot_Customers.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders with shipping method FedEx. Secondly, we need to filter orders with order status Paid. Finally, we need to select the names of customers who have orders that meet both conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_name from table 'Customers' and filter by customer_id from table 'Customer_Orders'. We also need to filter by shipping_method_code and order_status_code from table 'Customer_Orders'.\n\n<3> SQL Generation: Use 'where' to filter orders with shipping method FedEx and order status Paid, and then select the customer names.\n\nSQL query: SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE shipping_method_code  =  'FedEx' AND order_status_code  =  'Paid'",
        "predict": "SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE shipping_method_code  =  'FedEx' AND order_status_code  =  'Paid'",
        "hardness": "medium"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT count(*) FROM COURSE WHERE Credits  >  2",
        "question": "How many courses have more than 2 credits?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on courses with more than 2 credits. We need to select courses based on their credit value.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Course' table and the 'Credits' column.\n\n<3> SQL Generation: Use 'where' to filter courses with more than 2 credits and count them.\n\nSQL query: SELECT count(*) FROM COURSE WHERE Credits  >  2",
        "predict": "SELECT count(*) FROM COURSE WHERE Credits  >  2",
        "hardness": "easy"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT count(*) FROM DEPARTMENT WHERE Division  =  \"AS\"",
        "question": "How many departments are in the division AS?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of departments in the division AS.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the departments from the table 'Department' where the division is AS.\n\n<3> SQL Generation: Use 'where' to filter departments with the division AS, and then use 'count' to calculate the number of departments.\n\nSQL query: SELECT count(*) FROM DEPARTMENT WHERE Division  =  \"AS\"",
        "predict": "SELECT count(*) FROM DEPARTMENT WHERE Division  =  \"AS\"",
        "hardness": "easy"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade  =  \"B\"",
        "question": "How many students have had at least one \"B\" grade?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students who have at least one \"B\" grade. Secondly, we need to count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from table 'Enrolled_in' where Grade = \"B\".\n\n<3> SQL Generation: Use 'where' to filter students who have at least one \"B\" grade, and then use 'count' to count the number of selected students.\n\nSQL query: SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade  =  \"B\"",
        "predict": "SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade  =  \"B\"",
        "hardness": "easy"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Room FROM FACULTY WHERE Rank  =  \"Professor\" AND Building  =  \"NEB\"",
        "question": "What are the rooms for members of the faculty who are professors and who live in building NEB?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter members of the faculty who are professors. Secondly, we need to filter members of the faculty who live in building NEB. Finally, we need to select the rooms for the filtered faculty members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the rooms from table 'Faculty' where the rank is 'professor' and the building is 'NEB'.\n\n<3> SQL Generation: Use 'where' to filter members of the faculty who are professors and who live in building NEB, and then select the rooms for the filtered faculty members.\n\nSQL query: SELECT Room FROM FACULTY WHERE Rank  =  \"Professor\" AND Building  =  \"NEB\"",
        "predict": "SELECT Room FROM FACULTY WHERE Rank  =  \"Professor\" AND Building  =  \"NEB\"",
        "hardness": "medium"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T2.Dname ,  T2.Room FROM COURSE AS T1 JOIN DEPARTMENT AS T2 ON T1.DNO  =  T2.DNO WHERE T1.CName  =  \"INTRODUCTION TO COMPUTER SCIENCE\"",
        "question": "What are the department name and room for the course INTRODUCTION TO COMPUTER SCIENCE?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the course with the name 'INTRODUCTION TO COMPUTER SCIENCE'. Secondly, we need to find the department name and room for that course.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CID from table 'Course' where CName = 'INTRODUCTION TO COMPUTER SCIENCE'. In the second step, we need to select DName and Room from table 'Department' where DNO matches the DNO in the Course table.\n\n<3> SQL Generation: Use 'where' to find the course with the name 'INTRODUCTION TO COMPUTER SCIENCE', and then use 'where' to find the department name and room for that course.\n\nSQL query: SELECT T2.Dname ,  T2.Room FROM COURSE AS T1 JOIN DEPARTMENT AS T2 ON T1.DNO  =  T2.DNO WHERE T1.CName  =  \"INTRODUCTION TO COMPUTER SCIENCE\"",
        "predict": "SELECT T2.Dname ,  T2.Room FROM COURSE AS T1 JOIN DEPARTMENT AS T2 ON T1.DNO  =  T2.DNO WHERE T1.CName  =  \"INTRODUCTION TO COMPUTER SCIENCE\"",
        "hardness": "medium"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT max(T2.gradepoint) ,  min(T2.gradepoint) FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T3.city_code  =  \"NYC\"",
        "question": "What is the maximum and minimum grade point of students who live in NYC?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who live in NYC. Secondly, we need to calculate the maximum and minimum grade point of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where city_code = 'NYC'. In the second step, we need to select gradepoint from table 'Gradeconversion' and filter by lettergrade from table 'Enrolled_in' where StuID is from the first step.\n\n<3> SQL Generation: Use 'where' to find the students who live in NYC, and then use 'where' to filter the grade points of these students and calculate the maximum and minimum values.\n\nSQL query: SELECT max(T2.gradepoint) ,  min(T2.gradepoint) FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T3.city_code  =  \"NYC\"",
        "predict": "SELECT max(T2.gradepoint) ,  min(T2.gradepoint) FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T3.city_code  =  \"NYC\"",
        "hardness": "hard"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "question": "Find the first name of students not enrolled in any course.",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires finding students who are not enrolled in any course. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first name from the 'Student' table and filter out students who have entries in the 'Enrolled_in' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Student' and 'Enrolled_in' tables on the 'StuID' column. Then, we can filter out the rows where the 'CID' column is null, indicating that the student is not enrolled in any course. Finally, we can select the first name of these students.\n\nSQL query: SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "predict": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "hardness": "hard"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "question": "What are the first names of all students that are not enrolled in courses?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires finding students who are not enrolled in any courses and retrieving their first names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select first names from the 'Student' table and filter out the students who have entries in the 'Enrolled_in' table.\n\n<3> SQL Generation: We can use a left join between the 'Student' and 'Enrolled_in' tables on the 'StuID' column. Then, we can filter out the rows where the 'CID' column is null (indicating that the student is not enrolled in any courses). Finally, we can select the first names of these students.\n\nSQL query: SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "predict": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "hardness": "hard"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT T1.product_id FROM product_suppliers AS T1 JOIN products AS T2 ON T1.product_id  =  T2.product_id WHERE T1.supplier_id  =  2 AND T2.product_price  >  (SELECT avg(product_price) FROM products)",
        "question": "Return ids of all the products that are supplied by supplier id 2 and are more expensive than the average price of all products.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the average price of all products. Secondly, we need to filter products that are supplied by supplier id 2 and have a price higher than the average price.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the average product price from table 'Products'. In the second step, we need to filter product ids from table 'Product_Suppliers' based on supplier id 2 and price higher than the average price.\n\n<3> SQL Generation: Use 'where' to find the average product price, and then use 'where' to filter product ids that are supplied by supplier id 2 and have a price higher than the average price.\n\nSQL query: SELECT T1.product_id FROM product_suppliers AS T1 JOIN products AS T2 ON T1.product_id  =  T2.product_id WHERE T1.supplier_id  =  2 AND T2.product_price  >  (SELECT avg(product_price) FROM products)",
        "predict": "SELECT T1.product_id FROM product_suppliers AS T1 JOIN products AS T2 ON T1.product_id  =  T2.product_id WHERE T1.supplier_id  =  2 AND T2.product_price  >  (SELECT avg(product_price) FROM products)",
        "hardness": "extra"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT product_name ,  product_id FROM products WHERE product_price BETWEEN 600 AND 700",
        "question": "What are the names and ids of products costing between 600 and 700?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their cost. Secondly, we need to select the names and ids of the filtered products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information about products, we only need the 'Products' table.\n\n<3> SQL Generation: Use 'where' to filter products based on their cost, and then select the names and ids of the filtered products.\n\nSQL query: SELECT product_name ,  product_id FROM products WHERE product_price BETWEEN 600 AND 700",
        "predict": "SELECT product_name ,  product_id FROM products WHERE product_price BETWEEN 600 AND 700",
        "hardness": "medium"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT product_id ,  product_name FROM products WHERE product_price  <  600 OR product_price  >  900",
        "question": "What are id and name of the products whose price is lower than 600 or higher than 900?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their price being lower than 600 or higher than 900. Secondly, we need to select the id and name of the filtered products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Products' table for this query, we can directly use it.\n\n<3> SQL Generation: Use 'where' to filter products based on their price being lower than 600 or higher than 900, and then select the id and name of the filtered products.\n\nSQL query: SELECT product_id ,  product_name FROM products WHERE product_price  <  600 OR product_price  >  900",
        "predict": "SELECT product_id ,  product_name FROM products WHERE product_price  <  600 OR product_price  >  900",
        "hardness": "extra"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE \"%WY%\" AND payment_method_code != \"Credit Card\"",
        "question": "Find the id and name of customers whose address contains WY state and do not use credit card for payment.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter customers whose address contains WY state. Secondly, we need to filter customers who do not use credit card for payment. Finally, we need to select the id and name of the filtered customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id and customer_name from table 'Customers' and filter by customer_address from table 'Addresses'. We also need to filter by payment_method_code from table 'Customers'.\n\n<3> SQL Generation: Use 'like' to filter customers whose address contains WY state, and then use 'not in' to filter customers who do not use credit card for payment. Finally, select the id and name of the filtered customers.\n\nSQL query: SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE \"%WY%\" AND payment_method_code != \"Credit Card\"",
        "predict": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE \"%WY%\" AND payment_method_code != \"Credit Card\"",
        "hardness": "extra"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT Name FROM pilot WHERE Age  <=  30 ORDER BY Name DESC",
        "question": "List names of all pilot aged 30 or younger in descending alphabetical order.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter pilots based on their age being 30 or younger. Secondly, we need to sort the names of the selected pilots in descending alphabetical order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'pilot' table and the 'Name' column, we can directly use the 'pilot' table.\n\n<3> SQL Generation: Use 'where' to filter pilots with age 30 or younger, and then use 'order by' and 'desc' to sort the names in descending alphabetical order.\n\nSQL query: SELECT Name FROM pilot WHERE Age  <=  30 ORDER BY Name DESC",
        "predict": "SELECT Name FROM pilot WHERE Age  <=  30 ORDER BY Name DESC",
        "hardness": "medium"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "question": "find the name of pilots who did not win the matches held in the country of Australia.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the matches held in the country of Australia. Secondly, we need to filter out the winning pilots from those matches. Finally, we need to find the names of pilots who did not win.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select matches from table 'match' where country = 'Australia'. In the second step, we need to filter winning pilots from table 'match'. In the final step, we need to select names of pilots from table 'pilot' who did not win.\n\n<3> SQL Generation: Use 'where' to find matches held in the country of Australia, and then use 'not in' to filter winning pilots. Finally, select the names of pilots who did not win.\n\nSQL query: SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "predict": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "hardness": "hard"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "question": "What are the names of the pilots that have not won any matches in Australia?",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter matches that took place in Australia. Secondly, we need to find the pilots who did not win any matches in Australia.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter matches based on the 'Country' column. In the second step, we need to select the names of pilots who did not win any matches.\n\n<3> SQL Generation: Use 'where' to filter matches that took place in Australia, and then use 'not in' to filter the pilots who did not win any matches.\n\nSQL query: SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "predict": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "hardness": "hard"
    },
    {
        "db_id": "school_player",
        "gold": "SELECT LOCATION FROM school WHERE School_ID NOT IN (SELECT School_ID FROM Player)",
        "question": "Which schools do not have any player? Give me the school locations.",
        "fields": "Table player, columns = [*,Player_ID,Player,Team,Age,Position,School_ID]\nTable school, columns = [*,School_ID,School,Location,Enrollment,Founded,Denomination,Boys_or_Girls,Day_or_Boarding,Year_Entered_Competition,School_Colors]\nTable school_details, columns = [*,School_ID,Nickname,Colors,League,Class,Division]\nTable school_performance, columns = [*,School_Id,School_Year,Class_A,Class_AA]\n",
        "foreign_keys": "Foreign_keys = [school_details.School_ID = school.School_ID,school_performance.School_Id = school.School_ID,player.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the schools that do not have any player. Secondly, we need to retrieve the locations of those schools.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select School_ID from table 'player' and filter the schools that do not have any player. Then, we need to retrieve the School_ID and Location from table 'school'.\n\n<3> SQL Generation: Use 'where' to filter the schools that do not have any player, and then select the School_ID and Location from table 'school'.\n\nSQL query: SELECT LOCATION FROM school WHERE School_ID NOT IN (SELECT School_ID FROM Player)",
        "predict": "SELECT LOCATION FROM school WHERE School_ID NOT IN (SELECT School_ID FROM Player)",
        "hardness": "hard"
    },
    {
        "db_id": "store_product",
        "gold": "SELECT District_name ,  City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000",
        "question": "Find the name and population of district with population between 200000 and 2000000",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on districts with population between 200000 and 2000000. Firstly, we need to identify the districts with the specified population range. Secondly, we need to select the name and population of these districts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the district table and its columns 'District_name' and 'City_Population', we only need the 'district' table.\n\n<3> SQL Generation: Use 'where' to filter districts with population between 200000 and 2000000, and then select the name and population of these districts.\n\nSQL query: SELECT District_name ,  City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000",
        "predict": "SELECT District_name ,  City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000",
        "hardness": "medium"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(*) FROM tryout WHERE decision  =  'yes'",
        "question": "How many students got accepted after the tryout?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of students who got accepted after the tryout. We need to filter the tryout records where the decision is \"accepted\" and count the number of unique players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the pID column from the Player table and filter the Tryout table based on the decision column.\n\n<3> SQL Generation: Use 'where' to filter the tryout records where the decision is \"accepted\" and count the number of unique players using the COUNT and DISTINCT functions.\n\nSQL query: SELECT count(*) FROM tryout WHERE decision  =  'yes'",
        "predict": "SELECT count(*) FROM tryout WHERE decision  =  'yes'",
        "hardness": "easy"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'",
        "question": "What are the names of all students who successfully tried out for the position of striker?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the position of striker in the table 'Tryout' and returning the names of the students who successfully tried out.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires the names of the students, we only need the 'Player' table.\n\n<3> SQL Generation: Use 'where' to filter the rows in the 'Tryout' table where the position is 'striker' and the decision is 'successful'. Then, join the 'Player' table on the 'pID' column to retrieve the names of the students.\n\nSQL query: SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'",
        "predict": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'",
        "hardness": "medium"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "question": "Which college has any student who is a goalie and succeeded in the tryout.",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find students who are goalies and succeeded in the tryout. Secondly, we need to find the college that has any student meeting the criteria found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select pID from table 'Player' where pPos = 'goalie' and yCard = 'succeeded'. In the second step, we need to select cName from table 'Tryout' and filter by pID.\n\n<3> SQL Generation: Use 'where' to find students who are goalies and succeeded in the tryout, and then use 'where' to filter colleges that have any student meeting the criteria found in the first step.\n\nSQL query: SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "predict": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "hardness": "medium"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "question": "What college has a student who successfully made the team in the role of a goalie?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: The query requires finding a college that has a student who successfully made the team in the role of a goalie. Firstly, we need to filter tryouts based on the position 'goalie'. Secondly, we need to find the corresponding college for the selected tryouts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select pID from table 'tryout' where pPos = 'goalie'. In the second step, we need to select cName from table 'tryout' and find the corresponding college.\n\n<3> SQL Generation: Use 'where' to filter tryouts with the position 'goalie', and then use 'where' to find the corresponding college.\n\nSQL query: SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "predict": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "hardness": "medium"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT sum(enr) FROM college WHERE cName NOT IN (SELECT cName FROM tryout WHERE pPos  =  \"goalie\")",
        "question": "What is the total number of enrollment of schools that do not have any goalie player?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the schools that do not have any goalie player. Secondly, we need to calculate the total enrollment of these schools.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select cName from table 'College' where there is no corresponding pID in table 'Player' with pPos = 'goalie'. In the second step, we need to sum the enr column from table 'College' for the selected schools.\n\n<3> SQL Generation: Use 'where' and 'not in' to find the schools that do not have any goalie player, and then use 'sum' to calculate the total enrollment of these schools.\n\nSQL query: SELECT sum(enr) FROM college WHERE cName NOT IN (SELECT cName FROM tryout WHERE pPos  =  \"goalie\")",
        "predict": "SELECT sum(enr) FROM college WHERE cName NOT IN (SELECT cName FROM tryout WHERE pPos  =  \"goalie\")",
        "hardness": "extra"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(DISTINCT state) FROM college WHERE enr  <  (SELECT avg(enr) FROM college)",
        "question": "What is the number of states that has some colleges whose enrollment is smaller than the average enrollment?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average enrollment of colleges. Secondly, we need to find the states that have colleges with enrollment smaller than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select state and enrollment from table 'College'.\n\n<3> SQL Generation: Use 'avg' to calculate the average enrollment of colleges, and then use 'where' to filter colleges with enrollment smaller than the average. Finally, use 'distinct' to count the number of states.\n\nSQL query: SELECT count(DISTINCT state) FROM college WHERE enr  <  (SELECT avg(enr) FROM college)",
        "predict": "SELECT count(DISTINCT state) FROM college WHERE enr  <  (SELECT avg(enr) FROM college)",
        "hardness": "hard"
    },
    {
        "db_id": "device",
        "gold": "SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1",
        "question": "What is the shop name corresponding to the shop that opened in the most recent year?",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the most recent year in the 'Open_Year' column of the 'shop' table. Secondly, we need to find the shop name corresponding to that year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'shop' table for this query.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the most recent year from the 'Open_Year' column of the 'shop' table, and then use 'where' to filter the shop name corresponding to that year.\n\nSQL query: SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1",
        "predict": "SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1",
        "hardness": "medium"
    },
    {
        "db_id": "device",
        "gold": "SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock)",
        "question": "List the names of shops that have no devices in stock.",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding shops that have no devices in stock. Firstly, we need to identify the shops that have devices in stock. Secondly, we need to filter out the shops that do not have any devices in stock.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Shop_ID from table 'stock' and filter by Device_ID. Then, we need to select Shop_Name from table 'shop' and filter out the shops that do not have any devices in stock.\n\n<3> SQL Generation: Use 'distinct' to select the unique Shop_ID from table 'stock'. Then, use 'not in' to filter out the shops that have devices in stock. Finally, select the Shop_Name from table 'shop'.\n\nSQL query: SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock)",
        "predict": "SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock)",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Badlands\" AND T1.StagePosition  =  \"back\"",
        "question": "Who is performing in the back stage position for the song \"Badlands\"? Show the first name and the last name.",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Badlands\". Secondly, we need to find the bandmate performing in the back stage position for that song. Finally, we need to show their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Badlands\". In the second step, we need to select the BandmateId from the table 'Performance' where the SongId matches the one found in the first step. In the final step, we need to select the Firstname and Lastname from the table 'Band' where the Id matches the BandmateId found in the second step.\n\n<3> SQL Generation: Use 'where' to find the SongId for the song \"Badlands\", then use 'where' to find the BandmateId for the back stage position of that song, and finally use 'where' to find the Firstname and Lastname of the bandmate.\n\nSQL query: SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Badlands\" AND T1.StagePosition  =  \"back\"",
        "predict": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Badlands\" AND T1.StagePosition  =  \"back\"",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Le Pop\"",
        "question": "What instrument did the musician with last name \"Heilo\" use in the song \"Le Pop\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the musician with last name \"Heilo\". Secondly, we need to find the song \"Le Pop\" and the corresponding musician's instrument.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'Band' where Lastname = \"Heilo\". In the second step, we need to find the SongId from table 'Songs' where Title = \"Le Pop\" and the corresponding BandmateId from table 'Instruments'.\n\n<3> SQL Generation: Use 'where' to find the musician with last name \"Heilo\", and then use 'where' to find the song \"Le Pop\" and the corresponding musician's instrument.\n\nSQL query: SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Le Pop\"",
        "predict": "SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Le Pop\"",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "question": "How many instruments does the song \"Le Pop\" use?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Le Pop\". Secondly, we need to count the number of instruments used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Le Pop\". In the second step, we need to count the number of instruments from the table 'Instruments' where the SongId matches the SongId found in the first step.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Le Pop\", and then use 'count' to count the number of instruments in the table 'Instruments' where the SongId matches the SongId found in the first step.\n\nSQL query: SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "predict": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "question": "How many different instruments are used in the song \"Le Pop\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Le Pop\". Secondly, we need to identify the different instruments used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the song_id from table 'Songs' where the title is \"Le Pop\". In the second step, we need to select the distinct instruments from table 'Instruments' based on the song_id.\n\n<3> SQL Generation: Use 'where' to find the song with the title \"Le Pop\", and then use 'distinct' to select the different instruments used in that song.\n\nSQL query: SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "predict": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN Band AS T2 ON T1.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\"",
        "question": "How many different instruments does the musician with the last name \"Heilo\" use?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the musician with the last name \"Heilo\". Secondly, we need to count the number of different instruments used by this musician.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'Band' where Lastname = \"Heilo\". In the second step, we need to select distinct Instrument from table 'Instruments' where BandmateId is the Id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the musician with the last name \"Heilo\", and then use 'where' and 'distinct' to count the number of different instruments used by this musician.\n\nSQL query: SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN Band AS T2 ON T1.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\"",
        "predict": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN Band AS T2 ON T1.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "question": "How many songs have a lead vocal?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: We need to count the number of songs that have a lead vocal.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the SongId from the Vocals table where the Type is 'lead'.\n\n<3> SQL Generation: Use 'where' to filter the songs with a lead vocal and count them.\n\nSQL query: SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "predict": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "question": "How many songs have vocals of type lead?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of songs that have vocals of type lead.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the SongId from the Vocals table where the Type is lead.\n\n<3> SQL Generation: Use 'where' to filter the rows where the Type is lead in the Vocals table, and then count the number of distinct SongIds.\n\nSQL query: SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "predict": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid JOIN band AS T3 ON T1.bandmate  =  T3.id WHERE T3.firstname  =  \"Solveig\" AND T2.title  =  \"A Bar In Amsterdam\"",
        "question": "Which vocal type did the musician with first name \"Solveig\" played in the song with title \"A Bar in Amsterdam\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the musician with first name \"Solveig\". Secondly, we need to find the song with title \"A Bar in Amsterdam\" and the corresponding musician's vocal type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'Band' where Firstname = \"Solveig\". In the second step, we need to select SongId from table 'Songs' where Title = \"A Bar in Amsterdam\" and find the corresponding vocal type from table 'Vocals'.\n\n<3> SQL Generation: Use 'where' to find the musician with first name \"Solveig\", and then use 'where' to find the song with title \"A Bar in Amsterdam\" and the corresponding musician's vocal type.\n\nSQL query: SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid JOIN band AS T3 ON T1.bandmate  =  T3.id WHERE T3.firstname  =  \"Solveig\" AND T2.title  =  \"A Bar In Amsterdam\"",
        "predict": "SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid JOIN band AS T3 ON T1.bandmate  =  T3.id WHERE T3.firstname  =  \"Solveig\" AND T2.title  =  \"A Bar In Amsterdam\"",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Badlands\"",
        "question": "How many different instruments are used in the song \"Badlands\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Badlands\". Secondly, we need to identify the different instruments used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Badlands\". In the second step, we need to select the distinct instruments from the table 'Instruments' based on the SongId.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Badlands\", and then use 'distinct' to select the different instruments used in that song.\n\nSQL query: SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Badlands\"",
        "predict": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Badlands\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(*) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "question": "How many vocal types are used in the song \"Le Pop\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Le Pop\". Secondly, we need to count the number of unique vocal types used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Le Pop\". In the second step, we need to count the distinct vocal types from the table 'Vocals' based on the SongId.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Le Pop\", and then use 'count(distinct)' to count the number of unique vocal types based on the SongId.\n\nSQL query: SELECT count(*) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "predict": "SELECT count(*) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"shared\"",
        "question": "How many different songs have shared vocals?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the songs that have shared vocals. Secondly, we need to count the number of different songs that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select distinct SongId from table 'Vocals'.\n\n<3> SQL Generation: Use 'distinct' and 'count' to select the number of different songs that have shared vocals.\n\nSQL query: SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"shared\"",
        "predict": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"shared\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Der Kapitan\" AND T1.StagePosition  =  \"back\"",
        "question": "What is the first and last name of the artist who performed back stage for the song \"Der Kapitan\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song \"Der Kapitan\" in the table 'Songs'. Secondly, we need to find the bandmate who performed back stage for that song in the table 'Performance'. Finally, we need to find the first and last name of that bandmate in the table 'Band'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select SongId from table 'Songs' where Title = \"Der Kapitan\". In the second step, we need to select Bandmate from table 'Performance' where SongId matches the SongId found in the first step. In the final step, we need to select Firstname and Lastname from table 'Band' where Id matches the Bandmate found in the second step.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Der Kapitan\" in the table 'Songs'. Then, use 'where' to find the Bandmate who performed back stage for that song in the table 'Performance'. Finally, use 'where' to find the first and last name of that bandmate in the table 'Band'.\n\nSQL query: SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Der Kapitan\" AND T1.StagePosition  =  \"back\"",
        "predict": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Der Kapitan\" AND T1.StagePosition  =  \"back\"",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT T3.title) FROM albums AS T1 JOIN tracklists AS T2 ON T1.aid  =  T2.albumid JOIN songs AS T3 ON T2.songid  =  T3.songid WHERE t1.type  =  \"Studio\"",
        "question": "How many songs appear in studio albums?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the songs that appear in studio albums. Secondly, we need to count the number of these songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are interested in studio albums, we need to select songs from the 'Songs' table that are included in studio albums. To determine if an album is a studio album, we can check the 'Type' column in the 'Albums' table.\n\n<3> SQL Generation: Use 'where' to filter songs that appear in studio albums and count them.\n\nSQL query: SELECT count(DISTINCT T3.title) FROM albums AS T1 JOIN tracklists AS T2 ON T1.aid  =  T2.albumid JOIN songs AS T3 ON T2.songid  =  T3.songid WHERE t1.type  =  \"Studio\"",
        "predict": "SELECT count(DISTINCT T3.title) FROM albums AS T1 JOIN tracklists AS T2 ON T1.aid  =  T2.albumid JOIN songs AS T3 ON T2.songid  =  T3.songid WHERE t1.type  =  \"Studio\"",
        "hardness": "hard"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT count(*) FROM manufacturers WHERE founder  =  'Andy'",
        "question": "How many companies were created by Andy?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies created by Andy. Secondly, we need to count the number of companies found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for companies created by Andy, we need to select the companies from the 'Manufacturers' table where the 'Founder' column is 'Andy'.\n\n<3> SQL Generation: Use 'where' to filter the companies created by Andy, and then use 'count' to count the number of companies.\n\nSQL query: SELECT count(*) FROM manufacturers WHERE founder  =  'Andy'",
        "predict": "SELECT count(*) FROM manufacturers WHERE founder  =  'Andy'",
        "hardness": "easy"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT sum(revenue) FROM manufacturers WHERE headquarter  =  'Austin'",
        "question": "What is the sum of revenue from companies with headquarters in Austin?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies with headquarters in Austin. Secondly, we need to calculate the sum of their revenue.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Manufacturers' table to filter companies with headquarters in Austin.\n\n<3> SQL Generation: Use 'where' to filter companies with headquarters in Austin, and then use 'sum' to calculate the sum of their revenue.\n\nSQL query: SELECT sum(revenue) FROM manufacturers WHERE headquarter  =  'Austin'",
        "predict": "SELECT sum(revenue) FROM manufacturers WHERE headquarter  =  'Austin'",
        "hardness": "easy"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name ,  headquarter ,  revenue FROM manufacturers ORDER BY revenue DESC",
        "question": "Find the name, headquarter and revenue of all manufacturers sorted by their revenue in the descending order.",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: We need to select the name, headquarter, and revenue of all manufacturers. Then, we need to sort them by revenue in descending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the name, headquarter, and revenue columns from the Manufacturers table.\n\n<3> SQL Generation: Use 'SELECT' to select the desired columns from the Manufacturers table. Then, use 'ORDER BY' to sort the results by revenue in descending order.\n\nSQL query: SELECT name ,  headquarter ,  revenue FROM manufacturers ORDER BY revenue DESC",
        "predict": "SELECT name ,  headquarter ,  revenue FROM manufacturers ORDER BY revenue DESC",
        "hardness": "medium"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "question": "Find the name of companies whose revenue is greater than the average revenue of all companies.",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average revenue of all companies. Secondly, we need to filter companies based on their revenue being greater than the average revenue.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have two tables, 'Manufacturers' and 'Products', we only need the 'Manufacturers' table.\n\n<3> SQL Generation: Use 'select avg(revenue)' to calculate the average revenue of all companies, and then use 'where' to filter companies with revenue greater than the average revenue.\n\nSQL query: SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "predict": "SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "hardness": "hard"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "question": "What are the names of manufacturers with revenue greater than the average of all revenues?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average revenue of all manufacturers. Secondly, we need to filter manufacturers based on their revenue being greater than the average revenue.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Manufacturers' table for this query.\n\n<3> SQL Generation: Use 'select' to calculate the average revenue of all manufacturers, and then use 'where' to filter manufacturers based on their revenue being greater than the average revenue.\n\nSQL query: SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "predict": "SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "hardness": "hard"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name FROM products WHERE price  <=  200",
        "question": "What are the names of products with price at most 200?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on products with a price at most 200. We need to select the names of these products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Products' table.\n\n<3> SQL Generation: Use 'where' to filter products with a price at most 200 and select their names.\n\nSQL query: SELECT name FROM products WHERE price  <=  200",
        "predict": "SELECT name FROM products WHERE price  <=  200",
        "hardness": "easy"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT problem_log_id FROM problem_log ORDER BY log_entry_date DESC LIMIT 1",
        "question": "Which problem log was created most recently? Give me the log id.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the problem log that was created most recently. We need to identify the log entry date and log entry id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select log_entry_date and problem_log_id from table 'Problem_Log'.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the problem log with the most recent log entry date, and then select the corresponding log entry id.\n\nSQL query: SELECT problem_log_id FROM problem_log ORDER BY log_entry_date DESC LIMIT 1",
        "predict": "SELECT problem_log_id FROM problem_log ORDER BY log_entry_date DESC LIMIT 1",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT DISTINCT T2.problem_id ,  T2.problem_log_id FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"",
        "question": "Which problem id and log id are assigned to the staff named Rylan Homenick?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the staff with the name \"Rylan Homenick\". Secondly, we need to find the problem ids and log ids that are assigned to this staff.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select problem_id and log_id from table 'Problem_Log' where assigned_to_staff_id is the staff_id of the staff named \"Rylan Homenick\".\n\n<3> SQL Generation: Use 'where' to find the staff_id of the staff named \"Rylan Homenick\", and then use 'where' to filter problem_id and log_id from table 'Problem_Log' based on the staff_id.\n\nSQL query: SELECT DISTINCT T2.problem_id ,  T2.problem_log_id FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"",
        "predict": "SELECT DISTINCT T2.problem_id ,  T2.problem_log_id FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT count(*) FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id WHERE T1.product_name = \"voluptatem\"",
        "question": "How many problems are there for product voluptatem?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the product_id for the product \"voluptatem\". Secondly, we need to count the number of problems with that product_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Product' where product_name = \"voluptatem\". In the second step, we need to count the number of problems with the selected product_id from table 'Problems'.\n\n<3> SQL Generation: Use 'where' to find the product_id for the product \"voluptatem\", and then use 'where' to count the number of problems with that product_id.\n\nSQL query: SELECT count(*) FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id WHERE T1.product_name = \"voluptatem\"",
        "predict": "SELECT count(*) FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id WHERE T1.product_name = \"voluptatem\"",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT DISTINCT product_name FROM product ORDER BY product_name",
        "question": "List the names of all the distinct product names in alphabetical order?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: The query requires listing distinct product names in alphabetical order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'product_name' column, we can use the 'Product' table.\n\n<3> SQL Generation: Use 'SELECT DISTINCT' to select distinct product names from the 'Product' table and order them alphabetically.\n\nSQL query: SELECT DISTINCT product_name FROM product ORDER BY product_name",
        "predict": "SELECT DISTINCT product_name FROM product ORDER BY product_name",
        "hardness": "easy"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "question": "What are the ids of the problems reported after the date of any problems reported by Rylan Homenick?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the date of problems reported by Rylan Homenick. Secondly, we need to filter problems reported after that date and select their ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select date_problem_reported from table 'Problems' where reported_by_staff_id = (select staff_id from Staff where staff_first_name = 'Rylan' and staff_last_name = 'Homenick'). In the second step, we need to filter problem_id from table 'Problems' based on the date_problem_reported.\n\n<3> SQL Generation: Use 'where' to find the date of problems reported by Rylan Homenick, and then use 'where' to filter problems reported after that date and select their ids.\n\nSQL query: SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "predict": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "question": "Find the ids of the problems reported after the date of any problems reported by the staff Rylan Homenick.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the date of problems reported by the staff Rylan Homenick. Secondly, we need to filter problems reported after that date and select their ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select date_problem_reported from table 'Problems' where reported_by_staff_id = (select staff_id from Staff where staff_first_name = 'Rylan' and staff_last_name = 'Homenick'). In the second step, we need to filter problem_id from table 'Problems' based on the date_problem_reported.\n\n<3> SQL Generation: Use 'where' to find the date of problems reported by the staff Rylan Homenick, and then use 'where' to filter problems reported after that date and select their ids.\n\nSQL query: SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "predict": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "hardness": "extra"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)",
        "question": "List the branch name and city without any registered members.",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding branches without any registered members. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select branch name and city from the 'branch' table and check if there are any corresponding entries in the 'membership_register_branch' table.\n\n<3> SQL Generation: Use a left join to combine the 'branch' and 'membership_register_branch' tables on the 'Branch_ID' column. Then, filter the rows where the 'Member_ID' is null, indicating that there are no registered members for that branch.\n\nSQL query: SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)",
        "predict": "SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)",
        "hardness": "extra"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT sum(total_pounds) FROM purchase AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.city  =  'London' AND T1.year  =  2018",
        "question": "What is the sum of total pounds of purchase in year 2018 for all branches in London?",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter branches in London. Secondly, we need to filter purchases in year 2018. Finally, we need to calculate the sum of total pounds for the selected purchases.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Branch_ID from table 'branch' where City = 'London'. In the second step, we need to filter Total_pounds from table 'purchase' where Year = 2018. In the final step, we need to calculate the sum of Total_pounds.\n\n<3> SQL Generation: Use 'where' to filter branches in London, and then use 'where' to filter purchases in year 2018. Finally, use 'sum' to calculate the sum of Total_pounds.\n\nSQL query: SELECT sum(total_pounds) FROM purchase AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.city  =  'London' AND T1.year  =  2018",
        "predict": "SELECT sum(total_pounds) FROM purchase AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.city  =  'London' AND T1.year  =  2018",
        "hardness": "medium"
    },
    {
        "db_id": "voter_2",
        "gold": "SELECT Fname FROM STUDENT WHERE Age  >  22",
        "question": "What are the first names of all the students aged above 22?",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on students aged above 22. We need to select the first names of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table.\n\n<3> SQL Generation: Use 'where' to filter students aged above 22 and select their first names.\n\nSQL query: SELECT Fname FROM STUDENT WHERE Age  >  22",
        "predict": "SELECT Fname FROM STUDENT WHERE Age  >  22",
        "hardness": "easy"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT product_name FROM products WHERE product_category_code  =  \"Spices\"",
        "question": "What are the names of products with category \"Spices\"?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on products with category \"Spices\". We need to select the names of these products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the product names from the 'Products' table where the product category is \"Spices\".\n\n<3> SQL Generation: Use 'where' to filter products with category \"Spices\" and select their names.\n\nSQL query: SELECT product_name FROM products WHERE product_category_code  =  \"Spices\"",
        "predict": "SELECT product_name FROM products WHERE product_category_code  =  \"Spices\"",
        "hardness": "easy"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"sesame\"",
        "question": "Count the number of different characteristic names the product 'cumin' has.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the product_id of the product 'cumin'. Secondly, we need to find the characteristic_ids associated with the product_id. Finally, we count the number of different characteristic names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Products' where product_name = 'cumin'. In the second step, we need to select characteristic_ids from table 'Product_Characteristics' where product_id = the product_id found in the first step. In the final step, we need to select characteristic_names from table 'Characteristics' where characteristic_id = the characteristic_ids found in the second step.\n\n<3> SQL Generation: Use 'where' to find the product_id of the product 'cumin', then use 'where' to find the characteristic_ids associated with the product_id, and finally use 'count' and 'distinct' to count the number of different characteristic names.\n\nSQL query: SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"sesame\"",
        "predict": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"sesame\"",
        "hardness": "hard"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t3.characteristic_name  =  \"hot\"",
        "question": "How many products have the characteristic named \"hot\"?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the characteristic named \"hot\" and counting the number of products that have this characteristic.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the characteristic_id from the Characteristics table where the characteristic_name is \"hot\". Then, we need to count the number of products that have this characteristic in the Product_Characteristics table.\n\n<3> SQL Generation: Use 'where' to find the characteristic_id of the characteristic named \"hot\", and then use 'where' to filter the Product_Characteristics table and count the number of products.\n\nSQL query: SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t3.characteristic_name  =  \"hot\"",
        "predict": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t3.characteristic_name  =  \"hot\"",
        "hardness": "hard"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"white\" OR t3.characteristic_name  =  \"hot\"",
        "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their color described as 'white'. Secondly, we need to filter products based on their characteristic with the name 'hot'. Finally, we need to count the number of products that meet either of these conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter products based on their color and characteristic, we need tables ['Products', 'Ref_Colors', 'Characteristics'].\n\n<3> SQL Generation: We need to join the 'Products' table with the 'Ref_Colors' table on the 'color_code' column and filter the rows where the color description is 'white'. Then, we need to join the 'Products' table with the 'Characteristics' table using the 'Product_Characteristics' table as a bridge and filter the rows where the characteristic name is 'hot'. Finally, we count the number of distinct product IDs that meet either of these conditions.\n\nSQL query: SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"white\" OR t3.characteristic_name  =  \"hot\"",
        "predict": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"white\" OR t3.characteristic_name  =  \"hot\"",
        "hardness": "extra"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )",
        "question": "Count the number of colors that are not used in any products.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find all the colors used in products. Secondly, we need to count the number of colors that are not used.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select color_code from table 'Products'.\n\n<3> SQL Generation: Use 'distinct' to select unique color codes from table 'Products', and then use 'not in' to filter colors that are not used. Finally, count the number of colors.\n\nSQL query: SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )",
        "predict": "SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )",
        "hardness": "extra"
    },
    {
        "db_id": "swimming",
        "gold": "SELECT count(DISTINCT city) FROM stadium WHERE opening_year  <  2006",
        "question": "How many cities have a stadium that was opened before the year of 2006?",
        "fields": "Table event, columns = [*,ID,Name,Stadium_ID,Year]\nTable record, columns = [*,ID,Result,Swimmer_ID,Event_ID]\nTable stadium, columns = [*,ID,name,Capacity,City,Country,Opening_year]\nTable swimmer, columns = [*,ID,name,Nationality,meter_100,meter_200,meter_300,meter_400,meter_500,meter_600,meter_700,Time]\n",
        "foreign_keys": "Foreign_keys = [event.Stadium_ID = stadium.ID,record.Swimmer_ID = swimmer.ID,record.Event_ID = event.ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the stadiums that were opened before the year 2006. Secondly, we need to count the number of unique cities that have such stadiums.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the cities from table 'stadium' where the opening year is before 2006. In the second step, we need to count the number of unique cities from the first step.\n\n<3> SQL Generation: Use 'where' to find the stadiums that were opened before the year 2006, and then use 'count' and 'distinct' to count the number of unique cities.\n\nSQL query: SELECT count(DISTINCT city) FROM stadium WHERE opening_year  <  2006",
        "predict": "SELECT count(DISTINCT city) FROM stadium WHERE opening_year  <  2006",
        "hardness": "easy"
    },
    {
        "db_id": "railway",
        "gold": "SELECT max(LEVEL) FROM manager WHERE Country != \"Australia\"",
        "question": "What is the maximum level of managers in countries that are not \"Australia\"?",
        "fields": "Table manager, columns = [*,Manager_ID,Name,Country,Working_year_starts,Age,Level]\nTable railway, columns = [*,Railway_ID,Railway,Builder,Built,Wheels,Location,ObjectNumber]\nTable railway_manage, columns = [*,Railway_ID,Manager_ID,From_Year]\nTable train, columns = [*,Train_ID,Train_Num,Name,From,Arrival,Railway_ID]\n",
        "foreign_keys": "Foreign_keys = [train.Railway_ID = railway.Railway_ID,railway_manage.Railway_ID = railway.Railway_ID,railway_manage.Manager_ID = manager.Manager_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter managers based on their countries, excluding \"Australia\". Secondly, we need to find the maximum level among the selected managers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'manager' table, we can directly use it.\n\n<3> SQL Generation: Use 'where' to filter managers from countries other than \"Australia\", and then use 'max' to find the maximum level among the selected managers.\n\nSQL query: SELECT max(LEVEL) FROM manager WHERE Country != \"Australia\"",
        "predict": "SELECT max(LEVEL) FROM manager WHERE Country != \"Australia\"",
        "hardness": "easy"
    },
    {
        "db_id": "customers_and_products_contacts",
        "gold": "SELECT count(*) FROM products WHERE product_price  >  (SELECT avg(product_price) FROM products)",
        "question": "How many products have a price higher than the average?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Contacts, columns = [*,contact_id,customer_id,gender,first_name,last_name,contact_phone]\nTable Customer_Address_History, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\n",
        "foreign_keys": "Foreign_keys = [Customer_Address_History.address_id = Addresses.address_id,Customer_Address_History.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average price of products. Secondly, we need to count the number of products with a price higher than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'product_price' column from the 'Products' table, we only need the 'Products' table.\n\n<3> SQL Generation: Use 'avg' to calculate the average price of products, and then use 'where' to filter products with a price higher than the average.\n\nSQL query: SELECT count(*) FROM products WHERE product_price  >  (SELECT avg(product_price) FROM products)",
        "predict": "SELECT count(*) FROM products WHERE product_price  >  (SELECT avg(product_price) FROM products)",
        "hardness": "hard"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "question": "How many female students (sex is F) whose age is below 25?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their sex and age. Secondly, we need to count the number of selected female students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter students based on their sex and age, we only need the 'Student' table.\n\n<3> SQL Generation: Use 'where' to filter students based on their sex and age, and then use 'count' to calculate the number of selected female students.\n\nSQL query: SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "predict": "SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "hardness": "medium"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "question": "How many girl students who are younger than 25?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter candidates using column 'Sex' in table 'Student' and column 'Age'. Secondly, we need to count the number of selected female students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need table 'Student' for filtering and counting, we only need this table.\n\n<3> SQL Generation: We need to filter the rows where 'Sex' is 'F' and 'Age' is less than 25. Finally, we count the number of rows that meet these conditions.\n\nSQL query: SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "predict": "SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "hardness": "medium"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100",
        "question": "Find the name and gender type of the dorms whose capacity is greater than 300 or less than 100.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter dorms based on their capacity being greater than 300 or less than 100. Secondly, we need to select the name and gender type of the filtered dorms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select dorm_name and gender from table 'Dorm' and filter by capacity.\n\n<3> SQL Generation: Use 'where' to filter dorms based on their capacity being greater than 300 or less than 100, and then select the name and gender type of the filtered dorms.\n\nSQL query: SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100",
        "predict": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT amenity_name FROM dorm_amenity ORDER BY amenity_name",
        "question": "List in alphabetic order all different amenities.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires listing all different amenities. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is only focused on amenities, we only need the 'Dorm_amenity' table.\n\n<3> SQL Generation: Use 'SELECT DISTINCT' to select all different amenities from the 'Dorm_amenity' table and order them alphabetically.\n\nSQL query: SELECT amenity_name FROM dorm_amenity ORDER BY amenity_name",
        "predict": "SELECT amenity_name FROM dorm_amenity ORDER BY amenity_name",
        "hardness": "easy"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT fname ,  lname FROM student WHERE age  <  (SELECT avg(age) FROM student)",
        "question": "Find the first and last name of students whose age is younger than the average age.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average age of all students. Secondly, we need to filter students whose age is younger than the average age. Finally, we need to select the first and last name of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the first and last name of students, we only need the 'Student' table.\n\n<3> SQL Generation: Use 'avg' to calculate the average age of all students, and then use 'where' to filter students whose age is younger than the average age. Finally, select the first and last name of these students.\n\nSQL query: SELECT fname ,  lname FROM student WHERE age  <  (SELECT avg(age) FROM student)",
        "predict": "SELECT fname ,  lname FROM student WHERE age  <  (SELECT avg(age) FROM student)",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall'",
        "question": "What are the first names of all students in Smith Hall?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the dorm with the name 'Smith Hall'. Secondly, we need to find the students who live in that dorm and retrieve their first names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dormid from table 'Dorm' where dorm_name = 'Smith Hall'. In the second step, we need to filter stuid and retrieve first names from table 'Student' based on the dormid found in the first step.\n\n<3> SQL Generation: Use 'where' to find the dorm with the name 'Smith Hall', and then use 'where' to filter students who live in that dorm and retrieve their first names.\n\nSQL query: SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall'",
        "predict": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall'",
        "hardness": "hard"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT avg(T1.age) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.student_capacity  =  (SELECT max(student_capacity) FROM dorm)",
        "question": "Find the average age of students who are living in the dorm with the largest capacity.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the dorm with the largest capacity. Secondly, we need to filter students based on their dorm and calculate the average age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dormid with the largest capacity from table 'Dorm'. In the second step, we need to filter students based on dormid from table 'Lives_in' and calculate the average age from table 'Student'.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select dorm with the largest capacity, and then use 'where' to filter students and calculate the average age.\n\nSQL query: SELECT avg(T1.age) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.student_capacity  =  (SELECT max(student_capacity) FROM dorm)",
        "predict": "SELECT avg(T1.age) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.student_capacity  =  (SELECT max(student_capacity) FROM dorm)",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "question": "Find the first name and age of students who are living in the dorms that do not have amenity TV Lounge.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the dorms that do not have the amenity \"TV Lounge\". Secondly, we need to find the students who are living in those dorms and retrieve their first name and age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dormid from table 'Dorm' where amenity_name != \"TV Lounge\". In the second step, we need to filter dormid from table 'Lives_in' and retrieve the corresponding first name and age from table 'Student'.\n\n<3> SQL Generation: Use 'where' to find the dorms that do not have the amenity \"TV Lounge\", and then use 'where' to filter students who are living in those dorms and select their first name and age.\n\nSQL query: SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "predict": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "hardness": "extra"
    },
    {
        "db_id": "customer_complaints",
        "gold": "SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints)",
        "question": "Find the prices of products which has never received a single complaint.",
        "fields": "Table Complaints, columns = [*,complaint_id,product_id,customer_id,complaint_outcome_code,complaint_status_code,complaint_type_code,date_complaint_raised,date_complaint_closed,staff_id]\nTable Customers, columns = [*,customer_id,customer_type_code,address_line_1,address_line_2,town_city,state,email_address,phone_number]\nTable Products, columns = [*,product_id,parent_product_id,product_category_code,date_product_first_available,date_product_discontinued,product_name,product_description,product_price]\nTable Staff, columns = [*,staff_id,gender,first_name,last_name,email_address,phone_number]\n",
        "foreign_keys": "Foreign_keys = [Complaints.customer_id = Customers.customer_id,Complaints.product_id = Products.product_id,Complaints.staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the products that have never received a single complaint. Secondly, we need to select the prices of those products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Complaints' and count the number of complaints for each product. In the second step, we need to select product_id and product_price from table 'Products'.\n\n<3> SQL Generation: Use 'group by' and 'having' to find the products that have never received a single complaint, and then select the prices of those products.\n\nSQL query: SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints)",
        "predict": "SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints)",
        "hardness": "hard"
    },
    {
        "db_id": "workshop_paper",
        "gold": "SELECT Author FROM submission WHERE Submission_ID NOT IN (SELECT Submission_ID FROM acceptance)",
        "question": "List the authors who do not have submission to any workshop.",
        "fields": "Table Acceptance, columns = [*,Submission_ID,Workshop_ID,Result]\nTable submission, columns = [*,Submission_ID,Scores,Author,College]\nTable workshop, columns = [*,Workshop_ID,Date,Venue,Name]\n",
        "foreign_keys": "Foreign_keys = [Acceptance.Workshop_ID = workshop.Workshop_ID,Acceptance.Submission_ID = submission.Submission_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the authors who have submissions to workshops. Secondly, we need to filter out the authors who do not have any submissions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Author from table 'submission' and filter by Workshop_ID. Then, we need to filter out the authors who do not have any submissions from table 'submission'.\n\n<3> SQL Generation: Use 'where' to filter authors who have submissions to workshops, and then use 'not in' to filter out the authors who do not have any submissions.\n\nSQL query: SELECT Author FROM submission WHERE Submission_ID NOT IN (SELECT Submission_ID FROM acceptance)",
        "predict": "SELECT Author FROM submission WHERE Submission_ID NOT IN (SELECT Submission_ID FROM acceptance)",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_share_transactions",
        "gold": "SELECT min(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code  =  \"PUR\" AND share_count  >  50",
        "question": "Show the minimum amount of transactions whose type code is \"PUR\" and whose share count is bigger than 50.",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter transactions with type code \"PUR\" and share count bigger than 50. Secondly, we need to find the minimum amount among these transactions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select amount_of_transaction from table 'Transactions' where transaction_type_code = \"PUR\" and share_count > 50.\n\n<3> SQL Generation: Use 'where' to filter transactions with type code \"PUR\" and share count bigger than 50, and then use 'min' to find the minimum amount among these transactions.\n\nSQL query: SELECT min(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code  =  \"PUR\" AND share_count  >  50",
        "predict": "SELECT min(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code  =  \"PUR\" AND share_count  >  50",
        "hardness": "medium"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "question": "Show the average price range of hotels that have 5 star ratings and allow pets.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter hotels that have 5 star ratings and allow pets. Secondly, we need to calculate the average price range of these hotels.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select price_range from table 'Hotels' where star_rating_code = 5 and pets_allowed_yn = 'Y'.\n\n<3> SQL Generation: Use 'where' to filter hotels that have 5 star ratings and allow pets, and then use 'avg' to calculate the average price range.\n\nSQL query: SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "predict": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "hardness": "medium"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT T1.Name ,  T3.Visit_Date FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Vincent\" OR T2.Tourist_Details  =  \"Vivian\"",
        "question": "For each tourist attraction, return its name and the date when the tourists named Vincent or Vivian visited there.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the tourists named Vincent or Vivian. Secondly, we need to find the tourist attractions they visited and the corresponding visit dates. Finally, we need to return the name of each tourist attraction and the visit dates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the name from the 'Tourist_Attractions' table, the tourist ID from the 'Visitors' table, and the visit date from the 'Visits' table.\n\n<3> SQL Generation: We need to join the 'Tourist_Attractions', 'Visitors', and 'Visits' tables on the corresponding foreign keys. Then, we filter the rows where the tourist name is either Vincent or Vivian. Finally, we select the name of each tourist attraction and the visit dates.\n\nSQL query: SELECT T1.Name ,  T3.Visit_Date FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Vincent\" OR T2.Tourist_Details  =  \"Vivian\"",
        "predict": "SELECT T1.Name ,  T3.Visit_Date FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Vincent\" OR T2.Tourist_Details  =  \"Vivian\"",
        "hardness": "extra"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits )",
        "question": "How many tourists did not make any visit?",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding tourists who did not make any visit. We need to count the number of tourists who do not have any corresponding records in the 'Visits' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Tourist_ID' column from the 'Visitors' table and filter out the tourists who have corresponding records in the 'Visits' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Visitors' and 'Visits' tables on the 'Tourist_ID' column. Then, we can filter out the rows where the 'Visit_ID' is null (indicating no visit) and count the number of tourists.\n\nSQL query: SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits )",
        "predict": "SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits )",
        "hardness": "extra"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT gtype FROM Video_games WHERE gname  =  \"Call of Destiny\"",
        "question": "What type of game is Call of Destiny?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: We need to find the game type of \"Call of Destiny\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the game type from the \"Video_Games\" table where the game name is \"Call of Destiny\".\n\n<3> SQL Generation: Use 'where' to filter the game name and select the game type.\n\nSQL query: SELECT gtype FROM Video_games WHERE gname  =  \"Call of Destiny\"",
        "predict": "SELECT gtype FROM Video_games WHERE gname  =  \"Call of Destiny\"",
        "hardness": "easy"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT count(*) FROM Video_games WHERE gtype  =  \"Massively multiplayer online game\"",
        "question": "How many video games have type Massively multiplayer online game?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: We need to filter video games based on their type and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Video_Games' table and its 'GType' column, we can directly use this table.\n\n<3> SQL Generation: Use 'where' to filter video games with type 'Massively multiplayer online game' and count them.\n\nSQL query: SELECT count(*) FROM Video_games WHERE gtype  =  \"Massively multiplayer online game\"",
        "predict": "SELECT count(*) FROM Video_games WHERE gtype  =  \"Massively multiplayer online game\"",
        "hardness": "easy"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT date_became_customer FROM customers WHERE customer_id BETWEEN 10 AND 20",
        "question": "Find the \"date became customers\" of the customers whose ID is between 10 and 20.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter customers based on their ID being between 10 and 20. Secondly, we need to select the \"date became customers\" for the selected customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the \"date became customers\" from table 'Customers', we only need this table.\n\n<3> SQL Generation: Use 'where' to filter customers based on their ID being between 10 and 20, and then select the \"date became customers\" for the selected customers.\n\nSQL query: SELECT date_became_customer FROM customers WHERE customer_id BETWEEN 10 AND 20",
        "predict": "SELECT date_became_customer FROM customers WHERE customer_id BETWEEN 10 AND 20",
        "hardness": "easy"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT count(DISTINCT t3.product_id) FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t1.customer_name  =  \"Rodrick Heaney\"",
        "question": "How many types of products have Rodrick Heaney bought in total?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of Rodrick Heaney. Secondly, we need to find the order_id of Rodrick Heaney's orders. Thirdly, we need to find the product_id of the products bought in Rodrick Heaney's orders. Finally, we need to count the number of distinct product types.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_name = 'Rodrick Heaney'. In the second step, we need to select order_id from table 'Customer_Orders' where customer_id = the customer_id found in the first step. In the third step, we need to select product_id from table 'Order_Items' where order_id = the order_id found in the second step. In the final step, we need to count the distinct product types from table 'Products' using the product_id found in the third step.\n\n<3> SQL Generation: Use 'where' to find the customer_id of Rodrick Heaney, and then use 'where' to find the order_id of Rodrick Heaney's orders. Next, use 'where' to find the product_id of the products bought in Rodrick Heaney's orders. Finally, use 'count(distinct)' to count the number of distinct product types.\n\nSQL query: SELECT count(DISTINCT t3.product_id) FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t1.customer_name  =  \"Rodrick Heaney\"",
        "predict": "SELECT count(DISTINCT t3.product_id) FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t1.customer_name  =  \"Rodrick Heaney\"",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT count(DISTINCT customer_id) FROM customer_orders WHERE order_status  =  \"Cancelled\"",
        "question": "How many customers have at least one order with status \"Cancelled\"?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders with status \"Cancelled\". Secondly, we need to count the number of customers who have at least one order with this status.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customer_Orders' where order_status = \"Cancelled\". Then, we count the distinct customer_ids.\n\n<3> SQL Generation: Use 'where' to filter orders with status \"Cancelled\", and then use 'count' and 'distinct' to count the number of customers.\n\nSQL query: SELECT count(DISTINCT customer_id) FROM customer_orders WHERE order_status  =  \"Cancelled\"",
        "predict": "SELECT count(DISTINCT customer_id) FROM customer_orders WHERE order_status  =  \"Cancelled\"",
        "hardness": "easy"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT customer_name FROM customers WHERE payment_method != 'Cash'",
        "question": "What is the name of customers who do not use Cash as payment method.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on customers who do not use Cash as the payment method. We need to select the names of these customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the customer_name from the Customers table and filter by the payment_method column.\n\n<3> SQL Generation: Use 'where' to filter customers who do not use Cash as the payment method and select their names.\n\nSQL query: SELECT customer_name FROM customers WHERE payment_method != 'Cash'",
        "predict": "SELECT customer_name FROM customers WHERE payment_method != 'Cash'",
        "hardness": "easy"
    },
    {
        "db_id": "roller_coaster",
        "gold": "SELECT Status FROM roller_coaster WHERE LENGTH  >  3300 OR Height  >  100",
        "question": "Show the statuses of roller coasters longer than 3300 or higher than 100.",
        "fields": "Table country, columns = [*,Country_ID,Name,Population,Area,Languages]\nTable roller_coaster, columns = [*,Roller_Coaster_ID,Name,Park,Country_ID,Length,Height,Speed,Opened,Status]\n",
        "foreign_keys": "Foreign_keys = [roller_coaster.Country_ID = country.Country_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter roller coasters based on their length and height. Secondly, we need to show the statuses of the selected roller coasters.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'roller_coaster' table, we only need this table.\n\n<3> SQL Generation: Use 'where' to filter roller coasters based on their length and height, and then select the 'status' column.\n\nSQL query: SELECT Status FROM roller_coaster WHERE LENGTH  >  3300 OR Height  >  100",
        "predict": "SELECT Status FROM roller_coaster WHERE LENGTH  >  3300 OR Height  >  100",
        "hardness": "medium"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "question": "what are the names and classes of the ships that do not have any captain yet?",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding ships that do not have any captain yet. Firstly, we need to identify the ships that have captains. Secondly, we need to filter out the ships that do not have any captain.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Ship_ID from table 'captain' and filter by Ship_ID. Then, we need to select Name and Class from table 'Ship' and filter by Ship_ID.\n\n<3> SQL Generation: Use 'where' to find the Ship_IDs that have captains, and then use 'where' to filter out the ships that do not have any captain. Finally, select the Name and Class of the remaining ships.\n\nSQL query: SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "predict": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "hardness": "extra"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "question": "Return the names and classes of ships that do not have a captain?",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on ships that do not have a captain. Firstly, we need to identify the ships that do not have a captain. Secondly, we need to select the names and classes of those ships.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Ship_ID from table 'captain' and filter by Ship_ID. In the second step, we need to select Name and Class from table 'Ship' and filter by Ship_ID.\n\n<3> SQL Generation: Use 'where' to find the Ship_IDs of ships that do not have a captain, and then use 'where' to select the names and classes of those ships.\n\nSQL query: SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "predict": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "hardness": "extra"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT count(*) FROM addresses WHERE state_province_county  =  \"Colorado\"",
        "question": "How many cities are there in state \"Colorado\"?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of cities in the state \"Colorado\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for cities in a specific state, we need to use the \"Addresses\" table and filter on the \"state_province_county\" column.\n\n<3> SQL Generation: Use the \"where\" clause to filter the rows where the \"state_province_county\" is \"Colorado\", and then use the \"count\" function to count the number of cities.\n\nSQL query: SELECT count(*) FROM addresses WHERE state_province_county  =  \"Colorado\"",
        "predict": "SELECT count(*) FROM addresses WHERE state_province_county  =  \"Colorado\"",
        "hardness": "easy"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT organization_name FROM organizations WHERE organization_name LIKE \"%Party%\"",
        "question": "What are the names of organizations that contain the word \"Party\"?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering organizations based on their names containing the word \"Party\". We need to select the names of these organizations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Organizations' table and the 'organization_name' column.\n\n<3> SQL Generation: Use 'where' to filter organizations whose names contain the word \"Party\" and select their names.\n\nSQL query: SELECT organization_name FROM organizations WHERE organization_name LIKE \"%Party%\"",
        "predict": "SELECT organization_name FROM organizations WHERE organization_name LIKE \"%Party%\"",
        "hardness": "medium"
    },
    {
        "db_id": "school_bus",
        "gold": "SELECT party FROM driver WHERE home_city  =  'Hartford' AND age  >  40",
        "question": "Show the party with drivers from Hartford and drivers older than 40.",
        "fields": "Table driver, columns = [*,Driver_ID,Name,Party,Home_city,Age]\nTable school, columns = [*,School_ID,Grade,School,Location,Type]\nTable school_bus, columns = [*,School_ID,Driver_ID,Years_Working,If_full_time]\n",
        "foreign_keys": "Foreign_keys = [school_bus.Driver_ID = driver.Driver_ID,school_bus.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter drivers based on their home city and age. Secondly, we need to find the party of the selected drivers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Driver_ID from table 'driver' where Home_city = 'Hartford' and Age > 40. In the second step, we need to select Party from table 'driver' based on the Driver_ID obtained in the first step.\n\n<3> SQL Generation: Use 'where' to filter drivers based on their home city and age, and then use 'select' to find the party of the selected drivers.\n\nSQL query: SELECT party FROM driver WHERE home_city  =  'Hartford' AND age  >  40",
        "predict": "SELECT party FROM driver WHERE home_city  =  'Hartford' AND age  >  40",
        "hardness": "medium"
    },
    {
        "db_id": "school_bus",
        "gold": "SELECT name FROM driver WHERE driver_id NOT IN (SELECT driver_id FROM school_bus)",
        "question": "Show the names of the drivers without a school bus.",
        "fields": "Table driver, columns = [*,Driver_ID,Name,Party,Home_city,Age]\nTable school, columns = [*,School_ID,Grade,School,Location,Type]\nTable school_bus, columns = [*,School_ID,Driver_ID,Years_Working,If_full_time]\n",
        "foreign_keys": "Foreign_keys = [school_bus.Driver_ID = driver.Driver_ID,school_bus.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding drivers without a school bus. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'driver' table in this case.\n\n<3> SQL Generation: Use 'where' to filter drivers without a school bus.\n\nSQL query: SELECT name FROM driver WHERE driver_id NOT IN (SELECT driver_id FROM school_bus)",
        "predict": "SELECT name FROM driver WHERE driver_id NOT IN (SELECT driver_id FROM school_bus)",
        "hardness": "hard"
    },
    {
        "db_id": "school_bus",
        "gold": "SELECT school ,  TYPE FROM school WHERE school_id NOT IN (SELECT school_id FROM school_bus)",
        "question": "Show the school name and type for schools without a school bus.",
        "fields": "Table driver, columns = [*,Driver_ID,Name,Party,Home_city,Age]\nTable school, columns = [*,School_ID,Grade,School,Location,Type]\nTable school_bus, columns = [*,School_ID,Driver_ID,Years_Working,If_full_time]\n",
        "foreign_keys": "Foreign_keys = [school_bus.Driver_ID = driver.Driver_ID,school_bus.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding schools without a school bus. Firstly, we need to identify the schools that have a school bus. Secondly, we need to select the school name and type for schools that do not have a school bus.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'school' and table 'school_bus' have a direct foreign key relationship, we only need these two tables.\n\n<3> SQL Generation: We need to join the 'school' and 'school_bus' tables on the 'School_ID' column. Then, we filter the rows where there is no matching entry in the 'school_bus' table. Finally, we select the school name and type for these schools.\n\nSQL query: SELECT school ,  TYPE FROM school WHERE school_id NOT IN (SELECT school_id FROM school_bus)",
        "predict": "SELECT school ,  TYPE FROM school WHERE school_id NOT IN (SELECT school_id FROM school_bus)",
        "hardness": "extra"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT T3.ssn ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "question": "What are the SSN and names of scientists working on the project with the most hours?",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the project with the most hours. Secondly, we need to find the scientists working on that project and retrieve their SSN and names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the project code with the maximum hours from the 'Projects' table. In the second step, we need to join the 'AssignedTo' and 'Scientists' tables on the project code and scientist SSN, respectively, and retrieve the SSN and names of the scientists.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the project with the most hours, and then join the 'AssignedTo' and 'Scientists' tables on the project code and scientist SSN. Finally, select the SSN and names of the scientists.\n\nSQL query: SELECT T3.ssn ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "predict": "SELECT T3.ssn ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "hardness": "extra"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT Name FROM Projects WHERE Code NOT IN (SELECT Project FROM AssignedTo)",
        "question": "Select the project names which are not assigned yet.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: The query requires selecting project names that are not assigned yet. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to select project names, we only need the 'Projects' table.\n\n<3> SQL Generation: Use 'where' to filter projects that are not assigned yet.\n\nSQL query: SELECT Name FROM Projects WHERE Code NOT IN (SELECT Project FROM AssignedTo)",
        "predict": "SELECT Name FROM Projects WHERE Code NOT IN (SELECT Project FROM AssignedTo)",
        "hardness": "hard"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT Name FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "question": "Find the name of scientists who are not assigned to any project.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: The query requires finding scientists who are not assigned to any project. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of scientists from the 'Scientists' table who do not have corresponding entries in the 'AssignedTo' table.\n\n<3> SQL Generation: Use a left join to combine the 'Scientists' and 'AssignedTo' tables on the 'SSN' and 'Scientist' columns, respectively. Then, filter the rows where the 'Project' column is null (indicating that the scientist is not assigned to any project). Finally, select the names of the scientists.\n\nSQL query: SELECT Name FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "predict": "SELECT Name FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "hardness": "hard"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "question": "How many scientists do not have any projects assigned to them?",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: We need to find scientists who do not have any projects assigned to them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select scientists from the 'Scientists' table and filter out those who have projects assigned to them in the 'AssignedTo' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Scientists' and 'AssignedTo' tables on the 'SSN' column. Then, we can filter out the rows where the 'Project' column is null, indicating that no project is assigned to the scientist. Finally, we can count the number of scientists who meet this condition.\n\nSQL query: SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "predict": "SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT DISTINCT Name FROM WINE WHERE YEAR  <  2000 OR YEAR  >  2010",
        "question": "Give the distinct names of wines made before 2000 or after 2010.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines based on their year, selecting wines made before 2000 or after 2010. Secondly, we need to select the distinct names of the filtered wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Name' column from the 'wine' table, we only need to use the 'wine' table.\n\n<3> SQL Generation: Use 'where' to filter wines based on their year, selecting wines made before 2000 or after 2010. Then, use 'distinct' to select the distinct names of the filtered wines.\n\nSQL query: SELECT DISTINCT Name FROM WINE WHERE YEAR  <  2000 OR YEAR  >  2010",
        "predict": "SELECT DISTINCT Name FROM WINE WHERE YEAR  <  2000 OR YEAR  >  2010",
        "hardness": "medium"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "question": "What are the average prices and cases of wines produced in the year of 2009 and made of Zinfandel grape?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines based on their year and grape. Secondly, we need to calculate the average prices and cases of the selected wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select wines with year = 2009 and grape = 'Zinfandel' from table 'wine'. In the second step, we need to calculate the average prices and cases from table 'wine'.\n\n<3> SQL Generation: Use 'where' to filter wines with year = 2009 and grape = 'Zinfandel', and then use 'avg' to calculate the average prices and cases.\n\nSQL query: SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "predict": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "hardness": "hard"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "question": "Give the average price and case of wines made from Zinfandel grapes in the year 2009.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines based on the grape variety 'Zinfandel' and the year '2009'. Secondly, we need to calculate the average price and case count of the selected wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select price and cases from table 'wine' where grape = 'Zinfandel' and year = 2009.\n\n<3> SQL Generation: Use 'where' to filter wines based on grape and year, and then use 'avg' to calculate the average price and 'sum' to calculate the total cases.\n\nSQL query: SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "predict": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "hardness": "hard"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT Name FROM WINE WHERE YEAR  <  (SELECT min(YEAR) FROM WINE WHERE Winery  =  \"Brander\")",
        "question": "What are the names of wines whose production year are before the year of all wines by Brander winery?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the production year of all wines by Brander winery. Secondly, we need to filter wines whose production year is before the year found in the first step and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select production year from table 'wine' where winery = 'Brander'. In the second step, we need to filter wines based on their production year and select their names from table 'wine'.\n\n<3> SQL Generation: Use 'where' to find the production year of all wines by Brander winery, and then use 'where' to filter wines whose production year is before the year found in the first step and select their names.\n\nSQL query: SELECT Name FROM WINE WHERE YEAR  <  (SELECT min(YEAR) FROM WINE WHERE Winery  =  \"Brander\")",
        "predict": "SELECT Name FROM WINE WHERE YEAR  <  (SELECT min(YEAR) FROM WINE WHERE Winery  =  \"Brander\")",
        "hardness": "hard"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "question": "Find the average price of wines that are not produced from Sonoma county.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines that are not produced from Sonoma county. Secondly, we need to calculate the average price of the selected wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'wine' table and the 'appellations' table, we will use these two tables.\n\n<3> SQL Generation: Use 'where' to filter wines that are not produced from Sonoma county, and then use 'avg' to calculate the average price of the selected wines.\n\nSQL query: SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "predict": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "question": "What is the average price for wines not produced in Sonoma county?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on wines not produced in Sonoma county. Firstly, we need to identify the wines produced in Sonoma county. Secondly, we need to calculate the average price for wines that are not produced in Sonoma county.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Appelation from table 'appellations' where County = 'Sonoma'. In the second step, we need to filter wines based on their Appelation and calculate the average price.\n\n<3> SQL Generation: Use 'where' to filter wines produced in Sonoma county, and then use 'where' to filter wines that are not produced in Sonoma county and calculate the average price.\n\nSQL query: SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "predict": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "hardness": "extra"
    },
    {
        "db_id": "train_station",
        "gold": "SELECT T2.name FROM train_station AS T1 JOIN train AS T2 ON T1.train_id  =  T2.train_id WHERE T1.station_id NOT IN (SELECT T4.station_id FROM train_station AS T3 JOIN station AS T4 ON T3.station_id  =  T4.station_id WHERE t4.location  =  \"London\")",
        "question": "Find the names of the trains that do not pass any station located in London.",
        "fields": "Table station, columns = [*,Station_ID,Name,Annual_entry_exit,Annual_interchanges,Total_Passengers,Location,Main_Services,Number_of_Platforms]\nTable train, columns = [*,Train_ID,Name,Time,Service]\nTable train_station, columns = [*,Train_ID,Station_ID]\n",
        "foreign_keys": "Foreign_keys = [train_station.Station_ID = station.Station_ID,train_station.Train_ID = train.Train_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the stations located in London. Secondly, we need to filter the trains that do not pass any of these stations. Finally, we need to retrieve the names of these trains.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Station_ID from table 'station' where Location = 'London'. We also need to select Train_ID from table 'train_station' and filter by Station_ID.\n\n<3> SQL Generation: Use 'where' to filter stations located in London, and then use 'not in' to filter trains that do not pass any of these stations. Finally, select the names of these trains.\n\nSQL query: SELECT T2.name FROM train_station AS T1 JOIN train AS T2 ON T1.train_id  =  T2.train_id WHERE T1.station_id NOT IN (SELECT T4.station_id FROM train_station AS T3 JOIN station AS T4 ON T3.station_id  =  T4.station_id WHERE t4.location  =  \"London\")",
        "predict": "SELECT T2.name FROM train_station AS T1 JOIN train AS T2 ON T1.train_id  =  T2.train_id WHERE T1.station_id NOT IN (SELECT T4.station_id FROM train_station AS T3 JOIN station AS T4 ON T3.station_id  =  T4.station_id WHERE t4.location  =  \"London\")",
        "hardness": "extra"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT date_joined_staff FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";",
        "question": "When did the staff member with first name as Janessa and last name as Sawayn join the company?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the staff member with first name as Janessa and last name as Sawayn. Secondly, we need to retrieve the date they joined the company.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select date_joined_staff from table 'Staff' where first_name = Janessa and last_name = Sawayn.\n\n<3> SQL Generation: Use 'where' to find the staff member with first name as Janessa and last name as Sawayn, and then select the date they joined the company.\n\nSQL query: SELECT date_joined_staff FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";",
        "predict": "SELECT date_joined_staff FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";",
        "hardness": "medium"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Rylan\" AND T2.last_name = \"Goodwin\" AND T1.lesson_status_code = \"Completed\";",
        "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with first name 'Rylan' and last name 'Goodwin'. Secondly, we need to filter lessons based on the customer and lesson status code.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where first_name = 'Rylan' and last_name = 'Goodwin'. In the second step, we need to filter lesson_id from table 'Lessons' where customer_id matches the customer found in the first step and lesson_status_code is 'completed'.\n\n<3> SQL Generation: Use 'where' to find the customer with first name 'Rylan' and last name 'Goodwin', and then use 'where' to filter lessons based on the customer and lesson status code. Finally, count the number of lessons that meet these conditions.\n\nSQL query: SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Rylan\" AND T2.last_name = \"Goodwin\" AND T1.lesson_status_code = \"Completed\";",
        "predict": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Rylan\" AND T2.last_name = \"Goodwin\" AND T1.lesson_status_code = \"Completed\";",
        "hardness": "medium"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT count(*) FROM Lessons WHERE lesson_status_code = \"Cancelled\";",
        "question": "How many lessons were in cancelled state?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of lessons in the cancelled state.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the lesson_status_code from the Lessons table.\n\n<3> SQL Generation: Use 'where' to filter lessons with the lesson_status_code = 'cancelled' and count them.\n\nSQL query: SELECT count(*) FROM Lessons WHERE lesson_status_code = \"Cancelled\";",
        "predict": "SELECT count(*) FROM Lessons WHERE lesson_status_code = \"Cancelled\";",
        "hardness": "easy"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT sum(lesson_time) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "question": "How long is the total lesson time taught by staff with first name as Janessa and last name as Sawayn?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the staff with first name 'Janessa' and last name 'Sawayn'. Secondly, we need to calculate the total lesson time taught by these staff.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select staff_id from table 'Staff' where first_name = 'Janessa' and last_name = 'Sawayn'. In the second step, we need to filter lesson_time from table 'Lessons' based on the staff_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the staff with first name 'Janessa' and last name 'Sawayn', and then use 'sum' to calculate the total lesson time taught by these staff.\n\nSQL query: SELECT sum(lesson_time) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "predict": "SELECT sum(lesson_time) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "hardness": "medium"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Ray\"",
        "question": "How many lesson does customer with first name Ray took?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with first name Ray. Secondly, we need to count the number of lessons taken by that customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where first_name = 'Ray'. In the second step, we need to count the number of rows in table 'Lessons' where customer_id matches the customer_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer with first name Ray, and then use 'count' to count the number of lessons taken by that customer.\n\nSQL query: SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Ray\"",
        "predict": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Ray\"",
        "hardness": "medium"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT count(*) FROM Faculty WHERE Sex  =  'F' AND Rank  =  \"Professor\"",
        "question": "How many female Professors do we have?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Decomposition: We need to filter the professors based on their gender.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Sex' column from the 'Faculty' table.\n\n<3> SQL Generation: Use 'where' to filter the professors based on their gender and count them.\n\nSQL query: SELECT count(*) FROM Faculty WHERE Sex  =  'F' AND Rank  =  \"Professor\"",
        "predict": "SELECT count(*) FROM Faculty WHERE Sex  =  'F' AND Rank  =  \"Professor\"",
        "hardness": "medium"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  \"Linda\" AND T2.lname  =  \"Smith\"",
        "question": "Who is the advisor of Linda Smith? Give me the first name and last name.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name 'Linda Smith'. Secondly, we need to find the advisor of the student found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to select Fname and Lname from table 'Faculty' where FacID is the advisor of the student found in the first step.\n\n<3> SQL Generation: Use 'where' to find the student with the name 'Linda Smith', and then use 'where' to find the advisor of the student and select their first name and last name.\n\nSQL query: SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  \"Linda\" AND T2.lname  =  \"Smith\"",
        "predict": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  \"Linda\" AND T2.lname  =  \"Smith\"",
        "hardness": "extra"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "question": "What is the number of airlines based in Russia?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: We need to filter airlines based on their country, specifically Russia.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airlines' table and the 'country' column.\n\n<3> SQL Generation: Use 'where' to filter airlines based on their country being Russia, and then count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "predict": "SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "hardness": "easy"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM airports WHERE name LIKE '%International%'",
        "question": "How many airports' names have the word Interanation in them?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on airport names that contain the word \"Interanation\". We need to find the airports with names that match this criteria.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airports' table and the 'name' column.\n\n<3> SQL Generation: Use the 'LIKE' operator with the '%' wildcard to search for airport names that contain the word \"Interanation\". Then, use the 'COUNT' function to count the number of airports that match this criteria.\n\nSQL query: SELECT count(*) FROM airports WHERE name LIKE '%International%'",
        "predict": "SELECT count(*) FROM airports WHERE name LIKE '%International%'",
        "hardness": "medium"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "question": "In how many cities are there airports in the country of Greenland?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the airports in the country of Greenland. Secondly, we need to count the number of cities where these airports are located.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select apid from table 'airports' where country = 'Greenland'. In the second step, we need to select city from table 'airports' and count the distinct cities.\n\n<3> SQL Generation: Use 'where' to find the airports in the country of Greenland, and then use 'count' and 'distinct' to count the number of cities where these airports are located.\n\nSQL query: SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "predict": "SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "hardness": "easy"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'",
        "question": "What is the number of routes that end at John F Kennedy International Airport?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: The query requires finding routes that end at John F Kennedy International Airport. We need to filter routes based on their destination airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select routes that have the destination airport ID matching the ID of John F Kennedy International Airport.\n\n<3> SQL Generation: Use 'where' to filter routes based on the destination airport ID matching the ID of John F Kennedy International Airport.\n\nSQL query: SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'",
        "predict": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'",
        "hardness": "medium"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "question": "Find the number of routes from the United States to Canada.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the airports in the United States and Canada. Secondly, we need to filter routes based on their source and destination airports.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select apid from table 'airports' where country = 'United States' or country = 'Canada'. In the second step, we need to filter routes based on src_apid and dst_apid from table 'routes'.\n\n<3> SQL Generation: Use 'where' to filter airports in the United States and Canada, and then use 'where' to filter routes based on their source and destination airports. Finally, count the number of routes that meet these conditions.\n\nSQL query: SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "predict": "SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T2.order_id ,  T2.order_status FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "question": "Give me a list of id and status of orders which belong to the customer named \"Jeramie\".",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of the customer named \"Jeramie\". Secondly, we need to filter orders based on their customer_id and select the id and status columns.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_name = \"Jeramie\". In the second step, we need to filter order_id and order_status from table 'Orders' based on the customer_id.\n\n<3> SQL Generation: Use 'where' to find the customer_id of the customer named \"Jeramie\", and then use 'where' to filter orders based on their customer_id and select the id and status columns.\n\nSQL query: SELECT T2.order_id ,  T2.order_status FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "predict": "SELECT T2.order_id ,  T2.order_status FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T2.date_order_placed FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "question": "Find the dates of orders which belong to the customer named \"Jeramie\".",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of the customer named \"Jeramie\". Secondly, we need to filter orders based on their customer_id and select the dates of those orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_name = \"Jeramie\". In the second step, we need to filter order_id and date_order_placed from table 'Orders'.\n\n<3> SQL Generation: Use 'where' to find the customer_id of the customer named \"Jeramie\", and then use 'where' to filter orders based on their customer_id and select the dates of those orders.\n\nSQL query: SELECT T2.date_order_placed FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "predict": "SELECT T2.date_order_placed FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.date_order_placed >= \"2009-01-01\" AND T2.date_order_placed <= \"2010-01-01\"",
        "question": "Give me the names of customers who have placed orders between 2009-01-01 and 2010-01-01.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders based on their date_order_placed column, selecting only orders placed between 2009-01-01 and 2010-01-01. Secondly, we need to retrieve the names of the customers who placed these orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_name from the Customers table and filter orders based on the date_order_placed column in the Orders table.\n\n<3> SQL Generation: Use 'where' to filter orders placed between 2009-01-01 and 2010-01-01, and then join the Orders and Customers tables on the customer_id column to retrieve the customer names.\n\nSQL query: SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.date_order_placed >= \"2009-01-01\" AND T2.date_order_placed <= \"2010-01-01\"",
        "predict": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.date_order_placed >= \"2009-01-01\" AND T2.date_order_placed <= \"2010-01-01\"",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT DISTINCT T2.product_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id WHERE T1.date_order_placed >= \"1975-01-01\" AND T1.date_order_placed <= \"1976-01-01\"",
        "question": "Give me a list of distinct product ids from orders placed between 1975-01-01 and 1976-01-01?",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders based on the date_order_placed column between 1975-01-01 and 1976-01-01. Secondly, we need to select distinct product_ids from the filtered orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select product_id from the Order_Items table and filter by the order_id from the Orders table.\n\n<3> SQL Generation: Use 'where' to filter orders placed between 1975-01-01 and 1976-01-01, and then use 'distinct' to select unique product_ids from the filtered orders.\n\nSQL query: SELECT DISTINCT T2.product_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id WHERE T1.date_order_placed >= \"1975-01-01\" AND T1.date_order_placed <= \"1976-01-01\"",
        "predict": "SELECT DISTINCT T2.product_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id WHERE T1.date_order_placed >= \"1975-01-01\" AND T1.date_order_placed <= \"1976-01-01\"",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT order_id FROM shipments WHERE shipment_date > \"2000-01-01\"",
        "question": "Find the ids of orders which are shipped after 2000-01-01.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on orders that are shipped after a specific date. Firstly, we need to identify the orders that meet this condition. Secondly, we need to select the order ids of these orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select order_id from table 'Orders' and filter by shipment_date from table 'Shipments'.\n\n<3> SQL Generation: Use 'where' to filter orders that are shipped after 2000-01-01 and select the order ids.\n\nSQL query: SELECT order_id FROM shipments WHERE shipment_date > \"2000-01-01\"",
        "predict": "SELECT order_id FROM shipments WHERE shipment_date > \"2000-01-01\"",
        "hardness": "easy"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT count(*) FROM architect WHERE gender  =  'female'",
        "question": "How many architects are female?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of female architects.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'architect' table and the 'gender' column.\n\n<3> SQL Generation: Use 'where' to filter architects with gender = 'female' and count them.\n\nSQL query: SELECT count(*) FROM architect WHERE gender  =  'female'",
        "predict": "SELECT count(*) FROM architect WHERE gender  =  'female'",
        "hardness": "easy"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT name ,  built_year FROM mill WHERE TYPE  =  'Grondzeiler'",
        "question": "What are the names and year of construction for the mills of 'Grondzeiler' type?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter mills based on their type, specifically 'Grondzeiler'. Secondly, we need to select the names and construction years of the filtered mills.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'mill' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter mills of type 'Grondzeiler', and then select the names and construction years of the filtered mills.\n\nSQL query: SELECT name ,  built_year FROM mill WHERE TYPE  =  'Grondzeiler'",
        "predict": "SELECT name ,  built_year FROM mill WHERE TYPE  =  'Grondzeiler'",
        "hardness": "medium"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT LOCATION FROM bridge WHERE name  =  'Kolob Arch' OR name  =  'Rainbow Bridge'",
        "question": "What is the location of the bridge named 'Kolob Arch' or 'Rainbow Bridge'?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the bridges with names 'Kolob Arch' or 'Rainbow Bridge'. Secondly, we need to find the location of these bridges.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are only interested in the location of the bridges, we only need the 'bridge' table.\n\n<3> SQL Generation: Use 'where' to filter bridges with names 'Kolob Arch' or 'Rainbow Bridge' and select their locations.\n\nSQL query: SELECT LOCATION FROM bridge WHERE name  =  'Kolob Arch' OR name  =  'Rainbow Bridge'",
        "predict": "SELECT LOCATION FROM bridge WHERE name  =  'Kolob Arch' OR name  =  'Rainbow Bridge'",
        "hardness": "medium"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT DISTINCT T1.name FROM mill AS T1 JOIN architect AS t2 ON T1.architect_id  =  T2.id JOIN bridge AS T3 ON T3.architect_id  =  T2.id WHERE T3.length_meters  >  80",
        "question": "What are the distinct name of the mills built by the architects who have also built a bridge longer than 80 meters?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the architects who have built a bridge longer than 80 meters. Secondly, we need to find the mills built by these architects and select their distinct names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select architect_id from table 'bridge' where length_meters > 80. In the second step, we need to filter architect_id and name from table 'mill' and select distinct names.\n\n<3> SQL Generation: Use 'where' to find the architect_ids of the architects who have built a bridge longer than 80 meters. Then, use 'where' to filter mills built by these architects and select their distinct names.\n\nSQL query: SELECT DISTINCT T1.name FROM mill AS T1 JOIN architect AS t2 ON T1.architect_id  =  T2.id JOIN bridge AS T3 ON T3.architect_id  =  T2.id WHERE T3.length_meters  >  80",
        "predict": "SELECT DISTINCT T1.name FROM mill AS T1 JOIN architect AS t2 ON T1.architect_id  =  T2.id JOIN bridge AS T3 ON T3.architect_id  =  T2.id WHERE T3.length_meters  >  80",
        "hardness": "hard"
    },
    {
        "db_id": "culture_company",
        "gold": "SELECT avg(budget_million) ,  max(budget_million) ,  min(budget_million) FROM movie WHERE YEAR  <  2000",
        "question": "What is the average, maximum, and minimum budget for all movies before 2000.",
        "fields": "Table book_club, columns = [*,book_club_id,Year,Author_or_Editor,Book_Title,Publisher,Category,Result]\nTable culture_company, columns = [*,Company_name,Type,Incorporated_in,Group_Equity_Shareholding,book_club_id,movie_id]\nTable movie, columns = [*,movie_id,Title,Year,Director,Budget_million,Gross_worldwide]\n",
        "foreign_keys": "Foreign_keys = [culture_company.movie_id = movie.movie_id,culture_company.book_club_id = book_club.book_club_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter movies based on their release year. Secondly, we need to calculate the average, maximum, and minimum budget for the selected movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'movie' table, we can directly use it.\n\n<3> SQL Generation: Use 'where' to filter movies released before 2000, and then use 'avg', 'max', and 'min' functions to calculate the average, maximum, and minimum budget.\n\nSQL query: SELECT avg(budget_million) ,  max(budget_million) ,  min(budget_million) FROM movie WHERE YEAR  <  2000",
        "predict": "SELECT avg(budget_million) ,  max(budget_million) ,  min(budget_million) FROM movie WHERE YEAR  <  2000",
        "hardness": "medium"
    },
    {
        "db_id": "device",
        "predict": "SELECT avg(Quantity) FROM stock",
        "question": "Give the average quantity of stocks.",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n"
    },
    {
        "db_id": "news_report",
        "predict": "SELECT Nationality FROM journalist GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common nationality for journalists.",
        "fields": "Table event, columns = [*,Event_ID,Date,Venue,Name,Event_Attendance]\nTable journalist, columns = [*,journalist_ID,Name,Nationality,Age,Years_working]\nTable news_report, columns = [*,journalist_ID,Event_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [news_report.Event_ID = event.Event_ID,news_report.journalist_ID = journalist.journalist_ID]\n"
    },
    {
        "db_id": "soccer_2",
        "predict": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1",
        "question": "What was the most popular position at tryouts?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n"
    },
    {
        "db_id": "film_rank",
        "predict": "SELECT Studio ,  COUNT(*) FROM film GROUP BY Studio",
        "question": "How films are produced by each studio?",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n"
    },
    {
        "db_id": "tracking_grants_for_research",
        "predict": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'",
        "question": "What are the details of the project that is producing both patents and papers as outcomes?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n"
    },
    {
        "db_id": "hospital_1",
        "predict": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  \"Thesisin\"",
        "question": "What is the names of the physicians who prescribe medication Thesisin?",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n"
    },
    {
        "db_id": "activity_1",
        "predict": "SELECT rank ,  sex ,  count(*) FROM Faculty GROUP BY rank ,  sex",
        "question": "Show all the ranks and the number of male and female faculty for each rank.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n"
    },
    {
        "db_id": "network_2",
        "predict": "SELECT avg(age) ,  job FROM Person WHERE gender  =  'male' GROUP BY job",
        "question": "What is average age of male for different job title?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n"
    },
    {
        "db_id": "hospital_1",
        "predict": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  \"John Wen\"",
        "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n"
    },
    {
        "db_id": "soccer_1",
        "predict": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)",
        "question": "What are the names of players who have the best dribbling?",
        "fields": "Table Country, columns = [*,id,name]\nTable League, columns = [*,id,country_id,name]\nTable Player, columns = [*,id,player_api_id,player_name,player_fifa_api_id,birthday,height,weight]\nTable Player_Attributes, columns = [*,id,player_fifa_api_id,player_api_id,date,overall_rating,potential,preferred_foot,attacking_work_rate,defensive_work_rate,crossing,finishing,heading_accuracy,short_passing,volleys,dribbling,curve,free_kick_accuracy,long_passing,ball_control,acceleration,sprint_speed,agility,reactions,balance,shot_power,jumping,stamina,strength,long_shots,aggression,interceptions,positioning,vision,penalties,marking,standing_tackle,sliding_tackle,gk_diving,gk_handling,gk_kicking,gk_positioning,gk_reflexes]\nTable Team, columns = [*,id,team_api_id,team_fifa_api_id,team_long_name,team_short_name]\nTable Team_Attributes, columns = [*,id,team_fifa_api_id,team_api_id,date,buildUpPlaySpeed,buildUpPlaySpeedClass,buildUpPlayDribbling,buildUpPlayDribblingClass,buildUpPlayPassing,buildUpPlayPassingClass,buildUpPlayPositioningClass,chanceCreationPassing,chanceCreationPassingClass,chanceCreationCrossing,chanceCreationCrossingClass,chanceCreationShooting,chanceCreationShootingClass,chanceCreationPositioningClass,defencePressure,defencePressureClass,defenceAggression,defenceAggressionClass,defenceTeamWidth,defenceTeamWidthClass,defenceDefenderLineClass]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "foreign_keys": "Foreign_keys = [Player_Attributes.player_api_id = Player.player_api_id,Player_Attributes.player_fifa_api_id = Player.player_fifa_api_id,League.country_id = Country.id,Team_Attributes.team_api_id = Team.team_api_id,Team_Attributes.team_fifa_api_id = Team.team_fifa_api_id]\n"
    },
    {
        "db_id": "music_2",
        "predict": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Badlands\"",
        "question": "How many instruments does the song \"Badlands\" use?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n"
    },
    {
        "db_id": "company_office",
        "predict": "SELECT name FROM Companies ORDER BY Market_Value_billion DESC",
        "question": "Sort the company names in descending order of the company's market value.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n"
    },
    {
        "db_id": "products_gen_characteristics",
        "predict": "SELECT count(*) FROM products WHERE product_category_code  =  \"Seeds\"",
        "question": "Count the number of products in the category 'Seeds'.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT max(stars) ,  min(stars) FROM Rating",
        "question": "What is the maximum and mininum number of stars a rating can receive?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "chinook_1",
        "predict": "SELECT BirthDate FROM EMPLOYEE WHERE City  =  \"Edmonton\"",
        "question": "Find the birth dates corresponding to employees who live in the city of Edmonton.",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n"
    },
    {
        "db_id": "twitter_1",
        "predict": "SELECT name FROM user_profiles WHERE email LIKE '%superstar%' OR email LIKE '%edu%'",
        "question": "Find the names of users whose emails contain superstar or edu.",
        "fields": "Table follows, columns = [*,f1,f2]\nTable tweets, columns = [*,id,uid,text,createdate]\nTable user_profiles, columns = [*,uid,name,email,partitionid,followers]\n",
        "foreign_keys": "Foreign_keys = [follows.f2 = user_profiles.uid,follows.f1 = user_profiles.uid,tweets.uid = user_profiles.uid]\n"
    },
    {
        "db_id": "sports_competition",
        "predict": "SELECT Competition_type ,  COUNT(*) FROM competition GROUP BY Competition_type",
        "question": "What are the types of competition and number of competitions for that type?",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n"
    },
    {
        "db_id": "party_host",
        "predict": "SELECT Nationality FROM HOST WHERE Age  >  45 INTERSECT SELECT Nationality FROM HOST WHERE Age  <  35",
        "question": "Show the nations that have both hosts older than 45 and hosts younger than 35.",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n"
    },
    {
        "db_id": "scientist_1",
        "predict": "SELECT Name FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "question": "Find the name of scientists who are not assigned to any project.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "question": "How many movies were made before 2000?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "student_1",
        "predict": "SELECT T2.firstname ,  T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"EVELINA\" AND T1.lastname  =  \"BROMLEY\"",
        "question": "Which teachers teach the student named EVELINA BROMLEY? Give me the first and last name  of the teachers.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n"
    },
    {
        "db_id": "apartment_rentals",
        "predict": "SELECT count(*) FROM Apartment_Bookings",
        "question": "How many apartment bookings are there in total?",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n"
    },
    {
        "db_id": "cinema",
        "predict": "SELECT title ,  directed_by FROM film",
        "question": "What are the title and director of each film?",
        "fields": "Table cinema, columns = [*,Cinema_ID,Name,Openning_year,Capacity,Location]\nTable film, columns = [*,Film_ID,Rank_in_series,Number_in_season,Title,Directed_by,Original_air_date,Production_code]\nTable schedule, columns = [*,Cinema_ID,Film_ID,Date,Show_times_per_day,Price]\n",
        "foreign_keys": "Foreign_keys = [schedule.Cinema_ID = cinema.Cinema_ID,schedule.Film_ID = film.Film_ID]\n"
    },
    {
        "db_id": "phone_1",
        "predict": "SELECT DISTINCT T2.Hardware_Model_name , T2.Company_name FROM screen_mode AS T1 JOIN phone AS T2 ON T1.Graphics_mode = T2.screen_mode WHERE T1.used_kb BETWEEN 10 AND 15;",
        "question": "List the phone hardware model and company name for the phones whose screen usage in kb is between 10 and 15.",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n"
    },
    {
        "db_id": "county_public_safety",
        "predict": "SELECT T1.White ,  T2.Crime_rate FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID  =  T2.County_ID",
        "question": "What are the white percentages of cities, and the corresponding crime rates of the counties they correspond to?",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n"
    },
    {
        "db_id": "tracking_grants_for_research",
        "predict": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )",
        "question": "Which projects have no outcome? List the project details.",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n"
    },
    {
        "db_id": "game_injury",
        "predict": "SELECT max(home_games) ,  min(home_games) ,  avg(home_games) FROM stadium",
        "question": "What are the maximum, minimum and average home games each stadium held?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n"
    },
    {
        "db_id": "customers_and_invoices",
        "predict": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'",
        "question": "What are the ids, names, dates of opening, and other details for accounts corresponding to the customer with the first name \"Meaghan\"?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n"
    },
    {
        "db_id": "wine_1",
        "predict": "SELECT Price FROM WINE WHERE YEAR  <  2010",
        "question": "What are the prices of wines produced before the year of 2010?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n"
    },
    {
        "db_id": "voter_2",
        "predict": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  \"2192\"",
        "question": "What are the distinct last names of the students who have president votes but do not have 2192 as the advisor?",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n"
    },
    {
        "db_id": "insurance_policies",
        "predict": "SELECT Payment_Method_Code ,  Date_Payment_Made ,  Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC",
        "question": "What are the method, date and amount of each payment? Sort the list in ascending order of date.",
        "fields": "Table Claims, columns = [*,Claim_ID,Policy_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled]\nTable Customer_Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Payments, columns = [*,Payment_ID,Settlement_ID,Payment_Method_Code,Date_Payment_Made,Amount_Payment]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled,Customer_Policy_ID]\n",
        "foreign_keys": "Foreign_keys = [Customer_Policies.Customer_ID = Customers.Customer_ID,Claims.Policy_ID = Customer_Policies.Policy_ID,Settlements.Claim_ID = Claims.Claim_ID,Payments.Settlement_ID = Settlements.Settlement_ID]\n"
    },
    {
        "db_id": "assets_maintenance",
        "predict": "SELECT asset_model FROM Assets WHERE asset_id NOT IN (SELECT asset_id FROM Fault_Log)",
        "question": "Which assets did not incur any fault log? List the asset model.",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n"
    },
    {
        "db_id": "epinions_1",
        "predict": "SELECT T1.name ,  avg(trust) FROM useracct AS T1 JOIN trust AS T2 ON T1.u_id  =  T2.target_u_id GROUP BY T2.target_u_id",
        "question": "Find each target user's name and average trust score.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n"
    },
    {
        "db_id": "program_share",
        "predict": "SELECT name FROM channel WHERE OWNER != 'CCTV'",
        "question": "Find the names of channels that are not owned by CCTV.",
        "fields": "Table broadcast, columns = [*,Channel_ID,Program_ID,Time_of_day]\nTable broadcast_share, columns = [*,Channel_ID,Program_ID,Date,Share_in_percent]\nTable channel, columns = [*,Channel_ID,Name,Owner,Share_in_percent,Rating_in_percent]\nTable program, columns = [*,Program_ID,Name,Origin,Launch,Owner]\n",
        "foreign_keys": "Foreign_keys = [broadcast.Program_ID = program.Program_ID,broadcast.Channel_ID = channel.Channel_ID,broadcast_share.Program_ID = program.Program_ID,broadcast_share.Channel_ID = channel.Channel_ID]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the movie that has been reviewed the most?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "twitter_1",
        "predict": "SELECT name ,  email FROM user_profiles WHERE name LIKE '%Swift%'",
        "question": "Find the name and email of the user whose name contains the word Swift.",
        "fields": "Table follows, columns = [*,f1,f2]\nTable tweets, columns = [*,id,uid,text,createdate]\nTable user_profiles, columns = [*,uid,name,email,partitionid,followers]\n",
        "foreign_keys": "Foreign_keys = [follows.f2 = user_profiles.uid,follows.f1 = user_profiles.uid,tweets.uid = user_profiles.uid]\n"
    },
    {
        "db_id": "wine_1",
        "predict": "SELECT DISTINCT Name FROM WINE WHERE YEAR  <  2000 OR YEAR  >  2010",
        "question": "Give the distinct names of wines made before 2000 or after 2010.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n"
    },
    {
        "db_id": "party_host",
        "predict": "SELECT LOCATION FROM party ORDER BY Number_of_hosts DESC LIMIT 1",
        "question": "What is the location of the party with the most hosts?",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n"
    },
    {
        "db_id": "flight_4",
        "predict": "SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "question": "How many different cities do have some airport in the country of Greenland?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n"
    },
    {
        "db_id": "wine_1",
        "predict": "SELECT Grape ,  Appelation FROM WINE",
        "question": "What are the grapes and appelations of each wine?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n"
    },
    {
        "db_id": "debate",
        "predict": "SELECT T2.Name FROM debate_people AS T1 JOIN people AS T2 ON T1.Negative  =  T2.People_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2",
        "question": "Show the names of people who have been on the negative side of debates at least twice.",
        "fields": "Table debate, columns = [*,Debate_ID,Date,Venue,Num_of_Audience]\nTable debate_people, columns = [*,Debate_ID,Affirmative,Negative,If_Affirmative_Win]\nTable people, columns = [*,People_ID,District,Name,Party,Age]\n",
        "foreign_keys": "Foreign_keys = [debate_people.Negative = people.People_ID,debate_people.Affirmative = people.People_ID,debate_people.Debate_ID = debate.Debate_ID]\n"
    },
    {
        "db_id": "party_host",
        "predict": "SELECT avg(Number_of_hosts) FROM party",
        "question": "What is the average number of hosts for parties?",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n"
    },
    {
        "db_id": "manufactory_1",
        "predict": "SELECT avg(revenue) ,  max(revenue) ,  sum(revenue) FROM manufacturers",
        "question": "Return the average, maximum, and total revenues across all manufacturers.",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n"
    },
    {
        "db_id": "flight_4",
        "predict": "SELECT name ,  city ,  country FROM airports ORDER BY elevation LIMIT 1",
        "question": "Find the name, city, and country of the airport that has the lowest altitude.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n"
    },
    {
        "db_id": "products_for_hire",
        "predict": "SELECT payment_date FROM payments WHERE amount_paid  >  300 OR payment_type_code  =  'Check'",
        "question": "What are the payment date of the payment with amount paid higher than 300 or with payment type is 'Check'",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n"
    },
    {
        "db_id": "loan_1",
        "predict": "SELECT cust_name FROM customer WHERE acc_type  =  'saving' INTERSECT SELECT cust_name FROM customer WHERE acc_type  =  'checking'",
        "question": "What are the names of customers who have both savings and checking accounts?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n"
    },
    {
        "db_id": "music_2",
        "predict": "SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Badlands\"",
        "question": "What instruments did the musician with the last name \"Heilo\" play in \"Badlands\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n"
    },
    {
        "db_id": "bike_1",
        "predict": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE \"12/%\"",
        "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n"
    },
    {
        "db_id": "swimming",
        "predict": "SELECT t1.name ,  t1.nationality FROM swimmer AS t1 JOIN record AS t2 ON t1.id  =  t2.swimmer_id WHERE RESULT  =  'Win' GROUP BY t2.swimmer_id HAVING count(*)  >  1",
        "question": "Find the name and nationality of the swimmer who has won (i.e., has a result of \"win\") more than 1 time.",
        "fields": "Table event, columns = [*,ID,Name,Stadium_ID,Year]\nTable record, columns = [*,ID,Result,Swimmer_ID,Event_ID]\nTable stadium, columns = [*,ID,name,Capacity,City,Country,Opening_year]\nTable swimmer, columns = [*,ID,name,Nationality,meter_100,meter_200,meter_300,meter_400,meter_500,meter_600,meter_700,Time]\n",
        "foreign_keys": "Foreign_keys = [event.Stadium_ID = stadium.ID,record.Swimmer_ID = swimmer.ID,record.Event_ID = event.ID]\n"
    },
    {
        "db_id": "swimming",
        "predict": "SELECT name FROM event ORDER BY YEAR DESC LIMIT 1",
        "question": "What is the name of the event that happened in the most recent year?",
        "fields": "Table event, columns = [*,ID,Name,Stadium_ID,Year]\nTable record, columns = [*,ID,Result,Swimmer_ID,Event_ID]\nTable stadium, columns = [*,ID,name,Capacity,City,Country,Opening_year]\nTable swimmer, columns = [*,ID,name,Nationality,meter_100,meter_200,meter_300,meter_400,meter_500,meter_600,meter_700,Time]\n",
        "foreign_keys": "Foreign_keys = [event.Stadium_ID = stadium.ID,record.Swimmer_ID = swimmer.ID,record.Event_ID = event.ID]\n"
    },
    {
        "db_id": "entrepreneur",
        "predict": "SELECT T2.Name FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID",
        "question": "Return the names of entrepreneurs.",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "college_3",
        "predict": "SELECT count(*) FROM COURSE",
        "question": "Count the number of courses.",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n"
    },
    {
        "db_id": "baseball_1",
        "predict": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );",
        "question": "How many times in total did the team Boston Red Stockings participate in postseason games?",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "predict": "SELECT account_id ,  account_details FROM Accounts",
        "question": "What are the ids and details of all accounts?",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n"
    },
    {
        "db_id": "network_2",
        "predict": "SELECT name FROM Person WHERE gender  =  'male' AND age  =  (SELECT min(age) FROM person WHERE gender  =  'male' )",
        "question": "Who is the youngest male?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n"
    },
    {
        "db_id": "university_basketball",
        "predict": "SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "question": "Find how many school locations have the word 'NY'.",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)",
        "question": "What are the names of students who took a course in the Fall of 2003?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "sports_competition",
        "predict": "SELECT count(DISTINCT POSITION) FROM player",
        "question": "how many different positions are there?",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n"
    },
    {
        "db_id": "program_share",
        "predict": "SELECT name FROM channel WHERE OWNER  =  'CCTV' OR OWNER  =  'HBS'",
        "question": "List the names of all the channels owned by either CCTV or HBS",
        "fields": "Table broadcast, columns = [*,Channel_ID,Program_ID,Time_of_day]\nTable broadcast_share, columns = [*,Channel_ID,Program_ID,Date,Share_in_percent]\nTable channel, columns = [*,Channel_ID,Name,Owner,Share_in_percent,Rating_in_percent]\nTable program, columns = [*,Program_ID,Name,Origin,Launch,Owner]\n",
        "foreign_keys": "Foreign_keys = [broadcast.Program_ID = program.Program_ID,broadcast.Channel_ID = channel.Channel_ID,broadcast_share.Program_ID = program.Program_ID,broadcast_share.Channel_ID = channel.Channel_ID]\n"
    },
    {
        "db_id": "manufacturer",
        "predict": "SELECT name ,  open_year FROM manufacturer WHERE num_of_shops  >  10 OR Num_of_Factories  <  10",
        "question": "Give me the name and year of opening of the manufacturers that have either less than 10 factories or more than 10 shops.",
        "fields": "Table furniture, columns = [*,Furniture_ID,Name,Num_of_Component,Market_Rate]\nTable furniture_manufacte, columns = [*,Manufacturer_ID,Furniture_ID,Price_in_Dollar]\nTable manufacturer, columns = [*,Manufacturer_ID,Open_Year,Name,Num_of_Factories,Num_of_Shops]\n",
        "foreign_keys": "Foreign_keys = [furniture_manufacte.Furniture_ID = furniture.Furniture_ID,furniture_manufacte.Manufacturer_ID = manufacturer.Manufacturer_ID]\n"
    },
    {
        "db_id": "formula_1",
        "predict": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN results AS T2 ON T1.driverid = T2.driverid JOIN races AS T3 ON T2.raceid = T3.raceid GROUP BY T1.driverid ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the id and surname of the driver who participated the most number of races?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n"
    },
    {
        "db_id": "station_weather",
        "predict": "SELECT train_number ,  name FROM train ORDER BY TIME",
        "question": "show all train numbers and names ordered by their time from early to late.",
        "fields": "Table route, columns = [*,train_id,station_id]\nTable station, columns = [*,id,network_name,services,local_authority]\nTable train, columns = [*,id,train_number,name,origin,destination,time,interval]\nTable weekly_weather, columns = [*,station_id,day_of_week,high_temperature,low_temperature,precipitation,wind_speed_mph]\n",
        "foreign_keys": "Foreign_keys = [route.station_id = station.id,route.train_id = train.id,weekly_weather.station_id = station.id]\n"
    },
    {
        "db_id": "insurance_and_eClaims",
        "predict": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers",
        "question": "Find the total and average amount paid in claim headers.",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n"
    },
    {
        "db_id": "tracking_orders",
        "predict": "SELECT T1.order_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id GROUP BY T1.order_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id of the order which has the most items?",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n"
    },
    {
        "db_id": "store_1",
        "predict": "SELECT title FROM albums ORDER BY title;",
        "question": "List every album ordered by album title in ascending order.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "predict": "SELECT T1.Marketing_Region_Name FROM Marketing_Regions AS T1 JOIN Stores AS T2 ON T1.Marketing_Region_Code  =  T2.Marketing_Region_Code WHERE T2.Store_Name  =  \"Rob Dinning\"",
        "question": "What is the name of the marketing region that the store Rob Dinning belongs to?",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT name FROM instructor WHERE dept_name  =  'Statistics' ORDER BY salary LIMIT 1",
        "question": "what is the name of the instructor who is in Statistics department and earns the lowest salary?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "insurance_fnol",
        "predict": "SELECT count(*) FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "question": "How many policies are listed for the customer named \"Dayana Robel\"?",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n"
    },
    {
        "db_id": "coffee_shop",
        "predict": "SELECT count(*) FROM member WHERE address != 'Hartford'",
        "question": "How many members are not living in Hartford?",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n"
    },
    {
        "db_id": "wrestler",
        "predict": "SELECT T2.Name ,  T1.Team FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID ORDER BY T2.Days_held DESC",
        "question": "What are the names of wrestlers and their teams in elimination, ordered descending by days held?",
        "fields": "Table Elimination, columns = [*,Elimination_ID,Wrestler_ID,Team,Eliminated_By,Elimination_Move,Time]\nTable wrestler, columns = [*,Wrestler_ID,Name,Reign,Days_held,Location,Event]\n",
        "foreign_keys": "Foreign_keys = [Elimination.Wrestler_ID = wrestler.Wrestler_ID]\n"
    },
    {
        "db_id": "voter_2",
        "predict": "SELECT count(*) FROM VOTING_RECORD",
        "question": "Find the number of voting records in total.",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n"
    },
    {
        "db_id": "activity_1",
        "predict": "SELECT DISTINCT rank FROM Faculty",
        "question": "Find the list of distinct ranks for faculty.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n"
    },
    {
        "db_id": "soccer_2",
        "predict": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'",
        "question": "How many students whose are playing the role of goalie?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "predict": "SELECT T1.Service_Type_Description , T1.Service_Type_Code FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code GROUP BY T1.Service_Type_Code ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Find the description and code of the service type that is performed the most times.",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n"
    },
    {
        "db_id": "theme_gallery",
        "predict": "SELECT T2.theme ,  T1.date ,  T1.attendance FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T2.year  =  2004",
        "question": "Return the themes, dates, and attendance for exhibitions that happened in 2004.",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n"
    },
    {
        "db_id": "music_2",
        "predict": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the last name of the musician that have produced the most number of songs?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n"
    },
    {
        "db_id": "machine_repair",
        "predict": "SELECT Starting_Year FROM technician WHERE Team  =  \"CLE\" INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  \"CWS\"",
        "question": "Show the starting years shared by technicians from team \"CLE\" and \"CWS\".",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n"
    },
    {
        "db_id": "store_1",
        "predict": "SELECT title FROM albums;",
        "question": "List every album's title.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n"
    },
    {
        "db_id": "flight_4",
        "predict": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the name and city of the airport which is the destination of the most number of routes.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "predict": "SELECT Product_Name FROM PRODUCTS ORDER BY Product_Price DESC LIMIT 1",
        "question": "Tell me the name of the most pricy product.",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n"
    },
    {
        "db_id": "farm",
        "predict": "SELECT T2.Year ,  T1.Official_Name FROM city AS T1 JOIN farm_competition AS T2 ON T1.City_ID  =  T2.Host_city_ID",
        "question": "Give the years and official names of the cities of each competition.",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n"
    },
    {
        "db_id": "customers_card_transactions",
        "predict": "SELECT other_account_details FROM Accounts WHERE account_name  =  \"338\"",
        "question": "Show other account details for account with name 338.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n"
    },
    {
        "db_id": "flight_4",
        "predict": "SELECT city FROM airports GROUP BY city HAVING count(*)  =  2",
        "question": "Find the cities which have exactly two airports.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n"
    },
    {
        "db_id": "entrepreneur",
        "predict": "SELECT T2.Name FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Investor != \"Rachel Elnaugh\"",
        "question": "Return the names of entrepreneurs do no not have the investor Rachel Elnaugh.",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "predict": "SELECT T3.location_name FROM All_documents AS T1 JOIN Document_locations AS T2 ON T1.document_id  =  T2.document_id JOIN Ref_locations AS T3 ON T2.location_code  =  T3.location_code WHERE T1.document_name  =  \"Robin CV\"",
        "question": "Show the location name for document \"Robin CV\".",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n"
    },
    {
        "db_id": "student_1",
        "predict": "SELECT DISTINCT classroom ,  grade FROM list",
        "question": "For each classroom report the grade that is taught in it. Report just the classroom number and the grade number.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n"
    },
    {
        "db_id": "school_finance",
        "predict": "SELECT count(*) FROM budget WHERE budgeted  >  3000 AND YEAR  <=  2001",
        "question": "How many budgets are above 3000 in year 2001 or before?",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n"
    },
    {
        "db_id": "flight_4",
        "predict": "SELECT rid FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'United States') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "question": "What is the id of the routes whose source and destination airports are in the United States?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n"
    },
    {
        "db_id": "store_product",
        "predict": "SELECT District_name ,  City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000",
        "question": "What are the district names and city populations for all districts that between 200,000 and 2,000,000 residents?",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n"
    },
    {
        "db_id": "college_1",
        "predict": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'",
        "question": "What are the first names of all students who got a grade C in a class?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "predict": "SELECT count(*) FROM Ref_locations",
        "question": "How many locations are listed in the database?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n"
    },
    {
        "db_id": "loan_1",
        "predict": "SELECT sum(no_of_customers) FROM bank WHERE city  =  'New York City'",
        "question": "What is the total number of customers who use banks in New York City?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  \"Female\" AND T2.languages  =  \"bangla\"",
        "question": "What is the country of origin of the artist who is female and produced a song in Bangla?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "csu_1",
        "predict": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200",
        "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n"
    },
    {
        "db_id": "race_track",
        "predict": "SELECT LOCATION FROM track WHERE seating  >  90000 INTERSECT SELECT LOCATION FROM track WHERE seating  <  70000",
        "question": "Find the locations where have both tracks with more than 90000 seats and tracks with less than 70000 seats.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n"
    },
    {
        "db_id": "restaurant_1",
        "predict": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major = 600;",
        "question": "Which student's age is older than 18 and is majoring in 600? List each student's first and last name.",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n"
    },
    {
        "db_id": "soccer_2",
        "predict": "SELECT DISTINCT state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName",
        "question": "Find the states where have some college students in tryout.",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is",
        "question": "What is the shortest and most poorly rated song for each genre, ordered alphabetically by genre?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "flight_4",
        "predict": "SELECT max(elevation) FROM airports WHERE country  =  'Iceland'",
        "question": "What is the highest elevation of an airport in the country of Iceland?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n"
    },
    {
        "db_id": "aircraft",
        "predict": "SELECT International_Passengers ,  Domestic_Passengers FROM airport WHERE Airport_Name  =  \"London Heathrow\"",
        "question": "What are the number of international and domestic passengers of the airport named London \"Heathrow\"?",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n"
    },
    {
        "db_id": "college_3",
        "predict": "SELECT DName FROM DEPARTMENT EXCEPT SELECT T1.DName FROM DEPARTMENT AS T1 JOIN MINOR_IN AS T2 ON T1.DNO  =  T2.DNO",
        "question": "Find the name of the department that has no students minored in?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n"
    },
    {
        "db_id": "musical",
        "predict": "SELECT T1.Name ,  T2.Name FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID  =  T2.Musical_ID",
        "question": "Show names of actors and names of musicals they are in.",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n"
    },
    {
        "db_id": "party_people",
        "predict": "SELECT minister ,  took_office ,  left_office FROM party ORDER BY left_office",
        "question": "Who are the ministers, when did they take office, and when did they leave office, ordered by when they left office?",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "predict": "SELECT count(*) FROM CUSTOMERS",
        "question": "Count the number of customers recorded.",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n"
    },
    {
        "db_id": "driving_school",
        "predict": "SELECT count(*) FROM Staff;",
        "question": "How many staff in total?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n"
    },
    {
        "db_id": "club_1",
        "predict": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Davis\" AND t3.lname  =  \"Steven\"",
        "question": "What are the names of the clubs that have \"Davis Steven\" as a member?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n"
    },
    {
        "db_id": "customer_deliveries",
        "predict": "SELECT t1.customer_name ,  t1.customer_phone FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'",
        "question": "Find the names and phone numbers of customers living in California state.",
        "fields": "Table Actual_Order_Products, columns = [*,actual_order_id,product_id]\nTable Actual_Orders, columns = [*,actual_order_id,order_status_code,regular_order_id,actual_order_date]\nTable Addresses, columns = [*,address_id,address_details,city,zip_postcode,state_province_county,country]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,address_type,date_to]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,date_became_customer]\nTable Delivery_Route_Locations, columns = [*,location_code,route_id,location_address_id,location_name]\nTable Delivery_Routes, columns = [*,route_id,route_name,other_route_details]\nTable Employees, columns = [*,employee_id,employee_address_id,employee_name,employee_phone]\nTable Order_Deliveries, columns = [*,location_code,actual_order_id,delivery_status_code,driver_employee_id,truck_id,delivery_date]\nTable Products, columns = [*,product_id,product_name,product_price,product_description]\nTable Regular_Order_Products, columns = [*,regular_order_id,product_id]\nTable Regular_Orders, columns = [*,regular_order_id,distributer_id]\nTable Trucks, columns = [*,truck_id,truck_licence_number,truck_details]\n",
        "foreign_keys": "Foreign_keys = [Regular_Orders.distributer_id = Customers.customer_id,Regular_Order_Products.regular_order_id = Regular_Orders.regular_order_id,Regular_Order_Products.product_id = Products.product_id,Actual_Orders.regular_order_id = Regular_Orders.regular_order_id,Actual_Order_Products.actual_order_id = Actual_Orders.actual_order_id,Actual_Order_Products.product_id = Products.product_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Delivery_Route_Locations.route_id = Delivery_Routes.route_id,Delivery_Route_Locations.location_address_id = Addresses.address_id,Employees.employee_address_id = Addresses.address_id,Order_Deliveries.driver_employee_id = Employees.employee_id,Order_Deliveries.location_code = Delivery_Route_Locations.location_code,Order_Deliveries.actual_order_id = Actual_Orders.actual_order_id,Order_Deliveries.truck_id = Trucks.truck_id]\n"
    },
    {
        "db_id": "e_learning",
        "predict": "SELECT T1.address_line_1 ,  T2.author_id FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id GROUP BY T2.author_id HAVING Count(*)  >=  2",
        "question": "Find the addresses and author IDs of the course authors that teach at least two courses.",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n"
    },
    {
        "db_id": "college_3",
        "predict": "SELECT Fname FROM STUDENT ORDER BY Age DESC",
        "question": "Find the first name of students in the descending order of age.",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')",
        "question": "What are the names of students who haven't taken any Biology courses?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "cre_Theme_park",
        "predict": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'",
        "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n"
    },
    {
        "db_id": "railway",
        "predict": "SELECT Wheels ,  LOCATION FROM railway",
        "question": "List the wheels and locations of the railways.",
        "fields": "Table manager, columns = [*,Manager_ID,Name,Country,Working_year_starts,Age,Level]\nTable railway, columns = [*,Railway_ID,Railway,Builder,Built,Wheels,Location,ObjectNumber]\nTable railway_manage, columns = [*,Railway_ID,Manager_ID,From_Year]\nTable train, columns = [*,Train_ID,Train_Num,Name,From,Arrival,Railway_ID]\n",
        "foreign_keys": "Foreign_keys = [train.Railway_ID = railway.Railway_ID,railway_manage.Railway_ID = railway.Railway_ID,railway_manage.Manager_ID = manager.Manager_ID]\n"
    },
    {
        "db_id": "phone_market",
        "predict": "SELECT T2.Name FROM phone_market AS T1 JOIN phone AS T2 ON T1.Phone_ID  =  T2.Phone_ID GROUP BY T2.Name HAVING sum(T1.Num_of_stock)  >=  2000 ORDER BY sum(T1.Num_of_stock) DESC",
        "question": "Show the names of phones that have total number of stocks bigger than 2000, in descending order of the total number of stocks.",
        "fields": "Table market, columns = [*,Market_ID,District,Num_of_employees,Num_of_shops,Ranking]\nTable phone, columns = [*,Name,Phone_ID,Memory_in_G,Carrier,Price]\nTable phone_market, columns = [*,Market_ID,Phone_ID,Num_of_stock]\n",
        "foreign_keys": "Foreign_keys = [phone_market.Phone_ID = phone.Phone_ID,phone_market.Market_ID = market.Market_ID]\n"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "predict": "SELECT T2.Store_Name FROM Addresses AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Address_ID  =  T2.Address_ID WHERE T1.City_Town  =  \"Feliciaberg\"",
        "question": "Return the the names of the drama workshop groups that are located in Feliciaberg city.",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n"
    },
    {
        "db_id": "sports_competition",
        "predict": "SELECT T1.name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T2.Position  =  \"Right Wing\"",
        "question": "Show the names of clubs that have players with position \"Right Wing\".",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n"
    },
    {
        "db_id": "soccer_2",
        "predict": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie'",
        "question": "What are the names of all the states with college students playing in the mid position but no goalies?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n"
    },
    {
        "db_id": "mountain_photos",
        "predict": "SELECT T1.name ,  count(*) FROM camera_lens AS T1 JOIN photos AS T2 ON T1.id  =  T2.camera_lens_id GROUP BY T1.id ORDER BY count(*)",
        "question": "What is the name of each camera lens and the number of photos taken by it? Order the result by the count of photos.",
        "fields": "Table camera_lens, columns = [*,id,brand,name,focal_length_mm,max_aperture]\nTable mountain, columns = [*,id,name,Height,Prominence,Range,Country]\nTable photos, columns = [*,id,camera_lens_id,mountain_id,color,name]\n",
        "foreign_keys": "Foreign_keys = [photos.mountain_id = mountain.id,photos.camera_lens_id = camera_lens.id]\n"
    },
    {
        "db_id": "allergy_1",
        "predict": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype",
        "question": "Show all allergy type with number of students affected.",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n"
    },
    {
        "db_id": "e_learning",
        "predict": "SELECT T1.date_of_enrolment ,  T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.family_name  =  \"Zieme\" AND T2.personal_name  =  \"Bernie\"",
        "question": "List the dates of enrollment and completion of the student with family name \"Zieme\" and personal name \"Bernie\".",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n"
    },
    {
        "db_id": "sakila_1",
        "predict": "SELECT T1.title ,  T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the title and id of the film that has the greatest number of copies in inventory?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n"
    },
    {
        "db_id": "allergy_1",
        "predict": "SELECT StuID FROM Has_allergy GROUP BY StuID HAVING count(*)  >=  2",
        "question": "Show all student IDs who have at least two allergies.",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n"
    },
    {
        "db_id": "inn_1",
        "predict": "SELECT Kids FROM Reservations WHERE CheckIn  =  \"2010-09-21\" AND FirstName  =  \"DAMIEN\" AND LastName  =  \"TRACHSEL\";",
        "question": "Return the number of kids for the room reserved and checked in by DAMIEN TRACHSEL on  Sep 21, 2010.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n"
    },
    {
        "db_id": "dorm_1",
        "predict": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'",
        "question": "Find the total number of students living in the male dorm (with gender M).",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n"
    },
    {
        "db_id": "store_product",
        "predict": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  \"Khanewal District\"",
        "question": "Find the names of all stores in Khanewal District.",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n"
    },
    {
        "db_id": "dorm_1",
        "predict": "SELECT sum(student_capacity) FROM dorm",
        "question": "Find the total capacity of all dorms.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n"
    },
    {
        "db_id": "cre_Theme_park",
        "predict": "SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits )",
        "question": "Count the number of tourists who did not visit any place.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n"
    },
    {
        "db_id": "student_1",
        "predict": "SELECT DISTINCT firstname FROM list WHERE classroom  =  107",
        "question": "What are the first names of students studying in room 107?",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n"
    },
    {
        "db_id": "product_catalog",
        "predict": "SELECT attribute_data_type FROM Attribute_Definitions WHERE attribute_name  =  \"Green\"",
        "question": "What is the attribute data type of the attribute with name \"Green\"?",
        "fields": "Table Attribute_Definitions, columns = [*,attribute_id,attribute_name,attribute_data_type]\nTable Catalog_Contents, columns = [*,catalog_entry_id,catalog_level_number,parent_entry_id,previous_entry_id,next_entry_id,catalog_entry_name,product_stock_number,price_in_dollars,price_in_euros,price_in_pounds,capacity,length,height,width]\nTable Catalog_Contents_Additional_Attributes, columns = [*,catalog_entry_id,catalog_level_number,attribute_id,attribute_value]\nTable Catalog_Structure, columns = [*,catalog_level_number,catalog_id,catalog_level_name]\nTable Catalogs, columns = [*,catalog_id,catalog_name,catalog_publisher,date_of_publication,date_of_latest_revision]\n",
        "foreign_keys": "Foreign_keys = [Catalog_Structure.catalog_id = Catalogs.catalog_id,Catalog_Contents.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_entry_id = Catalog_Contents.catalog_entry_id]\n"
    },
    {
        "db_id": "body_builder",
        "predict": "SELECT min(snatch) FROM body_builder",
        "question": "What is the minimum snatch score?",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "voter_2",
        "predict": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.city_code  =  \"NYC\" AND T2.Election_Cycle  =  \"Spring\"",
        "question": "Which students live in the city with code \"NYC\" and have class senator votes in the spring election cycle? Count the numbers.",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n"
    },
    {
        "db_id": "journal_committee",
        "predict": "SELECT count(*) FROM editor",
        "question": "How many editors are there?",
        "fields": "Table editor, columns = [*,Editor_ID,Name,Age]\nTable journal, columns = [*,Journal_ID,Date,Theme,Sales]\nTable journal_committee, columns = [*,Editor_ID,Journal_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [journal_committee.Journal_ID = journal.Journal_ID,journal_committee.Editor_ID = editor.Editor_ID]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT dept_name FROM student GROUP BY dept_name ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the deparment with the highest enrollment?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "cre_Theme_park",
        "predict": "SELECT Name FROM TOURIST_ATTRACTIONS WHERE How_to_Get_There  =  \"bus\"",
        "question": "What are the names of the tourist attractions that can be accessed by bus?",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n"
    },
    {
        "db_id": "climbing",
        "predict": "SELECT DISTINCT T2.Name FROM climber AS T1 JOIN mountain AS T2 ON T1.Mountain_ID  =  T2.Mountain_ID WHERE T1.Country  =  \"West Germany\"",
        "question": "What are the different names of mountains ascended by climbers from the country of West Germany?",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n"
    },
    {
        "db_id": "products_for_hire",
        "predict": "SELECT max(booked_count) ,  min(booked_count) ,  avg(booked_count) FROM products_booked",
        "question": "What are the maximum, minimum, and average booked count for the products booked?",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n"
    },
    {
        "db_id": "party_host",
        "predict": "SELECT Nationality FROM HOST GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Which nationality has the most hosts?",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n"
    },
    {
        "db_id": "candidate_poll",
        "predict": "SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT 3",
        "question": "Return the top 3 greatest support rates.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "store_1",
        "predict": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.name = \"Rock\" OR T1.name = \"Jazz\"",
        "question": "What are the names of the tracks that are Rock or Jazz songs?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n"
    },
    {
        "db_id": "candidate_poll",
        "predict": "SELECT t1.name FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id WHERE t1.sex  =  'F' ORDER BY t1.name",
        "question": "What are the names of all female candidates in alphabetical order (sex is F)?",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "formula_1",
        "predict": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid",
        "question": "For each constructor id, how many races are there?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n"
    },
    {
        "db_id": "film_rank",
        "predict": "SELECT T1.Title ,  T2.Type FROM film AS T1 JOIN film_market_estimation AS T2 ON T1.Film_ID  =  T2.Film_ID",
        "question": "What are the titles of films and corresponding types of market estimations?",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "predict": "SELECT count(*) FROM Accounts",
        "question": "How many accounts do we have?",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n"
    },
    {
        "db_id": "customers_card_transactions",
        "predict": "SELECT count(*) FROM Accounts",
        "question": "How many accounts do we have?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n"
    },
    {
        "db_id": "formula_1",
        "predict": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "question": "What is the average fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n"
    },
    {
        "db_id": "driving_school",
        "predict": "SELECT date_of_birth FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";",
        "question": "What is the birthday of the staff member with first name as Janessa and last name as Sawayn?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "predict": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  \"MasterCard\"",
        "question": "What is the average quantities ordered with payment method code \"MasterCard\" on invoices?",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n"
    },
    {
        "db_id": "products_for_hire",
        "predict": "SELECT T1.good_or_bad_customer FROM customers AS T1 JOIN discount_coupons AS T2 ON T1.coupon_id  =  T2.coupon_id WHERE T2.coupon_amount  =  500",
        "question": "Are the customers holding coupons with amount 500 bad or good?",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT T1.name FROM instructor AS T1 JOIN teaches AS T2 ON T1.id  =  T2.id JOIN course AS T3 ON T2.course_id  =  T3.course_id WHERE T3.title  =  'C Programming'",
        "question": "Find the name of the instructors who taught C Programming course before.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "apartment_rentals",
        "predict": "SELECT T2.guest_first_name ,  T2.guest_last_name FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T1.booking_status_code  =  \"Confirmed\"",
        "question": "Which guests have apartment bookings with status code \"Confirmed\"? Return their first names and last names.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n"
    },
    {
        "db_id": "tracking_grants_for_research",
        "predict": "SELECT count(*) FROM Tasks",
        "question": "How many tasks are there in total?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT T1.title ,  T1.year FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title",
        "question": "For directors who had more than one movie, return the titles and produced years of all movies directed by them.",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "customers_and_addresses",
        "predict": "SELECT city FROM addresses WHERE zip_postcode  =  255",
        "question": "Find the city with post code 255.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n"
    },
    {
        "db_id": "driving_school",
        "predict": "SELECT first_name ,  last_name FROM Customers;",
        "question": "List the first name and last name of all customers.",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n"
    },
    {
        "db_id": "activity_1",
        "predict": "SELECT FacID FROM Faculty WHERE Sex  =  'M'",
        "question": "What are the faculty ids of all the male faculty members?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n"
    },
    {
        "db_id": "flight_4",
        "predict": "SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "question": "Find the number of routes from the United States to Canada.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n"
    },
    {
        "db_id": "insurance_and_eClaims",
        "predict": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)",
        "question": "What is the name of the customer who has made the minimum amount of payment in one claim?",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n"
    },
    {
        "db_id": "gymnast",
        "predict": "SELECT avg(T2.Age) FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID",
        "question": "What is the average age of all gymnasts?",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n"
    },
    {
        "db_id": "allergy_1",
        "predict": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy",
        "question": "What are the student ids of students who don't have any allergies?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n"
    },
    {
        "db_id": "customers_campaigns_ecommerce",
        "predict": "SELECT T2.customer_name ,  T2.payment_method FROM mailshot_customers AS T1 JOIN customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.outcome_code  =  'Order' INTERSECT SELECT T2.customer_name ,  T2.payment_method FROM mailshot_customers AS T1 JOIN customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.outcome_code  =  'No Response'",
        "question": "What are the name and payment method of customers who have both mailshots in 'Order' outcome and mailshots in 'No Response' outcome.",
        "fields": "Table Customer_Addresses, columns = [*,customer_id,premise_id,date_address_from,address_type_code,date_address_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,shipping_method_code,order_placed_datetime,order_delivered_datetime,order_shipping_charges]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,customer_address,customer_login,customer_password]\nTable Mailshot_Campaigns, columns = [*,mailshot_id,product_category,mailshot_name,mailshot_start_date,mailshot_end_date]\nTable Mailshot_Customers, columns = [*,mailshot_id,customer_id,outcome_code,mailshot_customer_date]\nTable Order_Items, columns = [*,item_id,order_item_status_code,order_id,product_id,item_status_code,item_delivered_datetime,item_order_quantity]\nTable Premises, columns = [*,premise_id,premises_type,premise_details]\nTable Products, columns = [*,product_id,product_category,product_name]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.premise_id = Premises.premise_id,Customer_Orders.customer_id = Customers.customer_id,Mailshot_Customers.mailshot_id = Mailshot_Campaigns.mailshot_id,Mailshot_Customers.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  \"Brittany Harris\"",
        "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "entertainment_awards",
        "predict": "SELECT avg(Num_of_Audience) FROM festival_detail",
        "question": "What is the average number of audience for festivals?",
        "fields": "Table artwork, columns = [*,Artwork_ID,Type,Name]\nTable festival_detail, columns = [*,Festival_ID,Festival_Name,Chair_Name,Location,Year,Num_of_Audience]\nTable nomination, columns = [*,Artwork_ID,Festival_ID,Result]\n",
        "foreign_keys": "Foreign_keys = [nomination.Festival_ID = festival_detail.Festival_ID,nomination.Artwork_ID = artwork.Artwork_ID]\n"
    },
    {
        "db_id": "customer_complaints",
        "predict": "SELECT t1.product_name ,  count(*) FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_name",
        "question": "What are all the different product names, and how many complains has each received?",
        "fields": "Table Complaints, columns = [*,complaint_id,product_id,customer_id,complaint_outcome_code,complaint_status_code,complaint_type_code,date_complaint_raised,date_complaint_closed,staff_id]\nTable Customers, columns = [*,customer_id,customer_type_code,address_line_1,address_line_2,town_city,state,email_address,phone_number]\nTable Products, columns = [*,product_id,parent_product_id,product_category_code,date_product_first_available,date_product_discontinued,product_name,product_description,product_price]\nTable Staff, columns = [*,staff_id,gender,first_name,last_name,email_address,phone_number]\n",
        "foreign_keys": "Foreign_keys = [Complaints.customer_id = Customers.customer_id,Complaints.product_id = Products.product_id,Complaints.staff_id = Staff.staff_id]\n"
    },
    {
        "db_id": "icfp_1",
        "predict": "SELECT lname FROM authors WHERE fname  =  \"Amal\"",
        "question": "Find the last name of the author with first name \"Amal\".",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n"
    },
    {
        "db_id": "ship_1",
        "predict": "SELECT count(*) ,  rank FROM captain GROUP BY rank",
        "question": "Count the number of captains that have each rank.",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n"
    },
    {
        "db_id": "club_1",
        "predict": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.city_code  =  \"HOU\"",
        "question": "Which clubs have one or more members from the city with code \"HOU\"? Give me the names of the clubs.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n"
    },
    {
        "db_id": "allergy_1",
        "predict": "SELECT count(*) FROM Student WHERE age  =  18",
        "question": "How many students are age 18?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n"
    },
    {
        "db_id": "storm_record",
        "predict": "SELECT T3.name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T2.region_name  =  'Denmark'",
        "question": "What are the names of the storms that affected Denmark?",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n"
    },
    {
        "db_id": "voter_2",
        "predict": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  \"PIT\"",
        "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n"
    },
    {
        "db_id": "decoration_competition",
        "predict": "SELECT Country FROM member GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1",
        "question": "Show the most common country across members.",
        "fields": "Table college, columns = [*,College_ID,Name,Leader_Name,College_Location]\nTable member, columns = [*,Member_ID,Name,Country,College_ID]\nTable round, columns = [*,Round_ID,Member_ID,Decoration_Theme,Rank_in_Round]\n",
        "foreign_keys": "Foreign_keys = [member.College_ID = college.College_ID,round.Member_ID = member.Member_ID]\n"
    },
    {
        "db_id": "allergy_1",
        "predict": "SELECT avg(age) ,  sex FROM Student GROUP BY sex",
        "question": "What are the average ages for male and female students?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT name FROM instructor ORDER BY salary DESC LIMIT 1",
        "question": "Who is the instructor with the highest salary?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "csu_1",
        "predict": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  \"San Francisco State University\"",
        "question": "How many people graduated from San Francisco State University in 2004?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n"
    },
    {
        "db_id": "activity_1",
        "predict": "SELECT count(*) FROM Faculty WHERE Sex  =  'F' AND Rank  =  \"Professor\"",
        "question": "How many female Professors do we have?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n"
    },
    {
        "db_id": "department_store",
        "predict": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')",
        "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n"
    },
    {
        "db_id": "party_host",
        "predict": "SELECT Party_Theme FROM party ORDER BY Number_of_hosts ASC",
        "question": "What are the themes of parties ordered by the number of hosts in ascending manner?",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n"
    },
    {
        "db_id": "bike_1",
        "predict": "SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  94107)",
        "question": "Which days had a minimum dew point smaller than any day in zip code 94107, and in which zip codes were those measurements taken?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n"
    },
    {
        "db_id": "gymnast",
        "predict": "SELECT T2.Age FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID ORDER BY T1.Total_Points DESC",
        "question": "What are the ages of the gymnasts, ordered descending by their total points?",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n"
    },
    {
        "db_id": "behavior_monitoring",
        "predict": "SELECT T1.date_of_notes FROM Assessment_Notes AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.first_name  =  \"Fanny\"",
        "question": "Find the dates of assessment notes for students with first name \"Fanny\".",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n"
    },
    {
        "db_id": "county_public_safety",
        "predict": "SELECT Name FROM county_public_safety ORDER BY Population DESC",
        "question": "List the names of counties in descending order of population.",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n"
    },
    {
        "db_id": "tracking_orders",
        "predict": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "Which customer made the most orders? Find the customer name.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "predict": "SELECT document_id ,  document_name FROM Documents",
        "question": "Show the ids and names of all documents.",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n"
    },
    {
        "db_id": "school_finance",
        "predict": "SELECT sum(T1.budgeted) FROM budget AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  'Glenn'",
        "question": "What is the total budget amount for school \"Glenn\" in all years?",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n"
    },
    {
        "db_id": "e_government",
        "predict": "SELECT t1.organization_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id GROUP BY t1.organization_name ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of organization that has the greatest number of contact individuals?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n"
    },
    {
        "db_id": "customers_card_transactions",
        "predict": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1",
        "question": "Return the code of the card type that is most common.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n"
    },
    {
        "db_id": "dorm_1",
        "predict": "SELECT fname ,  lname FROM student WHERE age  <  (SELECT avg(age) FROM student)",
        "question": "What is the first and last name of all students who are younger than average?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n"
    },
    {
        "db_id": "driving_school",
        "predict": "SELECT T1.state_province_county FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.state_province_county HAVING count(*) BETWEEN 2 AND 4;",
        "question": "List the states which have between 2 to 4 staffs living there.",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n"
    },
    {
        "db_id": "perpetrator",
        "predict": "SELECT count(DISTINCT LOCATION) FROM perpetrator",
        "question": "How many distinct locations of perpetrators are there?",
        "fields": "Table people, columns = [*,People_ID,Name,Height,Weight,Home Town]\nTable perpetrator, columns = [*,Perpetrator_ID,People_ID,Date,Year,Location,Country,Killed,Injured]\n",
        "foreign_keys": "Foreign_keys = [perpetrator.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "network_2",
        "predict": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "question": "Find the name, age, and job title of persons who are friends with Alice for the longest years.",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  \"bangla\"",
        "question": "What are the average rating and resolution of songs that are in Bangla?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "e_learning",
        "predict": "SELECT login_name FROM Course_Authors_and_Tutors INTERSECT SELECT login_name FROM Students",
        "question": "What are the login names used both by some course authors and some students?",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n"
    },
    {
        "db_id": "election",
        "predict": "SELECT count(DISTINCT Governor) FROM party",
        "question": "How many distinct governors are there?",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n"
    },
    {
        "db_id": "flight_company",
        "predict": "SELECT pilot FROM flight GROUP BY pilot ORDER BY count(*) DESC LIMIT 1",
        "question": "which pilot is in charge of the most number of flights?",
        "fields": "Table airport, columns = [*,id,City,Country,IATA,ICAO,name]\nTable flight, columns = [*,id,Vehicle_Flight_number,Date,Pilot,Velocity,Altitude,airport_id,company_id]\nTable operate_company, columns = [*,id,name,Type,Principal_activities,Incorporated_in,Group_Equity_Shareholding]\n",
        "foreign_keys": "Foreign_keys = [flight.company_id = operate_company.id,flight.airport_id = airport.id]\n"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "predict": "SELECT payment_method_code ,  count(*) FROM INVOICES GROUP BY payment_method_code",
        "question": "Show all payment method codes and the number of orders for each code.",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n"
    },
    {
        "db_id": "company_1",
        "predict": "SELECT t1.dname FROM department AS t1 JOIN dept_locations AS t2 ON t1.dnumber  =  t2.dnumber WHERE t2.dlocation  =  'Houston'",
        "question": "Find the names of departments that are located in Houston.",
        "fields": "Table department, columns = [*,Dname,Dnumber,Mgr_ssn,Mgr_start_date]\nTable dependent, columns = [*,Essn,Dependent_name,Sex,Bdate,Relationship]\nTable dept_locations, columns = [*,Dnumber,Dlocation]\nTable employee, columns = [*,Fname,Minit,Lname,Ssn,Bdate,Address,Sex,Salary,Super_ssn,Dno]\nTable project, columns = [*,Pname,Pnumber,Plocation,Dnum]\nTable works_on, columns = [*,Essn,Pno,Hours]\n",
        "foreign_keys": "Foreign_keys = ]\n"
    },
    {
        "db_id": "hr_1",
        "predict": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  \"Clara\") AND first_name != \"Clara\"",
        "question": "display the employee name ( first name and last name ) and hire date for all employees in the same department as Clara excluding Clara.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n"
    },
    {
        "db_id": "music_2",
        "predict": "SELECT count(*) FROM performance AS T1 JOIN band AS T2 ON T1.bandmate  =  T2.id JOIN songs AS T3 ON T3.songid  =  T1.songid WHERE T3.Title  =  \"Flash\"",
        "question": "How many musicians play in the song \"Flash\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n"
    },
    {
        "db_id": "music_4",
        "predict": "SELECT Famous_Title FROM artist WHERE Artist  =  \"Triumfall\"",
        "question": "Return the famous titles of the artist called \"Triumfall\".",
        "fields": "Table artist, columns = [*,Artist_ID,Artist,Age,Famous_Title,Famous_Release_date]\nTable music_festival, columns = [*,ID,Music_Festival,Date_of_ceremony,Category,Volume,Result]\nTable volume, columns = [*,Volume_ID,Volume_Issue,Issue_Date,Weeks_on_Top,Song,Artist_ID]\n",
        "foreign_keys": "Foreign_keys = [volume.Artist_ID = artist.Artist_ID,music_festival.Volume = volume.Volume_ID]\n"
    },
    {
        "db_id": "college_1",
        "predict": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of department where has the largest number of professors with a Ph.D. degree?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n"
    },
    {
        "db_id": "network_2",
        "predict": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "question": "What are the names of all people who are friends with Alice for the shortest amount of time?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n"
    },
    {
        "db_id": "device",
        "predict": "SELECT T2.Shop_Name FROM stock AS T1 JOIN shop AS T2 ON T1.Shop_ID  =  T2.Shop_ID GROUP BY T1.Shop_ID HAVING COUNT(*)  >  1",
        "question": "What are the names of shops that have more than a single kind of device in stock?",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n"
    },
    {
        "db_id": "flight_1",
        "predict": "SELECT eid FROM Employee WHERE salary  >  100000",
        "question": "Show ids for all employees with at least 100000 salary.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n"
    },
    {
        "db_id": "driving_school",
        "predict": "SELECT T1.state_province_county FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.state_province_county HAVING count(*) BETWEEN 2 AND 4;",
        "question": "What are the names of the states that have 2 to 4 employees living there?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n"
    },
    {
        "db_id": "formula_1",
        "predict": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year",
        "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n"
    },
    {
        "db_id": "music_4",
        "predict": "SELECT Famous_Title ,  Age FROM artist ORDER BY Age DESC",
        "question": "What are the famous titles and ages of each artist, listed in descending order by age?",
        "fields": "Table artist, columns = [*,Artist_ID,Artist,Age,Famous_Title,Famous_Release_date]\nTable music_festival, columns = [*,ID,Music_Festival,Date_of_ceremony,Category,Volume,Result]\nTable volume, columns = [*,Volume_ID,Volume_Issue,Issue_Date,Weeks_on_Top,Song,Artist_ID]\n",
        "foreign_keys": "Foreign_keys = [volume.Artist_ID = artist.Artist_ID,music_festival.Volume = volume.Volume_ID]\n"
    },
    {
        "db_id": "roller_coaster",
        "predict": "SELECT LENGTH ,  Height FROM roller_coaster",
        "question": "What are the lengths and heights of roller coasters?",
        "fields": "Table country, columns = [*,Country_ID,Name,Population,Area,Languages]\nTable roller_coaster, columns = [*,Roller_Coaster_ID,Name,Park,Country_ID,Length,Height,Speed,Opened,Status]\n",
        "foreign_keys": "Foreign_keys = [roller_coaster.Country_ID = country.Country_ID]\n"
    },
    {
        "db_id": "products_for_hire",
        "predict": "SELECT T2.product_name FROM view_product_availability AS T1 JOIN products_for_hire AS T2 ON T1.product_id  =  T2.product_id WHERE T1.available_yn  =  1",
        "question": "What are the names of products whose availability equals to 1?",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n"
    },
    {
        "db_id": "college_3",
        "predict": "SELECT * FROM COURSE ORDER BY Credits",
        "question": "What is all the information about courses, ordered by credits ascending?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n"
    },
    {
        "db_id": "college_3",
        "predict": "SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade  =  \"B\"",
        "question": "Find the number of students that have at least one grade \"B\".",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "predict": "SELECT document_type_name ,  document_type_description FROM Ref_document_types WHERE document_type_code  =  \"RV\"",
        "question": "Give me the name and description of the document type code RV.",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n"
    },
    {
        "db_id": "storm_record",
        "predict": "SELECT name ,  damage_millions_USD FROM storm ORDER BY max_speed DESC",
        "question": "List name and damage for all storms in a descending order of max speed.",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n"
    },
    {
        "db_id": "ship_1",
        "predict": "SELECT name FROM ship ORDER BY built_year ,  CLASS",
        "question": "List all ship names in the order of built year and class.",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n"
    },
    {
        "db_id": "election",
        "predict": "SELECT Party FROM party GROUP BY Party HAVING COUNT(*)  >=  2",
        "question": "Show the name of the party that has at least two records.",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n"
    },
    {
        "db_id": "chinook_1",
        "predict": "SELECT T1.Name FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId GROUP BY T2.MediaTypeId ORDER BY COUNT(*) ASC LIMIT 1",
        "question": "What is the name of the media type that is least common across all tracks?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "predict": "SELECT name ,  LOCATION FROM enzyme",
        "question": "What are the names and locations of all enzymes listed?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n"
    },
    {
        "db_id": "game_1",
        "predict": "SELECT lname ,  sex FROM Student WHERE StuID IN (SELECT T1.StuID FROM Plays_games AS T1 JOIN Video_games AS T2 ON T1.GameID  =  T2.GameID WHERE T2.Gname  =  \"Call of Destiny\" INTERSECT SELECT T1.StuID FROM Plays_games AS T1 JOIN Video_games AS T2 ON T1.GameID  =  T2.GameID WHERE T2.Gname  =  \"Works of Widenius\")",
        "question": "what is the last name and gender of all students who played both Call of Destiny and Works of Widenius?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n"
    },
    {
        "db_id": "college_1",
        "predict": "SELECT T2.dept_name ,  T2.dept_address ,  count(*) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 3",
        "question": "Find the name, address, number of students in the departments that have the top 3 highest number of students.",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n"
    },
    {
        "db_id": "customers_and_invoices",
        "predict": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  \"900\"",
        "question": "Show the first name and last name for the customer with account name 900.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n"
    },
    {
        "db_id": "voter_2",
        "predict": "SELECT max(Age) FROM STUDENT",
        "question": "What is the oldest age among the students?",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n"
    },
    {
        "db_id": "network_2",
        "predict": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'male' AND T1.job  =  'doctor'",
        "question": "Find the male friend of Alice whose job is a doctor?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "predict": "SELECT T1.statement_details ,  T2.document_name FROM Statements AS T1 JOIN Documents AS T2 ON T1.statement_id  =  T2.document_id WHERE T1.statement_details  =  'Private Project'",
        "question": "What are the details for statements with the details 'Private Project', and what are the names of the corresponding documents?",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT name FROM student WHERE dept_name  =  'History' ORDER BY tot_cred DESC LIMIT 1",
        "question": "Give the name of the student in the History department with the most credits.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "csu_1",
        "predict": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "question": "How many universities have a campus fee greater than the average?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n"
    },
    {
        "db_id": "loan_1",
        "predict": "SELECT state ,  acc_type ,  credit_score FROM customer WHERE no_of_loans  =  0",
        "question": "Find the state, account type, and credit score of the customer whose number of loan is 0.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n"
    },
    {
        "db_id": "gas_company",
        "predict": "SELECT T3.manager_name FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.company  =  'ExxonMobil'",
        "question": "What are the names of the managers for gas stations that are operated by the ExxonMobil company?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n"
    },
    {
        "db_id": "customers_card_transactions",
        "predict": "SELECT count(*) FROM Customers_cards WHERE card_type_code  =  \"Debit\"",
        "question": "How many debit cards do we have?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n"
    },
    {
        "db_id": "journal_committee",
        "predict": "SELECT T2.Name ,  T2.age ,  T3.Theme FROM journal_committee AS T1 JOIN editor AS T2 ON T1.Editor_ID  =  T2.Editor_ID JOIN journal AS T3 ON T1.Journal_ID  =  T3.Journal_ID ORDER BY T3.Theme ASC",
        "question": "Show the names and ages of editors and the theme of journals for which they serve on committees, in ascending alphabetical order of theme.",
        "fields": "Table editor, columns = [*,Editor_ID,Name,Age]\nTable journal, columns = [*,Journal_ID,Date,Theme,Sales]\nTable journal_committee, columns = [*,Editor_ID,Journal_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [journal_committee.Journal_ID = journal.Journal_ID,journal_committee.Editor_ID = editor.Editor_ID]\n"
    },
    {
        "db_id": "small_bank_1",
        "predict": "SELECT T1.name ,  T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T3.balance LIMIT 1",
        "question": "What are the names and balances of checking accounts belonging to the customer with the lowest savings balance?",
        "fields": "Table ACCOUNTS, columns = [*,custid,name]\nTable CHECKING, columns = [*,custid,balance]\nTable SAVINGS, columns = [*,custid,balance]\n",
        "foreign_keys": "Foreign_keys = [SAVINGS.custid = ACCOUNTS.custid,CHECKING.custid = ACCOUNTS.custid]\n"
    },
    {
        "db_id": "cre_Theme_park",
        "predict": "SELECT T1.Name ,  T3.Visit_Date FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Vincent\" OR T2.Tourist_Details  =  \"Vivian\"",
        "question": "What are the names of the tourist attractions and the dates when the tourists named Vincent or Vivian visited there?",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n"
    },
    {
        "db_id": "dorm_1",
        "predict": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n"
    },
    {
        "db_id": "dorm_1",
        "predict": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "question": "Find the first name and age of students who are living in the dorms that do not have amenity TV Lounge.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT 1",
        "question": "What is the name of the song that was released in the most recent year?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "gas_company",
        "predict": "SELECT rank ,  company ,  market_value FROM company WHERE main_industry  =  'Banking' ORDER BY sales_billion ,  profits_billion",
        "question": "What is the rank, company, and market value of every comapny in the banking industry ordered by sales and profits?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n"
    },
    {
        "db_id": "store_product",
        "predict": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the city with the most number of stores.",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n"
    },
    {
        "db_id": "county_public_safety",
        "predict": "SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population  >  20000)",
        "question": "Show the number of cities in counties that have a population more than 20000.",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n"
    },
    {
        "db_id": "county_public_safety",
        "predict": "SELECT name FROM city WHERE county_id IN (SELECT county_id FROM county_public_safety WHERE Crime_rate  <  100)",
        "question": "Show the names of cities in counties that have a crime rate less than 100.",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n"
    },
    {
        "db_id": "tracking_software_problems",
        "predict": "SELECT product_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Christop\" AND T2.staff_last_name = \"Berge\" INTERSECT SELECT product_id FROM problems AS T1 JOIN staff AS T2 ON T1.closure_authorised_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Ashley\" AND T2.staff_last_name = \"Medhurst\"",
        "question": "For which product was there a problem reported by Christop Berge, with closure authorised by Ashley Medhurst? Return the product ids.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n"
    },
    {
        "db_id": "department_store",
        "predict": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1",
        "question": "What are the names of staff who have been assigned multiple jobs?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n"
    },
    {
        "db_id": "insurance_and_eClaims",
        "predict": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)",
        "question": "Which customer is associated with the latest policy?",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n"
    },
    {
        "db_id": "election",
        "predict": "SELECT T2.Party ,  COUNT(*) FROM election AS T1 JOIN party AS T2 ON T1.Party  =  T2.Party_ID GROUP BY T1.Party",
        "question": "Show the name of each party and the corresponding number of delegates from that party.",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n"
    },
    {
        "db_id": "college_1",
        "predict": "SELECT stu_gpa ,  stu_phone ,  stu_fname FROM student ORDER BY stu_gpa DESC LIMIT 5",
        "question": "What is the first name, GPA, and phone number of the students with the top 5 GPAs?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n"
    },
    {
        "db_id": "cre_Theme_park",
        "predict": "SELECT count(DISTINCT Name) FROM PHOTOS",
        "question": "Count the number of distinct names associated with the photos.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n"
    },
    {
        "db_id": "college_3",
        "predict": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "question": "Find the first name of students not enrolled in any course.",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n"
    },
    {
        "db_id": "flight_1",
        "predict": "SELECT name ,  distance FROM Aircraft WHERE aid  =  12",
        "question": "What is the name and distance for aircraft with id 12?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n"
    },
    {
        "db_id": "chinook_1",
        "predict": "SELECT BirthDate FROM EMPLOYEE WHERE City  =  \"Edmonton\"",
        "question": "What are the birth dates of employees living in Edmonton?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n"
    },
    {
        "db_id": "twitter_1",
        "predict": "SELECT avg(followers) FROM user_profiles WHERE UID IN (SELECT UID FROM tweets)",
        "question": "Find the average number of followers for the users who had some tweets.",
        "fields": "Table follows, columns = [*,f1,f2]\nTable tweets, columns = [*,id,uid,text,createdate]\nTable user_profiles, columns = [*,uid,name,email,partitionid,followers]\n",
        "foreign_keys": "Foreign_keys = [follows.f2 = user_profiles.uid,follows.f1 = user_profiles.uid,tweets.uid = user_profiles.uid]\n"
    },
    {
        "db_id": "hospital_1",
        "predict": "SELECT name ,  phone FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn GROUP BY T1.patient HAVING count(*)  >  1",
        "question": "what are name and phone number of patients who had more than one appointment?",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n"
    },
    {
        "db_id": "party_people",
        "predict": "SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "question": "What are the names of parties that have no members?",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n"
    },
    {
        "db_id": "network_2",
        "predict": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age",
        "question": "What is the name and age of every male? Order the results by age.",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n"
    },
    {
        "db_id": "customers_and_invoices",
        "predict": "SELECT transaction_type ,  sum(transaction_amount) FROM Financial_transactions GROUP BY transaction_type",
        "question": "What are total transaction amounts for each transaction type?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  \"Female\" AND T2.languages  =  \"bangla\"",
        "question": "What countries are the female artists who sung in the language Bangla from?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT count(*) FROM artist WHERE country  =  \"Bangladesh\"",
        "question": "How many artists are from Bangladesh?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "college_1",
        "predict": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'",
        "question": "What is the first name of each student enrolled in class ACCT-211?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n"
    },
    {
        "db_id": "customer_complaints",
        "predict": "SELECT t1.phone_number FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.date_complaint_raised DESC LIMIT 1",
        "question": "Return the phone number of the customer who filed the complaint that was raised most recently.",
        "fields": "Table Complaints, columns = [*,complaint_id,product_id,customer_id,complaint_outcome_code,complaint_status_code,complaint_type_code,date_complaint_raised,date_complaint_closed,staff_id]\nTable Customers, columns = [*,customer_id,customer_type_code,address_line_1,address_line_2,town_city,state,email_address,phone_number]\nTable Products, columns = [*,product_id,parent_product_id,product_category_code,date_product_first_available,date_product_discontinued,product_name,product_description,product_price]\nTable Staff, columns = [*,staff_id,gender,first_name,last_name,email_address,phone_number]\n",
        "foreign_keys": "Foreign_keys = [Complaints.customer_id = Customers.customer_id,Complaints.product_id = Products.product_id,Complaints.staff_id = Staff.staff_id]\n"
    },
    {
        "db_id": "department_store",
        "predict": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  \"Pending\" ORDER BY T2.customer_id",
        "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n"
    },
    {
        "db_id": "ship_mission",
        "predict": "SELECT Name FROM ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM mission)",
        "question": "What are the names of the ships that are not involved in any missions?",
        "fields": "Table mission, columns = [*,Mission_ID,Ship_ID,Code,Launched_Year,Location,Speed_knots,Fate]\nTable ship, columns = [*,Ship_ID,Name,Type,Nationality,Tonnage]\n",
        "foreign_keys": "Foreign_keys = [mission.Ship_ID = ship.Ship_ID]\n"
    },
    {
        "db_id": "chinook_1",
        "predict": "SELECT T1.Title ,  T2.AlbumID ,  COUNT(*) FROM ALBUM AS T1 JOIN TRACK AS T2 ON T1.AlbumId  =  T2.AlbumId GROUP BY T2.AlbumID",
        "question": "Show the album names, ids and the number of tracks for each album.",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT song_name FROM song WHERE rating  <  (SELECT max(rating) FROM song WHERE genre_is  =  \"blues\")",
        "question": "What are the names of all songs that have a lower rating than some song of blues genre?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "twitter_1",
        "predict": "SELECT T1.name ,  T1.email FROM user_profiles AS T1 JOIN follows AS T2 ON T1.uid  =  T2.f1 GROUP BY T2.f1 HAVING count(*)  >  1",
        "question": "Find the name and email for the users who have more than one follower.",
        "fields": "Table follows, columns = [*,f1,f2]\nTable tweets, columns = [*,id,uid,text,createdate]\nTable user_profiles, columns = [*,uid,name,email,partitionid,followers]\n",
        "foreign_keys": "Foreign_keys = [follows.f2 = user_profiles.uid,follows.f1 = user_profiles.uid,tweets.uid = user_profiles.uid]\n"
    },
    {
        "db_id": "hr_1",
        "predict": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2",
        "question": "What are total salaries and department id for each department that has more than 2 employees?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5",
        "question": "What are the titles of all movies that have between 3 and 5 stars?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "sakila_1",
        "predict": "SELECT T1.first_name ,  T1.last_name FROM customer AS T1 JOIN rental AS T2 ON T1.customer_id  =  T2.customer_id ORDER BY T2.rental_date ASC LIMIT 1",
        "question": "What is the first name and the last name of the customer who made the earliest rental?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT DISTINCT T3.name ,  T2.title ,  T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.director  =  T3.name",
        "question": "What are the different reviewer names, movie titles, and stars for every rating where the reviewer had the same name as the director?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "shop_membership",
        "predict": "SELECT T2.name ,  T2.open_year FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T1.register_year  =  2016 GROUP BY T2.branch_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name and opening year for the branch that registered the most members in 2016?",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT title FROM Movie WHERE YEAR  >  (SELECT max(YEAR) FROM Movie WHERE director  =  \"Steven Spielberg\")",
        "question": "What are the names of all movies that were created after the most recent Steven Spielberg film?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "chinook_1",
        "predict": "SELECT AVG(Milliseconds) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Latin\" OR T1.Name  =  \"Pop\"",
        "question": "What is the average duration in milliseconds of tracks that belong to Latin or Pop genre?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "predict": "SELECT interaction_type ,  count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the most common interaction type between enzymes and medicine? And how many are there?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n"
    },
    {
        "db_id": "products_for_hire",
        "predict": "SELECT customer_id ,  sum(amount_paid) FROM Payments GROUP BY customer_id ORDER BY sum(amount_paid) DESC LIMIT 1",
        "question": "What is the maximum total amount paid by a customer? List the customer id and amount.",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n"
    },
    {
        "db_id": "activity_1",
        "predict": "SELECT phone ,  room ,  building FROM Faculty WHERE Fname  =  \"Jerry\" AND Lname  =  \"Prince\"",
        "question": "What are the phone, room, and building of the faculty member called Jerry Prince?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT name FROM instructor WHERE name LIKE '%dar%'",
        "question": "Find the names of all instructors whose name includes the substring dar.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "musical",
        "predict": "SELECT Duration FROM actor ORDER BY Age DESC LIMIT 1",
        "question": "What is the duration of the oldest actor?",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n"
    },
    {
        "db_id": "behavior_monitoring",
        "predict": "SELECT T2.monthly_rental FROM Addresses AS T1 JOIN Student_Addresses AS T2 ON T1.address_id  =  T2.address_id WHERE T1.state_province_county  =  \"Texas\"",
        "question": "What are the monthly rentals of student addresses in Texas state?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n"
    },
    {
        "db_id": "apartment_rentals",
        "predict": "SELECT building_short_name FROM Apartment_Buildings WHERE building_manager =  \"Emma\"",
        "question": "Show the short names of the buildings managed by \"Emma\".",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n"
    },
    {
        "db_id": "soccer_1",
        "predict": "SELECT max(weight) ,  min(weight) FROM Player",
        "question": "What is the maximum and minimum height of all players?",
        "fields": "Table Country, columns = [*,id,name]\nTable League, columns = [*,id,country_id,name]\nTable Player, columns = [*,id,player_api_id,player_name,player_fifa_api_id,birthday,height,weight]\nTable Player_Attributes, columns = [*,id,player_fifa_api_id,player_api_id,date,overall_rating,potential,preferred_foot,attacking_work_rate,defensive_work_rate,crossing,finishing,heading_accuracy,short_passing,volleys,dribbling,curve,free_kick_accuracy,long_passing,ball_control,acceleration,sprint_speed,agility,reactions,balance,shot_power,jumping,stamina,strength,long_shots,aggression,interceptions,positioning,vision,penalties,marking,standing_tackle,sliding_tackle,gk_diving,gk_handling,gk_kicking,gk_positioning,gk_reflexes]\nTable Team, columns = [*,id,team_api_id,team_fifa_api_id,team_long_name,team_short_name]\nTable Team_Attributes, columns = [*,id,team_fifa_api_id,team_api_id,date,buildUpPlaySpeed,buildUpPlaySpeedClass,buildUpPlayDribbling,buildUpPlayDribblingClass,buildUpPlayPassing,buildUpPlayPassingClass,buildUpPlayPositioningClass,chanceCreationPassing,chanceCreationPassingClass,chanceCreationCrossing,chanceCreationCrossingClass,chanceCreationShooting,chanceCreationShootingClass,chanceCreationPositioningClass,defencePressure,defencePressureClass,defenceAggression,defenceAggressionClass,defenceTeamWidth,defenceTeamWidthClass,defenceDefenderLineClass]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "foreign_keys": "Foreign_keys = [Player_Attributes.player_api_id = Player.player_api_id,Player_Attributes.player_fifa_api_id = Player.player_fifa_api_id,League.country_id = Country.id,Team_Attributes.team_api_id = Team.team_api_id,Team_Attributes.team_fifa_api_id = Team.team_fifa_api_id]\n"
    },
    {
        "db_id": "debate",
        "predict": "SELECT Date FROM debate WHERE Num_of_Audience  >  150",
        "question": "List the dates of debates with number of audience bigger than 150",
        "fields": "Table debate, columns = [*,Debate_ID,Date,Venue,Num_of_Audience]\nTable debate_people, columns = [*,Debate_ID,Affirmative,Negative,If_Affirmative_Win]\nTable people, columns = [*,People_ID,District,Name,Party,Age]\n",
        "foreign_keys": "Foreign_keys = [debate_people.Negative = people.People_ID,debate_people.Affirmative = people.People_ID,debate_people.Debate_ID = debate.Debate_ID]\n"
    },
    {
        "db_id": "culture_company",
        "predict": "SELECT publisher ,  count(*) FROM book_club GROUP BY publisher",
        "question": "Show all publishers and the number of books for each publisher.",
        "fields": "Table book_club, columns = [*,book_club_id,Year,Author_or_Editor,Book_Title,Publisher,Category,Result]\nTable culture_company, columns = [*,Company_name,Type,Incorporated_in,Group_Equity_Shareholding,book_club_id,movie_id]\nTable movie, columns = [*,movie_id,Title,Year,Director,Budget_million,Gross_worldwide]\n",
        "foreign_keys": "Foreign_keys = [culture_company.movie_id = movie.movie_id,culture_company.book_club_id = book_club.book_club_id]\n"
    },
    {
        "db_id": "musical",
        "predict": "SELECT Character FROM actor ORDER BY age DESC",
        "question": "What are the characters of actors in descending order of age?",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n"
    },
    {
        "db_id": "inn_1",
        "predict": "SELECT count(*) FROM Reservations WHERE FirstName = \"ROY\" AND LastName  =  \"SWEAZY\";",
        "question": "How many times does ROY SWEAZY has reserved a room.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n"
    },
    {
        "db_id": "customers_and_invoices",
        "predict": "SELECT avg(transaction_amount) ,  min(transaction_amount) ,  max(transaction_amount) ,   sum(transaction_amount) FROM Financial_transactions",
        "question": "What is the average, minimum, maximum, and total transaction amount?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "predict": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n"
    },
    {
        "db_id": "perpetrator",
        "predict": "SELECT Country FROM perpetrator WHERE Injured  >  50 INTERSECT SELECT Country FROM perpetrator WHERE Injured  <  20",
        "question": "Show the countries that have both perpetrators with injures more than 50 and perpetrators with injures smaller than 20.",
        "fields": "Table people, columns = [*,People_ID,Name,Height,Weight,Home Town]\nTable perpetrator, columns = [*,Perpetrator_ID,People_ID,Date,Year,Location,Country,Killed,Injured]\n",
        "foreign_keys": "Foreign_keys = [perpetrator.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "city_record",
        "predict": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city",
        "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.",
        "fields": "Table city, columns = [*,City_ID,City,Hanzi,Hanyu_Pinyin,Regional_Population,GDP]\nTable hosting_city, columns = [*,Year,Match_ID,Host_City]\nTable match, columns = [*,Match_ID,Date,Venue,Score,Result,Competition]\nTable temperature, columns = [*,City_ID,Jan,Feb,Mar,Apr,Jun,Jul,Aug,Sep,Oct,Nov,Dec]\n",
        "foreign_keys": "Foreign_keys = [temperature.City_ID = city.City_ID,hosting_city.Match_ID = match.Match_ID,hosting_city.Host_City = city.City_ID]\n"
    },
    {
        "db_id": "wine_1",
        "predict": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  \"John Anthony\")",
        "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n"
    },
    {
        "db_id": "customers_and_addresses",
        "predict": "SELECT t3.address_content FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t1.customer_name  =  \"Maudie Kertzmann\"",
        "question": "Return the address content for the customer whose name is \"Maudie Kertzmann\".",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n"
    },
    {
        "db_id": "icfp_1",
        "predict": "SELECT t1.name FROM inst AS t1 JOIN authorship AS t2 ON t1.instid  =  t2.instid JOIN papers AS t3 ON t2.paperid  =  t3.paperid GROUP BY t1.name ORDER BY count(*) DESC LIMIT 1",
        "question": "Which institution has the most papers? Find the name of the institution.",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n"
    },
    {
        "db_id": "cre_Doc_Control_Systems",
        "predict": "SELECT document_id , count(copy_number) FROM Draft_Copies GROUP BY document_id ORDER BY count(copy_number) DESC LIMIT 1;",
        "question": "Which document has the most draft copies? List its document id and number of draft copies.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Circulation_History, columns = [*,document_id,draft_number,copy_number,employee_id]\nTable Document_Drafts, columns = [*,document_id,draft_number,draft_details]\nTable Documents, columns = [*,document_id,document_status_code,document_type_code,shipping_agent_code,receipt_date,receipt_number,other_details]\nTable Documents_Mailed, columns = [*,document_id,mailed_to_address_id,mailing_date]\nTable Draft_Copies, columns = [*,document_id,draft_number,copy_number]\nTable Employees, columns = [*,employee_id,role_code,employee_name,other_details]\nTable Ref_Document_Status, columns = [*,document_status_code,document_status_description]\nTable Ref_Document_Types, columns = [*,document_type_code,document_type_description]\nTable Ref_Shipping_Agents, columns = [*,shipping_agent_code,shipping_agent_name,shipping_agent_description]\nTable Roles, columns = [*,role_code,role_description]\n",
        "foreign_keys": "Foreign_keys = [Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code,Documents.document_status_code = Ref_Document_Status.document_status_code,Documents.document_type_code = Ref_Document_Types.document_type_code,Employees.role_code = Roles.role_code,Document_Drafts.document_id = Documents.document_id,Draft_Copies.document_id = Document_Drafts.document_id,Draft_Copies.draft_number = Document_Drafts.draft_number,Circulation_History.employee_id = Employees.employee_id,Circulation_History.document_id = Draft_Copies.document_id,Circulation_History.draft_number = Draft_Copies.draft_number,Circulation_History.copy_number = Draft_Copies.copy_number,Documents_Mailed.mailed_to_address_id = Addresses.address_id,Documents_Mailed.document_id = Documents.document_id]\n"
    },
    {
        "db_id": "book_2",
        "predict": "SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication)",
        "question": "List the titles of books that are not published.",
        "fields": "Table book, columns = [*,Book_ID,Title,Issues,Writer]\nTable publication, columns = [*,Publication_ID,Book_ID,Publisher,Publication_Date,Price]\n",
        "foreign_keys": "Foreign_keys = [publication.Book_ID = book.Book_ID]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT T1.artist_name ,  count(*) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  \"english\" GROUP BY T2.artist_name HAVING count(*)  >=  1",
        "question": "Find the names and number of works of all artists who have at least one English songs.",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "county_public_safety",
        "predict": "SELECT Name FROM county_public_safety WHERE County_ID NOT IN (SELECT County_ID FROM city)",
        "question": "List the names of counties that do not have any cities.",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n"
    },
    {
        "db_id": "store_1",
        "predict": "SELECT first_name , last_name FROM employees ORDER BY birth_date DESC LIMIT 1;",
        "question": "Who is the youngest employee in the company? List employee's first and last name.",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n"
    },
    {
        "db_id": "customers_card_transactions",
        "predict": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers",
        "question": "Show ids, first names, last names, and phones for all customers.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n"
    },
    {
        "db_id": "customers_campaigns_ecommerce",
        "predict": "SELECT count(*) FROM premises",
        "question": "How many premises are there?",
        "fields": "Table Customer_Addresses, columns = [*,customer_id,premise_id,date_address_from,address_type_code,date_address_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,shipping_method_code,order_placed_datetime,order_delivered_datetime,order_shipping_charges]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,customer_address,customer_login,customer_password]\nTable Mailshot_Campaigns, columns = [*,mailshot_id,product_category,mailshot_name,mailshot_start_date,mailshot_end_date]\nTable Mailshot_Customers, columns = [*,mailshot_id,customer_id,outcome_code,mailshot_customer_date]\nTable Order_Items, columns = [*,item_id,order_item_status_code,order_id,product_id,item_status_code,item_delivered_datetime,item_order_quantity]\nTable Premises, columns = [*,premise_id,premises_type,premise_details]\nTable Products, columns = [*,product_id,product_category,product_name]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.premise_id = Premises.premise_id,Customer_Orders.customer_id = Customers.customer_id,Mailshot_Customers.mailshot_id = Mailshot_Campaigns.mailshot_id,Mailshot_Customers.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n"
    },
    {
        "db_id": "device",
        "predict": "SELECT T2.Carrier FROM stock AS T1 JOIN device AS T2 ON T1.Device_ID  =  T2.Device_ID GROUP BY T1.Device_ID HAVING COUNT(*)  >  1",
        "question": "What are the carriers of devices that are in stock in more than a single shop?",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n"
    },
    {
        "db_id": "election",
        "predict": "SELECT Delegate ,  Committee FROM election",
        "question": "Show the delegate and committee information of elections.",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n"
    },
    {
        "db_id": "dorm_1",
        "predict": "SELECT dorm_name FROM dorm EXCEPT SELECT T1.dorm_name FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid JOIN dorm_amenity AS T3 ON T2.amenid  =  T3.amenid WHERE T3.amenity_name  =  'TV Lounge'",
        "question": "What are the names of the dorm that does not have a TV Lounge?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n"
    },
    {
        "db_id": "city_record",
        "predict": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1",
        "question": "In February, which city marks the highest temperature?",
        "fields": "Table city, columns = [*,City_ID,City,Hanzi,Hanyu_Pinyin,Regional_Population,GDP]\nTable hosting_city, columns = [*,Year,Match_ID,Host_City]\nTable match, columns = [*,Match_ID,Date,Venue,Score,Result,Competition]\nTable temperature, columns = [*,City_ID,Jan,Feb,Mar,Apr,Jun,Jul,Aug,Sep,Oct,Nov,Dec]\n",
        "foreign_keys": "Foreign_keys = [temperature.City_ID = city.City_ID,hosting_city.Match_ID = match.Match_ID,hosting_city.Host_City = city.City_ID]\n"
    },
    {
        "db_id": "network_2",
        "predict": "SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  'new york city'",
        "question": "What are the names of all friends who are from New York?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n"
    },
    {
        "db_id": "county_public_safety",
        "predict": "SELECT T1.White ,  T2.Crime_rate FROM city AS T1 JOIN county_public_safety AS T2 ON T1.County_ID  =  T2.County_ID",
        "question": "Show white percentages of cities and the crime rates of counties they are in.",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n"
    },
    {
        "db_id": "pilot_record",
        "predict": "SELECT T3.Pilot_name ,  T2.Fleet_Series FROM pilot_record AS T1 JOIN aircraft AS T2 ON T1.Aircraft_ID  =  T2.Aircraft_ID JOIN pilot AS T3 ON T1.Pilot_ID  =  T3.Pilot_ID ORDER BY T3.Rank",
        "question": "Show the names of pilots and fleet series of the aircrafts they have flied with in ascending order of the rank of the pilot.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Order_Year,Manufacturer,Model,Fleet_Series,Powertrain,Fuel_Propulsion]\nTable pilot, columns = [*,Pilot_ID,Pilot_name,Rank,Age,Nationality,Position,Join_Year,Team]\nTable pilot_record, columns = [*,Record_ID,Pilot_ID,Aircraft_ID,Date]\n",
        "foreign_keys": "Foreign_keys = [pilot_record.Aircraft_ID = aircraft.Aircraft_ID,pilot_record.Pilot_ID = pilot.Pilot_ID]\n"
    },
    {
        "db_id": "hospital_1",
        "predict": "SELECT DISTINCT name FROM medication ORDER BY name",
        "question": "List the names of all distinct medications, ordered in an alphabetical order.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n"
    },
    {
        "db_id": "match_season",
        "predict": "SELECT Official_native_language FROM country WHERE Official_native_language LIKE \"%English%\"",
        "question": "What are the official native languages that contain the string \"English\".",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n"
    },
    {
        "db_id": "tracking_software_problems",
        "predict": "SELECT T1.problem_description FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE T2.staff_first_name = \"Christop\"",
        "question": "Which problems are reported by the staff with first name \"Christop\"? Show the descriptions of the problems.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n"
    },
    {
        "db_id": "music_4",
        "predict": "SELECT avg(T2.Weeks_on_Top) FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T1.age  <=  25",
        "question": "What is the average weeks on top of volumes associated with the artist aged 25 or younger?",
        "fields": "Table artist, columns = [*,Artist_ID,Artist,Age,Famous_Title,Famous_Release_date]\nTable music_festival, columns = [*,ID,Music_Festival,Date_of_ceremony,Category,Volume,Result]\nTable volume, columns = [*,Volume_ID,Volume_Issue,Issue_Date,Weeks_on_Top,Song,Artist_ID]\n",
        "foreign_keys": "Foreign_keys = [volume.Artist_ID = artist.Artist_ID,music_festival.Volume = volume.Volume_ID]\n"
    },
    {
        "db_id": "dorm_1",
        "predict": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  'M' GROUP BY city_code",
        "question": "Find the average age and number of male students (with sex M) from each city.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n"
    },
    {
        "db_id": "wine_1",
        "predict": "SELECT Grape ,  Appelation FROM WINE",
        "question": "List the grapes and appelations of all wines.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n"
    },
    {
        "db_id": "scientist_1",
        "predict": "SELECT name FROM projects ORDER BY hours DESC LIMIT 1",
        "question": "Find the name of project that continues for the longest time.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n"
    },
    {
        "db_id": "e_government",
        "predict": "SELECT organization_name FROM organizations ORDER BY date_formed ASC",
        "question": "List all the name of organizations in order of the date formed.",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n"
    },
    {
        "db_id": "train_station",
        "predict": "SELECT name ,  total_passengers FROM station WHERE LOCATION != 'London'",
        "question": "Show the names and total passengers for all train stations not in London.",
        "fields": "Table station, columns = [*,Station_ID,Name,Annual_entry_exit,Annual_interchanges,Total_Passengers,Location,Main_Services,Number_of_Platforms]\nTable train, columns = [*,Train_ID,Name,Time,Service]\nTable train_station, columns = [*,Train_ID,Station_ID]\n",
        "foreign_keys": "Foreign_keys = [train_station.Station_ID = station.Station_ID,train_station.Train_ID = train.Train_ID]\n"
    },
    {
        "db_id": "activity_1",
        "predict": "SELECT count(*) FROM Activity",
        "question": "How many activities do we have?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n"
    },
    {
        "db_id": "customer_complaints",
        "predict": "SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints)",
        "question": "What are the prices of products that have never gotten a complaint?",
        "fields": "Table Complaints, columns = [*,complaint_id,product_id,customer_id,complaint_outcome_code,complaint_status_code,complaint_type_code,date_complaint_raised,date_complaint_closed,staff_id]\nTable Customers, columns = [*,customer_id,customer_type_code,address_line_1,address_line_2,town_city,state,email_address,phone_number]\nTable Products, columns = [*,product_id,parent_product_id,product_category_code,date_product_first_available,date_product_discontinued,product_name,product_description,product_price]\nTable Staff, columns = [*,staff_id,gender,first_name,last_name,email_address,phone_number]\n",
        "foreign_keys": "Foreign_keys = [Complaints.customer_id = Customers.customer_id,Complaints.product_id = Products.product_id,Complaints.staff_id = Staff.staff_id]\n"
    },
    {
        "db_id": "inn_1",
        "predict": "SELECT decor , count(*) FROM Rooms WHERE basePrice  >  120 GROUP BY decor;",
        "question": "How many rooms cost more than 120, for each different decor?",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n"
    },
    {
        "db_id": "club_1",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Tracy\" AND t3.lname  =  \"Kim\"",
        "question": "For how many clubs is \"Tracy Kim\" a member?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n"
    },
    {
        "db_id": "perpetrator",
        "predict": "SELECT Country ,  COUNT(*) FROM perpetrator GROUP BY Country HAVING COUNT(*)  >=  2",
        "question": "What are the countries that have at least two perpetrators?",
        "fields": "Table people, columns = [*,People_ID,Name,Height,Weight,Home Town]\nTable perpetrator, columns = [*,Perpetrator_ID,People_ID,Date,Year,Location,Country,Killed,Injured]\n",
        "foreign_keys": "Foreign_keys = [perpetrator.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT avg(rating) ,  languages FROM song GROUP BY languages",
        "question": "What is the average song rating for each language?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "baseball_1",
        "predict": "SELECT state FROM park GROUP BY state HAVING count(*)  >  2;",
        "question": "Which states have more than 2 parks?",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT rID FROM Reviewer WHERE name LIKE \"%Mike%\"",
        "question": "What is the id of the reviewer whose name has substring Mike?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "driving_school",
        "predict": "SELECT email_address ,  date_of_birth FROM Customers WHERE first_name = \"Carole\"",
        "question": "List email address and birthday of customer whose first name as Carole.",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n"
    },
    {
        "db_id": "manufactory_1",
        "predict": "SELECT AVG(Price) ,  Manufacturer FROM Products GROUP BY Manufacturer",
        "question": "What are the average prices of products, grouped by manufacturer code?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "predict": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'",
        "question": "Show the medicine names and trade names that cannot interact with the enzyme with product 'Heme'.",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT semester ,  YEAR FROM takes GROUP BY semester ,  YEAR ORDER BY count(*) LIMIT 1",
        "question": "Find the semester and year which has the least number of student taking any class.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "small_bank_1",
        "predict": "SELECT T2.balance ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T3.balance LIMIT 1",
        "question": "What is the name and checking balance of the account which has the lowest savings balance?",
        "fields": "Table ACCOUNTS, columns = [*,custid,name]\nTable CHECKING, columns = [*,custid,balance]\nTable SAVINGS, columns = [*,custid,balance]\n",
        "foreign_keys": "Foreign_keys = [SAVINGS.custid = ACCOUNTS.custid,CHECKING.custid = ACCOUNTS.custid]\n"
    },
    {
        "db_id": "sakila_1",
        "predict": "SELECT T1.title ,  T2.inventory_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id  =  T2.film_id JOIN rental AS T3 ON T2.inventory_id  =  T3.inventory_id GROUP BY T2.inventory_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the film title and inventory id of the item in the inventory which was rented most frequently?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n"
    },
    {
        "db_id": "allergy_1",
        "predict": "SELECT count(DISTINCT advisor) FROM Student",
        "question": "How many advisors are there?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n"
    },
    {
        "db_id": "train_station",
        "predict": "SELECT count(*) FROM station",
        "question": "How many train stations are there?",
        "fields": "Table station, columns = [*,Station_ID,Name,Annual_entry_exit,Annual_interchanges,Total_Passengers,Location,Main_Services,Number_of_Platforms]\nTable train, columns = [*,Train_ID,Name,Time,Service]\nTable train_station, columns = [*,Train_ID,Station_ID]\n",
        "foreign_keys": "Foreign_keys = [train_station.Station_ID = station.Station_ID,train_station.Train_ID = train.Train_ID]\n"
    },
    {
        "db_id": "icfp_1",
        "predict": "SELECT DISTINCT t3.name FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t1.fname  =  \"Matthias\" AND t1.lname  =  \"Blume\"",
        "question": "Which institution is the author \"Matthias Blume\" belong to? Give me the name of the institution.",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n"
    },
    {
        "db_id": "scientist_1",
        "predict": "SELECT T2.name ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT min(hours) FROM projects)",
        "question": "What is the name of the project that requires the fewest number of hours, and the names of the scientists assigned to it?",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n"
    },
    {
        "db_id": "customer_complaints",
        "predict": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1",
        "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?",
        "fields": "Table Complaints, columns = [*,complaint_id,product_id,customer_id,complaint_outcome_code,complaint_status_code,complaint_type_code,date_complaint_raised,date_complaint_closed,staff_id]\nTable Customers, columns = [*,customer_id,customer_type_code,address_line_1,address_line_2,town_city,state,email_address,phone_number]\nTable Products, columns = [*,product_id,parent_product_id,product_category_code,date_product_first_available,date_product_discontinued,product_name,product_description,product_price]\nTable Staff, columns = [*,staff_id,gender,first_name,last_name,email_address,phone_number]\n",
        "foreign_keys": "Foreign_keys = [Complaints.customer_id = Customers.customer_id,Complaints.product_id = Products.product_id,Complaints.staff_id = Staff.staff_id]\n"
    },
    {
        "db_id": "hr_1",
        "predict": "SELECT * FROM employees WHERE first_name LIKE '%D%' OR first_name LIKE '%S%' ORDER BY salary DESC",
        "question": "What is all the information about employees with D or S in their first name, ordered by salary descending?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "predict": "SELECT count(*) FROM CUSTOMERS",
        "question": "How many customers do we have?",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n"
    },
    {
        "db_id": "college_1",
        "predict": "SELECT T2.dept_name ,  avg(T1.stu_gpa) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY avg(T1.stu_gpa) DESC LIMIT 1",
        "question": "Which department has the highest average student GPA, and what is the average gpa?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n"
    },
    {
        "db_id": "apartment_rentals",
        "predict": "SELECT sum(T2.room_count) FROM Apartment_Buildings AS T1 JOIN Apartments AS T2 ON T1.building_id  =  T2.building_id WHERE T1.building_short_name  =  \"Columbus Square\"",
        "question": "Show the total number of rooms of the apartments in the building with short name \"Columbus Square\".",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "predict": "SELECT T2.employee_name ,  T3.employee_name FROM Documents_to_be_destroyed AS T1 JOIN Employees AS T2 ON T1.Destruction_Authorised_by_Employee_ID = T2.employee_id JOIN Employees AS T3 ON T1.Destroyed_by_Employee_ID = T3.employee_id;",
        "question": "What are the names of the employees who authorised the destruction and the employees who destroyed the corresponding documents?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n"
    },
    {
        "db_id": "sakila_1",
        "predict": "SELECT title ,  film_id FROM film WHERE rental_rate  =  0.99 INTERSECT SELECT T1.title ,  T1.film_id FROM film AS T1 JOIN inventory AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id HAVING count(*)  <  3",
        "question": "Which film is rented at a fee of 0.99 and has less than 3 in the inventory? List the film title and id.",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n"
    },
    {
        "db_id": "music_2",
        "predict": "SELECT count(*) FROM Songs",
        "question": "How many songs are there?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n"
    },
    {
        "db_id": "gymnast",
        "predict": "SELECT Name FROM People ORDER BY Age DESC LIMIT 5",
        "question": "What are the names of the five oldest people?",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n"
    },
    {
        "db_id": "scientist_1",
        "predict": "SELECT name FROM scientists EXCEPT SELECT T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "question": "What are the names of scientists who are not working on the project with the most hours?",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n"
    },
    {
        "db_id": "company_office",
        "predict": "SELECT Stories FROM buildings ORDER BY Height DESC LIMIT 1",
        "question": "What is the stories of highest building?",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "predict": "SELECT product ,  chromosome ,  porphyria FROM enzyme WHERE LOCATION  =  'Cytosol'",
        "question": "What is the product, chromosome and porphyria related to the enzymes which take effect at the location 'Cytosol'?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n"
    },
    {
        "db_id": "body_builder",
        "predict": "SELECT count(*) FROM people WHERE people_id NOT IN (SELECT People_ID FROM body_builder)",
        "question": "How many persons are not body builders?",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "college_1",
        "predict": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num GROUP BY T2.stu_num HAVING count(*)  =  1",
        "question": "Find the first names of students who took exactly one class.",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n"
    },
    {
        "db_id": "csu_1",
        "predict": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  \"Orange\" AND T2.year  >=  2000 GROUP BY T1.campus",
        "question": "What is the total number of degrees granted after 2000 for each Orange county campus?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n"
    },
    {
        "db_id": "e_learning",
        "predict": "SELECT T1.course_description ,  T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name HAVING COUNT(*)  >  2",
        "question": "Return the descriptions and names of the courses that have more than two students enrolled in.",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n"
    },
    {
        "db_id": "college_3",
        "predict": "SELECT T3.Fname ,  T3.LName ,  T2.gradepoint FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID",
        "question": "Find the student first and last names and grade points of all enrollments.",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n"
    },
    {
        "db_id": "tracking_software_problems",
        "predict": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "question": "Find the ids of the problems reported after the date of any problems reported by the staff Rylan Homenick.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n"
    },
    {
        "db_id": "music_2",
        "predict": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id WHERE stageposition  =  \"back\" GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the last name of the musician that has been at the back position the most?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n"
    },
    {
        "db_id": "perpetrator",
        "predict": "SELECT max(YEAR) FROM perpetrator;",
        "question": "In which year did the most recent crime happen?",
        "fields": "Table people, columns = [*,People_ID,Name,Height,Weight,Home Town]\nTable perpetrator, columns = [*,Perpetrator_ID,People_ID,Date,Year,Location,Country,Killed,Injured]\n",
        "foreign_keys": "Foreign_keys = [perpetrator.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "student_assessment",
        "predict": "SELECT student_id FROM student_course_attendance WHERE course_id  =  301",
        "question": "What are the id of students who registered course 301?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n"
    },
    {
        "db_id": "insurance_policies",
        "predict": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1",
        "question": "Find the policy type the most customers choose.",
        "fields": "Table Claims, columns = [*,Claim_ID,Policy_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled]\nTable Customer_Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Payments, columns = [*,Payment_ID,Settlement_ID,Payment_Method_Code,Date_Payment_Made,Amount_Payment]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled,Customer_Policy_ID]\n",
        "foreign_keys": "Foreign_keys = [Customer_Policies.Customer_ID = Customers.Customer_ID,Claims.Policy_ID = Customer_Policies.Policy_ID,Settlements.Claim_ID = Claims.Claim_ID,Payments.Settlement_ID = Settlements.Settlement_ID]\n"
    },
    {
        "db_id": "student_assessment",
        "predict": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"statistics\" ORDER BY T2.date_of_attendance",
        "question": "List the id of students who attended  statistics courses in the order of attendance date.",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n"
    },
    {
        "db_id": "store_1",
        "predict": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  \"USA\" GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;",
        "question": "What are the states with the most invoices?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n"
    },
    {
        "db_id": "insurance_and_eClaims",
        "predict": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the name of the claim processing stage that most of the claims are on?",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "predict": "SELECT Marketing_Region_Descriptrion FROM Marketing_Regions WHERE Marketing_Region_Name  =  \"China\"",
        "question": "What is the description of the marketing region China?",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n"
    },
    {
        "db_id": "inn_1",
        "predict": "SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT 3;",
        "question": "Find the name and id of the top 3 expensive rooms.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n"
    },
    {
        "db_id": "inn_1",
        "predict": "SELECT count(*) FROM Rooms WHERE bedType  =  \"King\";",
        "question": "Find the number of rooms with a king bed.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n"
    },
    {
        "db_id": "gas_company",
        "predict": "SELECT LOCATION FROM gas_station ORDER BY open_year",
        "question": "order all gas station locations by the opening year.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n"
    },
    {
        "db_id": "culture_company",
        "predict": "SELECT avg(budget_million) ,  max(budget_million) ,  min(budget_million) FROM movie WHERE YEAR  <  2000",
        "question": "What is the average, maximum, and minimum budget for all movies before 2000.",
        "fields": "Table book_club, columns = [*,book_club_id,Year,Author_or_Editor,Book_Title,Publisher,Category,Result]\nTable culture_company, columns = [*,Company_name,Type,Incorporated_in,Group_Equity_Shareholding,book_club_id,movie_id]\nTable movie, columns = [*,movie_id,Title,Year,Director,Budget_million,Gross_worldwide]\n",
        "foreign_keys": "Foreign_keys = [culture_company.movie_id = movie.movie_id,culture_company.book_club_id = book_club.book_club_id]\n"
    },
    {
        "db_id": "company_office",
        "predict": "SELECT max(Sales_billion) ,  min(Sales_billion) FROM Companies WHERE Industry != \"Banking\"",
        "question": "Find the maximum and minimum sales of the companies that are not in the \"Banking\" industry.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "predict": "SELECT role_name ,  role_description FROM ROLES WHERE role_code  =  \"MG\"",
        "question": "What are the name and description for role code \"MG\"?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != \"null\" GROUP BY director",
        "question": "For each director, what are the titles and ratings for all the movies they reviewed?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "voter_2",
        "predict": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  \"8741\"",
        "question": "Find the distinct last names of all the students who have president votes and whose advisor is 8741.",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n"
    },
    {
        "db_id": "school_finance",
        "predict": "SELECT count(DISTINCT T1.donator_name) FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Glenn\"",
        "question": "How many donors have endowment for school named \"Glenn\"?",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n"
    },
    {
        "db_id": "sports_competition",
        "predict": "SELECT name FROM club ORDER BY name DESC",
        "question": "What are the names of all the clubs ordered in descending alphabetical order?",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n"
    },
    {
        "db_id": "game_1",
        "predict": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1",
        "question": "What type has the most games?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n"
    },
    {
        "db_id": "machine_repair",
        "predict": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID ORDER BY T2.quality_rank",
        "question": "What are the names of the technicians by ascending order of quality rank for the machine they are assigned?",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n"
    },
    {
        "db_id": "bike_1",
        "predict": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id",
        "question": "What is the average latitude and longitude of the starting points of all trips?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n"
    },
    {
        "db_id": "club_1",
        "predict": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  \"600\" GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1",
        "question": "Which club has the most members majoring in \"600\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  \"null\"",
        "question": "Find the names of all reviewers who have ratings with a NULL value for the date.",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "wine_1",
        "predict": "SELECT count(*) ,  Grape FROM WINE GROUP BY Grape",
        "question": "What are the numbers of wines for different grapes?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n"
    },
    {
        "db_id": "voter_2",
        "predict": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  \"M\" AND T2.Election_Cycle  =  \"Fall\"",
        "question": "Count the number of male students who had class senator votes in the fall election cycle.",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n"
    },
    {
        "db_id": "phone_1",
        "predict": "SELECT Model_name ,  RAM_MiB FROM chip_model ORDER BY RAM_MiB ASC LIMIT 1;",
        "question": "Which model has the least amount of RAM? List the model name and the amount of RAM.",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n"
    },
    {
        "db_id": "company_employee",
        "predict": "SELECT Name FROM company ORDER BY Sales_in_Billion ASC",
        "question": "List the names of companies by ascending number of sales.",
        "fields": "Table company, columns = [*,Company_ID,Name,Headquarters,Industry,Sales_in_Billion,Profits_in_Billion,Assets_in_Billion,Market_Value_in_Billion]\nTable employment, columns = [*,Company_ID,People_ID,Year_working]\nTable people, columns = [*,People_ID,Age,Name,Nationality,Graduation_College]\n",
        "foreign_keys": "Foreign_keys = [employment.People_ID = people.People_ID,employment.Company_ID = company.Company_ID]\n"
    },
    {
        "db_id": "insurance_fnol",
        "predict": "SELECT DISTINCT t3.policy_type_code FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id JOIN available_policies AS t3 ON t2.policy_id  =  t3.policy_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "question": "Tell me the types of the policy used by the customer named \"Dayana Robel\".",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n"
    },
    {
        "db_id": "tracking_share_transactions",
        "predict": "SELECT max(share_count) FROM TRANSACTIONS WHERE amount_of_transaction  <  10000",
        "question": "Show the maximum share count of transactions where the amount is smaller than 10000",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE T2.course_id IN (SELECT T4.prereq_id FROM course AS T3 JOIN prereq AS T4 ON T3.course_id  =  T4.course_id WHERE T3.title  =  'International Finance')",
        "question": "Find the name of students who have taken the prerequisite course of the course with title International Finance.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "farm",
        "predict": "SELECT Official_Name FROM city ORDER BY Population DESC",
        "question": "What are the official names of cities, ordered descending by population?",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n"
    },
    {
        "db_id": "icfp_1",
        "predict": "SELECT fname ,  lname FROM authors ORDER BY lname",
        "question": "Sort the list of all the first and last names of authors in alphabetical order of the last names.",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n"
    },
    {
        "db_id": "debate",
        "predict": "SELECT Party ,  COUNT(*) FROM people GROUP BY Party",
        "question": "Show different parties of people along with the number of people in each party.",
        "fields": "Table debate, columns = [*,Debate_ID,Date,Venue,Num_of_Audience]\nTable debate_people, columns = [*,Debate_ID,Affirmative,Negative,If_Affirmative_Win]\nTable people, columns = [*,People_ID,District,Name,Party,Age]\n",
        "foreign_keys": "Foreign_keys = [debate_people.Negative = people.People_ID,debate_people.Affirmative = people.People_ID,debate_people.Debate_ID = debate.Debate_ID]\n"
    },
    {
        "db_id": "browser_web",
        "predict": "SELECT name FROM browser ORDER BY market_share DESC",
        "question": "List the name of browsers in descending order by market share.",
        "fields": "Table Web_client_accelerator, columns = [*,id,name,Operating_system,Client,Connection]\nTable accelerator_compatible_browser, columns = [*,accelerator_id,browser_id,compatible_since_year]\nTable browser, columns = [*,id,name,market_share]\n",
        "foreign_keys": "Foreign_keys = [accelerator_compatible_browser.browser_id = browser.id,accelerator_compatible_browser.accelerator_id = Web_client_accelerator.id]\n"
    },
    {
        "db_id": "decoration_competition",
        "predict": "SELECT T1.Name FROM member AS T1 JOIN round AS T2 ON T1.Member_ID  =  T2.Member_ID ORDER BY Rank_in_Round ASC",
        "question": "Show the names of members in ascending order of their rank in rounds.",
        "fields": "Table college, columns = [*,College_ID,Name,Leader_Name,College_Location]\nTable member, columns = [*,Member_ID,Name,Country,College_ID]\nTable round, columns = [*,Round_ID,Member_ID,Decoration_Theme,Rank_in_Round]\n",
        "foreign_keys": "Foreign_keys = [member.College_ID = college.College_ID,round.Member_ID = member.Member_ID]\n"
    },
    {
        "db_id": "railway",
        "predict": "SELECT LOCATION FROM railway GROUP BY LOCATION HAVING COUNT(*)  >  1",
        "question": "Show the locations that have more than one railways.",
        "fields": "Table manager, columns = [*,Manager_ID,Name,Country,Working_year_starts,Age,Level]\nTable railway, columns = [*,Railway_ID,Railway,Builder,Built,Wheels,Location,ObjectNumber]\nTable railway_manage, columns = [*,Railway_ID,Manager_ID,From_Year]\nTable train, columns = [*,Train_ID,Train_Num,Name,From,Arrival,Railway_ID]\n",
        "foreign_keys": "Foreign_keys = [train.Railway_ID = railway.Railway_ID,railway_manage.Railway_ID = railway.Railway_ID,railway_manage.Manager_ID = manager.Manager_ID]\n"
    },
    {
        "db_id": "soccer_2",
        "predict": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC",
        "question": "What are the name of the players who received a card in descending order of the hours of training?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n"
    },
    {
        "db_id": "document_management",
        "predict": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id",
        "question": "Find names of the document without any images.",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n"
    },
    {
        "db_id": "store_1",
        "predict": "SELECT sum(T2.total) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "question": "How much money did Lucas Mancini spend?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n"
    },
    {
        "db_id": "music_2",
        "predict": "SELECT DISTINCT title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid EXCEPT SELECT t2.title FROM vocals AS t1 JOIN songs AS t2 ON t1.songid  =  t2.songid WHERE TYPE  =  \"back\"",
        "question": "What are the names of the songs that do not have back vocals?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n"
    },
    {
        "db_id": "apartment_rentals",
        "predict": "SELECT gender_code ,  COUNT(*) FROM Guests GROUP BY gender_code ORDER BY COUNT(*) DESC",
        "question": "Show each gender code and the corresponding count of guests sorted by the count in descending order.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n"
    },
    {
        "db_id": "customers_and_addresses",
        "predict": "SELECT country FROM addresses GROUP BY country HAVING count(address_id)  >  4",
        "question": "For which countries are there more than four distinct addresses listed?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n"
    },
    {
        "db_id": "sports_competition",
        "predict": "SELECT name FROM CLub WHERE Club_ID NOT IN (SELECT Club_ID FROM player)",
        "question": "What are the names of all clubs that do not have any players?",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n"
    },
    {
        "db_id": "music_2",
        "predict": "SELECT DISTINCT TYPE FROM vocals",
        "question": "Find all the vocal types.",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n"
    },
    {
        "db_id": "products_gen_characteristics",
        "predict": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"red\" AND t3.characteristic_name  =  \"slow\"",
        "question": "Find the number of the products that have their color described as \"red\" and have a characteristic named \"slow\".",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n"
    },
    {
        "db_id": "game_1",
        "predict": "SELECT Gname FROM Plays_games AS T1 JOIN Video_games AS T2 ON T1.gameid  =  T2.gameid JOIN Student AS T3 ON T3.Stuid  =  T1.Stuid WHERE T3.Lname  =  \"Smith\" AND T3.Fname  =  \"Linda\"",
        "question": "What are the names of all games played by Linda Smith?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n"
    },
    {
        "db_id": "soccer_2",
        "predict": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'striker'",
        "question": "Find the states of the colleges that have students in the tryout who played in striker position.",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n"
    },
    {
        "db_id": "scientist_1",
        "predict": "SELECT count(DISTINCT name) FROM projects",
        "question": "Find the number of distinct projects.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n"
    },
    {
        "db_id": "customers_and_invoices",
        "predict": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name",
        "question": "Show all product names and the number of customers having an order on each product.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n"
    },
    {
        "db_id": "perpetrator",
        "predict": "SELECT T1.Name FROM people AS T1 JOIN perpetrator AS T2 ON T1.People_ID  =  T2.People_ID",
        "question": "What are the names of perpetrators?",
        "fields": "Table people, columns = [*,People_ID,Name,Height,Weight,Home Town]\nTable perpetrator, columns = [*,Perpetrator_ID,People_ID,Date,Year,Location,Country,Killed,Injured]\n",
        "foreign_keys": "Foreign_keys = [perpetrator.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "customer_deliveries",
        "predict": "SELECT customer_name FROM Customers ORDER BY date_became_customer LIMIT 5",
        "question": "Find the name of the first 5 customers.",
        "fields": "Table Actual_Order_Products, columns = [*,actual_order_id,product_id]\nTable Actual_Orders, columns = [*,actual_order_id,order_status_code,regular_order_id,actual_order_date]\nTable Addresses, columns = [*,address_id,address_details,city,zip_postcode,state_province_county,country]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,address_type,date_to]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,date_became_customer]\nTable Delivery_Route_Locations, columns = [*,location_code,route_id,location_address_id,location_name]\nTable Delivery_Routes, columns = [*,route_id,route_name,other_route_details]\nTable Employees, columns = [*,employee_id,employee_address_id,employee_name,employee_phone]\nTable Order_Deliveries, columns = [*,location_code,actual_order_id,delivery_status_code,driver_employee_id,truck_id,delivery_date]\nTable Products, columns = [*,product_id,product_name,product_price,product_description]\nTable Regular_Order_Products, columns = [*,regular_order_id,product_id]\nTable Regular_Orders, columns = [*,regular_order_id,distributer_id]\nTable Trucks, columns = [*,truck_id,truck_licence_number,truck_details]\n",
        "foreign_keys": "Foreign_keys = [Regular_Orders.distributer_id = Customers.customer_id,Regular_Order_Products.regular_order_id = Regular_Orders.regular_order_id,Regular_Order_Products.product_id = Products.product_id,Actual_Orders.regular_order_id = Regular_Orders.regular_order_id,Actual_Order_Products.actual_order_id = Actual_Orders.actual_order_id,Actual_Order_Products.product_id = Products.product_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Delivery_Route_Locations.route_id = Delivery_Routes.route_id,Delivery_Route_Locations.location_address_id = Addresses.address_id,Employees.employee_address_id = Addresses.address_id,Order_Deliveries.driver_employee_id = Employees.employee_id,Order_Deliveries.location_code = Delivery_Route_Locations.location_code,Order_Deliveries.actual_order_id = Actual_Orders.actual_order_id,Order_Deliveries.truck_id = Trucks.truck_id]\n"
    },
    {
        "db_id": "customers_card_transactions",
        "predict": "SELECT count(*) FROM Accounts",
        "question": "Count the number of accounts.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n"
    },
    {
        "db_id": "tracking_share_transactions",
        "predict": "SELECT T1.purchase_details FROM PURCHASES AS T1 JOIN TRANSACTIONS AS T2 ON T1.purchase_transaction_id  =  T2.transaction_id WHERE T2.amount_of_transaction  >  10000",
        "question": "What are the purchase details of transactions with amount bigger than 10000?",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n"
    },
    {
        "db_id": "gas_company",
        "predict": "SELECT min(market_value) ,  max(market_value) ,  avg(market_value) FROM company",
        "question": "Show minimum, maximum, and average market value for all companies.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n"
    },
    {
        "db_id": "student_assessment",
        "predict": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"statistics\" ORDER BY T2.registration_date",
        "question": "List the id of students who registered course statistics in the order of registration date.",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n"
    },
    {
        "db_id": "scientist_1",
        "predict": "SELECT T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.name  =  'Matter of Time' INTERSECT SELECT T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.name  =  'A Puzzling Parallax'",
        "question": "What are the names of any scientists who worked on projects named 'Matter of Time' and 'A Puzzling Pattern'?",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n"
    },
    {
        "db_id": "icfp_1",
        "predict": "SELECT count(*) FROM authors",
        "question": "How many authors are there?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n"
    },
    {
        "db_id": "store_1",
        "predict": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.album_id GROUP BY T1.id HAVING count(T1.id)  >  10;",
        "question": "What are the names of the albums that have more than 10 tracks?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n"
    },
    {
        "db_id": "soccer_2",
        "predict": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  'Charles'",
        "question": "In which state is the college that Charles attends?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  \"Brittany Harris\"",
        "question": "What are the ids of the movies that are not reviewed by Brittany Harris.",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "customers_card_transactions",
        "predict": "SELECT DISTINCT card_type_code FROM Customers_Cards",
        "question": "Show all card type codes.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n"
    },
    {
        "db_id": "flight_1",
        "predict": "SELECT destination ,  count(*) FROM Flight GROUP BY destination",
        "question": "Show all destinations and the number of flights to each destination.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n"
    },
    {
        "db_id": "flight_1",
        "predict": "SELECT count(DISTINCT eid) FROM Certificate",
        "question": "What is the count of distinct employees with certificates?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n"
    },
    {
        "db_id": "candidate_poll",
        "predict": "SELECT t1.name ,  t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id ORDER BY t2.support_rate DESC LIMIT 1",
        "question": "Find the name and gender of the candidate who got the highest support rate.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "entertainment_awards",
        "predict": "SELECT T2.Name ,  T3.Festival_Name FROM nomination AS T1 JOIN artwork AS T2 ON T1.Artwork_ID  =  T2.Artwork_ID JOIN festival_detail AS T3 ON T1.Festival_ID  =  T3.Festival_ID",
        "question": "For each nomination, show the name of the artwork and name of the festival where it is nominated.",
        "fields": "Table artwork, columns = [*,Artwork_ID,Type,Name]\nTable festival_detail, columns = [*,Festival_ID,Festival_Name,Chair_Name,Location,Year,Num_of_Audience]\nTable nomination, columns = [*,Artwork_ID,Festival_ID,Result]\n",
        "foreign_keys": "Foreign_keys = [nomination.Festival_ID = festival_detail.Festival_ID,nomination.Artwork_ID = artwork.Artwork_ID]\n"
    },
    {
        "db_id": "club_1",
        "predict": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Davis\" AND t3.lname  =  \"Steven\"",
        "question": "List the clubs having \"Davis Steven\" as a member.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n"
    },
    {
        "db_id": "product_catalog",
        "predict": "SELECT t1.catalog_name ,  t1.date_of_publication FROM catalogs AS t1 JOIN catalog_structure AS t2 ON t1.catalog_id  =  t2.catalog_id WHERE catalog_level_number  >  5",
        "question": "Find the names and publication dates of all catalogs that have catalog level number greater than 5.",
        "fields": "Table Attribute_Definitions, columns = [*,attribute_id,attribute_name,attribute_data_type]\nTable Catalog_Contents, columns = [*,catalog_entry_id,catalog_level_number,parent_entry_id,previous_entry_id,next_entry_id,catalog_entry_name,product_stock_number,price_in_dollars,price_in_euros,price_in_pounds,capacity,length,height,width]\nTable Catalog_Contents_Additional_Attributes, columns = [*,catalog_entry_id,catalog_level_number,attribute_id,attribute_value]\nTable Catalog_Structure, columns = [*,catalog_level_number,catalog_id,catalog_level_name]\nTable Catalogs, columns = [*,catalog_id,catalog_name,catalog_publisher,date_of_publication,date_of_latest_revision]\n",
        "foreign_keys": "Foreign_keys = [Catalog_Structure.catalog_id = Catalogs.catalog_id,Catalog_Contents.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_entry_id = Catalog_Contents.catalog_entry_id]\n"
    },
    {
        "db_id": "cre_Doc_Control_Systems",
        "predict": "SELECT Employees.employee_name , count(*) FROM Employees JOIN Circulation_History ON Circulation_History.employee_id = Employees.employee_id GROUP BY Circulation_History.document_id , Circulation_History.draft_number , Circulation_History.copy_number ORDER BY count(*) DESC LIMIT 1;",
        "question": "Which employee has showed up in most circulation history documents. List the employee's name and the number of drafts and copies.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Circulation_History, columns = [*,document_id,draft_number,copy_number,employee_id]\nTable Document_Drafts, columns = [*,document_id,draft_number,draft_details]\nTable Documents, columns = [*,document_id,document_status_code,document_type_code,shipping_agent_code,receipt_date,receipt_number,other_details]\nTable Documents_Mailed, columns = [*,document_id,mailed_to_address_id,mailing_date]\nTable Draft_Copies, columns = [*,document_id,draft_number,copy_number]\nTable Employees, columns = [*,employee_id,role_code,employee_name,other_details]\nTable Ref_Document_Status, columns = [*,document_status_code,document_status_description]\nTable Ref_Document_Types, columns = [*,document_type_code,document_type_description]\nTable Ref_Shipping_Agents, columns = [*,shipping_agent_code,shipping_agent_name,shipping_agent_description]\nTable Roles, columns = [*,role_code,role_description]\n",
        "foreign_keys": "Foreign_keys = [Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code,Documents.document_status_code = Ref_Document_Status.document_status_code,Documents.document_type_code = Ref_Document_Types.document_type_code,Employees.role_code = Roles.role_code,Document_Drafts.document_id = Documents.document_id,Draft_Copies.document_id = Document_Drafts.document_id,Draft_Copies.draft_number = Document_Drafts.draft_number,Circulation_History.employee_id = Employees.employee_id,Circulation_History.document_id = Draft_Copies.document_id,Circulation_History.draft_number = Draft_Copies.draft_number,Circulation_History.copy_number = Draft_Copies.copy_number,Documents_Mailed.mailed_to_address_id = Addresses.address_id,Documents_Mailed.document_id = Documents.document_id]\n"
    },
    {
        "db_id": "formula_1",
        "predict": "SELECT DISTINCT T1.driverid ,  T1.nationality FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid WHERE T2.milliseconds >  100000",
        "question": "Find all the distinct id and nationality of drivers who have had laptime more than 100000 milliseconds?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n"
    },
    {
        "db_id": "club_1",
        "predict": "SELECT clubname FROM club",
        "question": "What are the names of all clubs?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n"
    },
    {
        "db_id": "gymnast",
        "predict": "SELECT Hometown FROM people WHERE Age  >  23 INTERSECT SELECT Hometown FROM people WHERE Age  <  20",
        "question": "From which hometowns did both people older than 23 and younger than 20 come from?",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n"
    },
    {
        "db_id": "college_3",
        "predict": "SELECT DName FROM DEPARTMENT WHERE Building  =  \"Mergenthaler\"",
        "question": "Find the department name that is in Building \"Mergenthaler\".",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n"
    },
    {
        "db_id": "mountain_photos",
        "predict": "SELECT T2.name FROM photos AS T1 JOIN camera_lens AS T2 ON T1.camera_lens_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1",
        "question": "What are the names of the cameras that have taken picture of the most mountains?",
        "fields": "Table camera_lens, columns = [*,id,brand,name,focal_length_mm,max_aperture]\nTable mountain, columns = [*,id,name,Height,Prominence,Range,Country]\nTable photos, columns = [*,id,camera_lens_id,mountain_id,color,name]\n",
        "foreign_keys": "Foreign_keys = [photos.mountain_id = mountain.id,photos.camera_lens_id = camera_lens.id]\n"
    },
    {
        "db_id": "city_record",
        "predict": "SELECT T2.year FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city WHERE T1.city  =  \"Taizhou ( Zhejiang )\"",
        "question": "IN which year did city \"Taizhou ( Zhejiang )\" serve as a host city?",
        "fields": "Table city, columns = [*,City_ID,City,Hanzi,Hanyu_Pinyin,Regional_Population,GDP]\nTable hosting_city, columns = [*,Year,Match_ID,Host_City]\nTable match, columns = [*,Match_ID,Date,Venue,Score,Result,Competition]\nTable temperature, columns = [*,City_ID,Jan,Feb,Mar,Apr,Jun,Jul,Aug,Sep,Oct,Nov,Dec]\n",
        "foreign_keys": "Foreign_keys = [temperature.City_ID = city.City_ID,hosting_city.Match_ID = match.Match_ID,hosting_city.Host_City = city.City_ID]\n"
    },
    {
        "db_id": "baseball_1",
        "predict": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75",
        "question": "What are the first name and last name of the players who have weight above 220 or height below 75?",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n"
    },
    {
        "db_id": "icfp_1",
        "predict": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid WHERE t1.fname  =  \"Olin\" AND t1.lname  =  \"Shivers\"",
        "question": "Find the papers which have \"Olin Shivers\" as an author.",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n"
    },
    {
        "db_id": "icfp_1",
        "predict": "SELECT lname FROM authors WHERE fname  =  \"Amal\"",
        "question": "Which authors have first name \"Amal\"? List their last names.",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n"
    },
    {
        "db_id": "store_product",
        "predict": "SELECT product FROM product WHERE max_page_size  =  \"A4\" OR pages_per_minute_color  <  5",
        "question": "What are the products with the maximum page size eqal to A4 or a pages per minute color less than 5?",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n"
    },
    {
        "db_id": "city_record",
        "predict": "SELECT venue FROM MATCH ORDER BY date DESC",
        "question": "List venues of all matches in the order of their dates starting from the most recent one.",
        "fields": "Table city, columns = [*,City_ID,City,Hanzi,Hanyu_Pinyin,Regional_Population,GDP]\nTable hosting_city, columns = [*,Year,Match_ID,Host_City]\nTable match, columns = [*,Match_ID,Date,Venue,Score,Result,Competition]\nTable temperature, columns = [*,City_ID,Jan,Feb,Mar,Apr,Jun,Jul,Aug,Sep,Oct,Nov,Dec]\n",
        "foreign_keys": "Foreign_keys = [temperature.City_ID = city.City_ID,hosting_city.Match_ID = match.Match_ID,hosting_city.Host_City = city.City_ID]\n"
    },
    {
        "db_id": "allergy_1",
        "predict": "SELECT StuID FROM Has_allergy GROUP BY StuID HAVING count(*)  >=  2",
        "question": "What are the students ids of students who have more than one allergy?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n"
    },
    {
        "db_id": "customers_and_addresses",
        "predict": "SELECT city FROM addresses WHERE city NOT IN ( SELECT DISTINCT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id)",
        "question": "What are the cities no customers live in?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n"
    },
    {
        "db_id": "manufactory_1",
        "predict": "SELECT avg(T1.Price) ,  T2.name FROM products AS T1 JOIN Manufacturers AS T2 ON T1.manufacturer  =  T2.code GROUP BY T2.name",
        "question": "What are the average prices of products, grouped by manufacturer name?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n"
    },
    {
        "db_id": "manufactory_1",
        "predict": "SELECT name ,  max(revenue) ,  Headquarter FROM manufacturers GROUP BY Headquarter",
        "question": "Find the name and revenue of the company that earns the highest revenue in each city.",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n"
    },
    {
        "db_id": "customer_complaints",
        "predict": "SELECT town_city FROM customers WHERE customer_type_code  =  \"Good Credit Rating\" GROUP BY town_city ORDER BY count(*) LIMIT 1",
        "question": "Which city has the least number of customers whose type code is \"Good Credit Rating\"?",
        "fields": "Table Complaints, columns = [*,complaint_id,product_id,customer_id,complaint_outcome_code,complaint_status_code,complaint_type_code,date_complaint_raised,date_complaint_closed,staff_id]\nTable Customers, columns = [*,customer_id,customer_type_code,address_line_1,address_line_2,town_city,state,email_address,phone_number]\nTable Products, columns = [*,product_id,parent_product_id,product_category_code,date_product_first_available,date_product_discontinued,product_name,product_description,product_price]\nTable Staff, columns = [*,staff_id,gender,first_name,last_name,email_address,phone_number]\n",
        "foreign_keys": "Foreign_keys = [Complaints.customer_id = Customers.customer_id,Complaints.product_id = Products.product_id,Complaints.staff_id = Staff.staff_id]\n"
    },
    {
        "db_id": "inn_1",
        "predict": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE firstname LIKE '%ROY%'",
        "question": "What are the name of rooms booked by customers whose first name has \"ROY\" in part?",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n"
    },
    {
        "db_id": "dorm_1",
        "predict": "SELECT avg(age) ,  city_code FROM student GROUP BY city_code",
        "question": "What is the average age for each city and what are those cities?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n"
    },
    {
        "db_id": "workshop_paper",
        "predict": "SELECT avg(Scores) FROM submission",
        "question": "What is the average score of submissions?",
        "fields": "Table Acceptance, columns = [*,Submission_ID,Workshop_ID,Result]\nTable submission, columns = [*,Submission_ID,Scores,Author,College]\nTable workshop, columns = [*,Workshop_ID,Date,Venue,Name]\n",
        "foreign_keys": "Foreign_keys = [Acceptance.Workshop_ID = workshop.Workshop_ID,Acceptance.Submission_ID = submission.Submission_ID]\n"
    },
    {
        "db_id": "college_1",
        "predict": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code",
        "question": "How many professors have a Ph.D. in each department?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n"
    },
    {
        "db_id": "chinook_1",
        "predict": "SELECT max(Milliseconds) ,  min(Milliseconds) FROM TRACK",
        "question": "Find the maximum and minimum durations of tracks in milliseconds.",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n"
    },
    {
        "db_id": "gymnast",
        "predict": "SELECT Total_Points FROM gymnast ORDER BY Total_Points DESC",
        "question": "List the total points of gymnasts in descending order.",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n"
    },
    {
        "db_id": "scientist_1",
        "predict": "SELECT name FROM projects WHERE hours  >  (SELECT avg(hours) FROM projects)",
        "question": "List the name of all projects that are operated longer than the average working hours of all projects.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n"
    },
    {
        "db_id": "assets_maintenance",
        "predict": "SELECT T1.part_name ,  T1.part_id FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id GROUP BY T1.part_id HAVING count(*)  >  2",
        "question": "Which parts have more than 2 faults? Show the part name and id.",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n"
    },
    {
        "db_id": "loan_1",
        "predict": "SELECT sum(acc_bal) FROM customer WHERE state  =  'Utah' OR state  =  'Texas'",
        "question": "Find the total account balance of each customer from Utah or Texas.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "predict": "SELECT budget_type_code ,  count(*) FROM Documents_with_expenses GROUP BY budget_type_code",
        "question": "What are the different budget type codes, and how many documents are there for each?",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n"
    },
    {
        "db_id": "tracking_grants_for_research",
        "predict": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the type and id of the organization that has the most research staff?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n"
    },
    {
        "db_id": "hr_1",
        "predict": "SELECT salary ,  manager_id FROM employees WHERE manager_id != \"null\"",
        "question": "Find the salary and manager number for those employees who is working under a manager.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n"
    },
    {
        "db_id": "city_record",
        "predict": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000",
        "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.",
        "fields": "Table city, columns = [*,City_ID,City,Hanzi,Hanyu_Pinyin,Regional_Population,GDP]\nTable hosting_city, columns = [*,Year,Match_ID,Host_City]\nTable match, columns = [*,Match_ID,Date,Venue,Score,Result,Competition]\nTable temperature, columns = [*,City_ID,Jan,Feb,Mar,Apr,Jun,Jul,Aug,Sep,Oct,Nov,Dec]\n",
        "foreign_keys": "Foreign_keys = [temperature.City_ID = city.City_ID,hosting_city.Match_ID = match.Match_ID,hosting_city.Host_City = city.City_ID]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1",
        "question": "What is the gender and name of the artist who sang the song with the smallest resolution?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "department_store",
        "predict": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1",
        "question": "List the name of staff who has been assigned multiple jobs.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n"
    },
    {
        "db_id": "hospital_1",
        "predict": "SELECT T4.name FROM stay AS T1 JOIN patient AS T2 ON T1.Patient  =  T2.SSN JOIN Prescribes AS T3 ON T3.Patient  =  T2.SSN JOIN Medication AS T4 ON T3.Medication  =  T4.Code WHERE room  =  111",
        "question": "What is the name of the medication used for the patient staying in room 111?",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n"
    },
    {
        "db_id": "manufacturer",
        "predict": "SELECT max(num_of_shops) ,  avg(Num_of_Factories) FROM manufacturer WHERE open_year  <  1990",
        "question": "what is the average number of factories and maximum number of shops for manufacturers that opened before 1990.",
        "fields": "Table furniture, columns = [*,Furniture_ID,Name,Num_of_Component,Market_Rate]\nTable furniture_manufacte, columns = [*,Manufacturer_ID,Furniture_ID,Price_in_Dollar]\nTable manufacturer, columns = [*,Manufacturer_ID,Open_Year,Name,Num_of_Factories,Num_of_Shops]\n",
        "foreign_keys": "Foreign_keys = [furniture_manufacte.Furniture_ID = furniture.Furniture_ID,furniture_manufacte.Manufacturer_ID = manufacturer.Manufacturer_ID]\n"
    },
    {
        "db_id": "music_2",
        "predict": "SELECT * FROM Albums WHERE YEAR  =  2012",
        "question": "return all columns of the albums created in the year of 2012.",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n"
    },
    {
        "db_id": "network_2",
        "predict": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )",
        "question": "What is the name of the oldest student?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n"
    },
    {
        "db_id": "products_gen_characteristics",
        "predict": "SELECT t2.unit_of_measure FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  \"cumin\"",
        "question": "Give the unit of measure for the product with the name 'cumin'.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n"
    },
    {
        "db_id": "tracking_orders",
        "predict": "SELECT invoice_number FROM invoices WHERE invoice_date < \"1989-09-03\" OR invoice_date > \"2007-12-25\"",
        "question": "What are the invoice numbers created before 1989-09-03 or after 2007-12-25?",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n"
    },
    {
        "db_id": "shop_membership",
        "predict": "SELECT T3.name ,  T2.name FROM membership_register_branch AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id JOIN member AS T3 ON T1.member_id  =  T3.member_id ORDER BY T1.register_year",
        "question": "What are the names of the members and branches at which they are registered sorted by year of registration?",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n"
    },
    {
        "db_id": "cinema",
        "predict": "SELECT T2.title ,  max(T1.price) FROM schedule AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id",
        "question": "Give me the title and highest price for each film.",
        "fields": "Table cinema, columns = [*,Cinema_ID,Name,Openning_year,Capacity,Location]\nTable film, columns = [*,Film_ID,Rank_in_series,Number_in_season,Title,Directed_by,Original_air_date,Production_code]\nTable schedule, columns = [*,Cinema_ID,Film_ID,Date,Show_times_per_day,Price]\n",
        "foreign_keys": "Foreign_keys = [schedule.Cinema_ID = cinema.Cinema_ID,schedule.Film_ID = film.Film_ID]\n"
    },
    {
        "db_id": "hr_1",
        "predict": "SELECT T1.first_name ,  T1.job_id FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T2.department_name  =  'Finance'",
        "question": "Give the first name and job id for all employees in the Finance department.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "predict": "SELECT T3.location_name FROM All_documents AS T1 JOIN Document_locations AS T2 ON T1.document_id  =  T2.document_id JOIN Ref_locations AS T3 ON T2.location_code  =  T3.location_code WHERE T1.document_name  =  \"Robin CV\"",
        "question": "What is the location name of the document \"Robin CV\"?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n"
    },
    {
        "db_id": "baseball_1",
        "predict": "SELECT name_first ,  name_last FROM player AS T1 JOIN all_star AS T2 ON T1.player_id  =  T2.player_id WHERE YEAR  =  1998",
        "question": "List the first and last name for players who participated in all star game in 1998.",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n"
    },
    {
        "db_id": "chinook_1",
        "predict": "SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreID  =  T3.GenreID WHERE T3.Name  =  'Reggae' INTERSECT SELECT T1.Title FROM Album AS T1 JOIN Track AS T2 ON T1.AlbumId  =  T2.AlbumId JOIN Genre AS T3 ON T2.GenreID  =  T3.GenreID WHERE T3.Name  =  'Rock'",
        "question": "What are the album titles for albums containing both 'Reggae' and 'Rock' genre tracks?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n"
    },
    {
        "db_id": "shop_membership",
        "predict": "SELECT city FROM branch EXCEPT SELECT city FROM branch WHERE membership_amount  >  100",
        "question": "Show all cities without a branch having more than 100 memberships.",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n"
    },
    {
        "db_id": "manufactory_1",
        "predict": "SELECT name ,  price FROM Products ORDER BY price ASC LIMIT 1",
        "question": "Select the name and price of the cheapest product.",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n"
    },
    {
        "db_id": "csu_1",
        "predict": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004",
        "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n"
    },
    {
        "db_id": "county_public_safety",
        "predict": "SELECT Case_burden FROM county_public_safety ORDER BY Population DESC",
        "question": "Show the case burden of counties in descending order of population.",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n"
    },
    {
        "db_id": "coffee_shop",
        "predict": "SELECT count(*) ,  address FROM member GROUP BY address",
        "question": "Find the number of members living in each address.",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n"
    },
    {
        "db_id": "entrepreneur",
        "predict": "SELECT Investor ,  COUNT(*) FROM entrepreneur GROUP BY Investor",
        "question": "What are the investors of entrepreneurs and the corresponding number of entrepreneurs invested by each investor?",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "products_gen_characteristics",
        "predict": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS",
        "question": "Find the names of all the product characteristics.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n"
    },
    {
        "db_id": "wine_1",
        "predict": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  \"White\" AND T2.score  >  90",
        "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n"
    },
    {
        "db_id": "customers_card_transactions",
        "predict": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "question": "What is the phone and email for customer with first name Aniyah and last name Feest?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n"
    },
    {
        "db_id": "shop_membership",
        "predict": "SELECT name ,  address_road ,  city FROM branch ORDER BY open_year",
        "question": "Show name, address road, and city for all branches sorted by open year.",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n"
    },
    {
        "db_id": "city_record",
        "predict": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1",
        "question": "Which city has hosted the most events?",
        "fields": "Table city, columns = [*,City_ID,City,Hanzi,Hanyu_Pinyin,Regional_Population,GDP]\nTable hosting_city, columns = [*,Year,Match_ID,Host_City]\nTable match, columns = [*,Match_ID,Date,Venue,Score,Result,Competition]\nTable temperature, columns = [*,City_ID,Jan,Feb,Mar,Apr,Jun,Jul,Aug,Sep,Oct,Nov,Dec]\n",
        "foreign_keys": "Foreign_keys = [temperature.City_ID = city.City_ID,hosting_city.Match_ID = match.Match_ID,hosting_city.Host_City = city.City_ID]\n"
    },
    {
        "db_id": "music_1",
        "predict": "SELECT song_name FROM song WHERE rating  <   (SELECT min(rating) FROM song WHERE languages  =  'english')",
        "question": "What are the names of the songs whose rating is below the rating of all songs in English?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n"
    },
    {
        "db_id": "pilot_record",
        "predict": "SELECT Pilot_name FROM pilot WHERE Team  =  \"Bradley\" OR Team  =  \"Fordham\"",
        "question": "Show the names of pilots from team \"Bradley\" or \"Fordham\".",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Order_Year,Manufacturer,Model,Fleet_Series,Powertrain,Fuel_Propulsion]\nTable pilot, columns = [*,Pilot_ID,Pilot_name,Rank,Age,Nationality,Position,Join_Year,Team]\nTable pilot_record, columns = [*,Record_ID,Pilot_ID,Aircraft_ID,Date]\n",
        "foreign_keys": "Foreign_keys = [pilot_record.Aircraft_ID = aircraft.Aircraft_ID,pilot_record.Pilot_ID = pilot.Pilot_ID]\n"
    },
    {
        "db_id": "formula_1",
        "predict": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20",
        "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "predict": "SELECT DISTINCT location_code FROM Document_locations",
        "question": "What are the different location codes for documents?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n"
    },
    {
        "db_id": "coffee_shop",
        "predict": "SELECT membership_card FROM member WHERE address  =  'Hartford' INTERSECT SELECT membership_card FROM member WHERE address  =  'Waterbury'",
        "question": "What is the membership card held by both members living in Hartford and ones living in Waterbury address?",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n"
    },
    {
        "db_id": "music_2",
        "predict": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Le Pop\"",
        "question": "Who performed the song named \"Le Pop\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n"
    },
    {
        "db_id": "hospital_1",
        "predict": "SELECT name FROM physician WHERE POSITION LIKE '%senior%'",
        "question": "Find the name of physicians whose position title contains the word 'senior'.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director",
        "question": "How many movie reviews does each director get?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "predict": "SELECT count(*) FROM Statements",
        "question": "Count the number of statements.",
        "fields": "Table Accounts, columns = [*,Account_ID,Statement_ID,Account_Details]\nTable Documents, columns = [*,Document_ID,Document_Type_Code,Project_ID,Document_Date,Document_Name,Document_Description,Other_Details]\nTable Documents_with_Expenses, columns = [*,Document_ID,Budget_Type_Code,Document_Details]\nTable Projects, columns = [*,Project_ID,Project_Details]\nTable Ref_Budget_Codes, columns = [*,Budget_Type_Code,Budget_Type_Description]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Statements, columns = [*,Statement_ID,Statement_Details]\n",
        "foreign_keys": "Foreign_keys = [Documents.Project_ID = Projects.Project_ID,Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Statements.Statement_ID = Documents.Document_ID,Documents_with_Expenses.Document_ID = Documents.Document_ID,Documents_with_Expenses.Budget_Type_Code = Ref_Budget_Codes.Budget_Type_Code,Accounts.Statement_ID = Statements.Statement_ID]\n"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "predict": "SELECT Product_Name ,  avg(Product_Price) FROM PRODUCTS GROUP BY Product_Name",
        "question": "What are the different product names? What is the average product price for each of them?",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n"
    },
    {
        "db_id": "party_host",
        "predict": "SELECT T2.Name FROM party_host AS T1 JOIN HOST AS T2 ON T1.Host_ID  =  T2.Host_ID JOIN party AS T3 ON T1.Party_ID  =  T3.Party_ID WHERE T3.Number_of_hosts  >  20",
        "question": "Which parties have more than 20 hosts? Give me the host names for these parties.",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n"
    },
    {
        "db_id": "flight_company",
        "predict": "SELECT id ,  country ,  city ,  name FROM airport ORDER BY name",
        "question": "List the id, country, city and name of the airports ordered alphabetically by the name.",
        "fields": "Table airport, columns = [*,id,City,Country,IATA,ICAO,name]\nTable flight, columns = [*,id,Vehicle_Flight_number,Date,Pilot,Velocity,Altitude,airport_id,company_id]\nTable operate_company, columns = [*,id,name,Type,Principal_activities,Incorporated_in,Group_Equity_Shareholding]\n",
        "foreign_keys": "Foreign_keys = [flight.company_id = operate_company.id,flight.airport_id = airport.id]\n"
    },
    {
        "db_id": "loan_1",
        "predict": "SELECT count(DISTINCT acc_type) FROM customer",
        "question": "Count the number of different account types.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n"
    },
    {
        "db_id": "club_1",
        "predict": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  \"F\" GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1",
        "question": "Which club has the most female students as their members? Give me the name of the club.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n"
    },
    {
        "db_id": "hr_1",
        "predict": "SELECT * FROM employees WHERE hire_date  <  '2002-06-21'",
        "question": "display all the details from Employees table for those employees who was hired before 2002-06-21.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n"
    },
    {
        "db_id": "soccer_2",
        "predict": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "question": "What college has a student who successfully made the team in the role of a goalie?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n"
    },
    {
        "db_id": "student_1",
        "predict": "SELECT count(*) FROM list",
        "question": "How many students are there?",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n"
    },
    {
        "db_id": "customers_and_invoices",
        "predict": "SELECT T2.customer_last_name ,  T1.customer_id ,  T2.phone_number FROM Orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "question": "What is the customer last name, id and phone number with most number of orders?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n"
    },
    {
        "db_id": "department_store",
        "predict": "SELECT product_id ,  product_type_code FROM products ORDER BY product_price LIMIT 1",
        "question": "Give the id and product type of the product with the lowest price.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n"
    },
    {
        "db_id": "device",
        "predict": "SELECT LOCATION FROM shop WHERE Open_Year  >  2012 INTERSECT SELECT LOCATION FROM shop WHERE Open_Year  <  2008",
        "question": "Show the locations shared by shops with open year later than 2012 and shops with open year before 2008.",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT building ,  room_number FROM classroom WHERE capacity BETWEEN 50 AND 100",
        "question": "Find the room number of the rooms which can sit 50 to 100 students and their buildings.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "roller_coaster",
        "predict": "SELECT T1.Name FROM country AS T1 JOIN roller_coaster AS T2 ON T1.Country_ID  =  T2.Country_ID GROUP BY T1.Name HAVING COUNT(*)  >  1",
        "question": "Show the names of countries that have more than one roller coaster.",
        "fields": "Table country, columns = [*,Country_ID,Name,Population,Area,Languages]\nTable roller_coaster, columns = [*,Roller_Coaster_ID,Name,Park,Country_ID,Length,Height,Speed,Opened,Status]\n",
        "foreign_keys": "Foreign_keys = [roller_coaster.Country_ID = country.Country_ID]\n"
    },
    {
        "db_id": "sports_competition",
        "predict": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20",
        "question": "What are the positions of players whose average number of points scored by that position is larger than 20?",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n"
    },
    {
        "db_id": "race_track",
        "predict": "SELECT count(*) FROM race",
        "question": "Count the number of races.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n"
    },
    {
        "db_id": "company_office",
        "predict": "SELECT count(DISTINCT Industry) FROM Companies",
        "question": "How many different industries are the companies in?",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n"
    },
    {
        "db_id": "hr_1",
        "predict": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'",
        "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n"
    },
    {
        "db_id": "college_2",
        "predict": "SELECT count(*) FROM classroom WHERE building  =  'Lamberton' AND capacity  <  50",
        "question": "Count the number of rooms in Lamberton with capacity lower than 50.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n"
    },
    {
        "db_id": "movie_1",
        "predict": "SELECT max(T1.stars) ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.year  =  (SELECT max(YEAR) FROM Movie)",
        "question": "What is highest rating for the most recent movie and when was it released?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n"
    },
    {
        "db_id": "body_builder",
        "predict": "SELECT T2.weight FROM body_builder AS T1 JOIN people AS T2 ON T1.people_id  =  T2.people_id WHERE T1.snatch  >  140 OR T2.height  >  200;",
        "question": "List the weight of the body builders who have snatch score higher than 140 or have the height greater than 200.",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n"
    },
    {
        "db_id": "customers_and_addresses",
        "predict": "SELECT sum(t3.order_quantity) FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t1.customer_name  =  \"Rodrick Heaney\"",
        "question": "Tell me the total quantity of products bought by the customer called \"Rodrick Heaney\".",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "predict": "SELECT employee_id FROM Employees EXCEPT SELECT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed",
        "question": "Which employees do not authorize destruction for any document? Give me their employee ids.",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n"
    },
    {
        "db_id": "cre_Theme_park",
        "predict": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  \"walk\" OR  T2.How_to_Get_There  =  \"bus\"",
        "question": "What are the details of the markets that can be accessed by walk or bus?",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n"
    },
    {
        "db_id": "school_player",
        "predict": "SELECT count(*) FROM school",
        "question": "How many schools are there?",
        "fields": "Table player, columns = [*,Player_ID,Player,Team,Age,Position,School_ID]\nTable school, columns = [*,School_ID,School,Location,Enrollment,Founded,Denomination,Boys_or_Girls,Day_or_Boarding,Year_Entered_Competition,School_Colors]\nTable school_details, columns = [*,School_ID,Nickname,Colors,League,Class,Division]\nTable school_performance, columns = [*,School_Id,School_Year,Class_A,Class_AA]\n",
        "foreign_keys": "Foreign_keys = [school_details.School_ID = school.School_ID,school_performance.School_Id = school.School_ID,player.School_ID = school.School_ID]\n"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "predict": "SELECT employee_name ,  role_code ,  date_of_birth FROM Employees WHERE employee_Name  =  'Armani'",
        "question": "Show the name, role code, and date of birth for the employee with name 'Armani'.",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n"
    },
    {
        "db_id": "driving_school",
        "predict": "SELECT customer_status_code FROM Customers GROUP BY customer_status_code ORDER BY count(*) ASC LIMIT 1;",
        "question": "Which customer status code has least number of customers?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n"
    }
]