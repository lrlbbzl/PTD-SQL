[
    {
        "db_id": "department_management",
        "gold": "SELECT count(*) FROM department WHERE department_id NOT IN (SELECT department_id FROM management);",
        "question": "How many departments are led by heads who are not mentioned?",
        "fields": "Table department, columns = [*,Department_ID,Name,Creation,Ranking,Budget_in_Billions,Num_Employees]\nTable head, columns = [*,head_ID,name,born_state,age]\nTable management, columns = [*,department_ID,head_ID,temporary_acting]\n",
        "foreign_keys": "Foreign_keys = [management.head_ID = head.head_ID,management.department_ID = department.Department_ID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of departments that are led by heads who are not mentioned. We need to filter departments based on the heads mentioned in the 'head' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the department_ID from the 'department' table and filter based on the head_ID mentioned in the 'head' table.\n\n<3> SQL Generation: Use 'where' to filter departments based on the head_ID mentioned in the 'head' table and count the number of departments.\n\n",
        "predict": "SELECT COUNT(*) FROM department WHERE Department_ID NOT IN (SELECT department_ID FROM management)"
    },
    {
        "db_id": "farm",
        "gold": "SELECT Hosts FROM farm_competition WHERE Theme !=  'Aliens'",
        "question": "Return the hosts of competitions for which the theme is not Aliens?",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on column 'theme', so we should apply the 'where' to column 'theme' and then return the hosts of selected competition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'farm_competition' has columns 'Theme' and 'Hosts', we only need table 'farm_competition'.\n\n<3> SQL Generation: Directly write the sql using 'where'.\n\n",
        "predict": "SELECT Hosts FROM farm_competition WHERE Theme != 'Aliens'"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "question": "List the id of students who never attends courses?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who have registered for courses. Secondly, we need to filter out the students who have never attended any courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from table 'Students' and filter by student_id in table 'Student_Course_Registrations' and 'Student_Course_Attendance'.\n\n<3> SQL Generation: We need to use 'left join' to combine the 'Students' table with the 'Student_Course_Registrations' table and 'Student_Course_Attendance' table. Then, we filter out the rows where the student_id in 'Student_Course_Attendance' is null, indicating that the student has never attended any courses.\n\n",
        "predict": "SELECT student_id FROM Students LEFT JOIN Student_Course_Registrations ON Students.student_id = Student_Course_Registrations.student_id LEFT JOIN Student_Course_Attendance ON Student_Course_Registrations.student_id = Student_Course_Attendance.student_id WHERE Student_Course_Attendance.student_id IS NULL"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "question": "What are the  ids of every student who has never attended a course?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the ids of all students. Secondly, we need to filter out the students who have attended a course. Finally, we need to return the ids of the remaining students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from table 'Students' and filter it based on the student_id in table 'Student_Course_Attendance'.\n\n<3> SQL Generation: Use 'where' to filter out the student_ids that appear in the 'Student_Course_Attendance' table, and then select the remaining student_ids.\n\n",
        "predict": "SELECT student_id FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Attendance)"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"English\"",
        "question": "How many students are attending English courses?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the course_id for English courses. Secondly, we need to count the number of students attending those courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'Courses' where course_name = 'English'. In the second step, we need to count the number of students from table 'Student_Course_Attendance' where course_id matches the course_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the course_id for English courses, and then use 'count' to count the number of students attending those courses.\n\n",
        "predict": "SELECT COUNT(DISTINCT student_id) FROM Student_Course_Attendance WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'English')"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "question": "How many courses do the student whose id is 171 attend?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with id 171. Secondly, we need to count the number of courses that the student attends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select student_id from table 'Students' where student_id = 171. In the second step, we need to count the number of courses from table 'Student_Course_Attendance' where student_id = 171.\n\n<3> SQL Generation: Use 'where' to find the student with id 171, and then use 'count' to count the number of courses that the student attends.\n\n",
        "predict": "SELECT COUNT(*) FROM Student_Course_Attendance WHERE student_id = 171"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "question": "How many courses does the student with id 171 actually attend?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the courses that the student with id 171 is registered for. Secondly, we need to count the number of courses that the student actually attends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'Student_Course_Registrations' where student_id = 171. In the second step, we need to count the number of rows in table 'Student_Course_Attendance' where student_id = 171 and course_id is in the list of courses obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the courses that the student with id 171 is registered for, and then use 'where' and 'count' to count the number of courses that the student actually attends.\n\n",
        "predict": "SELECT COUNT(*) FROM Student_Course_Attendance WHERE student_id = 171 AND course_id IN (SELECT course_id FROM Student_Course_Registrations WHERE student_id = 171)"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT candidate_id FROM candidate_assessments WHERE asessment_outcome_code = \"Pass\"",
        "question": "Find id of candidates whose assessment code is \"Pass\"?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the assessment code, so we should apply the 'where' to column 'assessment_outcome_code' and then return the candidate ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'Candidate_Assessments' has column 'assessment_outcome_code' and 'candidate_id', we only need table 'Candidate_Assessments'.\n\n<3> SQL Generation: Directly write the sql using 'where'.\n\n",
        "predict": "SELECT candidate_id FROM Candidate_Assessments WHERE assessment_outcome_code = 'Pass'"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "question": "What are all details of the students who registered but did not attend any course?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who registered for courses. Secondly, we need to filter out the students who did not attend any course. Finally, we need to retrieve all details of the remaining students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select all details from table 'Students' and filter by the students who registered for courses in table 'Student_Course_Registrations'. We also need to filter out the students who attended courses in table 'Student_Course_Attendance'.\n\n<3> SQL Generation: Use 'where' to filter the students who registered for courses and 'not in' to filter out the students who attended courses. Then, select all details of the remaining students.\n\n",
        "predict": "SELECT * FROM Students WHERE student_id IN (SELECT student_id FROM Student_Course_Registrations) AND student_id NOT IN (SELECT student_id FROM Student_Course_Attendance)"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT name FROM station WHERE lat  <  37.5",
        "question": "What are the names of stations that have latitude lower than 37.5?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on stations with latitude lower than 37.5. We need to select the names of these stations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'station' table and the 'name' column.\n\n<3> SQL Generation: Use 'where' to filter stations with latitude lower than 37.5 and select their names.\n\n",
        "predict": "SELECT name FROM station WHERE lat < 37.5"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT COUNT(*) FROM station WHERE city  =  \"Mountain View\"",
        "question": "How many stations does Mountain View city has?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of stations in Mountain View city.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'station' table and the 'city' column.\n\n<3> SQL Generation: Use 'where' to filter stations in Mountain View city and then use 'count' to calculate the number of stations.\n\n",
        "predict": "SELECT COUNT(*) FROM station WHERE city = 'Mountain View'"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8",
        "question": "What is the number of days that had an average humity above 50 and an average visibility above 8?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter days with an average humidity above 50. Secondly, we need to filter days with an average visibility above 8. Finally, we need to count the number of days that meet both conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'weather' table for this query.\n\n<3> SQL Generation: Use 'where' to filter days with an average humidity above 50 and an average visibility above 8, and then use 'count' to calculate the number of days that meet both conditions.\n\n",
        "predict": "SELECT COUNT(*) FROM weather WHERE mean_humidity > 50 AND mean_visibility_miles > 8"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT T1.lat ,  T1.long ,  T1.city FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id ORDER BY T2.duration LIMIT 1",
        "question": "What is the latitude, longitude, and city of the station from which the trip with smallest duration started?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the trip with the smallest duration. Secondly, we need to identify the station from which this trip started. Finally, we need to retrieve the latitude, longitude, and city of this station.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the minimum duration from table 'trip'. In the second step, we need to filter the trip with the minimum duration and retrieve the start_station_id. In the final step, we need to select the latitude, longitude, and city from table 'station' based on the start_station_id.\n\n<3> SQL Generation: Use 'where' to find the trip with the smallest duration, and then use 'where' to filter the start_station_id and select the corresponding latitude, longitude, and city.\n\n",
        "predict": "SELECT station.lat, station.long, station.city FROM trip JOIN station ON trip.start_station_id = station.id WHERE trip.duration = (SELECT MIN(duration) FROM trip)"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "question": "What is the average bike availability in stations that are not located in Palo Alto?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires calculating the average bike availability in stations that are not located in Palo Alto. Firstly, we need to identify the stations located in Palo Alto. Secondly, we need to filter stations that are not located in Palo Alto. Finally, we calculate the average bike availability in the remaining stations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'station' and 'status' tables. \n\n<3> SQL Generation: Use 'where' to filter stations located in Palo Alto, and then use 'not in' to filter stations that are not located in Palo Alto. Finally, calculate the average bike availability in the remaining stations.\n\n",
        "predict": "SELECT AVG(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city = 'Palo Alto')"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "question": "What is the average bike availablility for stations not in Palo Alto?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on stations that are not in Palo Alto. Firstly, we need to identify the stations located in Palo Alto. Secondly, we need to calculate the average bike availability for stations that are not in Palo Alto.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'station' where city = 'Palo Alto'. In the second step, we need to select bikes_available from table 'status' and filter by station_id.\n\n<3> SQL Generation: Use 'where' to filter stations in Palo Alto, and then use 'not in' to filter stations that are not in Palo Alto. Finally, calculate the average bike availability for the selected stations.\n\n",
        "predict": "SELECT AVG(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city = 'Palo Alto')"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != \"San Francisco\"",
        "question": "How many trips did not end in San Francisco?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on trips that did not end in San Francisco. Firstly, we need to identify the stations located in San Francisco. Secondly, we need to filter trips based on their end_station_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'station' where city = 'San Francisco'. In the second step, we need to select id from table 'trip' and filter by end_station_id.\n\n<3> SQL Generation: Use 'where' to filter stations in San Francisco, and then use 'not in' to filter trips that did not end in San Francisco.\n\n",
        "predict": "SELECT COUNT(*) FROM trip WHERE end_station_id NOT IN (SELECT id FROM station WHERE city = 'San Francisco')"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT DISTINCT start_station_name FROM trip WHERE duration  <  100",
        "question": "List all the distinct stations from which a trip of duration below 100 started.",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on trips with a duration below 100. Firstly, we need to identify the trips with a duration below 100. Secondly, we need to select the distinct start_station_id from these trips.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select start_station_id from table 'trip' where duration < 100. In the second step, we need to select distinct start_station_id from table 'trip'.\n\n<3> SQL Generation: Use 'where' to filter trips with a duration below 100, and then use 'distinct' to select the distinct start_station_id.\n\n",
        "predict": "SELECT DISTINCT start_station_id FROM trip WHERE duration < 100"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  12",
        "question": "What are the id and name of the stations that have ever had more than 12 bikes available?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: We need to filter stations based on the number of bikes available, specifically when it is more than 12.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'station' and 'status' tables, as we are interested in the number of bikes available at each station.\n\n<3> SQL Generation: We need to join the 'station' and 'status' tables on the 'id' column. Then, we filter the rows where the 'bikes_available' column is greater than 12. Finally, we select the 'id' and 'name' columns from the 'station' table.\n\n",
        "predict": "SELECT id, name FROM station JOIN status ON station.id = status.station_id WHERE status.bikes_available > 12"
    },
    {
        "db_id": "book_2",
        "gold": "SELECT Title FROM book WHERE Writer != \"Elaine Lee\"",
        "question": "What are the titles of the books whose writer is not \"Elaine Lee\"?",
        "fields": "Table book, columns = [*,Book_ID,Title,Issues,Writer]\nTable publication, columns = [*,Publication_ID,Book_ID,Publisher,Publication_Date,Price]\n",
        "foreign_keys": "Foreign_keys = [publication.Book_ID = book.Book_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the writer column in the book table. We need to select the titles of the books that have a writer different from \"Elaine Lee\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the book table for this query.\n\n<3> SQL Generation: Use the 'where' clause to filter the books where the writer is not \"Elaine Lee\" and select the titles of those books.\n\n",
        "predict": "SELECT Title FROM book WHERE Writer != 'Elaine Lee'"
    },
    {
        "db_id": "book_2",
        "gold": "SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication)",
        "question": "List the titles of books that are not published.",
        "fields": "Table book, columns = [*,Book_ID,Title,Issues,Writer]\nTable publication, columns = [*,Publication_ID,Book_ID,Publisher,Publication_Date,Price]\n",
        "foreign_keys": "Foreign_keys = [publication.Book_ID = book.Book_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on books that are not published. We need to select the titles of these books.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'book' table.\n\n<3> SQL Generation: Use 'where' to filter books that are not published and select their titles.\n\n",
        "predict": "SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication)"
    },
    {
        "db_id": "musical",
        "gold": "SELECT Name FROM actor WHERE Age != 20",
        "question": "What are the names of actors who are not 20 years old?",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the age of actors. We need to select the names of actors who are not 20 years old.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'actor' table.\n\n<3> SQL Generation: Use 'where' to filter actors who are not 20 years old and select their names.\n\n",
        "predict": "SELECT Name FROM actor WHERE age != 20"
    },
    {
        "db_id": "musical",
        "gold": "SELECT DISTINCT Nominee FROM musical WHERE Award != \"Tony Award\"",
        "question": "Return the different nominees of musicals that have an award that is not the Tony Award.",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on musicals that have an award that is not the Tony Award. Firstly, we need to identify the musicals with awards. Secondly, we need to filter the nominees of those musicals.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Musical_ID from table 'musical' where Award is not the Tony Award. In the second step, we need to filter the nominees from table 'musical'.\n\n<3> SQL Generation: Use 'where' to filter musicals with awards that are not the Tony Award, and then select the different nominees from those musicals.\n\n",
        "predict": "SELECT DISTINCT Nominee FROM musical WHERE Award != 'Tony Award'"
    },
    {
        "db_id": "musical",
        "gold": "SELECT Name FROM musical WHERE Musical_ID NOT IN (SELECT Musical_ID FROM actor)",
        "question": "List the name of musicals that do not have actors.",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding musicals that do not have actors. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'musical' table for this query.\n\n<3> SQL Generation: Use 'where' to filter musicals that do not have actors.\n\n",
        "predict": "SELECT Name FROM musical WHERE Musical_ID NOT IN (SELECT Musical_ID FROM actor)"
    },
    {
        "db_id": "twitter_1",
        "gold": "SELECT name ,  email FROM user_profiles WHERE followers  >  1000",
        "question": "Find the name and email of the users who have more than 1000 followers.",
        "fields": "Table follows, columns = [*,f1,f2]\nTable tweets, columns = [*,id,uid,text,createdate]\nTable user_profiles, columns = [*,uid,name,email,partitionid,followers]\n",
        "foreign_keys": "Foreign_keys = [follows.f2 = user_profiles.uid,follows.f1 = user_profiles.uid,tweets.uid = user_profiles.uid]\n",
        "reasoning": "<1> Decomposition: We need to filter users based on the number of followers they have, specifically those with more than 1000 followers. Then, we need to retrieve their name and email.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select name and email from table 'user_profiles' and filter by the number of followers.\n\n<3> SQL Generation: Use 'where' to filter users with more than 1000 followers, and then select their name and email.\n\n",
        "predict": "SELECT name, email FROM user_profiles WHERE followers > 1000"
    },
    {
        "db_id": "product_catalog",
        "gold": "SELECT t1.catalog_name ,  t1.date_of_publication FROM catalogs AS t1 JOIN catalog_structure AS t2 ON t1.catalog_id  =  t2.catalog_id WHERE catalog_level_number  >  5",
        "question": "Find the names and publication dates of all catalogs that have catalog level number greater than 5.",
        "fields": "Table Attribute_Definitions, columns = [*,attribute_id,attribute_name,attribute_data_type]\nTable Catalog_Contents, columns = [*,catalog_entry_id,catalog_level_number,parent_entry_id,previous_entry_id,next_entry_id,catalog_entry_name,product_stock_number,price_in_dollars,price_in_euros,price_in_pounds,capacity,length,height,width]\nTable Catalog_Contents_Additional_Attributes, columns = [*,catalog_entry_id,catalog_level_number,attribute_id,attribute_value]\nTable Catalog_Structure, columns = [*,catalog_level_number,catalog_id,catalog_level_name]\nTable Catalogs, columns = [*,catalog_id,catalog_name,catalog_publisher,date_of_publication,date_of_latest_revision]\n",
        "foreign_keys": "Foreign_keys = [Catalog_Structure.catalog_id = Catalogs.catalog_id,Catalog_Contents.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_entry_id = Catalog_Contents.catalog_entry_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on catalog level number, so we should apply the 'where' to column 'catalog_level_number' and then return the names and publication dates of selected catalogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'Catalogs' has columns 'catalog_name' and 'date_of_publication', we only need table 'Catalogs'.\n\n<3> SQL Generation: Directly write the sql using 'where'.\n\n",
        "predict": "SELECT catalog_name, date_of_publication FROM Catalogs WHERE catalog_level_number > 5"
    },
    {
        "db_id": "product_catalog",
        "gold": "SELECT t1.attribute_name ,  t1.attribute_id FROM Attribute_Definitions AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.attribute_id  =  t2.attribute_id WHERE t2.attribute_value  =  0",
        "question": "Which attribute definitions have attribute value 0? Give me the attribute name and attribute ID.",
        "fields": "Table Attribute_Definitions, columns = [*,attribute_id,attribute_name,attribute_data_type]\nTable Catalog_Contents, columns = [*,catalog_entry_id,catalog_level_number,parent_entry_id,previous_entry_id,next_entry_id,catalog_entry_name,product_stock_number,price_in_dollars,price_in_euros,price_in_pounds,capacity,length,height,width]\nTable Catalog_Contents_Additional_Attributes, columns = [*,catalog_entry_id,catalog_level_number,attribute_id,attribute_value]\nTable Catalog_Structure, columns = [*,catalog_level_number,catalog_id,catalog_level_name]\nTable Catalogs, columns = [*,catalog_id,catalog_name,catalog_publisher,date_of_publication,date_of_latest_revision]\n",
        "foreign_keys": "Foreign_keys = [Catalog_Structure.catalog_id = Catalogs.catalog_id,Catalog_Contents.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_level_number = Catalog_Structure.catalog_level_number,Catalog_Contents_Additional_Attributes.catalog_entry_id = Catalog_Contents.catalog_entry_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter attribute definitions based on their attribute value. Secondly, we need to select the attribute name and attribute ID for the filtered attribute definitions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select attribute_name and attribute_id from table 'Attribute_Definitions' and filter by attribute_value.\n\n<3> SQL Generation: Use 'where' to filter attribute definitions based on attribute_value and select attribute_name and attribute_id.\n\n",
        "predict": "SELECT attribute_name, attribute_id FROM Attribute_Definitions WHERE attribute_value = 0"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT aid FROM Aircraft WHERE distance  >  1000",
        "question": "Show ids for all aircrafts with more than 1000 distance.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on aircrafts with more than 1000 distance. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter on the 'distance' column, we only need the 'aircraft' table.\n\n<3> SQL Generation: Use 'where' to filter aircrafts with more than 1000 distance.\n\n",
        "predict": "SELECT aid FROM aircraft WHERE distance > 1000"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000",
        "question": "What is the number of employees that have a salary between 100000 and 200000?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on employees with a salary between 100000 and 200000. We need to select employees based on their salary.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'employee' table for this query.\n\n<3> SQL Generation: Use 'where' to filter employees based on their salary range and count the number of employees that meet the condition.\n\n",
        "predict": "SELECT COUNT(*) FROM employee WHERE salary BETWEEN 100000 AND 200000"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT name FROM Employee WHERE salary  >  (SELECT avg(salary) FROM Employee)",
        "question": "What are the names of all employees who have a salary higher than average?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average salary of all employees. Secondly, we need to filter employees based on their salary being higher than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'employee' table for this query, we can directly use it.\n\n<3> SQL Generation: Use 'avg' to calculate the average salary of all employees, and then use 'where' to filter employees with a salary higher than the average.\n\n",
        "predict": "SELECT name FROM employee WHERE salary > (SELECT AVG(salary) FROM employee)"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "question": "Show me the departure date and arrival date for all flights from Los Angeles to Honolulu.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter flights based on their origin and destination. Secondly, we need to select the departure date and arrival date for the filtered flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select departure_date and arrival_date from table 'flight' and filter by origin and destination.\n\n<3> SQL Generation: Use 'where' to filter flights from Los Angeles to Honolulu, and then select the departure date and arrival date.\n\n",
        "predict": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'Los Angeles' AND destination = 'Honolulu'"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "question": "What are the departure and arrival dates of all flights from LA to Honolulu?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter flights based on their origin and destination. Secondly, we need to select the departure and arrival dates of the filtered flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select departure_date and arrival_date from table 'flight' and filter by origin = 'LA' and destination = 'Honolulu'.\n\n<3> SQL Generation: Use 'where' to filter flights with origin = 'LA' and destination = 'Honolulu', and then select the departure_date and arrival_date.\n\n",
        "predict": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu'"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT flno FROM Flight WHERE distance  >  2000",
        "question": "What are the numbers of all flights that can cover a distance of more than 2000?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on flights that can cover a distance of more than 2000. We need to select the flight numbers that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'flight' table for this query.\n\n<3> SQL Generation: Use 'where' to filter flights with a distance greater than 2000, and select the flight numbers.\n\n",
        "predict": "SELECT flno FROM flight WHERE distance > 2000"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  \"animal\"",
        "question": "How many allergies have type animal?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of allergies with type 'animal'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of allergies from table 'Has_Allergy' where the allergy type is 'animal'.\n\n<3> SQL Generation: Use 'where' to filter allergies with type 'animal' and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Has_Allergy WHERE Allergy IN (SELECT Allergy FROM Allergy_Type WHERE AllergyType = 'animal')"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Student WHERE age  =  18",
        "question": "How many students are 18 years old?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of students who are 18 years old.\n\n<2> Schema Linking: In this step, we identify the table and column that should be used based on the first step. We need to use the 'Student' table and the 'Age' column.\n\n<3> SQL Generation: Use 'where' to filter students who are 18 years old and then use 'count' to calculate the number of rows that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM Student WHERE Age = 18"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT StuID FROM Student WHERE age  >  20",
        "question": "What are the student ids for students over 20 years old?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on students over 20 years old. We need to select the student ids for these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table.\n\n<3> SQL Generation: Use 'where' to filter students with age greater than 20 and select their student ids.\n\n",
        "predict": "SELECT StuID FROM Student WHERE Age > 20"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Student WHERE city_code  =  \"HKG\" OR city_code  =  \"CHI\"",
        "question": "How many students live in HKG or CHI?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their city_code, selecting only those who live in HKG or CHI. Secondly, we need to count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table and the 'city_code' column.\n\n<3> SQL Generation: Use 'where' to filter students who live in HKG or CHI, and then use 'count' to count the number of selected students.\n\n",
        "predict": "SELECT COUNT(*) FROM Student WHERE city_code = 'HKG' OR city_code = 'CHI'"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  \"Cat\"",
        "question": "How many students have cat allergies?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: We need to filter students based on their allergies, specifically cat allergies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from the table 'Has_Allergy' where Allergy is 'cat'.\n\n<3> SQL Generation: Use 'where' to filter students with cat allergies and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Has_Allergy WHERE Allergy = 'cat'"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  \"F\" AND T1.allergy  =  \"Milk\" OR T1.allergy  =  \"Eggs\"",
        "question": "How many female students have milk or egg allergies?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we filter candidates using column 'Sex' in table 'Student' and column 'Allergy' in table 'Has_Allergy'. Secondly, we use 'count' to calculate the number of selected female students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'Student' and table 'Has_Allergy' have direct foreign keys, so we need tables ['Student', 'Has_Allergy'].\n\n<3> SQL Generation: We need to join the 'Student' and 'Has_Allergy' tables on the 'StuID' column. Then, we filter the rows where 'Sex' is 'F' and 'Allergy' is either 'Milk' or 'Eggs'. Finally, we count the number of rows that meet these conditions.\n\n",
        "predict": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex = 'F' AND (T1.allergy = 'Milk' OR T1.allergy = 'Eggs')"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  \"F\" AND T1.allergy  =  \"Milk\" OR T1.allergy  =  \"Eggs\"",
        "question": "How many students who are female are allergic to milk or eggs?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students who are female. Secondly, we need to filter students who are allergic to milk or eggs. Finally, we need to count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from table 'Student' where Sex = 'female'. Then, we need to filter StuID from table 'Has_Allergy' where Allergy is either 'milk' or 'eggs'.\n\n<3> SQL Generation: We need to join the 'Student' and 'Has_Allergy' tables on the 'StuID' column. Then, we filter the rows where 'Sex' is 'female' and 'Allergy' is either 'milk' or 'eggs'. Finally, we count the number of rows that meet these conditions.\n\n",
        "predict": "SELECT COUNT(*) FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.StuID = T2.StuID WHERE T1.Sex = 'female' AND (T2.Allergy = 'milk' OR T2.Allergy = 'eggs')"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  \"food\"",
        "question": "How many students have a food allergy?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of students who have a food allergy. We need to filter students based on their allergies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from the table 'Has_Allergy' where AllergyType is 'Food'. Then, we count the number of unique StuIDs.\n\n<3> SQL Generation: Use 'where' to filter students with a food allergy, and then use 'count' to calculate the number of unique StuIDs.\n\n",
        "predict": "SELECT COUNT(DISTINCT StuID) FROM Has_Allergy WHERE Allergy IN (SELECT Allergy FROM Allergy_Type WHERE AllergyType = 'Food')"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  \"food\"",
        "question": "How many students are affected by food related allergies?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the students who have food-related allergies. Secondly, we need to count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from table 'Has_Allergy' where AllergyType is 'Food'. Then, we count the number of selected StuIDs in table 'Student'.\n\n<3> SQL Generation: Use 'where' to filter StuIDs with food-related allergies in table 'Has_Allergy', and then use 'count' to count the number of selected StuIDs in table 'Student'.\n\n",
        "predict": "SELECT COUNT(*) FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE AllergyType = 'Food')"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\")",
        "question": "List the first and last name of the students who do not have any food type allergy.",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who do not have any food type allergy. Secondly, we need to select their first and last names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from table 'Has_Allergy' where AllergyType = 'Food'. Then, we need to select LName and Fname from table 'Student' and filter out the students with StuID in the previous step.\n\n<3> SQL Generation: Use 'where' to find the StuID of students with food type allergy, and then use 'where' to filter out the students with StuID not in the previous step. Finally, select their first and last names.\n\n",
        "predict": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE AllergyType = 'Food')"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\")",
        "question": "What is the full name of each student who is not allergic to any type of food.",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find students who are not allergic to any type of food. Secondly, we need to retrieve the full name of each selected student.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find students who are not allergic to any type of food, we need to use the 'Student' table. \n\n<3> SQL Generation: Use 'not exists' to find students who do not have any allergies, and then select their full names.\n\n",
        "predict": "SELECT Fname, LName FROM Student WHERE NOT EXISTS (SELECT * FROM Has_Allergy WHERE Has_Allergy.StuID = Student.StuID)"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Student WHERE sex  =  \"M\" AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\")",
        "question": "How many male students (sex is 'M') are allergic to any type of food?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter candidates using column 'Sex' in table 'Student'. Secondly, we need to join table 'Student' with table 'Has_Allergy' on the 'StuID' column. Finally, we need to count the number of selected male students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'Student' and table 'Has_Allergy' have direct foreign keys, so we need tables ['Student', 'Has_Allergy'].\n\n<3> SQL Generation: We need to join the 'Student' and 'Has_Allergy' tables on the 'StuID' column. Then, we filter the rows where 'Sex' is 'M' and count the number of rows.\n\n",
        "predict": "SELECT COUNT(*) FROM student AS T1 JOIN has_allergy AS T2 ON T1.StuID = T2.StuID WHERE T1.sex = 'M'"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\" OR T2.allergytype  =  \"animal\")",
        "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their age, selecting only those who are older than 18. Secondly, we need to filter students based on their allergies, selecting only those who do not have allergies to either food or animals. Finally, we need to count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from table 'Student' where Age > 18. We also need to select StuID from table 'Has_Allergy' where AllergyType is not 'food' or 'animal'.\n\n<3> SQL Generation: Use 'where' to filter students based on their age and allergies, and then use 'count' to count the number of selected students.\n\n",
        "predict": "SELECT COUNT(*) FROM Student WHERE Age > 18 AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE AllergyType = 'food' OR AllergyType = 'animal')"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\" OR T2.allergytype  =  \"animal\")",
        "question": "How many students are over 18 and do not have allergy to food type or animal type?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students who are over 18. Secondly, we need to filter students who do not have allergies to food type or animal type. Finally, we need to count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from table 'Student' where Age > 18. We also need to select StuID from table 'Has_Allergy' where AllergyType is not 'food type' or 'animal type'.\n\n<3> SQL Generation: Use 'where' to filter students who are over 18, and then use 'not in' to filter students who have allergies to food type or animal type. Finally, count the number of selected students.\n\n",
        "predict": "SELECT COUNT(*) FROM Student WHERE Age > 18 AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE AllergyType = 'food type' OR AllergyType = 'animal type')"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  \"Soy\")",
        "question": "What are the first name and major of the students who are able to consume soy?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students who are able to consume soy based on the 'Allergy' column in the 'Has_Allergy' table. Secondly, we need to select the first name and major of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first name and major from the 'Student' table and filter by the 'StuID' column in the 'Has_Allergy' table.\n\n<3> SQL Generation: Use 'where' to filter students who are able to consume soy based on the 'Allergy' column in the 'Has_Allergy' table, and then select the first name and major from the 'Student' table.\n\n",
        "predict": "SELECT Fname, Major FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'soy')"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.first_name ,  T1.last_name FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id ORDER BY T2.invoice_date DESC LIMIT 5;",
        "question": "What are the first and last names of the 5 customers who purchased something most recently?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the most recent purchase date. Secondly, we need to find the customers who made purchases on that date. Finally, we need to select the first and last names of those customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first and last names from the 'customers' table and filter by the most recent purchase date from the 'invoices' table.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the most recent purchase date from the 'invoices' table. Then, join the 'invoices' and 'customers' tables on the 'customer_id' column and filter by the most recent purchase date. Finally, select the first and last names of the customers.\n\n",
        "predict": "SELECT first_name, last_name FROM customers JOIN invoices ON customers.id = invoices.customer_id ORDER BY invoice_date DESC LIMIT 5"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM albums AS T1 JOIN artists AS T2 ON  T1.artist_id = T2.id WHERE T2.name = \"Billy Cobham\";",
        "question": "How many albums has Billy Cobam released?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the artist_id of Billy Cobam. Secondly, we need to count the number of albums released by Billy Cobam based on his artist_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'artists' where name = 'Billy Cobam'. In the second step, we need to count the number of albums from table 'albums' where artist_id matches the artist_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the artist_id of Billy Cobam, and then use 'count' to count the number of albums where artist_id matches the artist_id found in the first step.\n\n",
        "predict": "SELECT COUNT(*) FROM albums WHERE artist_id = (SELECT id FROM artists WHERE name = 'Billy Cobam')"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "question": "What is Astrid Gruber's email and phone number?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: We need to find the email and phone number of Astrid Gruber.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select email and phone from table 'customers' where first_name = 'Astrid' and last_name = 'Gruber'.\n\n<3> SQL Generation: Use 'where' to filter customers with first_name = 'Astrid' and last_name = 'Gruber', and then select email and phone.\n\n",
        "predict": "SELECT email, phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber'"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "question": "What is the email and phone number of Astrid Gruber the customer?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with the name 'Astrid Gruber'. Secondly, we need to retrieve their email and phone number.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select email and phone from table 'customers' where first_name = 'Astrid' and last_name = 'Gruber'.\n\n<3> SQL Generation: Use 'where' to find the customer with the name 'Astrid Gruber', and then select their email and phone number.\n\n",
        "predict": "SELECT email, phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber'"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers WHERE city = \"Prague\";",
        "question": "How many customers live in Prague city?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of customers who live in Prague city.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of customers from the 'customers' table where the city is Prague.\n\n<3> SQL Generation: Use 'where' to filter customers who live in Prague city and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM customers WHERE city = 'Prague'"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "question": "How many customers in state of CA?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of customers in the state of CA.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of customers from the 'customers' table where the state is CA.\n\n<3> SQL Generation: Use 'where' to filter customers in the state of CA and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM customers WHERE state = 'CA'"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "question": "How many customers are from California?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: We need to count the number of customers who are from California.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'customers' table and the 'state' column.\n\n<3> SQL Generation: Use 'where' to filter customers from California and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM customers WHERE state = 'California'"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT country FROM customers WHERE first_name = \"Roberto\" AND last_name = \"Almeida\";",
        "question": "In which country does Roberto Almeida?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: We need to find the country of Roberto Almeida. To do this, we need to identify the customer with the name \"Roberto Almeida\" and retrieve their country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the country from the customers table where the first_name is \"Roberto\" and the last_name is \"Almeida\".\n\n<3> SQL Generation: Use 'where' to filter the customers table based on the first_name and last_name, and then select the country.\n\n",
        "predict": "SELECT country FROM customers WHERE first_name = 'Roberto' AND last_name = 'Almeida'"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM employees AS T1 JOIN customers AS T2 ON T2.support_rep_id = T1.id WHERE T1.first_name = \"Steve\" AND T1.last_name = \"Johnson\";",
        "question": "How many customers does Steve Johnson support?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the support_rep_id of Steve Johnson. Secondly, we need to count the number of customers with the support_rep_id found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'employees' where first_name = 'Steve' and last_name = 'Johnson'. In the second step, we need to count the number of customers with support_rep_id from table 'customers'.\n\n<3> SQL Generation: Use 'where' to find the support_rep_id of Steve Johnson, and then use 'count' to count the number of customers with the support_rep_id found in the first step.\n\n",
        "predict": "SELECT COUNT(*) FROM customers WHERE support_rep_id = (SELECT id FROM employees WHERE first_name = 'Steve' AND last_name = 'Johnson')"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = \"Nancy\" AND T1.last_name = \"Edwards\";",
        "question": "find the full name of employees who report to Nancy Edwards?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the employee with the name 'Nancy Edwards'. Secondly, we need to find the employees who report to Nancy Edwards and retrieve their full names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the employees who report to Nancy Edwards are also employees, we only need the 'employees' table.\n\n<3> SQL Generation: Use 'where' to find the employee with the name 'Nancy Edwards', and then use 'where' to filter employees who report to Nancy Edwards and select their full names.\n\n",
        "predict": "SELECT first_name || ' ' || last_name AS full_name FROM employees WHERE reports_to = (SELECT id FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards')"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT address FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "question": "What is the address of employee Nancy Edwards?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the address of employee Nancy Edwards.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the address from the 'employees' table where the first name is 'Nancy' and the last name is 'Edwards'.\n\n<3> SQL Generation: Use 'where' to filter the rows where the first name is 'Nancy' and the last name is 'Edwards', and then select the address.\n\n",
        "predict": "SELECT address FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards'"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT phone FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "question": "What is employee Nancy Edwards's phone number?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the phone number of employee Nancy Edwards.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the phone number from the 'employees' table where the first name is 'Nancy' and the last name is 'Edwards'.\n\n<3> SQL Generation: Use 'where' to filter the rows where the first name is 'Nancy' and the last name is 'Edwards', and then select the phone number.\n\n",
        "predict": "SELECT phone FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards'"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "question": "How many orders does Luca Mancini have in his invoices?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of Luca Mancini. Secondly, we need to count the number of orders in his invoices.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'customers' where first_name = 'Luca' and last_name = 'Mancini'. In the second step, we need to count the number of invoices where customer_id is the value found in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id of Luca Mancini, and then use 'where' to count the number of invoices where customer_id is the value found in the first step.\n\n",
        "predict": "SELECT COUNT(*) FROM invoices WHERE customer_id = (SELECT id FROM customers WHERE first_name = 'Luca' AND last_name = 'Mancini')"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = \"Balls to the Wall\";",
        "question": "What is title of album which track Balls to the Wall belongs to?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the track_id of the track \"Balls to the Wall\". Secondly, we need to find the album_id of the album that contains this track. Finally, we need to retrieve the title of the album.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the album_id from the table 'tracks' where the track name is \"Balls to the Wall\". Then, we need to select the title from the table 'albums' where the album_id matches the one we found in the previous step.\n\n<3> SQL Generation: Use 'where' to find the track_id of the track \"Balls to the Wall\", and then use 'where' to find the album_id that contains this track. Finally, select the title of the album.\n\n",
        "predict": "SELECT title FROM albums WHERE id = (SELECT album_id FROM tracks WHERE name = 'Balls to the Wall')"
    },
    {
        "db_id": "journal_committee",
        "gold": "SELECT Name FROM editor WHERE editor_id NOT IN (SELECT editor_id FROM journal_committee)",
        "question": "List the names of editors that are not on any journal committee.",
        "fields": "Table editor, columns = [*,Editor_ID,Name,Age]\nTable journal, columns = [*,Journal_ID,Date,Theme,Sales]\nTable journal_committee, columns = [*,Editor_ID,Journal_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [journal_committee.Journal_ID = journal.Journal_ID,journal_committee.Editor_ID = editor.Editor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on editors who are not on any journal committee. Firstly, we need to identify the editors who are on journal committees. Secondly, we need to filter out the editors who are on journal committees and return the remaining editors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter editors who are on journal committees, we only need the 'editor' and 'journal_committee' tables.\n\n<3> SQL Generation: We can use a subquery to select the editor IDs of editors who are on journal committees. Then, we can use 'not in' to filter out the editors who are on journal committees and select their names.\n\n",
        "predict": "SELECT Name FROM editor WHERE Editor_ID NOT IN (SELECT Editor_ID FROM journal_committee)"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "question": "Show the number of all customers without an account.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding customers without an account. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customers' and check if there is a corresponding entry in the 'Accounts' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Customers' and 'Accounts' tables on the 'customer_id' column. Then, we can filter the rows where the 'account_id' is null (indicating no account exists for that customer). Finally, we can count the number of rows that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM Customers LEFT JOIN Accounts ON Customers.customer_id = Accounts.customer_id WHERE Accounts.account_id IS NULL"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "question": "How many customers do not have an account?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding customers who do not have an account.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customers' and check if it exists in the 'account_id' column of table 'Accounts'.\n\n<3> SQL Generation: Use 'where' to filter customers who do not have an account and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "question": "What is the phone and email for customer with first name Aniyah and last name Feest?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id for the customer with first name Aniyah and last name Feest. Secondly, we need to retrieve the phone and email for that customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_first_name = 'Aniyah' and customer_last_name = 'Feest'. In the second step, we need to retrieve customer_phone and customer_email from table 'Customers' using the customer_id obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id for the customer with first name Aniyah and last name Feest, and then use 'select' to retrieve the phone and email for that customer.\n\n",
        "predict": "SELECT customer_phone, customer_email FROM Customers WHERE customer_first_name = 'Aniyah' AND customer_last_name = 'Feest'"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "question": "Return the phone and email of the customer with the first name Aniyah and last name Feest.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with the first name 'Aniyah' and last name 'Feest'. Secondly, we need to select the phone and email of the selected customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the phone and email of the customer, we only need the 'Customers' table.\n\n<3> SQL Generation: Use 'where' to filter customers with the first name 'Aniyah' and last name 'Feest', and then select the phone and email columns.\n\n",
        "predict": "SELECT customer_phone, customer_email FROM Customers WHERE customer_first_name = 'Aniyah' AND customer_last_name = 'Feest'"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "question": "How many cards does customer Art Turcotte have?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of customer Art Turcotte. Secondly, we need to count the number of cards associated with that customer_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_first_name = 'Art' and customer_last_name = 'Turcotte'. In the second step, we need to count the number of cards from table 'Customers_Cards' where customer_id matches the customer_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id of customer Art Turcotte, and then use 'count' to count the number of cards associated with that customer_id.\n\n",
        "predict": "SELECT COUNT(*) FROM Customers_Cards WHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_first_name = 'Art' AND customer_last_name = 'Turcotte')"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers_cards WHERE card_type_code  =  \"Debit\"",
        "question": "How many debit cards do we have?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of debit cards. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the card_type_code from the Customers_Cards table.\n\n<3> SQL Generation: Use 'where' to filter the rows where card_type_code is 'debit' and count the number of rows.\n\n",
        "predict": "SELECT COUNT(*) FROM Customers_Cards WHERE card_type_code = 'debit'"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name ,  seating FROM track WHERE year_opened  >  2000 ORDER BY seating",
        "question": "What are the names and seatings for all tracks opened after 2000, ordered by seating?",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter tracks that were opened after 2000. Secondly, we need to select the names and seatings of these tracks. Finally, we need to order the results by seating.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'track' table for this query.\n\n<3> SQL Generation: Use 'where' to filter tracks that were opened after 2000, and then select the names and seatings of these tracks. Finally, order the results by seating.\n\n",
        "predict": "SELECT Name, Seating FROM track WHERE Year_Opened > 2000 ORDER BY Seating"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "question": "Show all track names that have had no races.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: We need to find the track names that have had no races.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'track' table.\n\n<3> SQL Generation: We can use a subquery to find the track IDs that have had races, and then select the track names that are not in that list.\n\n",
        "predict": "SELECT Name FROM track WHERE Track_ID NOT IN (SELECT Track_ID FROM race)"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "question": "Return the names of tracks that have no had any races.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding tracks that have not had any races. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'track' table.\n\n<3> SQL Generation: We can use a subquery to find the track IDs that have had races, and then use a 'not in' clause to select tracks that are not in that list.\n\n",
        "predict": "SELECT Name FROM track WHERE Track_ID NOT IN (SELECT Track_ID FROM race)"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT year_opened FROM track WHERE seating BETWEEN 4000 AND 5000",
        "question": "Show year where a track with a seating at least 5000 opened and a track with seating no more than 4000 opened.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find tracks with seating at least 5000 and tracks with seating no more than 4000. Secondly, we need to select the years when these tracks were opened.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Year_Opened column from the track table.\n\n<3> SQL Generation: Use 'where' to filter tracks with seating at least 5000 and tracks with seating no more than 4000, and then select the corresponding years.\n\n",
        "predict": "SELECT Year_Opened FROM track WHERE Seating >= 5000 AND Seating <= 4000"
    },
    {
        "db_id": "coffee_shop",
        "gold": "SELECT shop_id ,  address FROM shop WHERE score  <  (SELECT avg(score) FROM shop)",
        "question": "Find the id and address of the shops whose score is below the average score.",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average score of all shops. Secondly, we need to filter shops based on their score being below the average score. Finally, we need to select the id and address of the filtered shops.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'shop' table for this query, we can directly use it.\n\n<3> SQL Generation: Use 'select' to calculate the average score of all shops. Then, use 'where' to filter shops with a score below the average score and select their id and address.\n\n",
        "predict": "SELECT Shop_ID, Address FROM shop WHERE Score < (SELECT AVG(Score) FROM shop)"
    },
    {
        "db_id": "coffee_shop",
        "gold": "SELECT address ,  num_of_staff FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM happy_hour)",
        "question": "Find the address and staff number of the shops that do not have any happy hour.",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the shops that do not have any happy hour. Secondly, we need to select the address and staff number of those shops.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are only interested in the address and staff number of the shops, we only need the 'shop' table.\n\n<3> SQL Generation: Use 'where' to filter the shops that do not have any happy hour, and then select the address and staff number from the 'shop' table.\n\n",
        "predict": "SELECT Address, Num_of_staff FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM happy_hour)"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT COUNT(*) FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId WHERE T2.Name  =  \"Metallica\"",
        "question": "Find the number of albums by the artist \"Metallica\".",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the artist_id of \"Metallica\" from table 'Artist'. Secondly, we need to count the number of albums with the artist_id found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select artist_id from table 'Artist' where name = \"Metallica\". In the second step, we need to count the number of albums from table 'Album' where artist_id is the value found in the first step.\n\n<3> SQL Generation: Use 'where' to find the artist_id of \"Metallica\", and then use 'where' to count the number of albums with the artist_id found in the first step.\n\n",
        "predict": "SELECT COUNT(*) FROM Album WHERE ArtistId = (SELECT ArtistId FROM Artist WHERE Name = \"Metallica\")"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT COUNT(*) FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId WHERE T1.Name  =  \"AAC audio file\"",
        "question": "How many tracks are in the AAC audio file media type?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the media type with the name 'AAC audio file'. Secondly, we need to count the number of tracks that have this media type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for tracks with a specific media type, we need to select the 'MediaTypeId' from the 'MediaType' table. Then, we need to count the number of tracks that have this media type, so we need to select the 'TrackId' from the 'Track' table.\n\n<3> SQL Generation: Use 'where' to find the media type with the name 'AAC audio file', and then use 'where' to filter tracks with this media type and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM track WHERE MediaTypeId = (SELECT MediaTypeId FROM mediatype WHERE Name = 'AAC audio file')"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM)",
        "question": "How many artists do not have any album?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the artists who do not have any albums. Secondly, we need to count the number of artists found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for artists who do not have any albums, we only need the 'Artist' table.\n\n<3> SQL Generation: Use 'left join' to combine the 'Artist' table with the 'Album' table on the 'ArtistId' column. Then, filter the rows where the 'AlbumId' is null (indicating that the artist does not have any albums). Finally, count the number of rows that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM Artist LEFT JOIN Album ON Artist.ArtistId = Album.ArtistId WHERE Album.AlbumId IS NULL"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT count(*) FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "question": "How many policies are listed for the customer named \"Dayana Robel\"?",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with the name \"Dayana Robel\". Secondly, we need to count the number of policies listed for that customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Customer_ID from table 'Customers' where Customer_name = \"Dayana Robel\". In the second step, we need to count the number of policies listed for that customer in table 'Customers_Policies'.\n\n<3> SQL Generation: Use 'where' to find the customer with the name \"Dayana Robel\", and then use 'count' to count the number of policies listed for that customer.\n\n",
        "predict": "SELECT COUNT(*) FROM Customers_Policies WHERE Customer_ID = (SELECT Customer_ID FROM Customers WHERE Customer_name = \"Dayana Robel\")"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id  =  T3.id WHERE T3.name  =  'Amisulpride' AND T2.interaction_type  =  'inhibitor'",
        "question": "What are the names of the enzymes used in the medicine  Amisulpride that acts as inhibitors?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the medicine with the name 'Amisulpride'. Secondly, we need to find the enzymes that are used in this medicine and act as inhibitors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'medicine' where name = 'Amisulpride'. In the second step, we need to select name from table 'enzyme' based on the enzyme_id in table 'medicine_enzyme_interaction'.\n\n<3> SQL Generation: Use 'where' to find the medicine with the name 'Amisulpride', and then use 'join' to link the 'medicine_enzyme_interaction' and 'enzyme' tables based on the enzyme_id. Finally, filter the rows where the interaction_type is 'inhibitor' and select the enzyme names.\n\n",
        "predict": "SELECT enzyme.name FROM medicine_enzyme_interaction JOIN enzyme ON medicine_enzyme_interaction.enzyme_id = enzyme.id WHERE medicine_enzyme_interaction.medicine_id = (SELECT id FROM medicine WHERE name = 'Amisulpride') AND medicine_enzyme_interaction.interaction_type = 'inhibitor'"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT T1.interaction_type FROM medicine_enzyme_interaction AS T1 JOIN medicine AS T2 ON T1.medicine_id  =  T2.id JOIN enzyme AS T3 ON T1.enzyme_id  =  T3.id WHERE T3.name  =  'ALA synthase' AND T2.name  =  'Aripiprazole'",
        "question": "What is the interaction type of the enzyme named 'ALA synthase' and the medicine named 'Aripiprazole'?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the enzyme with the name 'ALA synthase'. Secondly, we need to find the medicine with the name 'Aripiprazole'. Finally, we need to find the interaction type between these two entities.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the interaction_type from the table 'medicine_enzyme_interaction' where enzyme_id corresponds to the enzyme with the name 'ALA synthase' and medicine_id corresponds to the medicine with the name 'Aripiprazole'.\n\n<3> SQL Generation: Use 'where' to find the enzyme with the name 'ALA synthase' and the medicine with the name 'Aripiprazole', and then use 'where' to filter the interaction_type between these two entities.\n\n",
        "predict": "SELECT interaction_type FROM medicine_enzyme_interaction WHERE enzyme_id = (SELECT id FROM enzyme WHERE name = 'ALA synthase') AND medicine_id = (SELECT id FROM medicine WHERE name = 'Aripiprazole')"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );",
        "question": "How many enzymes do not have any interactions?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Decomposition: The query requires finding enzymes that do not have any interactions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select enzyme_id from table 'enzyme' and filter by enzyme_id in table 'medicine_enzyme_interaction'.\n\n<3> SQL Generation: Use 'where' to filter enzymes that do not have any interactions and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM enzyme WHERE id NOT IN (SELECT enzyme_id FROM medicine_enzyme_interaction)"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT founded FROM university WHERE affiliation != 'Public' ORDER BY founded DESC LIMIT 1",
        "question": "What is the founded year of the non public school that was founded most recently?",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter non-public schools. Secondly, we need to find the school with the most recent founded year among the filtered schools. Finally, we need to select the founded year of that school.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'university' table to filter non-public schools and select the founded year.\n\n<3> SQL Generation: Use 'where' to filter non-public schools, and then use 'order by' and 'desc' to select the school with the most recent founded year. Finally, select the founded year of that school.\n\n",
        "predict": "SELECT Founded FROM university WHERE Affiliation != 'public' ORDER BY Founded DESC LIMIT 1"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "question": "How many schools do not participate in the basketball match?",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding schools that do not participate in the basketball match. We need to count the number of schools that do not have any entries in the basketball_match table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the university table to count the number of schools.\n\n<3> SQL Generation: We can use a left join between the university table and the basketball_match table, and then count the number of rows where the basketball_match columns are null.\n\n",
        "predict": "SELECT COUNT(*) FROM university LEFT JOIN basketball_match ON university.School_ID = basketball_match.School_ID WHERE basketball_match.School_ID IS NULL"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "question": "Count the number of universities that do not participate in the baketball match.",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of universities that do not participate in the basketball match. We need to filter out universities that do participate in the basketball match.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select School_ID from table 'university' and filter out School_ID from table 'basketball_match'.\n\n<3> SQL Generation: Use 'where' to filter out universities that participate in the basketball match, and then use 'count' to count the number of universities that do not participate.\n\n",
        "predict": "SELECT COUNT(*) FROM university WHERE School_ID NOT IN (SELECT School_ID FROM basketball_match)"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT school FROM university WHERE founded  >  1850 OR affiliation  =  'Public'",
        "question": "Find the schools that were either founded after 1850 or public.",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter schools that were founded after 1850. Secondly, we need to filter schools that are public.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this case, we only need the 'university' table.\n\n<3> SQL Generation: Use 'where' to filter schools that were founded after 1850 and schools that are public.\n\n",
        "predict": "SELECT * FROM university WHERE Founded > 1850 OR Affiliation = 'public'"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "question": "Find how many school locations have the word 'NY'.",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter school locations that have the word 'NY'. Secondly, we need to count the number of unique school locations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires information from the 'university' table, we only need to use the 'university' table.\n\n<3> SQL Generation: Use 'where' to filter school locations that have the word 'NY', and then use 'count' to count the number of unique school locations.\n\n",
        "predict": "SELECT COUNT(DISTINCT Location) FROM university WHERE Location LIKE '%NY%'"
    },
    {
        "db_id": "phone_1",
        "gold": "SELECT count(*) FROM phone WHERE Company_name = \"Nokia Corporation\";",
        "question": "How many phone hardware models are produced by the company named \"Nokia Corporation\"?",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter phone hardware models produced by the company named \"Nokia Corporation\". Secondly, we need to count the number of unique hardware models.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter by the company name in the 'phone' table, we only need the 'phone' table.\n\n<3> SQL Generation: Use 'where' to filter phone hardware models produced by the company named \"Nokia Corporation\", and then use 'count' to count the number of unique hardware models.\n\n",
        "predict": "SELECT COUNT(DISTINCT Hardware_Model_name) FROM phone WHERE Company_name = 'Nokia Corporation'"
    },
    {
        "db_id": "phone_1",
        "gold": "SELECT avg(RAM_MiB) FROM chip_model WHERE model_name NOT IN (SELECT chip_model FROM phone)",
        "question": "Find the average ram mib size of the chip models that are never used by any phone.",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the chip models that are never used by any phone. Secondly, we need to calculate the average RAM_MiB size of those chip models.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Model_name from table 'chip_model' where Model_name does not exist in the 'chip_model' column of table 'phone'. In the second step, we need to calculate the average RAM_MiB size from table 'chip_model'.\n\n<3> SQL Generation: Use 'where not exists' to find the chip models that are never used by any phone, and then use 'avg' to calculate the average RAM_MiB size of those chip models.\n\n",
        "predict": "SELECT AVG(RAM_MiB) FROM chip_model WHERE NOT EXISTS (SELECT * FROM phone WHERE phone.chip_model = chip_model.Model_name)"
    },
    {
        "db_id": "match_season",
        "gold": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "question": "What are the names of teams that do no have match season record?",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding teams that do not have match season records.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is about teams and match seasons, we need tables ['team', 'match_season'].\n\n<3> SQL Generation: We need to use a left join to combine the 'team' and 'match_season' tables on the 'Team_id' column. Then, we filter the rows where the 'Season' column is null (indicating no match season record). Finally, we select the 'Name' column from the 'team' table.\n\n",
        "predict": "SELECT Name FROM team LEFT JOIN match_season ON team.Team_id = match_season.Team WHERE Season IS NULL"
    },
    {
        "db_id": "match_season",
        "gold": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "question": "Return the names of teams that have no match season record.",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding teams that have no match season record.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find teams that have no match season record, we only need the 'team' table.\n\n<3> SQL Generation: We can use a 'left join' to join the 'team' table with the 'match_season' table on the 'Team_id' column. Then, we can filter the rows where the 'match_season' columns are null, indicating that there is no match season record for that team. Finally, we can select the 'Name' column from the 'team' table.\n\n",
        "predict": "SELECT Name FROM team LEFT JOIN match_season ON team.Team_id = match_season.Team WHERE match_season.Team IS NULL"
    },
    {
        "db_id": "climbing",
        "gold": "SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber)",
        "question": "What are the names of countains that no climber has climbed?",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the mountains that no climber has climbed. Secondly, we need to retrieve the names of those mountains.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Mountain_ID from table 'mountain' where there is no corresponding entry in the 'climber' table.\n\n<3> SQL Generation: Use 'where not exists' to find the mountains that no climber has climbed, and then select the names of those mountains.\n\n",
        "predict": "SELECT Name FROM mountain WHERE NOT EXISTS (SELECT * FROM climber WHERE climber.Mountain_ID = mountain.Mountain_ID)"
    },
    {
        "db_id": "climbing",
        "gold": "SELECT Name FROM mountain WHERE Height  >  5000 OR Prominence  >  1000",
        "question": "What are the names of mountains that have a height of over 5000 or a prominence of over 1000?",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on mountains with a height over 5000 or a prominence over 1000. We need to select the names of these mountains.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'mountain' table.\n\n<3> SQL Generation: Use 'where' to filter mountains with a height over 5000 or a prominence over 1000, and select their names.\n\n",
        "predict": "SELECT Name FROM mountain WHERE Height > 5000 OR Prominence > 1000"
    },
    {
        "db_id": "body_builder",
        "gold": "SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Total  >  300",
        "question": "What are the names of body builders whose total score is higher than 300?",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on body builders whose total score is higher than 300. Firstly, we need to identify the body builders with a total score higher than 300. Secondly, we need to retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the total score is in the 'body_builder' table and the names are in the 'people' table, we need to use these two tables.\n\n<3> SQL Generation: Use 'where' to filter body builders with a total score higher than 300, and then select their names.\n\n",
        "predict": "SELECT people.Name FROM body_builder JOIN people ON body_builder.People_ID = people.People_ID WHERE body_builder.Total > 300"
    },
    {
        "db_id": "body_builder",
        "gold": "SELECT count(*) FROM people WHERE people_id NOT IN (SELECT People_ID FROM body_builder)",
        "question": "How many persons are not body builders?",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding persons who are not body builders. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find persons who are not body builders, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter out persons who are body builders and count the remaining persons.\n\n",
        "predict": "SELECT COUNT(*) FROM people WHERE People_ID NOT IN (SELECT People_ID FROM body_builder)"
    },
    {
        "db_id": "election_representative",
        "gold": "SELECT T2.Name FROM election AS T1 JOIN representative AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE Votes  >  10000",
        "question": "What are the names of representatives with more than 10000 votes in election?",
        "fields": "Table election, columns = [*,Election_ID,Representative_ID,Date,Votes,Vote_Percent,Seats,Place]\nTable representative, columns = [*,Representative_ID,Name,State,Party,Lifespan]\n",
        "foreign_keys": "Foreign_keys = [election.Representative_ID = representative.Representative_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on representatives with more than 10000 votes in an election. Firstly, we need to identify the representatives who received more than 10000 votes. Secondly, we need to retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the filtering is based on the 'Votes' column in the 'election' table, we only need the 'election' table.\n\n<3> SQL Generation: Use 'where' to filter representatives with more than 10000 votes and select their names.\n\n",
        "predict": "SELECT Name FROM representative WHERE Representative_ID IN (SELECT Representative_ID FROM election WHERE Votes > 10000)"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "question": "How many apartments do not have any facility?",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding apartments that do not have any facility. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select apt_id from table 'Apartments' and apt_id from table 'Apartment_Facilities'.\n\n<3> SQL Generation: We can use a left join to combine the 'Apartments' table with the 'Apartment_Facilities' table on the apt_id column. Then, we can filter the rows where the facility_code is null, indicating that the apartment does not have any facility. Finally, we can count the number of rows that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM Apartments LEFT JOIN Apartment_Facilities ON Apartments.apt_id = Apartment_Facilities.apt_id WHERE facility_code IS NULL"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "question": "Find the number of apartments that have no facility.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding apartments that have no facility. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select apt_id from table 'Apartments' and filter by apt_id in table 'Apartment_Facilities'.\n\n<3> SQL Generation: We can use a left join to combine the 'Apartments' and 'Apartment_Facilities' tables on the 'apt_id' column. Then, we can filter the rows where the 'facility_code' is null (indicating no facility) and count the number of rows that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM Apartments LEFT JOIN Apartment_Facilities ON Apartments.apt_id = Apartment_Facilities.apt_id WHERE facility_code IS NULL"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT count(*) FROM game WHERE season  >  2007",
        "question": "How many games are held after season 2007?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on games held after season 2007. Firstly, we need to identify the games that have a season greater than 2007. Secondly, we need to count the number of games that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the filtering is based on the 'Season' column in the 'game' table, we only need the 'game' table.\n\n<3> SQL Generation: Use 'where' to filter games with a season greater than 2007, and then use 'count' to count the number of games that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM game WHERE Season > 2007"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT player ,  number_of_matches ,  SOURCE FROM injury_accident WHERE injury != 'Knee problem'",
        "question": "What are the player name, number of matches, and information source for players who do not suffer from injury of 'Knee problem'?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter players who do not suffer from the injury of 'Knee problem'. Secondly, we need to select the player name, number of matches, and information source for the selected players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the injury information is stored in the 'injury_accident' table, we need to join the 'injury_accident' table with the 'game' table on the 'game_id' column. Then, we can filter the rows where the injury is not 'Knee problem' and select the player name, number of matches, and information source from the 'injury_accident' table.\n\n<3> SQL Generation: Use 'join' to link the 'injury_accident' and 'game' tables on the 'game_id' column. Then, use 'where' to filter the rows where the injury is not 'Knee problem'. Finally, select the player name, number of matches, and information source from the 'injury_accident' table.\n\n",
        "predict": "SELECT Player, Number_of_matches, Source FROM injury_accident JOIN game ON injury_accident.game_id = game.id WHERE Injury != 'Knee problem'"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT count(DISTINCT T1.injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id  =  T2.id WHERE T2.season  >  2010",
        "question": "How many distinct kinds of injuries happened after season 2010?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter injuries that happened after season 2010. Secondly, we need to count the distinct kinds of injuries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter game_id from table 'injury_accident' based on the season from table 'game'. In the second step, we need to select distinct kinds of injuries from table 'injury_accident'.\n\n<3> SQL Generation: Use 'where' to filter injuries that happened after season 2010, and then use 'count' and 'distinct' to count the distinct kinds of injuries.\n\n",
        "predict": "SELECT COUNT(DISTINCT Injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id = T2.id WHERE T2.Season > 2010"
    },
    {
        "db_id": "soccer_1",
        "gold": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  \"right\"",
        "question": "List the names of all players who have a crossing score higher than 90 and prefer their right foot.",
        "fields": "Table Country, columns = [*,id,name]\nTable League, columns = [*,id,country_id,name]\nTable Player, columns = [*,id,player_api_id,player_name,player_fifa_api_id,birthday,height,weight]\nTable Player_Attributes, columns = [*,id,player_fifa_api_id,player_api_id,date,overall_rating,potential,preferred_foot,attacking_work_rate,defensive_work_rate,crossing,finishing,heading_accuracy,short_passing,volleys,dribbling,curve,free_kick_accuracy,long_passing,ball_control,acceleration,sprint_speed,agility,reactions,balance,shot_power,jumping,stamina,strength,long_shots,aggression,interceptions,positioning,vision,penalties,marking,standing_tackle,sliding_tackle,gk_diving,gk_handling,gk_kicking,gk_positioning,gk_reflexes]\nTable Team, columns = [*,id,team_api_id,team_fifa_api_id,team_long_name,team_short_name]\nTable Team_Attributes, columns = [*,id,team_fifa_api_id,team_api_id,date,buildUpPlaySpeed,buildUpPlaySpeedClass,buildUpPlayDribbling,buildUpPlayDribblingClass,buildUpPlayPassing,buildUpPlayPassingClass,buildUpPlayPositioningClass,chanceCreationPassing,chanceCreationPassingClass,chanceCreationCrossing,chanceCreationCrossingClass,chanceCreationShooting,chanceCreationShootingClass,chanceCreationPositioningClass,defencePressure,defencePressureClass,defenceAggression,defenceAggressionClass,defenceTeamWidth,defenceTeamWidthClass,defenceDefenderLineClass]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "foreign_keys": "Foreign_keys = [Player_Attributes.player_api_id = Player.player_api_id,Player_Attributes.player_fifa_api_id = Player.player_fifa_api_id,League.country_id = Country.id,Team_Attributes.team_api_id = Team.team_api_id,Team_Attributes.team_fifa_api_id = Team.team_fifa_api_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter players based on their crossing score and preferred foot. Secondly, we need to select the names of the filtered players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select player_name from table 'Player' and filter based on crossing score from table 'Player_Attributes'.\n\n<3> SQL Generation: Use 'where' to filter players based on their crossing score and preferred foot, and then select the names of the filtered players.\n\n",
        "predict": "SELECT player_name FROM Player WHERE player_api_id IN (SELECT player_api_id FROM Player_Attributes WHERE crossing > 90 AND preferred_foot = 'right')"
    },
    {
        "db_id": "performance_attendance",
        "gold": "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM member_attendance)",
        "question": "List the names of members who did not attend any performance.",
        "fields": "Table member, columns = [*,Member_ID,Name,Nationality,Role]\nTable member_attendance, columns = [*,Member_ID,Performance_ID,Num_of_Pieces]\nTable performance, columns = [*,Performance_ID,Date,Host,Location,Attendance]\n",
        "foreign_keys": "Foreign_keys = [member_attendance.Performance_ID = performance.Performance_ID,member_attendance.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding members who did not attend any performance. Firstly, we need to identify all members who attended performances. Secondly, we need to filter out members who attended performances and return the names of the remaining members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Member_ID from table 'member_attendance' and filter by Performance_ID. Then, we need to select Name from table 'member' and filter out the members who attended performances.\n\n<3> SQL Generation: Use 'where' to filter members who attended performances, and then use 'not in' to filter out those members and select their names.\n\n",
        "predict": "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM member_attendance)"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "question": "Count the number of rooms that are not in the Lamberton building.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of rooms that are not in the Lamberton building. We need to filter out the rooms in the Lamberton building and count the remaining rooms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the rooms from the 'classroom' table and filter by the building column.\n\n<3> SQL Generation: Use 'where' to filter out the rooms in the Lamberton building and count the remaining rooms.\n\n",
        "predict": "SELECT COUNT(*) FROM classroom WHERE building != 'Lamberton'"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "question": "How many classrooms are not in Lamberton?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of classrooms that are not in Lamberton.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'classroom' table.\n\n<3> SQL Generation: Use 'where' to filter classrooms that are not in Lamberton and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM classroom WHERE building != 'Lamberton'"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT count(*) FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)",
        "question": "How many courses that do not have prerequisite?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: We need to find courses that do not have a prerequisite.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'course' table.\n\n<3> SQL Generation: We can use a subquery to find the courses that are not listed as a prerequisite in the 'prereq' table, and then count the number of courses returned.\n\n",
        "predict": "SELECT COUNT(*) FROM course WHERE course_id NOT IN (SELECT prereq_id FROM prereq)"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT count(*) FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)",
        "question": "Count the number of courses without prerequisites.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: We need to count the number of courses that do not have any prerequisites.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'course' table for this query.\n\n<3> SQL Generation: We can use a subquery to find the courses that have prerequisites, and then count the number of courses that are not in that subquery.\n\n",
        "predict": "SELECT COUNT(*) FROM course WHERE course_id NOT IN (SELECT prereq_id FROM prereq)"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)",
        "question": "Find the name of the courses that do not have any prerequisite?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the courses that do not have any prerequisite. Secondly, we need to retrieve the names of those courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for courses without prerequisites, we only need the 'course' table.\n\n<3> SQL Generation: Use 'where' to filter courses that do not have any prerequisite, and then select the course names.\n\n",
        "predict": "SELECT title FROM course WHERE course_id NOT IN (SELECT prereq_id FROM prereq)"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT i_id FROM advisor AS T1 JOIN student AS T2 ON T1.s_id  =  T2.id WHERE T2.dept_name  =  'History'",
        "question": "What is the id of the instructor who advises of all students from History department?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the department with the name 'History'. Secondly, we need to find the instructors who advise all students from the History department. Finally, we need to retrieve the id of the instructor.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the dept_name from the table 'department' where dept_name = 'History'. In the second step, we need to select the i_ID from the table 'advisor' where s_ID is in the result of the first step. Finally, we need to retrieve the id from the table 'instructor' where the id is in the result of the second step.\n\n<3> SQL Generation: Use 'where' to find the department with the name 'History', then use 'where' and 'in' to find the instructors who advise all students from the History department, and finally select the id of the instructor.\n\n",
        "predict": "SELECT ID FROM instructor WHERE ID IN (SELECT i_ID FROM advisor WHERE s_ID IN (SELECT ID FROM student WHERE dept_name = 'History') GROUP BY i_ID HAVING COUNT(DISTINCT s_ID) = (SELECT COUNT(*) FROM student WHERE dept_name = 'History'))"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT i_id FROM advisor AS T1 JOIN student AS T2 ON T1.s_id  =  T2.id WHERE T2.dept_name  =  'History'",
        "question": "Give id of the instructor who advises students in the History department.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the department with the name 'History'. Secondly, we need to find the instructor who advises students in that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dept_name from table 'department' where dept_name = 'History'. In the second step, we need to select i_ID from table 'advisor' where s_ID is the same as the ID of the students in the History department.\n\n<3> SQL Generation: Use 'where' to find the department with the name 'History', and then use 'where' to find the instructor who advises students in that department.\n\n",
        "predict": "SELECT i_ID FROM advisor WHERE s_ID IN (SELECT ID FROM student WHERE dept_name = 'History')"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)",
        "question": "Find the name of the courses that do not have any prerequisite?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the courses that do not have any prerequisite. Secondly, we need to retrieve the names of those courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for courses without prerequisites, we only need the 'course' table.\n\n<3> SQL Generation: Use 'where' to filter courses that do not have any prerequisite, and then select the course names.\n\n",
        "predict": "SELECT title FROM course WHERE course_id NOT IN (SELECT prereq_id FROM prereq)"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT title FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)",
        "question": "What are the names of courses without prerequisites?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding courses without prerequisites. We need to select the names of those courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'course' table to select the names of courses.\n\n<3> SQL Generation: We can use a subquery to find the course IDs that appear in the 'prereq' table. Then, we can select the names of courses that do not have their IDs in the subquery.\n\n",
        "predict": "SELECT title FROM course WHERE course_id NOT IN (SELECT prereq_id FROM prereq)"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester  =  'Spring')",
        "question": "What are the names of instructors who didn't teach courses in the Spring?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the instructors who taught courses in the Spring. Secondly, we need to filter out the instructors who didn't teach courses in the Spring and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select distinct ID from table 'teaches' where semester = 'Spring'. In the second step, we need to select name from table 'instructor' and filter out the instructors whose ID is not in the result of the first step.\n\n<3> SQL Generation: Use 'where' to find the instructors who taught courses in the Spring, and then use 'where' to filter out the instructors who didn't teach courses in the Spring and select their names.\n\n",
        "predict": "SELECT name FROM instructor WHERE ID NOT IN (SELECT DISTINCT ID FROM teaches WHERE semester = 'Spring')"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE T2.course_id IN (SELECT T4.prereq_id FROM course AS T3 JOIN prereq AS T4 ON T3.course_id  =  T4.course_id WHERE T3.title  =  'International Finance')",
        "question": "Find the name of students who have taken the prerequisite course of the course with title International Finance.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the course_id of the course with title International Finance. Secondly, we need to find the prerequisite course_id for the course found in the first step. Thirdly, we need to find the names of students who have taken the prerequisite course.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'course' where title = 'International Finance'. In the second step, we need to select prereq_id from table 'prereq' where course_id is the value found in the first step. In the third step, we need to select name from table 'student' where ID is the value found in the second step.\n\n<3> SQL Generation: Use 'where' to find the course_id of the course with title International Finance. Then, use 'where' to find the prerequisite course_id for the course found in the first step. Finally, use 'where' to find the names of students who have taken the prerequisite course.\n\n",
        "predict": "SELECT name FROM student WHERE ID IN (SELECT ID FROM takes WHERE course_id = (SELECT prereq_id FROM prereq WHERE course_id = (SELECT course_id FROM course WHERE title = 'International Finance')))"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "question": "Find the names of all instructors in Comp. Sci. department with salary > 80000.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter instructors based on their department and salary. Secondly, we need to select the names of the filtered instructors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter instructors based on their department, we need the 'instructor' and 'department' tables. We also need the 'salary' column from the 'instructor' table.\n\n<3> SQL Generation: Use 'where' to filter instructors in the Comp. Sci. department with a salary greater than 80000, and then select their names.\n\n",
        "predict": "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 80000"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "question": "What are the names of the instructors in the Comp. Sci. department who earn more than 80000?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter instructors based on their department and salary. Secondly, we need to select the names of the filtered instructors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ID and name from table 'instructor' where dept_name = 'Comp. Sci.' and salary > 80000.\n\n<3> SQL Generation: Use 'where' to filter instructors based on their department and salary, and then select their names.\n\n",
        "predict": "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 80000"
    },
    {
        "db_id": "debate",
        "gold": "SELECT Name FROM  people WHERE Age  =  35 OR Age  =  36",
        "question": "Show the names of people aged either 35 or 36.",
        "fields": "Table debate, columns = [*,Debate_ID,Date,Venue,Num_of_Audience]\nTable debate_people, columns = [*,Debate_ID,Affirmative,Negative,If_Affirmative_Win]\nTable people, columns = [*,People_ID,District,Name,Party,Age]\n",
        "foreign_keys": "Foreign_keys = [debate_people.Negative = people.People_ID,debate_people.Affirmative = people.People_ID,debate_people.Debate_ID = debate.Debate_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on people with age 35 or 36. We need to select the names of these people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter people with age 35 or 36 and select their names.\n\n",
        "predict": "SELECT Name FROM people WHERE Age = 35 OR Age = 36"
    },
    {
        "db_id": "debate",
        "gold": "SELECT T3.Name FROM debate_people AS T1 JOIN debate AS T2 ON T1.Debate_ID  =  T2.Debate_ID JOIN people AS T3 ON T1.Affirmative  =  T3.People_ID WHERE T2.Num_of_Audience  >  200",
        "question": "Show the names of people that are on affirmative side of debates with number of audience bigger than 200.",
        "fields": "Table debate, columns = [*,Debate_ID,Date,Venue,Num_of_Audience]\nTable debate_people, columns = [*,Debate_ID,Affirmative,Negative,If_Affirmative_Win]\nTable people, columns = [*,People_ID,District,Name,Party,Age]\n",
        "foreign_keys": "Foreign_keys = [debate_people.Negative = people.People_ID,debate_people.Affirmative = people.People_ID,debate_people.Debate_ID = debate.Debate_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter debates with number of audience bigger than 200. Secondly, we need to find the names of people on the affirmative side of these debates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter Debate_ID from table 'debate' where Num_of_Audience > 200. In the second step, we need to select Name from table 'people' where People_ID is in the affirmative column of table 'debate_people'.\n\n<3> SQL Generation: Use 'where' to filter debates with number of audience bigger than 200, and then use 'where' and 'join' to select the names of people on the affirmative side of these debates.\n\n",
        "predict": "SELECT people.Name FROM debate_people JOIN people ON debate_people.Affirmative = people.People_ID WHERE debate_people.Debate_ID IN (SELECT Debate_ID FROM debate WHERE Num_of_Audience > 200)"
    },
    {
        "db_id": "insurance_and_eClaims",
        "gold": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)",
        "question": "Find the customer who started a policy most recently.",
        "fields": "Table Claim_Headers, columns = [*,Claim_Header_ID,Claim_Status_Code,Claim_Type_Code,Policy_ID,Date_of_Claim,Date_of_Settlement,Amount_Claimed,Amount_Piad]\nTable Claims_Documents, columns = [*,Claim_ID,Document_Type_Code,Created_by_Staff_ID,Created_Date]\nTable Claims_Processing, columns = [*,Claim_Processing_ID,Claim_ID,Claim_Outcome_Code,Claim_Stage_ID,Staff_ID]\nTable Claims_Processing_Stages, columns = [*,Claim_Stage_ID,Next_Claim_Stage_ID,Claim_Status_Name,Claim_Status_Description]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Staff, columns = [*,Staff_ID,Staff_Details]\n",
        "foreign_keys": "Foreign_keys = [Policies.Customer_ID = Customers.Customer_ID,Claim_Headers.Policy_ID = Policies.Policy_ID,Claims_Documents.Created_by_Staff_ID = Staff.Staff_ID,Claims_Documents.Claim_ID = Claim_Headers.Claim_Header_ID,Claims_Processing.Staff_ID = Staff.Staff_ID,Claims_Processing.Claim_ID = Claim_Headers.Claim_Header_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the most recent start date of policies. Secondly, we need to find the customer associated with that policy.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the max start_date from table 'Policies'. In the second step, we need to filter the customer_id from table 'Policies' based on the max start_date.\n\n<3> SQL Generation: Use 'max' and 'order by' to find the most recent start date of policies, and then use 'where' to filter the customer associated with that policy.\n\n",
        "predict": "SELECT Customer_ID FROM Policies WHERE Start_Date = (SELECT MAX(Start_Date) FROM Policies)"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "question": "How many customers don't have an account?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding customers who don't have an account.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customers' and check if it exists in table 'Accounts'.\n\n<3> SQL Generation: Use 'where' to filter customers who don't have an account and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT transaction_id FROM Financial_transactions WHERE transaction_amount  >  (SELECT avg(transaction_amount) FROM Financial_transactions)",
        "question": "What are the ids for transactions that have an amount greater than the average amount of a transaction?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average amount of a transaction. Secondly, we need to filter transactions with an amount greater than the average amount.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select transaction_amount from table 'Financial_Transactions'.\n\n<3> SQL Generation: Use 'where' to filter transactions with an amount greater than the average amount.\n\n",
        "predict": "SELECT transaction_id FROM Financial_Transactions WHERE transaction_amount > (SELECT AVG(transaction_amount) FROM Financial_Transactions)"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "question": "How many products were not included in any order?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the products that were included in orders. Secondly, we need to count the products that were not included in any order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Order_Items'. In the second step, we need to select product_id from table 'Products' and count them.\n\n<3> SQL Generation: Use 'distinct' to select unique product_id from table 'Order_Items', and then use 'where' to filter products that were not included in any order and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Products WHERE product_id NOT IN (SELECT DISTINCT product_id FROM Order_Items)"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "question": "Count the number of products that were never ordered.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: We need to find the products that were never ordered. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select product_id from the 'Products' table and filter out the products that have corresponding entries in the 'Order_Items' table.\n\n<3> SQL Generation: We can use a left join between the 'Products' and 'Order_Items' tables and filter out the rows where the 'order_item_id' is null. Then, we can count the number of rows that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM Products LEFT JOIN Order_Items ON Products.product_id = Order_Items.product_id WHERE Order_Items.order_item_id IS NULL"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT count(*) FROM Church WHERE Open_Date  <  1850",
        "question": "How many churches opened before 1850 are there?",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on churches that opened before 1850. We need to filter churches based on their open date and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'church' table and its 'Open_Date' column.\n\n<3> SQL Generation: Use 'where' to filter churches that opened before 1850 and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM church WHERE Open_Date < 1850"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT count(*) FROM people WHERE is_male  =  'F' AND age  >  30",
        "question": "How many female people are older than 30 in our record?",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter people based on their gender and age. Secondly, we need to count the number of selected female people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'people' table to filter based on gender and age, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter people based on their gender and age, and then use 'count' to calculate the number of selected female people.\n\n",
        "predict": "SELECT COUNT(*) FROM people WHERE Is_Male = 0 AND Age > 30"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT T2.name ,  T3.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id WHERE T1.year  >  2014",
        "question": "Show the pair of male and female names in all weddings after year 2014",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter weddings that happened after year 2014. Secondly, we need to find the names of the male and female participants in those weddings.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Church_ID from table 'wedding' where Year > 2014. In the second step, we need to select Male_ID and Female_ID from table 'wedding' and join them with table 'people' to get the corresponding names.\n\n<3> SQL Generation: Use 'where' to filter weddings that happened after year 2014, and then use 'join' to connect the Male_ID and Female_ID with the People_ID in table 'people' to get the names of the participants.\n\n",
        "predict": "SELECT p1.Name AS Male_Name, p2.Name AS Female_Name FROM wedding AS w JOIN people AS p1 ON w.Male_ID = p1.People_ID JOIN people AS p2 ON w.Female_ID = p2.People_ID WHERE w.Year > 2014"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT name ,  age FROM people WHERE is_male  =  'T' AND people_id NOT IN (SELECT male_id FROM wedding)",
        "question": "Show the name and age for all male people who don't have a wedding.",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter male people. Secondly, we need to find male people who don't have a wedding. Finally, we need to select their names and ages.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'people' table for this query.\n\n<3> SQL Generation: Use 'where' to filter male people and then use 'not in' to filter people who have a wedding. Finally, select their names and ages.\n\n",
        "predict": "SELECT Name, Age FROM people WHERE Is_Male = true AND People_ID NOT IN (SELECT Male_ID FROM wedding)"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT T4.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id JOIN church AS T4 ON T4.church_id  =  T1.church_id WHERE T2.age  >  30 OR T3.age  >  30",
        "question": "Show the church names for the weddings of all people older than 30.",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter people based on their age being older than 30. Secondly, we need to find the church names for the weddings of these people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter People_ID from table 'people' where Age > 30. In the second step, we need to select Church_ID from table 'wedding' and filter by Male_ID and Female_ID from the filtered people in the first step.\n\n<3> SQL Generation: Use 'where' to filter people with age older than 30, and then use 'join' to link the 'wedding' table with the filtered people based on Male_ID and Female_ID. Finally, select the church names from the 'church' table.\n\n",
        "predict": "SELECT church.Name FROM church JOIN wedding ON church.Church_ID = wedding.Church_ID WHERE wedding.Male_ID IN (SELECT People_ID FROM people WHERE Age > 30) OR wedding.Female_ID IN (SELECT People_ID FROM people WHERE Age > 30)"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR  =  2016",
        "question": "How many churches have a wedding in year 2016?",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter weddings based on the year 2016. Secondly, we need to count the number of unique churches that have weddings in that year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Church_ID from table 'wedding' where Year = 2016. Then, we need to count the number of unique Church_IDs.\n\n<3> SQL Generation: Use 'where' to filter weddings in the year 2016, and then use 'count' and 'distinct' to count the number of unique Church_IDs.\n\n",
        "predict": "SELECT COUNT(DISTINCT Church_ID) FROM wedding WHERE Year = 2016"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT name ,  year_join FROM artist WHERE country != 'United States'",
        "question": "What are the names and year of joining for artists that do not have the country \"United States\"?",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter artists based on their country not being \"United States\". Secondly, we need to select the names and year of joining for the filtered artists.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'artist' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter artists based on their country not being \"United States\", and then select the names and year of joining for the filtered artists.\n\n",
        "predict": "SELECT Name, Year_Join FROM artist WHERE Country != 'United States'"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "question": "How many artists are above age 46 and joined after 1990?",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter artists based on their age and year of joining. Secondly, we need to count the number of selected artists.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'artist' table to filter artists based on age and year of joining, we only need the 'artist' table.\n\n<3> SQL Generation: Use 'where' to filter artists based on age and year of joining, and then use 'count' to count the number of selected artists.\n\n",
        "predict": "SELECT COUNT(*) FROM artist WHERE Age > 46 AND Year_Join > 1990"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "question": "Count the number of artists who are older than 46 and joined after 1990.",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter artists based on their age and year of joining. Secondly, we need to count the number of selected artists.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'artist' table to filter artists based on age and year of joining, we only need the 'artist' table.\n\n<3> SQL Generation: Use 'where' to filter artists based on age and year of joining, and then use 'count' to count the number of selected artists.\n\n",
        "predict": "SELECT COUNT(*) FROM artist WHERE Age > 46 AND Year_Join > 1990"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "question": "Find the number of items that did not receive any review.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding items that did not receive any review. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find items that did not receive any review, we only need the 'item' and 'review' tables.\n\n<3> SQL Generation: We can use a left join to combine the 'item' and 'review' tables on the 'i_id' column. Then, we can filter the rows where the 'rating' column is null (indicating no review) and count the number of rows.\n\n",
        "predict": "SELECT COUNT(*) FROM item LEFT JOIN review ON item.i_id = review.i_id WHERE review.rating IS NULL"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "question": "Find the number of users who did not write any review.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Decomposition: We need to find the users who did not write any review. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select u_id from table 'useracct' and filter out the u_id values that appear in the 'review' table.\n\n<3> SQL Generation: We can use a left join to combine the 'useracct' and 'review' tables on the 'u_id' column. Then, we can filter out the rows where the 'i_id' column is null (indicating that the user did not write any review). Finally, we can count the number of distinct 'u_id' values.\n\n",
        "predict": "SELECT COUNT(DISTINCT useracct.u_id) FROM useracct LEFT JOIN review ON useracct.u_id = review.u_id WHERE review.i_id IS NULL"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "question": "Find the number of items without any review.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Decomposition: We need to find the items that do not have any reviews.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'item' and 'review' tables.\n\n<3> SQL Generation: We can use a left join to combine the 'item' and 'review' tables on the 'i_id' column. Then, we can filter the rows where the 'review' table's 'i_id' is null, indicating that there are no reviews for that item. Finally, we can count the number of rows that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM item LEFT JOIN review ON item.i_id = review.i_id WHERE review.i_id IS NULL"
    },
    {
        "db_id": "riding_club",
        "gold": "SELECT Player_name FROM player ORDER BY Votes ASC",
        "question": "List the names of players in ascending order of votes.",
        "fields": "Table club, columns = [*,Club_ID,Club_name,Region,Start_year]\nTable coach, columns = [*,Coach_ID,Coach_name,Gender,Club_ID,Rank]\nTable match_result, columns = [*,Rank,Club_ID,Gold,Big_Silver,Small_Silver,Bronze,Points]\nTable player, columns = [*,Player_ID,Sponsor_name,Player_name,Gender,Residence,Occupation,Votes,Rank]\nTable player_coach, columns = [*,Player_ID,Coach_ID,Starting_year]\n",
        "foreign_keys": "Foreign_keys = [coach.Club_ID = club.Club_ID,player_coach.Coach_ID = coach.Coach_ID,player_coach.Player_ID = player.Player_ID,match_result.Club_ID = club.Club_ID]\n",
        "reasoning": "<1> Decomposition: We need to retrieve the names of players and sort them in ascending order based on their votes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'player' table for this query.\n\n<3> SQL Generation: We can directly select the 'Player_name' column from the 'player' table and order the results by the 'Votes' column in ascending order.\n\n",
        "predict": "SELECT Player_name FROM player ORDER BY Votes ASC"
    },
    {
        "db_id": "gymnast",
        "gold": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T2.Hometown != \"Santo Domingo\"",
        "question": "What are the names of gymnasts whose hometown is not \"Santo Domingo\"?",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on gymnasts whose hometown is not \"Santo Domingo\". We need to select the names of these gymnasts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names from the 'people' table and filter based on the 'hometown' column. We also need to join the 'gymnast' table with the 'people' table using the 'Gymnast_ID' and 'People_ID' columns.\n\n<3> SQL Generation: Use 'where' to filter gymnasts whose hometown is not \"Santo Domingo\" and select their names.\n\n",
        "predict": "SELECT Name FROM people JOIN gymnast ON people.People_ID = gymnast.Gymnast_ID WHERE Hometown != 'Santo Domingo'"
    },
    {
        "db_id": "small_bank_1",
        "gold": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)",
        "question": "What are the names of customers with checking balances lower than the average checking balance?",
        "fields": "Table ACCOUNTS, columns = [*,custid,name]\nTable CHECKING, columns = [*,custid,balance]\nTable SAVINGS, columns = [*,custid,balance]\n",
        "foreign_keys": "Foreign_keys = [SAVINGS.custid = ACCOUNTS.custid,CHECKING.custid = ACCOUNTS.custid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average checking balance. Secondly, we need to filter customers with checking balances lower than the average and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'ACCOUNTS' and 'CHECKING' tables.\n\n<3> SQL Generation: Use 'avg' to calculate the average checking balance, and then use 'where' to filter customers with checking balances lower than the average and select their names.\n\n",
        "predict": "SELECT name FROM ACCOUNTS WHERE custid IN (SELECT custid FROM CHECKING WHERE balance < (SELECT AVG(balance) FROM CHECKING))"
    },
    {
        "db_id": "browser_web",
        "gold": "SELECT count(*) FROM web_client_accelerator WHERE id NOT IN ( SELECT accelerator_id FROM accelerator_compatible_browser );",
        "question": "How many accelerators are not compatible with the browsers listed ?",
        "fields": "Table Web_client_accelerator, columns = [*,id,name,Operating_system,Client,Connection]\nTable accelerator_compatible_browser, columns = [*,accelerator_id,browser_id,compatible_since_year]\nTable browser, columns = [*,id,name,market_share]\n",
        "foreign_keys": "Foreign_keys = [accelerator_compatible_browser.browser_id = browser.id,accelerator_compatible_browser.accelerator_id = Web_client_accelerator.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the accelerators that are not compatible with the listed browsers. Secondly, we need to count the number of accelerators that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the accelerators from the table 'Web_client_accelerator' and filter them based on their compatibility with the listed browsers.\n\n<3> SQL Generation: Use 'where' to filter accelerators that are not compatible with the listed browsers, and then use 'count' to calculate the number of accelerators that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM Web_client_accelerator WHERE id NOT IN (SELECT accelerator_id FROM accelerator_compatible_browser WHERE browser_id IN (SELECT id FROM browser WHERE name IN ('browser1', 'browser2', 'browser3')))"
    },
    {
        "db_id": "wrestler",
        "gold": "SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1",
        "question": "What is the name of the wrestler with the fewest days held?",
        "fields": "Table Elimination, columns = [*,Elimination_ID,Wrestler_ID,Team,Eliminated_By,Elimination_Move,Time]\nTable wrestler, columns = [*,Wrestler_ID,Name,Reign,Days_held,Location,Event]\n",
        "foreign_keys": "Foreign_keys = [Elimination.Wrestler_ID = wrestler.Wrestler_ID]\n",
        "reasoning": "<1> Decomposition: We need to find the wrestler with the fewest days held. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'wrestler' table.\n\n<3> SQL Generation: We can use the 'MIN' function to find the minimum value of 'Days_held' in the 'wrestler' table and then select the corresponding wrestler's name.\n\n",
        "predict": "SELECT Name FROM wrestler WHERE Days_held = (SELECT MIN(Days_held) FROM wrestler)"
    },
    {
        "db_id": "wrestler",
        "gold": "SELECT Name FROM wrestler WHERE Days_held  <  100",
        "question": "What are the names of wrestlers days held less than 100?",
        "fields": "Table Elimination, columns = [*,Elimination_ID,Wrestler_ID,Team,Eliminated_By,Elimination_Move,Time]\nTable wrestler, columns = [*,Wrestler_ID,Name,Reign,Days_held,Location,Event]\n",
        "foreign_keys": "Foreign_keys = [Elimination.Wrestler_ID = wrestler.Wrestler_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on wrestlers with days held less than 100. We need to select the names of these wrestlers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'wrestler' table.\n\n<3> SQL Generation: Use 'where' to filter wrestlers with days held less than 100 and select their names.\n\n",
        "predict": "SELECT Name FROM wrestler WHERE Days_held < 100"
    },
    {
        "db_id": "school_finance",
        "gold": "SELECT count(DISTINCT T1.donator_name) FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Glenn\"",
        "question": "How many donors have endowment for school named \"Glenn\"?",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the school with the name \"Glenn\". Secondly, we need to count the number of donors who have an endowment for that school.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select School_id from table 'School' where School_name = \"Glenn\". In the second step, we need to count the number of distinct donors from table 'endowment' where School_id matches the School_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the School_id for the school named \"Glenn\", and then use 'count' to count the number of distinct donors from the 'endowment' table where School_id matches the School_id found in the first step.\n\n",
        "predict": "SELECT COUNT(DISTINCT donator_name) FROM endowment WHERE School_id = (SELECT School_id FROM School WHERE School_name = \"Glenn\")"
    },
    {
        "db_id": "school_finance",
        "gold": "SELECT count(*) FROM budget WHERE budgeted  <  invested",
        "question": "How many budget record has a budget amount smaller than the invested amount?",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on budget records where the budget amount is smaller than the invested amount. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'budget' table for this query.\n\n<3> SQL Generation: Use 'where' to filter budget records where the budget amount is smaller than the invested amount, and then count the number of records that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM budget WHERE Budgeted < Invested"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT name FROM building WHERE height_feet  >=  200 AND floors  >=  20",
        "question": "List the names of buildings with at least 200 feet of height and with at least 20 floors.",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on buildings with at least 200 feet of height and at least 20 floors. We need to select the names of these buildings.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'building' table.\n\n<3> SQL Generation: Use 'where' to filter buildings with at least 200 feet of height and at least 20 floors, and then select the names of these buildings.\n\n",
        "predict": "SELECT Name FROM building WHERE Height_feet >= 200 AND Floors >= 20"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT TYPE FROM institution WHERE founded  >  1990 AND enrollment  >=  1000",
        "question": "Show the institution type with an institution founded after 1990 and an institution with at least 1000 enrollment.",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter institutions based on their founding year and enrollment. Secondly, we need to select the institution type for the filtered institutions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the institution type from table 'Institution' and filter by founding year and enrollment.\n\n<3> SQL Generation: Use 'where' to filter institutions founded after 1990 and with at least 1000 enrollment, and then select the institution type.\n\n",
        "predict": "SELECT Type FROM Institution WHERE Founded > 1990 AND Enrollment >= 1000"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id WHERE T1.founded  >  1880 OR T1.type  =  'Private'",
        "question": "How many proteins are associated with an institution founded after 1880 or an institution with type \"Private\"?",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter institutions founded after 1880. Secondly, we need to filter institutions with type \"Private\". Finally, we need to count the number of proteins associated with these filtered institutions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter Institution_id from table 'Institution' where Founded > 1880. In the second step, we need to filter Institution_id from table 'Institution' where Type = \"Private\". In the final step, we need to count the number of proteins associated with the filtered Institution_id.\n\n<3> SQL Generation: Use 'where' to filter institutions founded after 1880 and institutions with type \"Private\". Then, use 'where' to filter proteins associated with the filtered Institution_id and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM protein WHERE Institution_id IN (SELECT Institution_id FROM Institution WHERE Founded > 1880 OR Type = \"Private\")"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT count(*) FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM protein)",
        "question": "How many institutions do not have an associated protein in our record?",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding institutions that do not have an associated protein in the record.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Institution_id from table 'Institution' and check if there is a corresponding Institution_id in table 'protein'.\n\n<3> SQL Generation: Use 'where' to filter institutions that do not have a corresponding Institution_id in the 'protein' table, and then count the number of institutions.\n\n",
        "predict": "SELECT COUNT(*) FROM Institution WHERE Institution_id NOT IN (SELECT Institution_id FROM protein)"
    },
    {
        "db_id": "cinema",
        "gold": "SELECT title ,  directed_by FROM film WHERE film_id NOT IN (SELECT film_id FROM schedule)",
        "question": "What are the title and director of the films without any schedule?",
        "fields": "Table cinema, columns = [*,Cinema_ID,Name,Openning_year,Capacity,Location]\nTable film, columns = [*,Film_ID,Rank_in_series,Number_in_season,Title,Directed_by,Original_air_date,Production_code]\nTable schedule, columns = [*,Cinema_ID,Film_ID,Date,Show_times_per_day,Price]\n",
        "foreign_keys": "Foreign_keys = [schedule.Cinema_ID = cinema.Cinema_ID,schedule.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the films that do not have any schedule. Secondly, we need to select the title and director of those films.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'film' table to select the title and director.\n\n<3> SQL Generation: Use 'not in' to find the films that do not have any schedule, and then select the title and director from the 'film' table.\n\n",
        "predict": "SELECT Title, Directed_by FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM schedule)"
    },
    {
        "db_id": "products_for_hire",
        "gold": "SELECT T2.product_name FROM view_product_availability AS T1 JOIN products_for_hire AS T2 ON T1.product_id  =  T2.product_id WHERE T1.available_yn  =  1",
        "question": "What are the names of products whose availability equals to 1?",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on products whose availability equals to 1. We need to select the names of these products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the product names from the table 'Products_for_Hire' where availability equals to 1.\n\n<3> SQL Generation: Use 'where' to filter products whose availability equals to 1 and select their names.\n\n",
        "predict": "SELECT product_name FROM Products_for_Hire WHERE availability = 1"
    },
    {
        "db_id": "products_for_hire",
        "gold": "SELECT count(*) FROM Products_for_hire WHERE product_id NOT IN ( SELECT product_id FROM products_booked WHERE booked_amount  >  200 )",
        "question": "How many products are never booked with amount higher than 200?",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the products that are never booked with an amount higher than 200. Secondly, we need to count the number of such products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select product_id from table 'Products_for_Hire' where booked_amount <= 200 and then count the number of distinct product_ids.\n\n<3> SQL Generation: Use 'where' to filter products that are never booked with an amount higher than 200, and then use 'count' to count the number of distinct product_ids.\n\n",
        "predict": "SELECT COUNT(DISTINCT product_id) FROM Products_for_Hire WHERE product_id NOT IN (SELECT DISTINCT product_id FROM Products_Booked WHERE booked_amount > 200)"
    },
    {
        "db_id": "products_for_hire",
        "gold": "SELECT payment_date FROM payments WHERE amount_paid  >  300 OR payment_type_code  =  'Check'",
        "question": "What are the payment date of the payment with amount paid higher than 300 or with payment type is 'Check'",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter payments with amount paid higher than 300. Secondly, we need to filter payments with payment type 'Check'. Finally, we need to select the payment dates of the filtered payments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select payment_date from table 'Payments' and filter by amount_paid or payment_type_code.\n\n<3> SQL Generation: Use 'where' to filter payments with amount paid higher than 300 or with payment type 'Check', and then select the payment dates.\n\n",
        "predict": "SELECT payment_date FROM Payments WHERE amount_paid > 300 OR payment_type_code = 'Check'"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "question": "Show the company name and the main industry for all companies whose headquarters are not from USA.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on companies whose headquarters are not from the USA. We need to select the company name and main industry for these companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select company name and main industry from table 'company' where headquarters is not from the USA.\n\n<3> SQL Generation: Use 'where' to filter companies whose headquarters are not from the USA, and then select the company name and main industry.\n\n",
        "predict": "SELECT Company, Main_Industry FROM company WHERE Headquarters != 'USA'"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "question": "What are the companies and main industries of all companies that are not headquartered in the United States?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on companies that are not headquartered in the United States. Firstly, we need to identify the companies that are not headquartered in the United States. Secondly, we need to select the company name and main industry of these companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'company' table, we only need to consider this table.\n\n<3> SQL Generation: Use 'where' to filter companies that are not headquartered in the United States, and then select the company name and main industry.\n\n",
        "predict": "SELECT Company, Main_Industry FROM company WHERE Headquarters != 'United States'"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT count(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005",
        "question": "How many gas station are opened between 2000 and 2005?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on gas stations that were opened between 2000 and 2005.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'gas_station' table.\n\n<3> SQL Generation: Use 'where' to filter gas stations that were opened between 2000 and 2005, and then count the number of rows that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM gas_station WHERE Open_Year >= 2000 AND Open_Year <= 2005"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "question": "Show company name and main industry without a gas station.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding companies without a gas station. We need to select the company name and main industry from the 'company' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'company' table.\n\n<3> SQL Generation: We can use a left join to combine the 'company' table with the 'station_company' table on the 'Company_ID' column. Then, we can filter the rows where the 'Station_ID' is null, indicating that the company does not have a gas station. Finally, we select the company name and main industry from the resulting rows.\n\n",
        "predict": "SELECT company.Company, company.Main_Industry FROM company LEFT JOIN station_company ON company.Company_ID = station_company.Company_ID WHERE station_company.Station_ID IS NULL"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "question": "What are the main industries of the companies without gas stations and what are the companies?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies without gas stations. Secondly, we need to identify the main industries of these companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Company_ID from table 'company' where Company_ID does not exist in table 'station_company'. In the second step, we need to select Main_Industry and Company from table 'company' based on the Company_IDs found in the first step.\n\n<3> SQL Generation: Use 'where' and 'not in' to find the Company_IDs that do not exist in table 'station_company', and then select Main_Industry and Company based on these Company_IDs.\n\n",
        "predict": "SELECT Main_Industry, Company FROM company WHERE Company_ID NOT IN (SELECT Company_ID FROM station_company)"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT T3.location FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.market_value  >  100",
        "question": "What are the locations that have gas stations owned by a company with a market value greater than 100?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies with a market value greater than 100. Secondly, we need to filter gas stations based on their ownership by these companies and select their locations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Company_ID from table 'company' where Market_Value > 100. In the second step, we need to filter Station_ID and Location from table 'gas_station' based on the ownership by the selected companies.\n\n<3> SQL Generation: Use 'where' to find the companies with a market value greater than 100, and then use 'where' to filter gas stations owned by these companies and select their locations.\n\n",
        "predict": "SELECT Location FROM gas_station WHERE Station_ID IN (SELECT Station_ID FROM station_company WHERE Company_ID IN (SELECT Company_ID FROM company WHERE Market_Value > 100))"
    },
    {
        "db_id": "party_people",
        "gold": "SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "question": "Show names of parties that does not have any members.",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding parties that do not have any members. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select party_name from table 'party' and filter parties that do not have any members.\n\n<3> SQL Generation: Use 'where' and 'not exists' to filter parties that do not have any members.\n\n",
        "predict": "SELECT party_name FROM party WHERE NOT EXISTS (SELECT * FROM member WHERE member.Party_ID = party.Party_ID)"
    },
    {
        "db_id": "cre_Doc_Control_Systems",
        "gold": "SELECT Ref_Document_Status.document_status_description FROM Ref_Document_Status JOIN Documents ON Documents.document_status_code = Ref_Document_Status.document_status_code WHERE Documents.document_id = 1;",
        "question": "What is the document status description of the document with id 1?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Circulation_History, columns = [*,document_id,draft_number,copy_number,employee_id]\nTable Document_Drafts, columns = [*,document_id,draft_number,draft_details]\nTable Documents, columns = [*,document_id,document_status_code,document_type_code,shipping_agent_code,receipt_date,receipt_number,other_details]\nTable Documents_Mailed, columns = [*,document_id,mailed_to_address_id,mailing_date]\nTable Draft_Copies, columns = [*,document_id,draft_number,copy_number]\nTable Employees, columns = [*,employee_id,role_code,employee_name,other_details]\nTable Ref_Document_Status, columns = [*,document_status_code,document_status_description]\nTable Ref_Document_Types, columns = [*,document_type_code,document_type_description]\nTable Ref_Shipping_Agents, columns = [*,shipping_agent_code,shipping_agent_name,shipping_agent_description]\nTable Roles, columns = [*,role_code,role_description]\n",
        "foreign_keys": "Foreign_keys = [Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code,Documents.document_status_code = Ref_Document_Status.document_status_code,Documents.document_type_code = Ref_Document_Types.document_type_code,Employees.role_code = Roles.role_code,Document_Drafts.document_id = Documents.document_id,Draft_Copies.document_id = Document_Drafts.document_id,Draft_Copies.draft_number = Document_Drafts.draft_number,Circulation_History.employee_id = Employees.employee_id,Circulation_History.document_id = Draft_Copies.document_id,Circulation_History.draft_number = Draft_Copies.draft_number,Circulation_History.copy_number = Draft_Copies.copy_number,Documents_Mailed.mailed_to_address_id = Addresses.address_id,Documents_Mailed.document_id = Documents.document_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the document status description of the document with id 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the document status description from the 'Ref_Document_Status' table based on the document id.\n\n<3> SQL Generation: Use 'where' to filter the document with id 1 and select the document status description.\n\n",
        "predict": "SELECT document_status_description FROM Ref_Document_Status WHERE document_status_code = (SELECT document_status_code FROM Documents WHERE document_id = 1)"
    },
    {
        "db_id": "company_1",
        "gold": "SELECT count(*) FROM dependent WHERE sex  =  'F'",
        "question": "how many female dependents are there?",
        "fields": "Table department, columns = [*,Dname,Dnumber,Mgr_ssn,Mgr_start_date]\nTable dependent, columns = [*,Essn,Dependent_name,Sex,Bdate,Relationship]\nTable dept_locations, columns = [*,Dnumber,Dlocation]\nTable employee, columns = [*,Fname,Minit,Lname,Ssn,Bdate,Address,Sex,Salary,Super_ssn,Dno]\nTable project, columns = [*,Pname,Pnumber,Plocation,Dnum]\nTable works_on, columns = [*,Essn,Pno,Hours]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of female dependents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is about dependents, we need the 'dependent' table.\n\n<3> SQL Generation: Use 'where' to filter dependents by sex and count the number of rows.\n\n",
        "predict": "SELECT COUNT(*) FROM dependent WHERE sex = 'female'"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT count(*) FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid WHERE T2.name = \"Australian Grand Prix\" AND YEAR = 2009",
        "question": "How many drivers were in the Australian Grand Prix held in 2009?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the raceId of the Australian Grand Prix held in 2009. Secondly, we need to count the number of drivers in that race.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select raceId from table 'races' where name = 'Australian Grand Prix' and year = 2009. In the second step, we need to count the distinct driverId from table 'results' where raceId matches the raceId found in the first step.\n\n<3> SQL Generation: Use 'where' to find the raceId of the Australian Grand Prix held in 2009, and then use 'count(distinct)' to count the number of drivers in that race.\n\n",
        "predict": "SELECT COUNT(DISTINCT driverId) FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2009)"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )",
        "question": "How many drivers did not participate in the races held in 2009?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the raceIds of the races held in 2009. Secondly, we need to find the driverIds of the drivers who participated in those races. Finally, we need to count the number of drivers who did not participate.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select raceId from table 'races' where year = 2009. In the second step, we need to select driverId from table 'results' where raceId is in the raceIds found in the first step. In the final step, we need to count the number of drivers who did not participate.\n\n<3> SQL Generation: Use 'where' to find the raceIds of the races held in 2009. Then, use 'where' to find the driverIds of the drivers who participated in those races. Finally, count the number of drivers who did not participate.\n\n",
        "predict": "SELECT COUNT(*) FROM drivers WHERE driverId NOT IN (SELECT driverId FROM results WHERE raceId IN (SELECT raceId FROM races WHERE year = 2009))"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )",
        "question": "How many drivers did not race in 2009?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: The query requires finding the drivers who did not race in 2009. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the driverId from the 'drivers' table and filter by the raceId from the 'races' table where the year is 2009. \n\n<3> SQL Generation: Use 'where' to filter the races in 2009, and then use 'not in' to filter the drivers who raced in 2009. Finally, count the number of drivers who did not race in 2009.\n\n",
        "predict": "SELECT COUNT(*) FROM drivers WHERE driverId NOT IN (SELECT driverId FROM results WHERE raceId IN (SELECT raceId FROM races WHERE year = 2009))"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20",
        "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter drivers who won in position 1 as driver standing. Secondly, we need to filter drivers who had more than 20 points. Finally, we need to select the distinct forenames of these drivers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select forename from table 'drivers' and filter by positionText = '1' in table 'driverStandings' and points > 20 in table 'driverStandings'.\n\n<3> SQL Generation: Use 'where' to filter drivers who won in position 1 as driver standing and had more than 20 points, and then use 'distinct' to select the forenames of these drivers.\n\n",
        "predict": "SELECT DISTINCT forename FROM drivers WHERE driverId IN (SELECT driverId FROM driverStandings WHERE positionText = '1' AND points > 20)"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011",
        "question": "What are the names of races held between 2009 and 2011?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter races based on their years, selecting races held between 2009 and 2011. Secondly, we need to retrieve the names of the selected races.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'races' table and its 'name' column.\n\n<3> SQL Generation: Use 'where' to filter races based on their years, and then select the names of the selected races.\n\n",
        "predict": "SELECT name FROM races WHERE year BETWEEN 2009 AND 2011"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT name FROM races WHERE TIME > \"12:00:00\" OR TIME < \"09:00:00\"",
        "question": "What are the names of all races that occurred after 12:00:00 or before 09:00:00?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on races that occurred after 12:00:00 or before 09:00:00. Firstly, we need to identify the races that occurred after 12:00:00. Secondly, we need to identify the races that occurred before 09:00:00. Finally, we need to combine the results from the two steps.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'races' table and the 'time' column.\n\n<3> SQL Generation: Use 'where' to filter races that occurred after 12:00:00 or before 09:00:00.\n\n",
        "predict": "SELECT name FROM races WHERE time > '12:00:00' OR time < '09:00:00'"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the race with the name 'Monaco Grand Prix' in the year 2008. Secondly, we need to find the maximum fastest lap speed in that race.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select raceId from table 'races' where name = 'Monaco Grand Prix' and year = 2008. In the second step, we need to select the maximum fastest lap speed from table 'results' where raceId matches the raceId found in the first step.\n\n<3> SQL Generation: Use 'where' to find the race with the name 'Monaco Grand Prix' in the year 2008, and then use 'where' and 'max' to find the maximum fastest lap speed in that race.\n\n",
        "predict": "SELECT MAX(fastestLapSpeed) FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Monaco Grand Prix' AND year = 2008)"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter races based on the race name 'Monaco Grand Prix' and the year '2008'. Secondly, we need to find the maximum fastest lap speed in the selected race.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select raceId from table 'races' where name = 'Monaco Grand Prix' and year = 2008. In the second step, we need to select the maximum fastest lap speed from table 'results' where raceId matches the selected raceId.\n\n<3> SQL Generation: Use 'where' to filter races based on the race name 'Monaco Grand Prix' and the year '2008', and then use 'where' and 'max' to find the maximum fastest lap speed in the selected race.\n\n",
        "predict": "SELECT MAX(fastestLapSpeed) FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Monaco Grand Prix' AND year = 2008)"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "question": "List the name of technicians whose team is not \"NYY\".",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the 'team' column in the 'technician' table. We need to select the names of technicians whose team is not \"NYY\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'technician' table and its 'name' and 'team' columns, we can directly use this table.\n\n<3> SQL Generation: Use 'where' to filter technicians whose team is not \"NYY\" and select their names.\n\n",
        "predict": "SELECT name FROM technician WHERE team != 'NYY'"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "question": "What is the name of the technician whose team is not 'NYY'?",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the team of the technician. We need to find the technician whose team is not 'NYY' and retrieve their name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the technician's name and team, we can directly use the 'technician' table.\n\n<3> SQL Generation: Use 'where' to filter technicians whose team is not 'NYY' and select their names.\n\n",
        "predict": "SELECT Name FROM technician WHERE Team != 'NYY'"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1",
        "question": "What is the starting year of the oldest technicians?",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Decomposition: We need to find the oldest technicians and retrieve their starting year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'technician' table to retrieve the starting year.\n\n<3> SQL Generation: We can use the 'MIN' function to find the minimum starting year from the 'technician' table.\n\n",
        "predict": "SELECT MIN(Starting_Year) FROM technician"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment)",
        "question": "List the names of technicians who have not been assigned to repair machines.",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding technicians who have not been assigned to repair machines. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find technicians who have not been assigned to repair machines, we need to select the names of technicians from the 'technician' table.\n\n<3> SQL Generation: We can use a left join to combine the 'technician' table with the 'repair_assignment' table on the 'technician_id' column. Then, we can filter the rows where the 'Machine_ID' is null, indicating that the technician has not been assigned to repair machines.\n\n",
        "predict": "SELECT Name FROM technician LEFT JOIN repair_assignment ON technician.technician_id = repair_assignment.technician_id WHERE repair_assignment.Machine_ID IS NULL"
    },
    {
        "db_id": "entrepreneur",
        "gold": "SELECT T2.Name FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Investor != \"Rachel Elnaugh\"",
        "question": "What are the names of entrepreneurs whose investor is not \"Rachel Elnaugh\"?",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the 'investor' column in the 'entrepreneur' table. We need to select the names of entrepreneurs whose investor is not \"Rachel Elnaugh\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'entrepreneur' table.\n\n<3> SQL Generation: Use 'where' to filter entrepreneurs whose investor is not \"Rachel Elnaugh\" and select their names.\n\n",
        "predict": "SELECT Name FROM entrepreneur WHERE Investor != 'Rachel Elnaugh'"
    },
    {
        "db_id": "entrepreneur",
        "gold": "SELECT T2.Name FROM entrepreneur AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Investor != \"Rachel Elnaugh\"",
        "question": "Return the names of entrepreneurs do no not have the investor Rachel Elnaugh.",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the investor column in the entrepreneur table. We need to select the names of entrepreneurs who do not have the investor Rachel Elnaugh.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the entrepreneur table.\n\n<3> SQL Generation: Use 'where' to filter entrepreneurs who do not have the investor Rachel Elnaugh and select their names.\n\n",
        "predict": "SELECT Name FROM entrepreneur WHERE Investor != 'Rachel Elnaugh'"
    },
    {
        "db_id": "entrepreneur",
        "gold": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)",
        "question": "What are the names of people who are not entrepreneurs?",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding people who are not entrepreneurs. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find people who are not entrepreneurs, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter out people who are entrepreneurs.\n\n",
        "predict": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)"
    },
    {
        "db_id": "perpetrator",
        "gold": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)",
        "question": "List the names of people that are not perpetrators.",
        "fields": "Table people, columns = [*,People_ID,Name,Height,Weight,Home Town]\nTable perpetrator, columns = [*,Perpetrator_ID,People_ID,Date,Year,Location,Country,Killed,Injured]\n",
        "foreign_keys": "Foreign_keys = [perpetrator.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on people who are not perpetrators. We need to select the names of those people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter out the perpetrators and select their names.\n\n",
        "predict": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "question": "What campuses are located in the county of Los Angeles?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires finding campuses located in the county of Los Angeles. Firstly, we need to identify the campuses with the county name 'Los Angeles'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Id' column from the 'Campuses' table where the 'County' column is 'Los Angeles'.\n\n<3> SQL Generation: Use 'where' to filter campuses with the county name 'Los Angeles'.\n\n",
        "predict": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles'"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE YEAR  >=  1935 AND YEAR  <=  1939",
        "question": "Which campus was opened between 1935 and 1939?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires finding campuses that were opened between 1935 and 1939. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information about the campuses, we only need the 'Campuses' table.\n\n<3> SQL Generation: Use 'where' to filter campuses that were opened between 1935 and 1939.\n\n",
        "predict": "SELECT Campus FROM Campuses WHERE Year >= 1935 AND Year <= 1939"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "question": "Find the count of universities whose campus fee is greater than the average campus fee.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average campus fee. Secondly, we need to count the number of universities whose campus fee is greater than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Campus' and 'CampusFee' columns from the 'csu_fees' table, we only need this table.\n\n<3> SQL Generation: Use 'select' and 'avg' to calculate the average campus fee, and then use 'where' to filter universities whose campus fee is greater than the average. Finally, use 'count' to count the number of universities.\n\n",
        "predict": "SELECT COUNT(*) FROM csu_fees WHERE CampusFee > (SELECT AVG(CampusFee) FROM csu_fees)"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "question": "How many universities have a campus fee higher than average?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average campus fee. Secondly, we need to count the number of universities with a campus fee higher than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'csu_fees' table to calculate the average campus fee and count the number of universities.\n\n<3> SQL Generation: Use 'avg' to calculate the average campus fee, and then use 'where' to filter universities with a campus fee higher than the average. Finally, use 'count' to count the number of universities.\n\n",
        "predict": "SELECT COUNT(*) FROM csu_fees WHERE CampusFee > (SELECT AVG(CampusFee) FROM csu_fees)"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "question": "Find the count of universities whose campus fee is greater than the average campus fee.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average campus fee. Secondly, we need to count the number of universities whose campus fee is greater than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Campus' and 'CampusFee' columns from the 'csu_fees' table, we only need this table.\n\n<3> SQL Generation: Use 'select avg' to calculate the average campus fee, and then use 'where' to filter universities whose campus fee is greater than the average. Finally, use 'count' to count the number of universities.\n\n",
        "predict": "SELECT COUNT(*) FROM csu_fees WHERE CampusFee > (SELECT AVG(CampusFee) FROM csu_fees)"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\" AND YEAR  >  1950",
        "question": "Which university is in Los Angeles county and opened after 1950?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter universities based on their location in Los Angeles county. Secondly, we need to filter universities based on their opening year after 1950.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Campus' column from the 'Campuses' table and filter by 'Location' and 'Year'.\n\n<3> SQL Generation: Use 'where' to filter universities based on their location in Los Angeles county and opening year after 1950.\n\n",
        "predict": "SELECT Campus FROM Campuses WHERE Location = 'Los Angeles county' AND Year > 1950"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2002 AND faculty  >  (SELECT max(faculty) FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2002 AND T1.county  =  \"Orange\")",
        "question": "What are the names of the campus that have more faculties in 2002 than the maximum number in Orange county?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the maximum number of faculties in Orange county. Secondly, we need to filter campuses based on their number of faculties in 2002 and compare it with the maximum number found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the maximum number of faculties from table 'faculty' where County = 'Orange' and Year = 2002. In the second step, we need to filter Campus and Year from table 'faculty' and compare the number of faculties with the maximum number.\n\n<3> SQL Generation: Use 'where' to find the maximum number of faculties in Orange county in 2002, and then use 'where' to filter campuses based on their number of faculties in 2002 and compare it with the maximum number.\n\n",
        "predict": "SELECT Campus FROM faculty WHERE Year = 2002 GROUP BY Campus HAVING COUNT(*) > (SELECT MAX(Faculty) FROM faculty WHERE County = 'Orange' AND Year = 2002)"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM campuses WHERE county  =  \"Los Angeles\"",
        "question": "How many campuses are there in Los Angeles county?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of campuses in Los Angeles county.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the campuses from the 'Campuses' table where the county is 'Los Angeles'.\n\n<3> SQL Generation: Use 'where' to filter the campuses in Los Angeles county and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Campuses WHERE County = 'Los Angeles'"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "question": "List the campuses in Los Angeles county.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on campuses in Los Angeles county. We need to select the campuses located in Los Angeles county.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Campus' column from the 'Campuses' table and filter by 'County' column where it is equal to 'Los Angeles'.\n\n<3> SQL Generation: Use 'where' to filter campuses in Los Angeles county.\n\n",
        "predict": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles'"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  \"San Francisco State University\" AND t2.year  =  2001",
        "question": "What are the degrees conferred in \"San Francisco State University\" in 2001.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the campus ID for \"San Francisco State University\". Secondly, we need to filter the degrees based on the campus ID and the year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the ID from the \"Campuses\" table where the campus name is \"San Francisco State University\". In the second step, we need to filter the degrees based on the campus ID and the year.\n\n<3> SQL Generation: Use 'where' to find the campus ID for \"San Francisco State University\", and then use 'where' to filter the degrees based on the campus ID and the year.\n\n",
        "predict": "SELECT Degrees FROM degrees WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2001"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004",
        "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter campuses based on the number of faculty lines. Secondly, we need to filter campuses based on the year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Campus from table 'faculty' and filter by the number of faculty lines. We also need to filter campuses based on the year from table 'Campuses'.\n\n<3> SQL Generation: Use 'where' to filter campuses based on the number of faculty lines and the year.\n\n",
        "predict": "SELECT Campus FROM faculty WHERE Year = 2004 AND Faculty BETWEEN 600 AND 1000"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  \"San Jose State University\"",
        "question": "How many undergraduates are there at San Jose State",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter the campus with the name 'San Jose State'. Secondly, we need to select the number of undergraduates from the 'discipline_enrollments' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the 'Id' from the 'Campuses' table where the 'Campus' is 'San Jose State'. In the second step, we need to select the 'Undergraduate' column from the 'discipline_enrollments' table.\n\n<3> SQL Generation: Use 'where' to filter the campus with the name 'San Jose State', and then select the 'Undergraduate' column from the 'discipline_enrollments' table.\n\n",
        "predict": "SELECT Undergraduate FROM discipline_enrollments WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State')"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT t1.campusfee FROM csu_fees AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t2.campus  =  \"San Francisco State University\" AND t1.year  =  2000",
        "question": "What is the campus fee of \"San Francisco State University\" in year 2000?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the campus ID of \"San Francisco State University\". Secondly, we need to filter the campus fee based on the campus ID and year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the ID from the \"Campuses\" table where the campus name is \"San Francisco State University\". In the second step, we need to select the campus fee from the \"csu_fees\" table based on the campus ID and year.\n\n<3> SQL Generation: Use 'where' to find the campus ID of \"San Francisco State University\", and then use 'where' to filter the campus fee based on the campus ID and year.\n\n",
        "predict": "SELECT CampusFee FROM csu_fees WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2000"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT name FROM people WHERE height  >  200 OR height  <  190",
        "question": "find the names of people who are taller than 200 or lower than 190.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on people's height, so we should apply the 'where' condition to the 'Height' column and then return the names of selected people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'people' table to filter on height and retrieve names, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter people based on their height and select their names.\n\n",
        "predict": "SELECT Name FROM people WHERE Height > 200 OR Height < 190"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "question": "what are the names of people who did not participate in the candidate election.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding the names of people who did not participate in the candidate election. Firstly, we need to identify the people who participated in the candidate election. Secondly, we need to filter out the names of people who did not participate.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'people' table to retrieve the names of people.\n\n<3> SQL Generation: Use 'not in' to filter out the people who participated in the candidate election and select their names.\n\n",
        "predict": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM candidate)"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "question": "Give the names of people who did not participate in the candidate election.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding people who did not participate in the candidate election. Firstly, we need to identify the people who participated in the candidate election. Secondly, we need to select the names of people who did not participate.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select People_ID from table 'candidate'. In the second step, we need to select Name from table 'people' and filter by People_ID.\n\n<3> SQL Generation: Use 'where' to find the People_ID of people who participated in the candidate election, and then use 'not in' to select the names of people who did not participate.\n\n",
        "predict": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM candidate)"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "question": "How many movies were made before 2000?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on movies made before 2000. We need to select movies based on their year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' table and the 'year' column.\n\n<3> SQL Generation: Use 'where' to filter movies made before 2000 and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Movie WHERE year < 2000"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "question": "How many movies were made before 2000?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on movies made before 2000. We need to select movies based on their year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' table and the 'year' column.\n\n<3> SQL Generation: Use 'where' to filter movies made before 2000 and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Movie WHERE year < 2000"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT count(*) FROM Rating WHERE stars  >  3",
        "question": "What is the total number of ratings that has more than 3 stars?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on ratings with more than 3 stars. We need to count the number of ratings that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rating' table for this query.\n\n<3> SQL Generation: Use 'where' to filter ratings with more than 3 stars, and then use 'count' to calculate the total number of ratings that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM Rating WHERE stars > 3"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT YEAR FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  >=  4 ORDER BY T1.year",
        "question": "In what years did a movie receive a 4 or 5 star rating, and list the years from oldest to most recently?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter movies that received a 4 or 5 star rating. Secondly, we need to list the years of these movies from oldest to most recently.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the year from table 'Movie' and filter by movies that have a 4 or 5 star rating in table 'Rating'.\n\n<3> SQL Generation: Use 'where' to filter movies that received a 4 or 5 star rating, and then use 'order by' to list the years from oldest to most recently.\n\n",
        "predict": "SELECT DISTINCT year FROM Movie WHERE mID IN (SELECT mID FROM Rating WHERE stars >= 4) ORDER BY year ASC"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT avg(T1.stars) ,  T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.year  =  (SELECT min(YEAR) FROM Movie)",
        "question": "For the oldest movie listed, what is its average rating and title?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the oldest movie listed. Secondly, we need to calculate the average rating for that movie. Finally, we need to retrieve the title of the movie.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the minimum year from the 'Movie' table and then join it with the 'Rating' table on the 'mID' column to calculate the average rating. We also need to retrieve the title from the 'Movie' table.\n\n<3> SQL Generation: Use 'where' to find the minimum year from the 'Movie' table. Then, join the 'Movie' and 'Rating' tables on the 'mID' column. Calculate the average rating using 'avg' and retrieve the title from the 'Movie' table.\n\n",
        "predict": "SELECT AVG(stars), title FROM Movie JOIN Rating ON Movie.mID = Rating.mID WHERE year = (SELECT MIN(year) FROM Movie)"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T2.title ,  T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  >  (SELECT avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.director  =  \"James Cameron\")",
        "question": "What are the titles and directors of the movies whose star is greater than the average stars of the movies directed by James Cameron?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the average stars of the movies directed by James Cameron. Secondly, we need to filter movies based on their stars being greater than the average stars found in the first step and select their titles and directors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select average stars from table 'Rating' where director = 'James Cameron' and join it with table 'Movie' on the 'mID' column. In the second step, we need to filter movies based on their stars being greater than the average stars found in the first step and select their titles and directors from table 'Movie'.\n\n<3> SQL Generation: Use 'join' to find the average stars of the movies directed by James Cameron, and then use 'where' to filter movies based on their stars being greater than the average stars found in the first step and select their titles and directors.\n\n",
        "predict": "SELECT title, director FROM Movie WHERE stars > (SELECT AVG(stars) FROM Rating JOIN Movie ON Rating.mID = Movie.mID WHERE director = 'James Cameron')"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Sarah Martinez'",
        "question": "Find the names of all directors whose movies are rated by Sarah Martinez.",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the movies that are rated by Sarah Martinez. Secondly, we need to find the directors of those movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select mID from table 'Rating' where rID = (select rID from Reviewer where name = 'Sarah Martinez'). In the second step, we need to select director from table 'Movie' where mID is in the result of the first step.\n\n<3> SQL Generation: Use 'where' to find the rID of Sarah Martinez, and then use 'where' and 'in' to filter movies rated by her and select the directors.\n\n",
        "predict": "SELECT director FROM Movie WHERE mID IN (SELECT mID FROM Rating WHERE rID = (SELECT rID FROM Reviewer WHERE name = 'Sarah Martinez'))"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT T3.name ,  T2.title ,  T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.director  =  T3.name",
        "question": "What are the different reviewer names, movie titles, and stars for every rating where the reviewer had the same name as the director?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the ratings where the reviewer had the same name as the director. Secondly, we need to retrieve the reviewer names, movie titles, and stars for those ratings.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the tables 'Rating', 'Reviewer', and 'Movie' on the corresponding foreign keys.\n\n<3> SQL Generation: Use 'join' to combine the tables based on the foreign key relationships. Then, use 'where' to filter the rows where the reviewer name is the same as the director's name. Finally, select the reviewer name, movie title, and stars from the resulting rows.\n\n",
        "predict": "SELECT Reviewer.name, Movie.title, Rating.stars FROM Rating JOIN Reviewer ON Rating.rID = Reviewer.rID JOIN Movie ON Rating.mID = Movie.mID WHERE Reviewer.name = Movie.director"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T1.title ,  T1.director FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title ORDER BY T1.director ,  T1.title",
        "question": "For all directors who directed more than one movie, return the titles of all movies directed by them, along with the director name. Sort by director name, then movie title.",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find directors who directed more than one movie. Secondly, we need to select the titles of all movies directed by each of these directors, along with their names. Finally, we need to sort the results by director name and then movie title.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select director names from table 'Movie' and count the number of movies directed by each director. Then, we need to join the 'Movie' and 'Rating' tables on the 'mID' column to select the titles of movies directed by each director.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter directors who directed more than one movie. Then, join the 'Movie' and 'Rating' tables on the 'mID' column and select the titles of movies directed by each director. Finally, sort the results by director name and then movie title.\n\n",
        "predict": "SELECT Movie.title, Movie.director FROM Movie JOIN Rating ON Movie.mID = Rating.mID GROUP BY Movie.director HAVING COUNT(*) > 1 ORDER BY Movie.director, Movie.title"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5",
        "question": "What are the titles of all movies that have rating star is between 3 and 5?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on movies with a rating star between 3 and 5. We need to select the titles of these movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' and 'Rating' tables.\n\n<3> SQL Generation: Use 'where' to filter movies with a rating star between 3 and 5, and then select the titles of these movies.\n\n",
        "predict": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating WHERE stars BETWEEN 3 AND 5)"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5",
        "question": "What are the titles of all movies that have between 3 and 5 stars?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on movies with a rating between 3 and 5 stars. We need to select the titles of these movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' and 'Rating' tables.\n\n<3> SQL Generation: We need to join the 'Movie' and 'Rating' tables on the 'mID' column. Then, we filter the rows where the 'stars' column is between 3 and 5. Finally, we select the 'title' column from the 'Movie' table.\n\n",
        "predict": "SELECT title FROM Movie JOIN Rating ON Movie.mID = Rating.mID WHERE stars BETWEEN 3 AND 5"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT title FROM Movie WHERE director  =  \"James Cameron\" OR YEAR   <  1980",
        "question": "What are the names of all movies made before 1980 or had James Cameron as the director?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter movies made before 1980. Secondly, we need to filter movies with James Cameron as the director. Finally, we need to select the names of the movies that meet either of these conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' table for this query.\n\n<3> SQL Generation: Use 'where' to filter movies made before 1980 or with James Cameron as the director, and then select the names of the movies.\n\n",
        "predict": "SELECT title FROM Movie WHERE year < 1980 OR director = 'James Cameron'"
    },
    {
        "db_id": "county_public_safety",
        "gold": "SELECT Hispanic FROM city WHERE Black  >  10",
        "question": "What are the percentage of hispanics in cities with the black percentage higher than 10?",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter cities with a black percentage higher than 10. Secondly, we need to calculate the percentage of Hispanics in these cities.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the columns 'Name' and 'Hispanic' from table 'city' and filter by the 'Black' column.\n\n<3> SQL Generation: Use 'where' to filter cities with a black percentage higher than 10, and then calculate the percentage of Hispanics in these cities.\n\n",
        "predict": "SELECT (Hispanic / (White + Black + Amerindian + Asian + Multiracial + Hispanic)) * 100 AS percentage_hispanics FROM city WHERE Black > 10"
    },
    {
        "db_id": "county_public_safety",
        "gold": "SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population  >  20000)",
        "question": "Show the number of cities in counties that have a population more than 20000.",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on counties with a population more than 20000. Firstly, we need to identify the counties with a population more than 20000. Secondly, we need to count the number of cities in those counties.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select County_ID from table 'county_public_safety' where Population > 20000. In the second step, we need to count the number of cities from table 'city' where County_ID is in the selected County_IDs.\n\n<3> SQL Generation: Use 'where' to filter counties with a population more than 20000, and then use 'where' and 'count' to count the number of cities in those counties.\n\n",
        "predict": "SELECT COUNT(*) FROM city WHERE County_ID IN (SELECT County_ID FROM county_public_safety WHERE Population > 20000)"
    },
    {
        "db_id": "county_public_safety",
        "gold": "SELECT Name FROM county_public_safety WHERE County_ID NOT IN (SELECT County_ID FROM city)",
        "question": "List the names of counties that do not have any cities.",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding counties that do not have any cities.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of counties from the 'county_public_safety' table where there are no corresponding entries in the 'city' table.\n\n<3> SQL Generation: Use a left join to combine the 'county_public_safety' and 'city' tables on the 'County_ID' column. Then, filter the rows where the 'City_ID' is null (indicating no corresponding city entry) and select the names of the counties.\n\n",
        "predict": "SELECT Name FROM county_public_safety LEFT JOIN city ON county_public_safety.County_ID = city.County_ID WHERE city.City_ID IS NULL"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT roomName FROM Rooms WHERE basePrice  <  160 AND beds =  2 AND decor  =  'modern';",
        "question": "What are the names of modern rooms that have a base price lower than $160 and two beds.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter rooms based on their decor, base price, and number of beds. Secondly, we need to select the names of the filtered rooms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rooms' table for this query.\n\n<3> SQL Generation: Use 'where' to filter rooms with decor = 'modern', base price < $160, and beds = 2. Then, select the room names.\n\n",
        "predict": "SELECT roomName FROM Rooms WHERE decor = 'modern' AND basePrice < 160 AND beds = 2"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT roomName ,  RoomId FROM Rooms WHERE basePrice  >  160 AND maxOccupancy  >  2;",
        "question": "Find all the rooms that have a price higher than 160 and can accommodate more than 2 people. Report room names and ids.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter rooms based on their price being higher than 160 and their maximum occupancy being more than 2. Secondly, we need to select the room names and ids of the filtered rooms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rooms' table for this query.\n\n<3> SQL Generation: Use 'where' to filter rooms based on their price and maximum occupancy, and then select the room names and ids.\n\n",
        "predict": "SELECT roomName, RoomId FROM Rooms WHERE basePrice > 160 AND maxOccupancy > 2"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT Adults FROM Reservations WHERE CheckIn  =  \"2010-10-23\" AND FirstName  =  \"CONRAD\" AND LastName  =  \"SELBIG\";",
        "question": "Find the number of adults for the room reserved and checked in by CONRAD SELBIG on Oct 23, 2010.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the reservation made by CONRAD SELBIG on Oct 23, 2010. Secondly, we need to retrieve the room reserved and checked in by CONRAD SELBIG. Finally, we need to find the number of adults for that room.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the reservation code from table 'Reservations' where LastName = 'SELBIG', FirstName = 'CONRAD', and CheckIn = '2010-10-23'. In the second step, we need to retrieve the room number from table 'Reservations' based on the reservation code. In the final step, we need to find the number of adults for that room from table 'Reservations'.\n\n<3> SQL Generation: Use 'where' to find the reservation made by CONRAD SELBIG on Oct 23, 2010. Then, retrieve the room number reserved and checked in by CONRAD SELBIG. Finally, find the number of adults for that room.\n\n",
        "predict": "SELECT Adults FROM Reservations WHERE LastName = 'SELBIG' AND FirstName = 'CONRAD' AND CheckIn = '2010-10-23'"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;",
        "question": "List how many times the number of people in the room reached the maximum occupancy of the room. The number of people include adults and kids.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the total number of people (adults + kids) in each reservation. Secondly, we need to count the number of times the total number of people reached the maximum occupancy of the room.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Room' column from the 'Reservations' table and the 'maxOccupancy' column from the 'Rooms' table.\n\n<3> SQL Generation: We need to join the 'Reservations' and 'Rooms' tables on the 'Room' column. Then, we calculate the total number of people (adults + kids) in each reservation by summing the 'Adults' and 'Kids' columns. Finally, we count the number of times the total number of people reached the maximum occupancy of the room.\n\n",
        "predict": "SELECT COUNT(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room = T2.RoomId WHERE (T1.Adults + T1.Kids) = T2.maxOccupancy"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0",
        "question": "What are the first and last names of people who payed more than the rooms' base prices?",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the rooms' base prices. Secondly, we need to filter reservations based on the payment amount and retrieve the first and last names of the people who paid more.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select basePrice from table 'Rooms'. In the second step, we need to filter reservations based on the payment amount and retrieve the first and last names from table 'Reservations'.\n\n<3> SQL Generation: Use 'where' to find the rooms' base prices, and then use 'where' to filter reservations based on the payment amount and select the first and last names.\n\n",
        "predict": "SELECT FirstName, LastName FROM Reservations WHERE Rate > (SELECT basePrice FROM Rooms)"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;",
        "question": "Find the name of the room with the maximum occupancy.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: We need to find the room with the maximum occupancy. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rooms' table to find the room with the maximum occupancy.\n\n<3> SQL Generation: We can use the 'MAX' function to find the maximum occupancy and then select the room name corresponding to that occupancy.\n\n",
        "predict": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms)"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT count(*) FROM rooms WHERE roomid NOT IN (SELECT DISTINCT room FROM reservations)",
        "question": "Find the number of rooms that do not have any reservation.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: We need to find the rooms that do not have any reservation.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rooms' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Rooms' table with the 'Reservations' table, and then filter the rows where the reservation code is null (indicating no reservation). Finally, we count the number of rooms that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM Rooms LEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room WHERE Reservations.Code IS NULL"
    },
    {
        "db_id": "party_host",
        "gold": "SELECT Name FROM HOST WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host)",
        "question": "List the names of hosts who did not serve as a host of any party in our record.",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding hosts who did not serve as a host of any party in the record. Firstly, we need to identify the hosts who served as hosts in the record. Secondly, we need to filter out the hosts who did not serve as hosts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Host_ID from table 'party_host' and filter by Host_ID in table 'host'.\n\n<3> SQL Generation: Use 'where' to select Host_ID from table 'party_host' and then use 'not in' to filter out the hosts who served as hosts.\n\n",
        "predict": "SELECT Name FROM host WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host)"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT count(*) FROM storm WHERE Number_Deaths  >  0",
        "question": "How many storms had death records?",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of storms that had death records.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Storm_ID from the 'storm' table and count the number of distinct Storm_IDs in the 'affected_region' table.\n\n<3> SQL Generation: Use 'distinct' and 'count' to select the distinct Storm_IDs from the 'affected_region' table and count them.\n\n",
        "predict": "SELECT COUNT(DISTINCT Storm_ID) FROM affected_region WHERE Number_Deaths > 0"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT avg(damage_millions_USD) ,  max(damage_millions_USD) FROM storm WHERE max_speed  >  1000",
        "question": "What is the average and maximum damage in millions for storms that had a max speed over 1000?",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter storms based on their maximum speed being over 1000. Secondly, we need to calculate the average and maximum damage in millions for the selected storms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'storm' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter storms with a maximum speed over 1000, and then use 'avg' and 'max' to calculate the average and maximum damage in millions for the selected storms.\n\n",
        "predict": "SELECT AVG(Damage_millions_USD), MAX(Damage_millions_USD) FROM storm WHERE Max_speed > 1000"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT sum(number_deaths) ,  sum(damage_millions_USD) FROM storm WHERE max_speed  >  (SELECT avg(max_speed) FROM storm)",
        "question": "Return the total number of deaths and total damange in millions for storms that had a max speed greater than the average.",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average max speed of storms. Secondly, we need to filter storms based on their max speed being greater than the average. Finally, we need to calculate the total number of deaths and total damage for the filtered storms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select max_speed from table 'storm' and calculate the average. Then, we need to filter storms based on their max_speed being greater than the average and select the storm_id. Finally, we need to join the 'storm' and 'affected_region' tables on the 'Storm_ID' column and calculate the total number of deaths and total damage.\n\n<3> SQL Generation: Use 'avg' to calculate the average max speed of storms. Then, use 'where' to filter storms based on their max speed being greater than the average. Join the 'storm' and 'affected_region' tables on the 'Storm_ID' column. Finally, use 'sum' to calculate the total number of deaths and total damage.\n\n",
        "predict": "SELECT SUM(storm.Number_Deaths), SUM(storm.Damage_millions_USD) FROM storm JOIN affected_region ON storm.Storm_ID = affected_region.Storm_ID WHERE storm.Max_speed > (SELECT AVG(Max_speed) FROM storm)"
    },
    {
        "db_id": "election",
        "gold": "SELECT count(DISTINCT T2.Delegate) FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District WHERE T1.Population  >  50000",
        "question": "How many distinct delegates are from counties with population larger than 50000?",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter counties with population larger than 50000. Secondly, we need to count the distinct delegates from these counties.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select County_Id from table 'county' where Population > 50000. In the second step, we need to filter Counties_Represented from table 'election' and count the distinct delegates.\n\n<3> SQL Generation: Use 'where' to filter counties with population larger than 50000, and then use 'count(distinct)' to count the distinct delegates from these counties.\n\n",
        "predict": "SELECT COUNT(DISTINCT Delegate) FROM election WHERE District IN (SELECT County_Id FROM county WHERE Population > 50000)"
    },
    {
        "db_id": "news_report",
        "gold": "SELECT T3.Name ,  T2.Name FROM news_report AS T1 JOIN event AS T2 ON T1.Event_ID  =  T2.Event_ID JOIN journalist AS T3 ON T1.journalist_ID  =  T3.journalist_ID ORDER BY T2.Event_Attendance ASC",
        "question": "Show the names of journalists and the names of the events they reported in ascending order",
        "fields": "Table event, columns = [*,Event_ID,Date,Venue,Name,Event_Attendance]\nTable journalist, columns = [*,journalist_ID,Name,Nationality,Age,Years_working]\nTable news_report, columns = [*,journalist_ID,Event_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [news_report.Event_ID = event.Event_ID,news_report.journalist_ID = journalist.journalist_ID]\n",
        "reasoning": "<1> Decomposition: We need to retrieve the names of journalists and the names of the events they reported. Then, we need to sort the results in ascending order based on the journalist names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the journalist names from the 'journalist' table and the event names from the 'event' table. We also need to join the 'news_report' table to link the journalists and events.\n\n<3> SQL Generation: We can use a simple join query to retrieve the journalist names and the corresponding event names. Then, we can use the 'ORDER BY' clause to sort the results in ascending order based on the journalist names.\n\n",
        "predict": "SELECT journalist.Name, event.Name FROM journalist JOIN news_report ON journalist.journalist_ID = news_report.journalist_ID JOIN event ON news_report.Event_ID = event.Event_ID ORDER BY journalist.Name ASC"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major = 600;",
        "question": "Which student's age is older than 18 and is majoring in 600? List each student's first and last name.",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their age and major. Secondly, we need to select the first and last name of the selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table for this query.\n\n<3> SQL Generation: Use 'where' to filter students based on their age and major, and then select the first and last name of the selected students.\n\n",
        "predict": "SELECT Fname, LName FROM Student WHERE Age > 18 AND Major = 600"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major != 600 AND Sex = 'F';",
        "question": "List all female students age is older than 18 who is not majoring in 600. List students' first name and last name.",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their gender, age, and major. Secondly, we need to select the first name and last name of the filtered students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select LName and Fname from table 'Student' and filter by Sex, Age, and Major.\n\n<3> SQL Generation: Use 'where' to filter students based on their gender, age, and major, and then select their first name and last name.\n\n",
        "predict": "SELECT Fname, Lname FROM Student WHERE Sex = 'F' AND Age > 18 AND Major != 600"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT sum(Spent) FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\";",
        "question": "How long does student Linda Smith spend on the restaurant in total?",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: We need to calculate the total time spent by student Linda Smith in the restaurant.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the time column from the Visits_Restaurant table and filter by the StuID of Linda Smith.\n\n<3> SQL Generation: Use 'where' to filter the rows where StuID is Linda Smith's ID, and then use 'sum' to calculate the total time spent.\n\n",
        "predict": "SELECT SUM(Time) FROM Visits_Restaurant WHERE StuID = (SELECT StuID FROM Student WHERE LName = 'Smith' AND Fname = 'Linda')"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT count(*) FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "question": "How many times has the student Linda Smith visited Subway?",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name 'Linda Smith'. Secondly, we need to find the restaurant with the name 'Subway'. Finally, we need to count the number of times Linda Smith has visited Subway.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to select ResID from table 'Restaurant' where ResName = 'Subway'. In the final step, we need to count the number of rows in table 'Visits_Restaurant' where StuID matches Linda Smith's StuID and ResID matches Subway's ResID.\n\n<3> SQL Generation: Use 'where' to find the StuID of Linda Smith and the ResID of Subway, and then use 'where' to filter rows in 'Visits_Restaurant' where StuID matches Linda Smith's StuID and ResID matches Subway's ResID. Finally, count the number of rows that meet these conditions.\n\n",
        "predict": "SELECT COUNT(*) FROM Visits_Restaurant WHERE StuID = (SELECT StuID FROM Student WHERE LName = 'Smith' AND Fname = 'Linda') AND ResID = (SELECT ResID FROM Restaurant WHERE ResName = 'Subway')"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT TIME FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "question": "When did Linda Smith visit Subway?",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the StuID of Linda Smith from table 'Student'. Secondly, we need to find the Time when Linda Smith visited Subway from table 'Visits_Restaurant'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to select Time from table 'Visits_Restaurant' where StuID is the StuID found in the first step and ResID is the ResID of Subway.\n\n<3> SQL Generation: Use 'where' to find the StuID of Linda Smith from table 'Student', and then use 'where' to find the Time when Linda Smith visited Subway from table 'Visits_Restaurant'.\n\n",
        "predict": "SELECT Time FROM Visits_Restaurant WHERE StuID = (SELECT StuID FROM Student WHERE LName = 'Smith' AND Fname = 'Linda') AND ResID = (SELECT ResID FROM Restaurant WHERE ResName = 'Subway')"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT DISTINCT t3.name FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t1.fname  =  \"Matthias\" AND t1.lname  =  \"Blume\"",
        "question": "What is the name of the institution that \"Matthias Blume\" belongs to?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the authID of \"Matthias Blume\" in table 'Authors'. Secondly, we need to find the instID associated with the authID in table 'Authorship'. Finally, we need to find the name of the institution associated with the instID in table 'Inst'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select authID from table 'Authors' where lname = 'Blume' and fname = 'Matthias'. In the second step, we need to select instID from table 'Authorship' where authID matches the value found in the first step. In the final step, we need to select name from table 'Inst' where instID matches the value found in the second step.\n\n<3> SQL Generation: Use 'where' to find the authID of \"Matthias Blume\" in table 'Authors', then use 'where' to find the instID associated with the authID in table 'Authorship', and finally use 'where' to find the name of the institution associated with the instID in table 'Inst'.\n\n",
        "predict": "SELECT name FROM Inst WHERE instID = (SELECT instID FROM Authorship WHERE authID = (SELECT authID FROM Authors WHERE lname = 'Blume' AND fname = 'Matthias'))"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT count(DISTINCT t1.title) FROM papers AS t1 JOIN authorship AS t2 ON t1.paperid  =  t2.paperid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"University of Pennsylvania\"",
        "question": "How many papers are written by authors from the institution \"University of Pennsylvania\"?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the institution with the name \"University of Pennsylvania\". Secondly, we need to filter authorship records based on the institution and count the number of papers written by those authors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select instID from table 'Inst' where name = \"University of Pennsylvania\". In the second step, we need to filter authID from table 'Authorship' based on the instID found in the first step and count the number of distinct paperIDs.\n\n<3> SQL Generation: Use 'where' to find the institution with the name \"University of Pennsylvania\", and then use 'where' to filter authorship records based on the institution and count the number of distinct paperIDs.\n\n",
        "predict": "SELECT COUNT(DISTINCT paperID) FROM Authorship WHERE instID = (SELECT instID FROM Inst WHERE name = \"University of Pennsylvania\")"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid JOIN inst AS t4 ON t2.instid  =  t4.instid WHERE t4.country  =  \"USA\" AND t2.authorder  =  2 AND t1.lname  =  \"Turon\"",
        "question": "Which paper is published in an institution in \"USA\" and have \"Turon\" as its second author?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the institution with the country \"USA\". Secondly, we need to find the paper with \"Turon\" as its second author.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select instID from table 'Inst' where country = \"USA\". In the second step, we need to find the paperID from table 'Authorship' where authOrder = 2 and authID corresponds to \"Turon\".\n\n<3> SQL Generation: Use 'where' to find the institution with the country \"USA\", and then use 'join' to connect the tables 'Authorship', 'Authors', and 'Papers' based on the foreign key relationships. Finally, use 'where' to filter the rows where authOrder = 2 and the author's name is \"Turon\".\n\n",
        "predict": "SELECT Papers.title FROM Papers JOIN Authorship ON Papers.paperID = Authorship.paperID JOIN Authors ON Authorship.authID = Authors.authID JOIN Inst ON Authorship.instID = Inst.instID WHERE Inst.country = \"USA\" AND Authors.lname = \"Turon\" AND Authorship.authOrder = 2"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT count(*) FROM customer WHERE active = '1'",
        "question": "How many customers have an active value of 1?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of customers with an active value of 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'customer' table and the 'active' column.\n\n<3> SQL Generation: Use 'where' to filter customers with an active value of 1 and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM customer WHERE active = 1"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name ,  acc_bal FROM customer WHERE cust_name LIKE '%a%'",
        "question": "Find the name and account balance of the customer whose name includes the letter ‘a’.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter customers whose name includes the letter 'a'. Secondly, we need to select the name and account balance of the filtered customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'customer' table, we only need to consider this table.\n\n<3> SQL Generation: Use 'where' to filter customers whose name includes the letter 'a', and then select the name and account balance of the filtered customers.\n\n",
        "predict": "SELECT cust_name, acc_bal FROM customer WHERE cust_name LIKE '%a%'"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1",
        "question": "What is the name of the customer with the worst credit score?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: We need to find the customer with the worst credit score.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the cust_name from the customer table.\n\n<3> SQL Generation: We can use the MIN function to find the minimum credit score and then select the cust_name of the customer with that score.\n\n",
        "predict": "SELECT cust_name FROM customer WHERE credit_score = (SELECT MIN(credit_score) FROM customer)"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE amount  >  3000",
        "question": "What are the names of customers who have a loan of more than 3000 in amount?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on loans with an amount greater than 3000. We need to identify the customers who have these loans and retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of customers from the 'customer' table who have loans with an amount greater than 3000 from the 'loan' table.\n\n<3> SQL Generation: Use 'where' to filter loans with an amount greater than 3000, join the 'customer' and 'loan' tables on the 'cust_ID' column, and select the names of the customers.\n\n",
        "predict": "SELECT cust_name FROM customer JOIN loan ON customer.cust_ID = loan.cust_ID WHERE loan.amount > 3000"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "question": "Find the average credit score of the customers who do not have any loan.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customers who do not have any loan. Secondly, we need to calculate the average credit score of those customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select cust_ID from table 'loan' and filter by cust_ID. In the second step, we need to select credit_score from table 'customer' and filter by cust_ID.\n\n<3> SQL Generation: Use 'where' to filter customers who do not have any loan, and then use 'avg' to calculate the average credit score of those customers.\n\n",
        "predict": "SELECT AVG(credit_score) FROM customer WHERE cust_ID NOT IN (SELECT cust_ID FROM loan)"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "question": "What is the average credit score for customers who have never taken a loan?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify customers who have never taken a loan. Secondly, we need to calculate the average credit score for these customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select cust_ID from table 'customer' where no_of_loans = 0, and then calculate the average credit score for these customers.\n\n<3> SQL Generation: Use 'where' to filter customers who have never taken a loan, and then use 'avg' to calculate the average credit score for these customers.\n\n",
        "predict": "SELECT AVG(credit_score) FROM customer WHERE no_of_loans = 0"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT count(*) FROM STUDENTS WHERE student_id NOT IN ( SELECT student_id FROM Behavior_Incident )",
        "question": "How many students are not involved in any behavior incident?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who are involved in behavior incidents. Secondly, we need to count the number of students who are not involved in any behavior incident.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from table 'Behavior_Incident'.\n\n<3> SQL Generation: Use 'where' to select student_id from table 'Behavior_Incident', and then use 'not in' to filter students who are not involved in any behavior incident and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Behavior_Incident)"
    },
    {
        "db_id": "assets_maintenance",
        "gold": "SELECT first_name ,  last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits)",
        "question": "Which engineers have never visited to maintain the assets? List the engineer first name and last name.",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the engineers who have visited to maintain the assets. Secondly, we need to filter out the engineers who have never visited and list their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select engineer_id from table 'Engineer_Visits' and engineer_id from table 'Maintenance_Engineers'.\n\n<3> SQL Generation: Use 'where' to find the engineers who have visited to maintain the assets, and then use 'not in' to filter out the engineers who have never visited. Finally, select their first name and last name.\n\n",
        "predict": "SELECT first_name, last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits)"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  \"ACCT-211\"",
        "question": "How many professors teach a class with the code ACCT-211?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the class with the code ACCT-211. Secondly, we need to find the professors who teach that class and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CLASS_CODE from table 'CLASS' where CRS_CODE = 'ACCT-211'. In the second step, we need to filter PROF_NUM from table 'CLASS'.\n\n<3> SQL Generation: Use 'where' to find the class with the code ACCT-211, and then use 'where' to filter professors who teach that class and count them.\n\n",
        "predict": "SELECT COUNT(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE = 'ACCT-211'"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'",
        "question": "How many classes does the professor whose last name is Graztevski teach?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the professor with the last name 'Graztevski'. Secondly, we need to count the number of classes taught by this professor.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select EMP_NUM from table 'EMPLOYEE' where EMP_LNAME = 'Graztevski'. In the second step, we need to count CLASS_CODE from table 'CLASS' where PROF_NUM is the value found in the first step.\n\n<3> SQL Generation: Use 'where' to find the professor with the last name 'Graztevski', and then use 'where' to count the number of classes taught by this professor.\n\n",
        "predict": "SELECT COUNT(*) FROM CLASS WHERE PROF_NUM = (SELECT EMP_NUM FROM EMPLOYEE WHERE EMP_LNAME = 'Graztevski')"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'",
        "question": "How many different locations does the school with code BUS has?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the department with code 'BUS'. Secondly, we need to count the number of different locations associated with this department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select DEPT_CODE from table 'DEPARTMENT' where DEPT_CODE = 'BUS'. In the second step, we need to count the distinct DEPT_ADDRESS from table 'DEPARTMENT' where DEPT_CODE = 'BUS'.\n\n<3> SQL Generation: Use 'where' to find the department with code 'BUS', and then use 'count' and 'distinct' to count the number of different locations associated with this department.\n\n",
        "predict": "SELECT COUNT(DISTINCT DEPT_ADDRESS) FROM DEPARTMENT WHERE DEPT_CODE = 'BUS'"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "question": "How many courses are offered by the Computer Info. Systems department?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the department with the department name 'Computer Info. Systems'. Secondly, we need to count the number of courses offered by that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for courses offered by the 'Computer Info. Systems' department, we need to select courses from the 'COURSE' table where the department code matches the department code of the 'Computer Info. Systems' department.\n\n<3> SQL Generation: Use 'where' to filter the courses with the department code of the 'Computer Info. Systems' department, and then use 'count' to calculate the number of courses.\n\n",
        "predict": "SELECT COUNT(*) FROM COURSE WHERE DEPT_CODE = (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Computer Info. Systems')"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "question": "How many courses does the department of Computer Information Systmes offer?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the department code for the department of Computer Information Systems. Secondly, we need to count the number of courses offered by that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select DEPT_CODE from table 'DEPARTMENT' where DEPT_NAME = 'Computer Information Systems'. In the second step, we need to count the number of courses from table 'COURSE' where DEPT_CODE matches the department code found in the first step.\n\n<3> SQL Generation: Use 'where' to find the department code for the department of Computer Information Systems, and then use 'where' to count the number of courses offered by that department.\n\n",
        "predict": "SELECT COUNT(*) FROM COURSE WHERE DEPT_CODE = (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Computer Information Systems')"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'",
        "question": "How many students enrolled in class ACCT-211?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the class code for class ACCT-211. Secondly, we need to count the number of students enrolled in that class.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CLASS_CODE from table 'COURSE' where CRS_DESCRIPTION = 'ACCT-211'. In the second step, we need to count the number of rows in table 'ENROLL' where CLASS_CODE is the value found in the first step.\n\n<3> SQL Generation: Use 'where' to find the class code for class ACCT-211, and then use 'count' to count the number of rows in table 'ENROLL' where CLASS_CODE is the value found in the first step.\n\n",
        "predict": "SELECT COUNT(*) FROM ENROLL WHERE CLASS_CODE = (SELECT CRS_CODE FROM COURSE WHERE CRS_DESCRIPTION = 'ACCT-211')"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'",
        "question": "What are the first names of all students who took ACCT-211 and received a C?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students who took ACCT-211. Secondly, we need to filter students who received a grade of C. Finally, we need to select the first names of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select STU_NUM from table 'ENROLL' where CLASS_CODE = 'ACCT-211' and ENROLL_GRADE = 'C'. Then, we need to select STU_FNAME from table 'STUDENT' where STU_NUM matches the selected STU_NUM.\n\n<3> SQL Generation: Use 'where' to filter students who took ACCT-211 and received a grade of C, and then select their first names.\n\n",
        "predict": "SELECT STU_FNAME FROM STUDENT WHERE STU_NUM IN (SELECT STU_NUM FROM ENROLL WHERE CLASS_CODE = 'ACCT-211' AND ENROLL_GRADE = 'C')"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.'",
        "question": "How many professors do have a Ph.D. degree?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: We need to filter professors who have a Ph.D. degree.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select professors with a Ph.D. degree from the 'PROFESSOR' table.\n\n<3> SQL Generation: Use 'where' to filter professors with a Ph.D. degree and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM professor WHERE prof_high_degree = 'Ph.D.'"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code WHERE T4.dept_name  =  'Accounting'",
        "question": "How many students are enrolled in some classes that are taught by an accounting professor?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the accounting professor's employee number. Secondly, we need to find the classes taught by the accounting professor. Finally, we need to count the number of students enrolled in those classes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select EMP_NUM from table 'EMPLOYEE' where DEPT_CODE = 'accounting'. In the second step, we need to select CLASS_CODE from table 'CLASS' where PROF_NUM matches the EMP_NUM found in the first step. In the final step, we need to count the number of students in table 'ENROLL' where CLASS_CODE matches the CLASS_CODE found in the second step.\n\n<3> SQL Generation: Use 'where' to find the accounting professor's employee number, then use 'where' to find the classes taught by the accounting professor, and finally use 'count' to count the number of students enrolled in those classes.\n\n",
        "predict": "SELECT COUNT(*) FROM ENROLL WHERE CLASS_CODE IN (SELECT CLASS_CODE FROM CLASS WHERE PROF_NUM = (SELECT EMP_NUM FROM EMPLOYEE WHERE DEPT_CODE = 'accounting'))"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T2.dept_name  =  'Accounting' OR T2.dept_name  =  'Biology'",
        "question": "How many professors who are from either Accounting or Biology department?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter professors who are from either the Accounting or Biology department. Secondly, we need to count the number of selected professors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select professors from the 'PROFESSOR' table and filter them based on their department.\n\n<3> SQL Generation: Use 'where' to filter professors who are from either the Accounting or Biology department, and then use 'count' to count the number of selected professors.\n\n",
        "predict": "SELECT COUNT(*) FROM professor WHERE dept_code = 'Accounting' OR dept_code = 'Biology'"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT stu_fname ,  stu_gpa FROM student WHERE stu_gpa  <  (SELECT avg(stu_gpa) FROM student)",
        "question": "Find the first name and gpa of the students whose gpa is lower than the average gpa of all students.",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average gpa of all students. Secondly, we need to filter students whose gpa is lower than the average gpa and select their first name and gpa.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select gpa from table 'STUDENT' and calculate the average. Then, we need to filter gpa, first name from table 'STUDENT'.\n\n<3> SQL Generation: Use 'select avg(gpa)' to calculate the average gpa of all students. Then, use 'where' to filter students whose gpa is lower than the average gpa and select their first name and gpa.\n\n",
        "predict": "SELECT STU_FNAME, STU_GPA FROM STUDENT WHERE STU_GPA < (SELECT AVG(STU_GPA) FROM STUDENT)"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'",
        "question": "Find the name of department that offers the class whose description has the word \"Statistics\".",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the class with the description containing the word \"Statistics\". Secondly, we need to find the department that offers this class.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CRS_CODE from table 'COURSE' where CRS_DESCRIPTION contains the word \"Statistics\". In the second step, we need to select DEPT_NAME from table 'DEPARTMENT' where DEPT_CODE matches the DEPT_CODE of the selected class.\n\n<3> SQL Generation: Use 'where' to find the class with the description containing the word \"Statistics\", and then use 'where' to find the department that offers this class.\n\n",
        "predict": "SELECT DEPT_NAME FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM COURSE WHERE CRS_DESCRIPTION LIKE '%Statistics%')"
    },
    {
        "db_id": "sports_competition",
        "gold": "SELECT name FROM CLub WHERE Club_ID NOT IN (SELECT Club_ID FROM player)",
        "question": "List the names of clubs that do not have any players.",
        "fields": "Table club, columns = [*,Club_ID,name,Region,Start_year]\nTable club_rank, columns = [*,Rank,Club_ID,Gold,Silver,Bronze,Total]\nTable competition, columns = [*,Competition_ID,Year,Competition_type,Country]\nTable competition_result, columns = [*,Competition_ID,Club_ID_1,Club_ID_2,Score]\nTable player, columns = [*,Player_ID,name,Position,Club_ID,Apps,Tries,Goals,Points]\n",
        "foreign_keys": "Foreign_keys = [club_rank.Club_ID = club.Club_ID,player.Club_ID = club.Club_ID,competition_result.Competition_ID = competition.Competition_ID,competition_result.Club_ID_2 = club.Club_ID,competition_result.Club_ID_1 = club.Club_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding clubs that do not have any players. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of clubs from the 'club' table that do not have any corresponding entries in the 'player' table.\n\n<3> SQL Generation: We can use a left join to combine the 'club' and 'player' tables on the 'Club_ID' column. Then, we can filter the rows where the 'Player_ID' is null, indicating that there are no players associated with that club. Finally, we can select the names of the clubs.\n\n",
        "predict": "SELECT name FROM club LEFT JOIN player ON club.Club_ID = player.Club_ID WHERE player.Player_ID IS NULL"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != \"null\" OR  department_id != 40",
        "question": "display all the information of employees whose salary is in the range of 8000 and 12000 and commission is not null or department number does not equal to 40.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter employees based on their salary range and commission. Secondly, we need to filter employees based on their department number.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select all columns from table 'employees' and filter based on salary and commission. We also need to filter based on department number from table 'departments'.\n\n<3> SQL Generation: Use 'where' to filter employees based on their salary range and commission, and use 'or' to filter employees based on their department number.\n\n",
        "predict": "SELECT * FROM employees WHERE (salary >= 8000 AND salary <= 12000 AND commission_pct IS NOT NULL) OR department_id != 40"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT salary ,  manager_id FROM employees WHERE manager_id != \"null\"",
        "question": "What are the salaries and manager ids for employees who have managers?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: The query requires retrieving salaries and manager ids for employees who have managers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select salaries and manager ids from the 'employees' table.\n\n<3> SQL Generation: Use 'where' to filter employees who have managers and select their salaries and manager ids.\n\n",
        "predict": "SELECT salary, manager_id FROM employees WHERE manager_id IS NOT NULL"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT job_title FROM jobs WHERE min_salary  >  9000",
        "question": "Which job titles correspond to jobs with salaries over 9000?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find jobs with salaries over 9000. Secondly, we need to find the corresponding job titles for those jobs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select job_id from table 'jobs' where salary > 9000. In the second step, we need to select job_title from table 'jobs' based on the job_ids found in the first step.\n\n<3> SQL Generation: Use 'where' to find jobs with salaries over 9000, and then use 'where' to select the corresponding job titles.\n\n",
        "predict": "SELECT job_title FROM jobs WHERE job_id IN (SELECT job_id FROM jobs WHERE salary > 9000)"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000",
        "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter employees who are presently earning a salary on and above 12000. Secondly, we need to find the jobs done by these employees. Finally, we need to return all detailed info of these jobs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select job_id from table 'employees' where salary >= 12000. Then, we need to filter job_id from table 'jobs' and return all detailed info.\n\n<3> SQL Generation: Use 'where' to filter employees who are presently earning a salary on and above 12000, and then use 'where' to filter jobs done by these employees and return all detailed info.\n\n",
        "predict": "SELECT * FROM jobs WHERE job_id IN (SELECT job_id FROM employees WHERE salary >= 12000)"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000",
        "question": "What is all the job history info done by employees earning a salary greater than or equal to 12000?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter employees based on their salary being greater than or equal to 12000. Secondly, we need to retrieve the job history information for these employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select job history information from table 'job_history' and filter employees based on their salary from table 'employees'.\n\n<3> SQL Generation: Use 'where' to filter employees with salary greater than or equal to 12000, and then join the 'job_history' table on the 'EMPLOYEE_ID' column to retrieve the job history information for these employees.\n\n",
        "predict": "SELECT * FROM job_history JOIN employees ON job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID WHERE employees.SALARY >= 12000"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)",
        "question": "Find the employee id for all employees who earn more than the average salary.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average salary. Secondly, we need to filter employees based on their salary being higher than the average salary.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'employees' table for this query, we don't need to consider any foreign key relationships.\n\n<3> SQL Generation: Use 'select' to calculate the average salary from the 'employees' table. Then, use 'where' to filter employees whose salary is higher than the average salary.\n\n",
        "predict": "SELECT EMPLOYEE_ID FROM employees WHERE SALARY > (SELECT AVG(SALARY) FROM employees)"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)",
        "question": "What are the ids for employees who do not work in departments with managers that have ids between 100 and 200?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the departments with managers that have ids between 100 and 200. Secondly, we need to filter employees who do not work in those departments and select their ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select department_id from table 'departments' where manager_id is between 100 and 200. In the second step, we need to filter employee_id from table 'employees' and exclude the employees who work in the departments found in the first step.\n\n<3> SQL Generation: Use 'where' to find the departments with managers that have ids between 100 and 200, and then use 'where' to filter employees who do not work in those departments and select their ids.\n\n",
        "predict": "SELECT employee_id FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  \"Clara\") AND first_name != \"Clara\"",
        "question": "display the employee name ( first name and last name ) and hire date for all employees in the same department as Clara excluding Clara.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the department ID of Clara. Secondly, we need to filter employees based on their department ID and exclude Clara.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select DEPARTMENT_ID from table 'employees' where FIRST_NAME = 'Clara' and LAST_NAME = 'Clara'. In the second step, we need to select FIRST_NAME, LAST_NAME, and HIRE_DATE from table 'employees' where DEPARTMENT_ID is the same as the department ID of Clara.\n\n<3> SQL Generation: Use 'where' to find the department ID of Clara, and then use 'where' to filter employees based on their department ID and exclude Clara.\n\n",
        "predict": "SELECT FIRST_NAME, LAST_NAME, HIRE_DATE FROM employees WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID FROM employees WHERE FIRST_NAME = 'Clara' AND LAST_NAME = 'Clara') AND (FIRST_NAME != 'Clara' OR LAST_NAME != 'Clara')"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "question": "display all the information of those employees who did not have any job in the past.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find employees who did not have any job in the past. Secondly, we need to display all the information of those employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select employee_id from table 'job_history'. In the second step, we need to select all columns from table 'employees'.\n\n<3> SQL Generation: Use 'not in' to find employees who did not have any job in the past, and then select all columns from table 'employees'.\n\n",
        "predict": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "question": "What is all the information about employees who have never had a job in the past?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find employees who have never had a job in the past. Secondly, we need to retrieve all the information about those employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select all columns from table 'employees' and filter by employees who do not have any records in table 'job_history'.\n\n<3> SQL Generation: Use 'where' to filter employees who do not have any records in table 'job_history' and select all columns from table 'employees'.\n\n",
        "predict": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT DISTINCT T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.resolution  <  800",
        "question": "What are the file sizes and formats for all songs with a resolution lower than 800?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter songs based on their resolution being lower than 800. Secondly, we need to select the file sizes and formats for the filtered songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select file_size and formats from table 'files' for the filtered songs.\n\n<3> SQL Generation: Use 'where' to filter songs with resolution lower than 800, and then select file_size and formats from table 'files' for the filtered songs.\n\n",
        "predict": "SELECT file_size, formats FROM files WHERE f_id IN (SELECT f_id FROM song WHERE resolution < 800)"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT count(*) FROM artist WHERE country  =  \"Bangladesh\"",
        "question": "How many Bangladeshi artists are listed?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: We need to filter artists based on their country being Bangladesh.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'artist' table.\n\n<3> SQL Generation: Use 'where' to filter artists with country = 'Bangladesh' and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM artist WHERE country = 'Bangladesh'"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  \"Female\" AND T2.languages  =  \"bangla\"",
        "question": "What is the country of origin of the artist who is female and produced a song in Bangla?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter artists based on their gender and the language of the song they produced. Secondly, we need to find the country of origin for the selected artist.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select artist_name from table 'artist' where gender = 'female'. In the second step, we need to filter artist_name from table 'song' where language = 'Bangla' and find the corresponding country of origin from table 'artist'.\n\n<3> SQL Generation: Use 'where' to filter artists based on their gender, and then use 'where' to filter songs based on the language and select the corresponding artist's country of origin.\n\n",
        "predict": "SELECT country FROM artist WHERE artist_name IN (SELECT artist_name FROM song WHERE language = 'Bangla' AND artist_name IN (SELECT artist_name FROM artist WHERE gender = 'female'))"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  \"Female\" AND T2.languages  =  \"bangla\"",
        "question": "What countries are the female artists who sung in the language Bangla from?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter female artists who sung in the language Bangla. Secondly, we need to find the countries of these artists.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select country from table 'artist' where gender = 'female' and artist_name exists in table 'song' where language = 'Bangla'.\n\n<3> SQL Generation: Use 'where' to filter female artists who sung in the language Bangla, and then select the corresponding countries.\n\n",
        "predict": "SELECT DISTINCT country FROM artist WHERE gender = 'female' AND artist_name IN (SELECT artist_name FROM song WHERE language = 'Bangla')"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  \"english\")",
        "question": "What are the different names for all songs that have a higher resolution than English songs?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the songs with a higher resolution than English songs. Secondly, we need to retrieve the different names of these songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select song_name from table 'song' where resolution is higher than English songs.\n\n<3> SQL Generation: Use 'where' to find the songs with a higher resolution than English songs, and then use 'distinct' to retrieve the different names of these songs.\n\n",
        "predict": "SELECT DISTINCT song_name FROM song WHERE resolution > (SELECT resolution FROM song WHERE languages = 'English')"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT g_name ,  rating FROM genre ORDER BY g_name",
        "question": "List the names of all genres in alphabetical oder, together with its ratings.",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: We need to select the names and ratings of all genres.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'genre' table.\n\n<3> SQL Generation: We can directly select the 'g_name' and 'rating' columns from the 'genre' table and order them by 'g_name' in alphabetical order.\n\n",
        "predict": "SELECT g_name, rating FROM genre ORDER BY g_name ASC"
    },
    {
        "db_id": "baseball_1",
        "gold": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000",
        "question": "How many players were in the team Boston Red Stockings in 2000?",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of players in the team 'Boston Red Stockings' in the year 2000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the player_id from the table 'team' where the team_id is 'Boston Red Stockings' and the year is 2000.\n\n<3> SQL Generation: Use 'where' to filter the rows where the team_id is 'Boston Red Stockings' and the year is 2000, and then count the number of player_ids.\n\n",
        "predict": "SELECT COUNT(*) FROM team WHERE team_id = 'Boston Red Stockings' AND year = 2000"
    },
    {
        "db_id": "baseball_1",
        "gold": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000",
        "question": "How many players did Boston Red Stockings have in 2000?",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the team_id of Boston Red Stockings in table 'team' based on the team name and year. Secondly, we need to count the number of players with the corresponding team_id in table 'player'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select team_id from table 'team' where team_name = 'Boston Red Stockings' and year = 2000. In the second step, we need to count the number of players with the corresponding team_id in table 'player'.\n\n<3> SQL Generation: Use 'where' to find the team_id of Boston Red Stockings in table 'team' based on the team name and year, and then use 'where' to count the number of players with the corresponding team_id in table 'player'.\n\n",
        "predict": "SELECT COUNT(*) FROM player WHERE player_id IN (SELECT player_id FROM team WHERE team_name = 'Boston Red Stockings' AND year = 2000)"
    },
    {
        "db_id": "baseball_1",
        "gold": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';",
        "question": "How many games were played in park \"Columbia Park\" in 1907?",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the park_id of \"Columbia Park\". Secondly, we need to filter games based on the park_id and the year 1907. Finally, we count the number of games played in \"Columbia Park\" in 1907.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select park_id from table 'park' where park_name = \"Columbia Park\". In the second step, we need to filter games from table 'home_game' based on park_id and year.\n\n<3> SQL Generation: Use 'where' to find the park_id of \"Columbia Park\", and then use 'where' to filter games based on the park_id and the year 1907. Finally, count the number of games.\n\n",
        "predict": "SELECT COUNT(*) FROM home_game WHERE park_id = (SELECT park_id FROM park WHERE park_name = \"Columbia Park\") AND year = 1907"
    },
    {
        "db_id": "baseball_1",
        "gold": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';",
        "question": "How many games were played in city Atlanta in 2000?",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of games played in Atlanta in the year 2000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the games played in Atlanta in the year 2000, so we need to use the 'team' and 'home_game' tables.\n\n<3> SQL Generation: Use 'where' to filter games played in Atlanta in the year 2000 and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM home_game JOIN team ON home_game.team_id = team.team_id WHERE team.city = 'Atlanta' AND home_game.year = 2000"
    },
    {
        "db_id": "baseball_1",
        "gold": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;",
        "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter the team with the name 'Boston Red Stockings' from table 'team'. Secondly, we need to filter the home games of the selected team from table 'home_game'. Finally, we need to calculate the total attendance of the filtered home games.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select team_id from table 'team' where name = 'Boston Red Stockings'. In the second step, we need to filter attendance from table 'home_game' where team_id matches the selected team_id.\n\n<3> SQL Generation: Use 'where' to filter the team with the name 'Boston Red Stockings' from table 'team'. Then, use 'where' to filter the home games of the selected team from table 'home_game'. Finally, use 'sum' to calculate the total attendance of the filtered home games.\n\n",
        "predict": "SELECT SUM(attendance) FROM home_game WHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings') AND year BETWEEN 2000 AND 2010"
    },
    {
        "db_id": "baseball_1",
        "gold": "SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;",
        "question": "Compute the total salary that the player with first name Len and last name Barker received between 1985 to 1990.",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the player with first name Len and last name Barker. Secondly, we need to filter the salary of the player between 1985 to 1990 and compute the total.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select player_id from table 'player' where name_first = 'Len' and name_last = 'Barker'. In the second step, we need to filter salary from table 'salary' where player_id matches the player found in the first step and the year is between 1985 to 1990.\n\n<3> SQL Generation: Use 'where' to find the player with first name Len and last name Barker, and then use 'where' to filter the salary of the player between 1985 to 1990. Finally, compute the total salary.\n\n",
        "predict": "SELECT SUM(salary) FROM salary WHERE player_id = (SELECT player_id FROM player WHERE name_first = 'Len' AND name_last = 'Barker') AND year BETWEEN 1985 AND 1990"
    },
    {
        "db_id": "mountain_photos",
        "gold": "SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos )",
        "question": "How many camera lenses are not used in taking any photos?",
        "fields": "Table camera_lens, columns = [*,id,brand,name,focal_length_mm,max_aperture]\nTable mountain, columns = [*,id,name,Height,Prominence,Range,Country]\nTable photos, columns = [*,id,camera_lens_id,mountain_id,color,name]\n",
        "foreign_keys": "Foreign_keys = [photos.mountain_id = mountain.id,photos.camera_lens_id = camera_lens.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the camera lenses that are not used in taking any photos. Secondly, we need to count the number of camera lenses found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'camera_lens' that do not have a corresponding entry in the 'camera_lens_id' column of table 'photos'. \n\n<3> SQL Generation: Use 'where' and 'not in' to find the camera lenses that are not used in taking any photos, and then use 'count' to count the number of camera lenses found.\n\n",
        "predict": "SELECT COUNT(*) FROM camera_lens WHERE id NOT IN (SELECT camera_lens_id FROM photos)"
    },
    {
        "db_id": "mountain_photos",
        "gold": "SELECT count(DISTINCT T2.camera_lens_id) FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.country  =  'Ethiopia'",
        "question": "How many distinct kinds of camera lenses are used to take photos of mountains in the country 'Ethiopia'?",
        "fields": "Table camera_lens, columns = [*,id,brand,name,focal_length_mm,max_aperture]\nTable mountain, columns = [*,id,name,Height,Prominence,Range,Country]\nTable photos, columns = [*,id,camera_lens_id,mountain_id,color,name]\n",
        "foreign_keys": "Foreign_keys = [photos.mountain_id = mountain.id,photos.camera_lens_id = camera_lens.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter mountains based on the country 'Ethiopia'. Secondly, we need to find the distinct camera lenses used to take photos of these mountains and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'mountain' where country = 'Ethiopia'. In the second step, we need to join table 'photos' and 'camera_lens' on the 'mountain_id' and 'camera_lens_id' columns, and then select distinct camera_lens_id.\n\n<3> SQL Generation: Use 'where' to filter mountains in Ethiopia, join 'photos' and 'camera_lens' tables on the corresponding columns, select distinct camera_lens_id, and count them.\n\n",
        "predict": "SELECT COUNT(DISTINCT camera_lens_id) FROM photos JOIN camera_lens ON photos.camera_lens_id = camera_lens.id WHERE photos.mountain_id IN (SELECT id FROM mountain WHERE country = 'Ethiopia')"
    },
    {
        "db_id": "program_share",
        "gold": "SELECT name FROM program WHERE origin != 'Beijing'",
        "question": "Which programs' origins are not \"Beijing\"? Give me the program names.",
        "fields": "Table broadcast, columns = [*,Channel_ID,Program_ID,Time_of_day]\nTable broadcast_share, columns = [*,Channel_ID,Program_ID,Date,Share_in_percent]\nTable channel, columns = [*,Channel_ID,Name,Owner,Share_in_percent,Rating_in_percent]\nTable program, columns = [*,Program_ID,Name,Origin,Launch,Owner]\n",
        "foreign_keys": "Foreign_keys = [broadcast.Program_ID = program.Program_ID,broadcast.Channel_ID = channel.Channel_ID,broadcast_share.Program_ID = program.Program_ID,broadcast_share.Channel_ID = channel.Channel_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on programs whose origins are not \"Beijing\". We need to select the program names that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'program' table for this query.\n\n<3> SQL Generation: Use 'where' to filter programs whose origins are not \"Beijing\" and select the program names.\n\n",
        "predict": "SELECT Name FROM program WHERE Origin != 'Beijing'"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name =  \"Cathrine\"",
        "question": "Return the addresses of the course authors or tutors whose personal name is \"Cathrine\".",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the personal name column in the Course_Authors_and_Tutors table. We need to select the addresses of the course authors or tutors whose personal name is \"Cathrine\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the Course_Authors_and_Tutors table.\n\n<3> SQL Generation: Use 'where' to filter the rows where the personal name is \"Cathrine\" and select the corresponding addresses.\n\n",
        "predict": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name = 'Cathrine'"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT count(*) FROM Student_Tests_Taken WHERE test_result  =  \"Fail\"",
        "question": "How many tests have result \"Fail\"?",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of tests with a result of \"Fail\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the test_result column from the Student_Tests_Taken table.\n\n<3> SQL Generation: Use 'where' to filter tests with a result of \"Fail\" and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Student_Tests_Taken WHERE test_result = 'Fail'"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.login_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  \"advanced database\"",
        "question": "Find the login name of the course author that teaches the course with name \"advanced database\".",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the course_id of the course with name \"advanced database\". Secondly, we need to find the author_id of the course author that teaches this course. Finally, we need to find the login name of the course author.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'Courses' where course_name = \"advanced database\". In the second step, we need to select author_id from table 'Courses' where course_id matches the course_id found in the first step. In the final step, we need to select login_name from table 'Course_Authors_and_Tutors' where author_id matches the author_id found in the second step.\n\n<3> SQL Generation: Use 'where' to find the course_id of the course with name \"advanced database\", and then use 'where' to find the author_id of the course author that teaches this course. Finally, use 'where' to find the login name of the course author.\n\n",
        "predict": "SELECT login_name FROM Course_Authors_and_Tutors WHERE author_id = (SELECT author_id FROM Courses WHERE course_name = \"advanced database\")"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)",
        "question": "How many students did not have any course enrollment?",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding students who did not have any course enrollment. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from the 'Students' table and check if there are any corresponding entries in the 'Student_Course_Enrolment' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Students' table with the 'Student_Course_Enrolment' table on the 'student_id' column. Then, we can filter the rows where the 'course_id' is null (indicating no course enrollment) and count the number of students.\n\n",
        "predict": "SELECT COUNT(*) FROM Students LEFT JOIN Student_Course_Enrolment ON Students.student_id = Student_Course_Enrolment.student_id WHERE Student_Course_Enrolment.course_id IS NULL"
    },
    {
        "db_id": "insurance_policies",
        "gold": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )",
        "question": "Return the claim start date for the claims whose claimed amount is no more than the average",
        "fields": "Table Claims, columns = [*,Claim_ID,Policy_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled]\nTable Customer_Policies, columns = [*,Policy_ID,Customer_ID,Policy_Type_Code,Start_Date,End_Date]\nTable Customers, columns = [*,Customer_ID,Customer_Details]\nTable Payments, columns = [*,Payment_ID,Settlement_ID,Payment_Method_Code,Date_Payment_Made,Amount_Payment]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Date_Claim_Made,Date_Claim_Settled,Amount_Claimed,Amount_Settled,Customer_Policy_ID]\n",
        "foreign_keys": "Foreign_keys = [Customer_Policies.Customer_ID = Customers.Customer_ID,Claims.Policy_ID = Customer_Policies.Policy_ID,Settlements.Claim_ID = Claims.Claim_ID,Payments.Settlement_ID = Settlements.Settlement_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the claimed amount, so we should calculate the average claimed amount and then filter the claims based on this average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires the claim start date, we only need the 'Claims' table.\n\n<3> SQL Generation: Use 'where' to filter claims where the claimed amount is less than or equal to the average claimed amount.\n\n",
        "predict": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims)"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT DISTINCT T1.name ,  T1.position FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.Brand  =  \"X\"",
        "question": "Which physicians prescribe a medication of brand X? Tell me the name and position of those physicians.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the physicians who prescribe a medication of brand X. Secondly, we need to retrieve the name and position of those physicians.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select physicians from table 'Physician' who prescribe a medication of brand X from table 'Prescribes'. We also need to retrieve the name and position of those physicians.\n\n<3> SQL Generation: Use 'where' to filter physicians who prescribe a medication of brand X, and then select the name and position of those physicians.\n\n",
        "predict": "SELECT Physician.Name, Physician.Position FROM Physician JOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician WHERE Prescribes.Medication IN (SELECT Code FROM Medication WHERE Brand = 'X')"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1",
        "question": "List the names of departments where some physicians are primarily affiliated with.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the physicians who are primarily affiliated with some departments. Secondly, we need to list the names of those departments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select distinct Department from table 'Affiliated_With' where PrimaryAffiliation is not null. In the second step, we need to select Name from table 'Department' where DepartmentID matches the departments found in the first step.\n\n<3> SQL Generation: Use 'where' to filter the physicians who are primarily affiliated with some departments, and then use 'distinct' to select the departments. Finally, join the 'Department' table to get the names of those departments.\n\n",
        "predict": "SELECT DISTINCT Department.Name FROM Affiliated_With JOIN Department ON Affiliated_With.Department = Department.DepartmentID WHERE Affiliated_With.PrimaryAffiliation IS NOT NULL"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )",
        "question": "Find the number of patients who are not using the medication of Procrastin-X.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the patients who are using the medication Procrastin-X. Secondly, we need to count the number of patients who are not using this medication.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select patients from table 'Patient' who are using the medication Procrastin-X from table 'Prescribes'.\n\n<3> SQL Generation: Use 'where' to filter patients who are using the medication Procrastin-X, and then use 'not in' to filter patients who are not using this medication and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Patient WHERE SSN NOT IN (SELECT Patient FROM Prescribes WHERE Medication = 'Procrastin-X')"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )",
        "question": "How many patients are not using Procrastin-X as medication?",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on patients who are not using Procrastin-X as medication. We need to identify the patients who are using Procrastin-X and then count the patients who are not using it.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select patients who are using Procrastin-X from the 'Prescribes' table and count the patients who are not using it from the 'Patient' table.\n\n<3> SQL Generation: Use 'where' to filter patients who are using Procrastin-X in the 'Prescribes' table, and then use 'where' to count the patients who are not using it in the 'Patient' table.\n\n",
        "predict": "SELECT COUNT(*) FROM Patient WHERE SSN NOT IN (SELECT Patient FROM Prescribes WHERE Medication = 'Procrastin-X')"
    },
    {
        "db_id": "ship_mission",
        "gold": "SELECT Name FROM ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM mission)",
        "question": "What are the names of the ships that are not involved in any missions?",
        "fields": "Table mission, columns = [*,Mission_ID,Ship_ID,Code,Launched_Year,Location,Speed_knots,Fate]\nTable ship, columns = [*,Ship_ID,Name,Type,Nationality,Tonnage]\n",
        "foreign_keys": "Foreign_keys = [mission.Ship_ID = ship.Ship_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding ships that are not involved in any missions. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find ships that are not involved in any missions, we only need the 'ship' table.\n\n<3> SQL Generation: We can use a 'left join' to join the 'ship' table with the 'mission' table on the 'Ship_ID' column. Then, we can filter the rows where the 'Mission_ID' is null, indicating that the ship is not involved in any missions. Finally, we can select the 'Name' column from the resulting rows.\n\n",
        "predict": "SELECT Name FROM ship LEFT JOIN mission ON ship.Ship_ID = mission.Ship_ID WHERE mission.Mission_ID IS NULL"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT DISTINCT T2.firstname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE grade  =  1",
        "question": "What are the first names of the teachers who teach grade 1?",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on teachers who teach grade 1. Firstly, we need to identify the teachers who teach grade 1. Secondly, we need to select their first names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no explicit foreign key relationship mentioned, we only need the 'teachers' table.\n\n<3> SQL Generation: Use 'where' to filter teachers who teach grade 1, and then select their first names.\n\n",
        "predict": "SELECT FirstName FROM teachers WHERE Classroom = 'Grade 1'"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "question": "Which students study under the teacher named OTHA MOYER? Give me the first and last names of the students.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name 'OTHA MOYER'. Secondly, we need to find the students who study under that teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no explicit foreign key relationship mentioned in the given information, we can assume that the 'Classroom' column in both tables can be used to link the tables.\n\n<3> SQL Generation: Use 'where' to find the teacher with the name 'OTHA MOYER', and then use 'where' to filter the students who study under that teacher and select their first and last names.\n\n",
        "predict": "SELECT FirstName, LastName FROM list WHERE Classroom IN (SELECT Classroom FROM teachers WHERE FirstName = 'OTHA' AND LastName = 'MOYER')"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT T2.firstname ,  T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"EVELINA\" AND T1.lastname  =  \"BROMLEY\"",
        "question": "Find the first and last name of all the teachers that teach EVELINA BROMLEY.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name 'EVELINA BROMLEY'. Secondly, we need to select the first and last name of the teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no foreign key relationship mentioned in the question, we only need the 'teachers' table.\n\n<3> SQL Generation: Use 'where' to filter the teacher with the name 'EVELINA BROMLEY', and then select the first and last name of the teacher.\n\n",
        "predict": "SELECT FirstName, LastName FROM teachers WHERE FirstName = 'EVELINA' AND LastName = 'BROMLEY'"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"LORIA\" AND T2.lastname  =  \"ONDERSMA\"",
        "question": "Count the number of students the teacher LORIA ONDERSMA teaches.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of students taught by a specific teacher. Firstly, we need to identify the teacher with the name \"LORIA ONDERSMA\". Secondly, we need to count the number of students in the teacher's classroom.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the teacher's name is in the 'teachers' table and the classroom information is in the 'list' table, we need to use both tables.\n\n<3> SQL Generation: Use 'where' to filter the teacher with the name \"LORIA ONDERSMA\" in the 'teachers' table. Then, join the 'teachers' and 'list' tables on the 'Classroom' column and count the number of students in the teacher's classroom.\n\n",
        "predict": "SELECT COUNT(*) FROM list JOIN teachers ON list.Classroom = teachers.Classroom WHERE teachers.LastName = 'ONDERSMA' AND teachers.FirstName = 'LORIA'"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"KAWA\" AND T2.lastname  =  \"GORDON\"",
        "question": "How many students does KAWA GORDON teaches?",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name \"KAWA GORDON\". Secondly, we need to count the number of students taught by that teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have the 'teachers' table, we need to select the rows where the 'LastName' is \"KAWA\" and the 'FirstName' is \"GORDON\".\n\n<3> SQL Generation: Use 'where' to filter the rows where 'LastName' is \"KAWA\" and 'FirstName' is \"GORDON\", and then count the number of rows.\n\n",
        "predict": "SELECT COUNT(*) FROM teachers WHERE LastName = 'KAWA' AND FirstName = 'GORDON'"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"TARRING\" AND T2.lastname  =  \"LEIA\"",
        "question": "Find the number of students taught by TARRING LEIA.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name 'TARRING LEIA'. Secondly, we need to count the number of students taught by that teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the teacher's information from table 'teachers' where the first name is 'LEIA' and the last name is 'TARRING'. In the second step, we need to count the number of students from table 'list' where the classroom matches the classroom of the teacher found in the first step.\n\n<3> SQL Generation: Use 'where' to find the teacher with the name 'TARRING LEIA', and then use 'where' to filter students based on the teacher's classroom and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM list WHERE Classroom = (SELECT Classroom FROM teachers WHERE FirstName = 'LEIA' AND LastName = 'TARRING')"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "question": "How many teachers does the student named MADLOCK RAY have?",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name \"MADLOCK RAY\". Secondly, we need to count the number of teachers in the same classroom as the student.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no explicit foreign key relationship mentioned in the question, we can assume that the classroom column in both tables can be used to link the student and teacher.\n\n<3> SQL Generation: Use 'where' to find the student with the name \"MADLOCK RAY\", and then use 'where' to filter teachers in the same classroom and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM teachers WHERE Classroom = (SELECT Classroom FROM list WHERE LastName = 'MADLOCK' AND FirstName = 'RAY')"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "question": "Find the number of teachers who teach the student called MADLOCK RAY.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name 'MADLOCK RAY'. Secondly, we need to find the teachers who teach this student.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the student with the name 'MADLOCK RAY' from table 'list'. Then, we need to find the teachers who teach this student by matching the classroom.\n\n<3> SQL Generation: Use 'where' to find the student with the name 'MADLOCK RAY' and select the corresponding classroom. Then, use 'where' to find the teachers who teach this student by matching the classroom.\n\n",
        "predict": "SELECT COUNT(*) FROM teachers WHERE Classroom IN (SELECT Classroom FROM list WHERE LastName = 'MADLOCK' AND FirstName = 'RAY')"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT DISTINCT T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.grade  =  3 AND T2.firstname != \"COVIN\" AND T2.lastname != \"JEROME\"",
        "question": "Find the last names of the students in third grade that are not taught by COVIN JEROME.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students in third grade. Secondly, we need to filter out the students taught by COVIN JEROME. Finally, we need to select the last names of the remaining students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no explicit foreign key relationship mentioned in the question, we only need the 'list' table.\n\n<3> SQL Generation: Use 'where' to filter students in third grade and not taught by COVIN JEROME, and then select their last names.\n\n",
        "predict": "SELECT LastName FROM list WHERE Grade = 'third' AND LastName != 'COVIN' AND FirstName != 'JEROME'"
    },
    {
        "db_id": "company_employee",
        "gold": "SELECT count(*) FROM company WHERE Headquarters  =  'USA'",
        "question": "How many companies are headquartered in the US?",
        "fields": "Table company, columns = [*,Company_ID,Name,Headquarters,Industry,Sales_in_Billion,Profits_in_Billion,Assets_in_Billion,Market_Value_in_Billion]\nTable employment, columns = [*,Company_ID,People_ID,Year_working]\nTable people, columns = [*,People_ID,Age,Name,Nationality,Graduation_College]\n",
        "foreign_keys": "Foreign_keys = [employment.People_ID = people.People_ID,employment.Company_ID = company.Company_ID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of companies that are headquartered in the US.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information about the companies, we only need the 'company' table.\n\n<3> SQL Generation: Use 'where' to filter companies that are headquartered in the US, and then use 'count' to calculate the number of rows that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM company WHERE Headquarters = 'US'"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT TYPE FROM film_market_estimation WHERE YEAR  =  1995",
        "question": "Return the types of film market estimations in 1995.",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the year 1995, so we should apply the 'where' to column 'Year' and then return the types of film market estimations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'film_market_estimation' has column 'Type', we only need table 'film_market_estimation'.\n\n<3> SQL Generation: Directly write the sql using 'where'.\n\n",
        "predict": "SELECT DISTINCT Type FROM film_market_estimation WHERE Year = 1995"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000",
        "question": "What is the average number of cities of markets with low film market estimate bigger than 10000?",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter markets with low film market estimate bigger than 10000. Secondly, we need to calculate the average number of cities for these markets.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Market_ID from table 'film_market_estimation' where Low_Estimate > 10000. In the second step, we need to select Number_cities from table 'market' and calculate the average.\n\n<3> SQL Generation: Use 'where' to filter markets with low film market estimate bigger than 10000, and then use 'avg' to calculate the average number of cities.\n\n",
        "predict": "SELECT AVG(Number_cities) FROM market WHERE Market_ID IN (SELECT Market_ID FROM film_market_estimation WHERE Low_Estimate > 10000)"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)",
        "question": "What are the titles of films that do not have a film market estimation?",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding films that do not have a film market estimation. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is about films and film market estimations, we need to use the tables 'film' and 'film_market_estimation'.\n\n<3> SQL Generation: We can use a left join to combine the 'film' and 'film_market_estimation' tables, and then filter the rows where the estimation ID is null (indicating that there is no film market estimation). Finally, we select the titles of the films that meet this condition.\n\n",
        "predict": "SELECT Title FROM film LEFT JOIN film_market_estimation ON film.Film_ID = film_market_estimation.Film_ID WHERE film_market_estimation.Estimation_ID IS NULL"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT title ,  director FROM film WHERE film_id NOT IN (SELECT film_id FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.market_id  =  T2.Market_ID WHERE country  =  'China')",
        "question": "Return the titles and directors of films that were never in the market of China.",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering films that were never in the market of China. Firstly, we need to identify the films that were in the market of China. Secondly, we need to filter films that were not in the market of China and select their titles and directors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Film_ID from table 'film_market_estimation' where Country = 'China'. In the second step, we need to filter Film_ID, Title, and Director from table 'film' where Film_ID is not in the Film_IDs selected in the first step.\n\n<3> SQL Generation: Use 'where' to find the Film_IDs in the market of China, and then use 'where' to filter films that were not in the market of China and select their titles and directors.\n\n",
        "predict": "SELECT Title, Director FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation WHERE Country = 'China')"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "gold": "SELECT count(*) FROM All_documents WHERE document_type_code  =  \"CV\" OR document_type_code  =  \"BK\"",
        "question": "How many documents have document type code CV or BK?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter documents based on their document type code, selecting documents with document type code 'CV' or 'BK'. Secondly, we need to count the number of selected documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter documents based on their document type code, we only need the 'All_Documents' table.\n\n<3> SQL Generation: Use 'where' to filter documents with document type code 'CV' or 'BK', and then use 'count' to count the number of selected documents.\n\n",
        "predict": "SELECT COUNT(*) FROM All_Documents WHERE Document_Type_Code = 'CV' OR Document_Type_Code = 'BK'"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "question": "Find the number of members of club \"Pen and Paper Gaming\".",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Pen and Paper Gaming\". Secondly, we need to count the number of members in that club.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Pen and Paper Gaming\". In the second step, we need to count the number of rows in table 'Member_of_club' where ClubID matches the ClubID found in the first step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of the club \"Pen and Paper Gaming\", and then use 'count' to count the number of members in that club.\n\n",
        "predict": "SELECT COUNT(*) FROM Member_of_club WHERE ClubID = (SELECT ClubID FROM Club WHERE ClubName = \"Pen and Paper Gaming\")"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "question": "How many people have membership in the club \"Pen and Paper Gaming\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Pen and Paper Gaming\". Secondly, we need to count the number of people who have membership in that club.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Pen and Paper Gaming\". In the second step, we need to count the number of rows in table 'Member_of_club' where ClubID matches the ClubID found in the first step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of the club \"Pen and Paper Gaming\", and then use 'count' to count the number of rows in table 'Member_of_club' where ClubID matches the ClubID found in the first step.\n\n",
        "predict": "SELECT COUNT(*) FROM Member_of_club WHERE ClubID = (SELECT ClubID FROM Club WHERE ClubName = \"Pen and Paper Gaming\")"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Linda\" AND t3.lname  =  \"Smith\"",
        "question": "How many clubs does \"Linda Smith\" belong to?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the StuID of \"Linda Smith\" in table 'Student'. Secondly, we need to count the number of clubs that Linda Smith belongs to based on her StuID in table 'Member_of_club'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to count the number of rows in table 'Member_of_club' where StuID matches the StuID of Linda Smith.\n\n<3> SQL Generation: Use 'where' to find the StuID of Linda Smith in table 'Student', and then use 'where' to count the number of rows in table 'Member_of_club' where StuID matches the StuID of Linda Smith.\n\n",
        "predict": "SELECT COUNT(*) FROM Member_of_club WHERE StuID = (SELECT StuID FROM Student WHERE LName = 'Smith' AND Fname = 'Linda')"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.sex  =  \"F\"",
        "question": "Find all the female members of club \"Bootup Baltimore\". Show the first name and last name.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Bootup Baltimore\". Secondly, we need to filter members based on their club and gender. Finally, we need to select the first name and last name of the female members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Bootup Baltimore\". In the second step, we need to filter StuID from table 'Member_of_club' where ClubID matches the value found in the first step. In the final step, we need to select Fname and LName from table 'Student' where StuID matches the values found in the second step and Sex is 'F'.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Bootup Baltimore\", then use 'where' to filter members based on their club and gender, and finally select the first name and last name of the female members.\n\n",
        "predict": "SELECT Fname, LName FROM Student WHERE StuID IN (SELECT StuID FROM Member_of_club WHERE ClubID = (SELECT ClubID FROM Club WHERE ClubName = \"Bootup Baltimore\")) AND Sex = 'F'"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t3.sex  =  \"M\"",
        "question": "What are the first name and last name of each male member in club \"Hopkins Student Enterprises\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter members based on their club name. Secondly, we need to select the first name and last name of male members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Hopkins Student Enterprises\". In the second step, we need to join table 'Member_of_club' and table 'Student' on StuID and filter by ClubID and Sex.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Hopkins Student Enterprises\", and then use 'join' to join 'Member_of_club' and 'Student' tables on StuID. Finally, filter by ClubID and Sex = 'M' and select the first name and last name.\n\n",
        "predict": "SELECT Student.Fname, Student.LName FROM Member_of_club JOIN Student ON Member_of_club.StuID = Student.StuID WHERE Member_of_club.ClubID = (SELECT ClubID FROM Club WHERE ClubName = \"Hopkins Student Enterprises\") AND Student.Sex = 'M'"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT clublocation FROM club WHERE clubname  =  \"Pen and Paper Gaming\"",
        "question": "Where is the club \"Pen and Paper Gaming\" located?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires finding the location of the club \"Pen and Paper Gaming\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find the location of the club, we only need the 'Club' table.\n\n<3> SQL Generation: Use 'where' to filter the club with the name \"Pen and Paper Gaming\" and select its location.\n\n",
        "predict": "SELECT ClubLocation FROM Club WHERE ClubName = 'Pen and Paper Gaming'"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "question": "Who is the \"CTO\" of club \"Hopkins Student Enterprises\"? Show the first name and last name.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Hopkins Student Enterprises\". Secondly, we need to find the member of the club with the position \"CTO\" and retrieve their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Hopkins Student Enterprises\". In the second step, we need to select StuID from table 'Member_of_club' where ClubID matches the ClubID found in the first step and Position = \"CTO\". Finally, we need to retrieve the first name and last name of the student from table 'Student' using the StuID found in the second step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Hopkins Student Enterprises\", then use 'where' to find the StuID of the member with the position \"CTO\" in the club, and finally select the first name and last name of the student using the StuID.\n\n",
        "predict": "SELECT Student.Fname, Student.LName FROM Club JOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID JOIN Student ON Member_of_club.StuID = Student.StuID WHERE Club.ClubName = \"Hopkins Student Enterprises\" AND Member_of_club.Position = \"CTO\""
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "question": "Find the first name and last name for the \"CTO\" of the club \"Hopkins Student Enterprises\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Hopkins Student Enterprises\". Secondly, we need to find the member of the club with the position \"CTO\" and retrieve their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Hopkins Student Enterprises\". In the second step, we need to select StuID from table 'Member_of_club' where ClubID matches the ClubID found in the first step and Position = \"CTO\". Finally, we need to retrieve the first name and last name from table 'Student' using the StuID found in the second step.\n\n<3> SQL Generation: Use 'where' to find the ClubID for the club \"Hopkins Student Enterprises\", and then use 'where' to find the StuID for the member with the position \"CTO\". Finally, join the 'Student' table to retrieve the first name and last name.\n\n",
        "predict": "SELECT Student.Fname, Student.LName FROM Student JOIN Member_of_club ON Student.StuID = Member_of_club.StuID WHERE Member_of_club.ClubID = (SELECT ClubID FROM Club WHERE ClubName = \"Hopkins Student Enterprises\") AND Member_of_club.Position = \"CTO\""
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  >  18",
        "question": "How many members of \"Bootup Baltimore\" are older than 18?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Bootup Baltimore\". Secondly, we need to filter members of that club who are older than 18. Finally, we need to count the number of members who meet these criteria.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Bootup Baltimore\". In the second step, we need to filter StuID from table 'Member_of_club' based on the ClubID obtained in the first step. In the third step, we need to filter Age from table 'Student' based on the StuID obtained in the second step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Bootup Baltimore\", then use 'where' to filter members of that club who are older than 18, and finally use 'count' to count the number of members who meet these criteria.\n\n",
        "predict": "SELECT COUNT(*) FROM Member_of_club AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.ClubID = (SELECT ClubID FROM Club WHERE ClubName = \"Bootup Baltimore\") AND T2.Age > 18"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  <  18",
        "question": "How many members of club \"Bootup Baltimore\" are younger than 18?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter members of club \"Bootup Baltimore\" from table 'Member_of_club'. Secondly, we need to filter members who are younger than 18 based on their age from table 'Student'. Finally, we count the number of selected members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'Member_of_club' and table 'Student' have direct foreign keys, so we need tables ['Member_of_club', 'Student'].\n\n<3> SQL Generation: We need to join the 'Member_of_club' and 'Student' tables on the 'StuID' column. Then, we filter the rows where 'ClubName' is 'Bootup Baltimore' and 'Age' is less than 18. Finally, we count the number of rows that meet these conditions.\n\n",
        "predict": "SELECT COUNT(*) FROM member_of_club AS T1 JOIN student AS T2 ON T1.StuID = T2.StuID WHERE T1.ClubID = (SELECT ClubID FROM club WHERE ClubName = 'Bootup Baltimore') AND T2.Age < 18"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.city_code  =  \"BAL\"",
        "question": "Find the names of all the clubs that have at least a member from the city with city code \"BAL\".",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the city with city code \"BAL\". Secondly, we need to find the clubs that have at least one member from that city and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubLocation = \"BAL\". In the second step, we need to filter ClubID from table 'Member_of_club' and select the corresponding ClubName from table 'Club'.\n\n<3> SQL Generation: Use 'where' to find the ClubID of the clubs that have at least one member from the city with city code \"BAL\", and then use 'where' to filter the ClubName from table 'Club'.\n\n",
        "predict": "SELECT ClubName FROM Club WHERE ClubID IN (SELECT ClubID FROM Member_of_club WHERE StuID IN (SELECT StuID FROM Student WHERE city_code = \"BAL\"))"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'",
        "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter grants based on grant amount greater than 5000. Secondly, we need to find the corresponding documents and retrieve their send dates. Finally, we need to filter the grants based on the organisation type description.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select grant_id from table 'Grants' where grant_amount > 5000. In the second step, we need to filter grant_id from table 'Documents' and retrieve the send dates. In the final step, we need to filter organisation_type_description from table 'Organisation_Types'.\n\n<3> SQL Generation: Use 'where' to filter grants based on grant amount greater than 5000. Then, join the 'Grants' and 'Documents' tables on the 'grant_id' column. Filter the rows where the grant amount is greater than 5000 and retrieve the send dates. Finally, join the 'Grants' and 'Organisations' tables on the 'organisation_id' column and filter the rows based on the organisation type description.\n\n",
        "predict": "SELECT sent_date FROM Documents JOIN Grants ON Documents.grant_id = Grants.grant_id JOIN Organisations ON Grants.organisation_id = Organisations.organisation_id WHERE Grants.grant_amount > 5000 AND Organisation_Types.organisation_type_description = 'description'"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )",
        "question": "List the project details of the projects which did not hire any staff for a researcher role.",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the projects that did not hire any staff for a researcher role. Secondly, we need to list the project details of those projects.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select project_id from table 'Projects' where there are no entries in table 'Project_Staff' with role_code = 'researcher' for that project_id. In the second step, we need to select project_details from table 'Projects' for the projects found in the first step.\n\n<3> SQL Generation: Use 'where not exists' to find the projects that did not hire any staff for a researcher role, and then select the project details for those projects.\n\n",
        "predict": "SELECT project_details FROM Projects WHERE NOT EXISTS (SELECT * FROM Project_Staff WHERE Projects.project_id = Project_Staff.project_id AND role_code = 'researcher')"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )",
        "question": "Which projects have no outcome? List the project details.",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find projects that have no outcome. Secondly, we need to list the project details of those projects.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select project_id from table 'Projects' where there is no corresponding project_id in table 'Project_Outcomes'. Then, we need to select project details from table 'Projects'.\n\n<3> SQL Generation: Use 'where' and 'not in' to find projects that have no outcome, and then select the project details of those projects.\n\n",
        "predict": "SELECT * FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Outcomes)"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'",
        "question": "How many project members were leaders or started working before '1989-04-24 23:51:54'?",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter project members who were leaders or started working before a specific date. Secondly, we need to count the number of selected project members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select staff_id from table 'Project_Staff' where role_code is either 'leader' or 'started' and date_from is before '1989-04-24 23:51:54'.\n\n<3> SQL Generation: Use 'where' to filter project members who were leaders or started working before the specified date, and then use 'count' to count the number of selected project members.\n\n",
        "predict": "SELECT COUNT(*) FROM Project_Staff WHERE (role_code = 'leader' OR role_code = 'started') AND date_from < '1989-04-24 23:51:54'"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT count(*) FROM Person WHERE gender  =  'female'",
        "question": "How many females are in the network?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter the network based on gender, selecting only females. Secondly, we need to count the number of females in the network.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have one table 'Person' and the gender column is directly available in that table, we only need to use the 'Person' table.\n\n<3> SQL Generation: Use 'where' to filter the network based on gender, selecting only females. Then, use 'count' to count the number of females in the network.\n\n",
        "predict": "SELECT COUNT(*) FROM Person WHERE gender = 'female'"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "question": "How old is the doctor named Zach?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: The query requires finding the age of a person named Zach who has the job title of doctor.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this case, we only need the 'Person' table.\n\n<3> SQL Generation: Use 'where' to filter the rows where the name is 'Zach' and the job is 'doctor', and then select the age.\n\n",
        "predict": "SELECT age FROM Person WHERE name = 'Zach' AND job = 'doctor'"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "question": "What is the age of the doctor named Zach?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: The query requires finding the age of a doctor named Zach.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires information from the 'Person' table, we only need to use that table.\n\n<3> SQL Generation: Use 'where' to filter the rows where the name is 'Zach' and the job is 'doctor', and then select the age.\n\n",
        "predict": "SELECT age FROM Person WHERE name = 'Zach' AND job = 'doctor'"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT count(*) FROM Person WHERE age  >  30 AND job  =  'engineer'",
        "question": "HOw many engineers are older than 30?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter candidates based on their job and age. Secondly, we need to count the number of selected engineers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have one table 'Person' and the query does not require any additional information, we only need table 'Person'.\n\n<3> SQL Generation: Use 'where' to filter engineers with age greater than 30, and then use 'count' to calculate the number of selected engineers.\n\n",
        "predict": "SELECT COUNT(*) FROM Person WHERE job = 'engineer' AND age > 30"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "question": "Find the female friends of Alice.",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Alice. Secondly, we need to filter the friends who are female.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select friend from table 'PersonFriend' where name = 'Alice'. In the second step, we need to filter the selected friends by their gender from table 'Person'.\n\n<3> SQL Generation: Use 'where' to find the friends of Alice, and then use 'where' to filter the friends who are female.\n\n",
        "predict": "SELECT friend FROM PersonFriend WHERE name = 'Alice' AND friend IN (SELECT name FROM Person WHERE gender = 'female')"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "question": "What are all the friends of Alice who are female?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Alice. Secondly, we need to filter the friends who are female.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the friends from table 'PersonFriend' where name = 'Alice'. In the second step, we need to filter the friends who are female from table 'Person'.\n\n<3> SQL Generation: Use 'where' to find the friends of Alice, and then use 'where' to filter the friends who are female.\n\n",
        "predict": "SELECT friend FROM PersonFriend WHERE name = 'Alice' AND friend IN (SELECT name FROM Person WHERE gender = 'female')"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)",
        "question": "Who has friends that are younger than the average age?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average age of all people. Secondly, we need to find people who have friends younger than the average age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we only need the 'age' column from the 'Person' table. In the second step, we need to join the 'Person' table with the 'PersonFriend' table on the 'name' column and filter based on the age of friends.\n\n<3> SQL Generation: Use 'avg' to calculate the average age from the 'Person' table. Then, join the 'Person' table with the 'PersonFriend' table on the 'name' column. Finally, filter the rows where the age of the friend is less than the average age.\n\n",
        "predict": "SELECT DISTINCT p.name FROM Person AS p JOIN PersonFriend AS pf ON p.name = pf.name WHERE pf.friend IN (SELECT name FROM Person WHERE age < (SELECT AVG(age) FROM Person))"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "question": "Who is the friend of Zach with longest year relationship?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Zach. Secondly, we need to filter the friends based on the longest year relationship.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select friend from table 'PersonFriend' where name = 'Zach'. In the second step, we need to filter friend and year from table 'PersonFriend'.\n\n<3> SQL Generation: Use 'where' to find the friends of Zach, and then use 'order by' and 'desc' to select the friend with the longest year relationship.\n\n",
        "predict": "SELECT friend FROM PersonFriend WHERE name = 'Zach' ORDER BY year DESC LIMIT 1"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name =  'Zach' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "question": "What is the age of the friend of Zach with longest year relationship?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friend of Zach. Secondly, we need to find the longest year relationship for each friend. Finally, we need to find the age of the friend with the longest year relationship.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the age from table 'Person' where the name is the friend of Zach.\n\n<3> SQL Generation: Use 'where' to find the friend of Zach, then use 'order by' and 'desc' to find the friend with the longest year relationship, and finally select the age of that friend.\n\n",
        "predict": "SELECT age FROM Person WHERE name = (SELECT friend FROM PersonFriend WHERE name = 'Zach' ORDER BY year DESC LIMIT 1)"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "question": "Find the name of persons who are friends with Alice for the shortest years.",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Alice. Secondly, we need to find the shortest years among the friendships. Finally, we need to find the names of the persons who have friendships with Alice for the shortest years.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the friend column from the PersonFriend table where the name is Alice. In the second step, we need to find the minimum year from the PersonFriend table. In the final step, we need to select the names from the Person table where the name is in the result of the first step and the year is equal to the minimum year found in the second step.\n\n<3> SQL Generation: Use 'where' to find the friends of Alice, then use 'min' to find the shortest years among the friendships, and finally use 'where' to find the names of the persons who have friendships with Alice for the shortest years.\n\n",
        "predict": "SELECT name FROM Person WHERE name IN (SELECT friend FROM PersonFriend WHERE name = 'Alice') AND year = (SELECT MIN(year) FROM PersonFriend)"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "question": "Find the name, age, and job title of persons who are friends with Alice for the longest years.",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Alice. Secondly, we need to calculate the number of years each person has been friends with Alice. Finally, we need to select the person with the longest friendship and retrieve their name, age, and job title.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the tables 'Person' and 'PersonFriend' to retrieve the necessary information.\n\n<3> SQL Generation: We need to join the 'Person' and 'PersonFriend' tables on the 'name' column. Then, we filter the rows where the friend is 'Alice'. Next, we group the rows by the person's name, age, and job title and calculate the maximum number of years using the 'MAX' function. Finally, we select the person with the longest friendship and retrieve their name, age, and job title.\n\n",
        "predict": "SELECT p.name, p.age, p.job FROM Person AS p JOIN PersonFriend AS pf ON p.name = pf.name WHERE pf.friend = 'Alice' GROUP BY p.name, p.age, p.job HAVING MAX(pf.year)"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')",
        "question": "What is the total number of people who have no friends living in Austin?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the people who have friends living in Austin. Secondly, we need to count the number of people who do not have friends living in Austin.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select distinct names from table 'PersonFriend' where friend = 'Austin'. In the second step, we need to count the number of distinct names from table 'Person' where name is not in the result of the first step.\n\n<3> SQL Generation: Use 'where' to find the distinct names of people who have friends living in Austin, and then use 'where' and 'not in' to count the number of people who do not have friends living in Austin.\n\n",
        "predict": "SELECT COUNT(DISTINCT name) FROM Person WHERE name NOT IN (SELECT DISTINCT name FROM PersonFriend WHERE friend = 'Austin')"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT DISTINCT T4.name FROM PersonFriend AS T1 JOIN Person AS T2 ON T1.name  =  T2.name JOIN PersonFriend AS T3 ON T1.friend  =  T3.name JOIN PersonFriend AS T4 ON T3.friend  =  T4.name WHERE T2.name  =  'Alice' AND T4.name != 'Alice'",
        "question": "Find Alice's friends of friends.",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find Alice's friends. Secondly, we need to find the friends of Alice's friends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the friends of Alice from table 'PersonFriend'. In the second step, we need to select the friends of Alice's friends from table 'PersonFriend'.\n\n<3> SQL Generation: Use 'where' to find Alice's friends, and then use 'where' to find the friends of Alice's friends.\n\n",
        "predict": "SELECT friend FROM PersonFriend WHERE name = 'Alice' UNION SELECT friend FROM PersonFriend WHERE name IN (SELECT friend FROM PersonFriend WHERE name = 'Alice')"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "question": "Find all the name of documents without any sections.",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the documents that do not have any sections. Secondly, we need to retrieve the names of those documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select document_code from table 'Documents' where there are no corresponding entries in table 'Document_Sections'. Then, we need to retrieve the document names from table 'Documents'.\n\n<3> SQL Generation: Use 'not exists' to find the documents that do not have any sections, and then select the document names.\n\n",
        "predict": "SELECT document_name FROM Documents WHERE NOT EXISTS (SELECT * FROM Document_Sections WHERE Documents.document_code = Document_Sections.document_code)"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "question": "What are the names of documents that do not have any sections?",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the documents that do not have any sections. Secondly, we need to retrieve the names of those documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select document_code from table 'Documents' where there are no corresponding entries in table 'Document_Sections'. Then, we need to retrieve the document names from table 'Documents'.\n\n<3> SQL Generation: Use 'where' and 'not exists' to find the documents that do not have any sections, and then select the document names.\n\n",
        "predict": "SELECT document_name FROM Documents WHERE NOT EXISTS (SELECT * FROM Document_Sections WHERE Documents.document_code = Document_Sections.document_code)"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT name FROM Companies ORDER BY Market_Value_billion DESC",
        "question": "Sort the company names in descending order of the company's market value.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Decomposition: We need to sort the company names based on their market value in descending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Companies' table for this query.\n\n<3> SQL Generation: Use 'order by' and 'desc' to sort the company names based on their market value in descending order.\n\n",
        "predict": "SELECT name FROM Companies ORDER BY Market_Value_billion DESC"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations)",
        "question": "List the names of buildings that have no company office.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Decomposition: We need to find the buildings that have no company office.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of buildings from the 'buildings' table where there is no corresponding entry in the 'Office_locations' table.\n\n<3> SQL Generation: We can use a left join to combine the 'buildings' and 'Office_locations' tables, and then filter the rows where the 'company_id' is null. Finally, we select the names of the buildings.\n\n",
        "predict": "SELECT name FROM buildings LEFT JOIN Office_locations ON buildings.id = Office_locations.building_id WHERE Office_locations.company_id IS NULL"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT count(*) FROM Companies WHERE Industry  =  \"Banking\" OR Industry  =  \"Conglomerate\"",
        "question": "How many companies are in either \"Banking\" industry or \"Conglomerate\" industry?",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter companies based on their industry, selecting companies in the \"Banking\" industry or \"Conglomerate\" industry. Secondly, we need to count the number of selected companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Companies' table and the 'Industry' column.\n\n<3> SQL Generation: Use 'where' to filter companies in the \"Banking\" industry or \"Conglomerate\" industry, and then use 'count' to count the number of selected companies.\n\n",
        "predict": "SELECT COUNT(*) FROM Companies WHERE Industry = 'Banking' OR Industry = 'Conglomerate'"
    },
    {
        "db_id": "solvency_ii",
        "gold": "SELECT Product_Name FROM Products ORDER BY Product_Price ASC",
        "question": "List the name of products in ascending order of price.",
        "fields": "Table Addresses, columns = [*,Address_ID,address_details]\nTable Agreements, columns = [*,Document_ID,Event_ID]\nTable Assets, columns = [*,Asset_ID,Other_Details]\nTable Assets_in_Events, columns = [*,Asset_ID,Event_ID]\nTable Channels, columns = [*,Channel_ID,Other_Details]\nTable Events, columns = [*,Event_ID,Address_ID,Channel_ID,Event_Type_Code,Finance_ID,Location_ID]\nTable Finances, columns = [*,Finance_ID,Other_Details]\nTable Locations, columns = [*,Location_ID,Other_Details]\nTable Parties, columns = [*,Party_ID,Party_Details]\nTable Parties_in_Events, columns = [*,Party_ID,Event_ID,Role_Code]\nTable Products, columns = [*,Product_ID,Product_Type_Code,Product_Name,Product_Price]\nTable Products_in_Events, columns = [*,Product_in_Event_ID,Event_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [Events.Finance_ID = Finances.Finance_ID,Events.Address_ID = Addresses.Address_ID,Events.Location_ID = Locations.Location_ID,Products_in_Events.Product_ID = Products.Product_ID,Products_in_Events.Event_ID = Events.Event_ID,Parties_in_Events.Event_ID = Events.Event_ID,Parties_in_Events.Party_ID = Parties.Party_ID,Agreements.Event_ID = Events.Event_ID,Assets_in_Events.Event_ID = Events.Event_ID,Assets_in_Events.Event_ID = Events.Event_ID]\n",
        "reasoning": "<1> Decomposition: We need to retrieve the names of products and sort them in ascending order of price.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Products' table for this query.\n\n<3> SQL Generation: We can directly select the 'Product_Name' column from the 'Products' table and order the results by the 'Product_Price' column in ascending order.\n\n",
        "predict": "SELECT Product_Name FROM Products ORDER BY Product_Price ASC"
    },
    {
        "db_id": "entertainment_awards",
        "gold": "SELECT Name FROM artwork WHERE TYPE != \"Program Talent Show\"",
        "question": "List the name of artworks whose type is not \"Program Talent Show\".",
        "fields": "Table artwork, columns = [*,Artwork_ID,Type,Name]\nTable festival_detail, columns = [*,Festival_ID,Festival_Name,Chair_Name,Location,Year,Num_of_Audience]\nTable nomination, columns = [*,Artwork_ID,Festival_ID,Result]\n",
        "foreign_keys": "Foreign_keys = [nomination.Festival_ID = festival_detail.Festival_ID,nomination.Artwork_ID = artwork.Artwork_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the type of artwork, so we should apply the 'where' clause to the column 'Type' and then return the names of the selected artworks.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires the names of the artworks, we only need the 'artwork' table.\n\n<3> SQL Generation: Directly write the SQL query using 'where'.\n\n",
        "predict": "SELECT Name FROM artwork WHERE Type != 'Program Talent Show'"
    },
    {
        "db_id": "entertainment_awards",
        "gold": "SELECT Name FROM Artwork WHERE Artwork_ID NOT IN (SELECT Artwork_ID FROM nomination)",
        "question": "List the name of artworks that are not nominated.",
        "fields": "Table artwork, columns = [*,Artwork_ID,Type,Name]\nTable festival_detail, columns = [*,Festival_ID,Festival_Name,Chair_Name,Location,Year,Num_of_Audience]\nTable nomination, columns = [*,Artwork_ID,Festival_ID,Result]\n",
        "foreign_keys": "Foreign_keys = [nomination.Festival_ID = festival_detail.Festival_ID,nomination.Artwork_ID = artwork.Artwork_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on artworks that are not nominated. We need to select the names of artworks that do not have corresponding entries in the 'nomination' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'artwork' table to select the names of artworks.\n\n<3> SQL Generation: Use 'where not exists' to filter artworks that do not have corresponding entries in the 'nomination' table and select their names.\n\n",
        "predict": "SELECT Name FROM artwork WHERE NOT EXISTS (SELECT * FROM nomination WHERE nomination.Artwork_ID = artwork.Artwork_ID)"
    },
    {
        "db_id": "customers_campaigns_ecommerce",
        "gold": "SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM mailshot_customers)",
        "question": "Show the name and phone of the customer without any mailshot.",
        "fields": "Table Customer_Addresses, columns = [*,customer_id,premise_id,date_address_from,address_type_code,date_address_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,shipping_method_code,order_placed_datetime,order_delivered_datetime,order_shipping_charges]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,customer_address,customer_login,customer_password]\nTable Mailshot_Campaigns, columns = [*,mailshot_id,product_category,mailshot_name,mailshot_start_date,mailshot_end_date]\nTable Mailshot_Customers, columns = [*,mailshot_id,customer_id,outcome_code,mailshot_customer_date]\nTable Order_Items, columns = [*,item_id,order_item_status_code,order_id,product_id,item_status_code,item_delivered_datetime,item_order_quantity]\nTable Premises, columns = [*,premise_id,premises_type,premise_details]\nTable Products, columns = [*,product_id,product_category,product_name]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.premise_id = Premises.premise_id,Customer_Orders.customer_id = Customers.customer_id,Mailshot_Customers.mailshot_id = Mailshot_Campaigns.mailshot_id,Mailshot_Customers.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customers who did not receive any mailshot. Secondly, we need to select the name and phone of those customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Mailshot_Customers' where outcome_code is not equal to 'Sent'. In the second step, we need to select customer_name and customer_phone from table 'Customers' based on the customer_id obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id from table 'Mailshot_Customers' where outcome_code is not equal to 'Sent', and then use 'where' to select the name and phone of those customers from table 'Customers'.\n\n",
        "predict": "SELECT customer_name, customer_phone FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Mailshot_Customers WHERE outcome_code != 'Sent')"
    },
    {
        "db_id": "customers_campaigns_ecommerce",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE shipping_method_code  =  'FedEx' AND order_status_code  =  'Paid'",
        "question": "Show the names of customers having an order with shipping method FedEx and order status Paid.",
        "fields": "Table Customer_Addresses, columns = [*,customer_id,premise_id,date_address_from,address_type_code,date_address_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,shipping_method_code,order_placed_datetime,order_delivered_datetime,order_shipping_charges]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,customer_address,customer_login,customer_password]\nTable Mailshot_Campaigns, columns = [*,mailshot_id,product_category,mailshot_name,mailshot_start_date,mailshot_end_date]\nTable Mailshot_Customers, columns = [*,mailshot_id,customer_id,outcome_code,mailshot_customer_date]\nTable Order_Items, columns = [*,item_id,order_item_status_code,order_id,product_id,item_status_code,item_delivered_datetime,item_order_quantity]\nTable Premises, columns = [*,premise_id,premises_type,premise_details]\nTable Products, columns = [*,product_id,product_category,product_name]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.premise_id = Premises.premise_id,Customer_Orders.customer_id = Customers.customer_id,Mailshot_Customers.mailshot_id = Mailshot_Campaigns.mailshot_id,Mailshot_Customers.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders with shipping method FedEx. Secondly, we need to filter orders with order status Paid. Finally, we need to select the names of customers who have orders that meet both conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_name from table 'Customers' and filter by customer_id from table 'Customer_Orders'. We also need to filter by shipping_method_code and order_status_code from table 'Customer_Orders'.\n\n<3> SQL Generation: Use 'where' to filter orders with shipping method FedEx and order status Paid, and then select the customer names.\n\n",
        "predict": "SELECT customer_name FROM Customers WHERE customer_id IN (SELECT customer_id FROM Customer_Orders WHERE shipping_method_code = 'FedEx' AND order_status_code = 'Paid')"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT count(*) FROM COURSE WHERE Credits  >  2",
        "question": "How many courses have more than 2 credits?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on courses with more than 2 credits. We need to select courses based on their credit value.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Course' table and the 'Credits' column.\n\n<3> SQL Generation: Use 'where' to filter courses with more than 2 credits and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Course WHERE Credits > 2"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT count(*) FROM DEPARTMENT WHERE Division  =  \"AS\"",
        "question": "How many departments are in the division AS?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of departments in the division AS.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the departments from the table 'Department' where the division is AS.\n\n<3> SQL Generation: Use 'where' to filter departments with the division AS, and then use 'count' to calculate the number of departments.\n\n",
        "predict": "SELECT COUNT(*) FROM Department WHERE Division = 'AS'"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade  =  \"B\"",
        "question": "How many students have had at least one \"B\" grade?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students who have at least one \"B\" grade. Secondly, we need to count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from table 'Enrolled_in' where Grade = \"B\".\n\n<3> SQL Generation: Use 'where' to filter students who have at least one \"B\" grade, and then use 'count' to count the number of selected students.\n\n",
        "predict": "SELECT COUNT(DISTINCT StuID) FROM Enrolled_in WHERE Grade = \"B\""
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Fname ,  Lname FROM FACULTY WHERE sex  =  \"M\" AND Building  =  \"NEB\"",
        "question": "What are the full names of faculties with sex M and who live in building NEB?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter faculties based on their sex and building. Secondly, we need to select their full names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Lname and Fname from table 'Faculty' where sex = 'M' and building = 'NEB'.\n\n<3> SQL Generation: Use 'where' to filter faculties based on their sex and building, and then select their full names.\n\n",
        "predict": "SELECT CONCAT(Fname, ' ', Lname) AS Full_Name FROM Faculty WHERE Sex = 'M' AND Building = 'NEB'"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Room FROM FACULTY WHERE Rank  =  \"Professor\" AND Building  =  \"NEB\"",
        "question": "What are the rooms for members of the faculty who are professors and who live in building NEB?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter members of the faculty who are professors. Secondly, we need to filter members of the faculty who live in building NEB. Finally, we need to select the rooms for the filtered faculty members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the rooms from table 'Faculty' where the rank is 'professor' and the building is 'NEB'.\n\n<3> SQL Generation: Use 'where' to filter members of the faculty who are professors and who live in building NEB, and then select the rooms for the filtered faculty members.\n\n",
        "predict": "SELECT Room FROM Faculty WHERE Rank = 'professor' AND Building = 'NEB'"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T2.Dname ,  T2.Room FROM COURSE AS T1 JOIN DEPARTMENT AS T2 ON T1.DNO  =  T2.DNO WHERE T1.CName  =  \"INTRODUCTION TO COMPUTER SCIENCE\"",
        "question": "What are the department name and room for the course INTRODUCTION TO COMPUTER SCIENCE?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the course with the name 'INTRODUCTION TO COMPUTER SCIENCE'. Secondly, we need to find the department name and room for that course.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CID from table 'Course' where CName = 'INTRODUCTION TO COMPUTER SCIENCE'. In the second step, we need to select DName and Room from table 'Department' where DNO matches the DNO in the Course table.\n\n<3> SQL Generation: Use 'where' to find the course with the name 'INTRODUCTION TO COMPUTER SCIENCE', and then use 'where' to find the department name and room for that course.\n\n",
        "predict": "SELECT DName, Room FROM Department WHERE DNO = (SELECT DNO FROM Course WHERE CName = 'INTRODUCTION TO COMPUTER SCIENCE')"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT DISTINCT T3.Fname FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T2.gradepoint  >=  3.8",
        "question": "What are the distinct first names for students with a grade point of 3.8 or above in at least one course?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who have a grade point of 3.8 or above in at least one course. Secondly, we need to select the distinct first names of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Enrolled_in' where gradepoint >= 3.8. In the second step, we need to select Fname from table 'Student' and filter by StuID.\n\n<3> SQL Generation: Use 'where' to find the students who have a grade point of 3.8 or above in at least one course, and then use 'distinct' to select the distinct first names of these students.\n\n",
        "predict": "SELECT DISTINCT Fname FROM Student WHERE StuID IN (SELECT StuID FROM Enrolled_in WHERE gradepoint >= 3.8)"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T1.Fname ,  T1.Lname FROM FACULTY AS T1 JOIN MEMBER_OF AS T2 ON T1.FacID  =  T2.FacID WHERE T2.DNO  =  520",
        "question": "What are the full names of faculty members who are a part of department 520?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires finding faculty members who are part of department 520 and retrieving their full names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the full names from the 'Faculty' table where the 'FacID' is present in the 'Member_of' table with 'DNO' as 520.\n\n<3> SQL Generation: Use 'where' to filter faculty members who are part of department 520 and select their full names.\n\n",
        "predict": "SELECT CONCAT(Fname, ' ', Lname) AS Full_Name FROM Faculty WHERE FacID IN (SELECT FacID FROM Member_of WHERE DNO = 520)"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT max(T2.gradepoint) ,  min(T2.gradepoint) FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T3.city_code  =  \"NYC\"",
        "question": "What is the maximum and minimum grade point of students who live in NYC?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who live in NYC. Secondly, we need to calculate the maximum and minimum grade point of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where city_code = 'NYC'. In the second step, we need to select gradepoint from table 'Gradeconversion' and filter by lettergrade from table 'Enrolled_in' where StuID is from the first step.\n\n<3> SQL Generation: Use 'where' to find the students who live in NYC, and then use 'where' to filter the grade points of these students and calculate the maximum and minimum values.\n\n",
        "predict": "SELECT MAX(gradepoint), MIN(gradepoint) FROM Gradeconversion WHERE lettergrade IN (SELECT Grade FROM Enrolled_in WHERE StuID IN (SELECT StuID FROM Student WHERE city_code = 'NYC'))"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "question": "Find the first name of students not enrolled in any course.",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires finding students who are not enrolled in any course. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first name from the 'Student' table and filter out students who have entries in the 'Enrolled_in' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Student' and 'Enrolled_in' tables on the 'StuID' column. Then, we can filter out the rows where the 'CID' column is null, indicating that the student is not enrolled in any course. Finally, we can select the first name of these students.\n\n",
        "predict": "SELECT Fname FROM Student LEFT JOIN Enrolled_in ON Student.StuID = Enrolled_in.StuID WHERE Enrolled_in.CID IS NULL"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "question": "What are the first names of all students that are not enrolled in courses?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires finding students who are not enrolled in any courses and retrieving their first names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select first names from the 'Student' table and filter out the students who have entries in the 'Enrolled_in' table.\n\n<3> SQL Generation: We can use a left join between the 'Student' and 'Enrolled_in' tables on the 'StuID' column. Then, we can filter out the rows where the 'CID' column is null (indicating that the student is not enrolled in any courses). Finally, we can select the first names of these students.\n\n",
        "predict": "SELECT Fname FROM Student LEFT JOIN Enrolled_in ON Student.StuID = Enrolled_in.StuID WHERE Enrolled_in.CID IS NULL"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  \"Department Manager\"",
        "question": "Return the staff ids and genders for any staff with the title Department Manager.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on staff with the title \"Department Manager\". We need to select the staff ids and genders of these staff members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select staff_id and staff_gender from the table 'Staff_Department_Assignments' where job_title_code is 'Department Manager'.\n\n<3> SQL Generation: Use 'where' to filter staff with the title \"Department Manager\" and select their staff ids and genders.\n\n",
        "predict": "SELECT staff_id, staff_gender FROM Staff_Department_Assignments WHERE job_title_code = 'Department Manager'"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT T1.product_id FROM product_suppliers AS T1 JOIN products AS T2 ON T1.product_id  =  T2.product_id WHERE T1.supplier_id  =  2 AND T2.product_price  >  (SELECT avg(product_price) FROM products)",
        "question": "Return ids of all the products that are supplied by supplier id 2 and are more expensive than the average price of all products.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the average price of all products. Secondly, we need to filter products that are supplied by supplier id 2 and have a price higher than the average price.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the average product price from table 'Products'. In the second step, we need to filter product ids from table 'Product_Suppliers' based on supplier id 2 and price higher than the average price.\n\n<3> SQL Generation: Use 'where' to find the average product price, and then use 'where' to filter product ids that are supplied by supplier id 2 and have a price higher than the average price.\n\n",
        "predict": "SELECT product_id FROM Product_Suppliers WHERE supplier_id = 2 AND product_id IN (SELECT product_id FROM Products WHERE product_price > (SELECT AVG(product_price) FROM Products))"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT T1.product_id FROM product_suppliers AS T1 JOIN products AS T2 ON T1.product_id  =  T2.product_id WHERE T1.supplier_id  =  2 AND T2.product_price  >  (SELECT avg(product_price) FROM products)",
        "question": "What are the ids of products from the supplier with id 2, which are more expensive than the average price across all products?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the average price across all products. Secondly, we need to filter products from the supplier with id 2 that have a price higher than the average price.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the average price from table 'Products'. In the second step, we need to filter product_id from table 'Products' based on the supplier_id and price.\n\n<3> SQL Generation: Use 'where' to find the average price across all products, and then use 'where' to filter products from the supplier with id 2 that have a price higher than the average price.\n\n",
        "predict": "SELECT product_id FROM Products WHERE supplier_id = 2 AND product_price > (SELECT AVG(product_price) FROM Products)"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT product_name ,  product_id FROM products WHERE product_price BETWEEN 600 AND 700",
        "question": "What are the names and ids of products costing between 600 and 700?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their cost. Secondly, we need to select the names and ids of the filtered products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information about products, we only need the 'Products' table.\n\n<3> SQL Generation: Use 'where' to filter products based on their cost, and then select the names and ids of the filtered products.\n\n",
        "predict": "SELECT product_name, product_id FROM products WHERE product_price BETWEEN 600 AND 700"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  \"Cancelled\")",
        "question": "What are the distinct ids of customers who made an order after any order that was Cancelled?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the order dates of orders that were Cancelled. Secondly, we need to filter customers who made an order after any of these Cancelled orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select order_date from table 'Customer_Orders' where order_status_code = 'Cancelled'. In the second step, we need to filter customer_id from table 'Customer_Orders' and select distinct customer_ids.\n\n<3> SQL Generation: Use 'where' to find the order dates of orders that were Cancelled, and then use 'where' to filter customers who made an order after any of these Cancelled orders and select the distinct customer_ids.\n\n",
        "predict": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date > (SELECT MAX(order_date) FROM Customer_Orders WHERE order_status_code = 'Cancelled')"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT product_id ,  product_name FROM products WHERE product_price  <  600 OR product_price  >  900",
        "question": "What are id and name of the products whose price is lower than 600 or higher than 900?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their price being lower than 600 or higher than 900. Secondly, we need to select the id and name of the filtered products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Products' table for this query, we can directly use it.\n\n<3> SQL Generation: Use 'where' to filter products based on their price being lower than 600 or higher than 900, and then select the id and name of the filtered products.\n\n",
        "predict": "SELECT product_id, product_name FROM Products WHERE product_price < 600 OR product_price > 900"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE \"%WY%\" AND payment_method_code != \"Credit Card\"",
        "question": "Find the id and name of customers whose address contains WY state and do not use credit card for payment.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter customers whose address contains WY state. Secondly, we need to filter customers who do not use credit card for payment. Finally, we need to select the id and name of the filtered customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id and customer_name from table 'Customers' and filter by customer_address from table 'Addresses'. We also need to filter by payment_method_code from table 'Customers'.\n\n<3> SQL Generation: Use 'like' to filter customers whose address contains WY state, and then use 'not in' to filter customers who do not use credit card for payment. Finally, select the id and name of the filtered customers.\n\n",
        "predict": "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'credit card'"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT Name FROM pilot WHERE Age  <=  30 ORDER BY Name DESC",
        "question": "List names of all pilot aged 30 or younger in descending alphabetical order.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter pilots based on their age being 30 or younger. Secondly, we need to sort the names of the selected pilots in descending alphabetical order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'pilot' table and the 'Name' column, we can directly use the 'pilot' table.\n\n<3> SQL Generation: Use 'where' to filter pilots with age 30 or younger, and then use 'order by' and 'desc' to sort the names in descending alphabetical order.\n\n",
        "predict": "SELECT Name FROM pilot WHERE Age <= 30 ORDER BY Name DESC"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "question": "find the name of pilots who did not win the matches held in the country of Australia.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the matches held in the country of Australia. Secondly, we need to filter out the winning pilots from those matches. Finally, we need to find the names of pilots who did not win.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select matches from table 'match' where country = 'Australia'. In the second step, we need to filter winning pilots from table 'match'. In the final step, we need to select names of pilots from table 'pilot' who did not win.\n\n<3> SQL Generation: Use 'where' to find matches held in the country of Australia, and then use 'not in' to filter winning pilots. Finally, select the names of pilots who did not win.\n\n",
        "predict": "SELECT Name FROM pilot WHERE Pilot_Id NOT IN (SELECT Winning_Pilot FROM match WHERE Country = 'Australia')"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "question": "What are the names of the pilots that have not won any matches in Australia?",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter matches that took place in Australia. Secondly, we need to find the pilots who did not win any matches in Australia.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter matches based on the 'Country' column. In the second step, we need to select the names of pilots who did not win any matches.\n\n<3> SQL Generation: Use 'where' to filter matches that took place in Australia, and then use 'not in' to filter the pilots who did not win any matches.\n\n",
        "predict": "SELECT Name FROM pilot WHERE Pilot_Id NOT IN (SELECT Winning_Pilot FROM match WHERE Country = 'Australia')"
    },
    {
        "db_id": "school_player",
        "gold": "SELECT LOCATION FROM school WHERE School_ID NOT IN (SELECT School_ID FROM Player)",
        "question": "Which schools do not have any player? Give me the school locations.",
        "fields": "Table player, columns = [*,Player_ID,Player,Team,Age,Position,School_ID]\nTable school, columns = [*,School_ID,School,Location,Enrollment,Founded,Denomination,Boys_or_Girls,Day_or_Boarding,Year_Entered_Competition,School_Colors]\nTable school_details, columns = [*,School_ID,Nickname,Colors,League,Class,Division]\nTable school_performance, columns = [*,School_Id,School_Year,Class_A,Class_AA]\n",
        "foreign_keys": "Foreign_keys = [school_details.School_ID = school.School_ID,school_performance.School_Id = school.School_ID,player.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the schools that do not have any player. Secondly, we need to retrieve the locations of those schools.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select School_ID from table 'player' and filter the schools that do not have any player. Then, we need to retrieve the School_ID and Location from table 'school'.\n\n<3> SQL Generation: Use 'where' to filter the schools that do not have any player, and then select the School_ID and Location from table 'school'.\n\n",
        "predict": "SELECT School_ID, Location FROM school WHERE School_ID NOT IN (SELECT School_ID FROM player)"
    },
    {
        "db_id": "store_product",
        "gold": "SELECT District_name ,  City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000",
        "question": "Find the name and population of district with population between 200000 and 2000000",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on districts with population between 200000 and 2000000. Firstly, we need to identify the districts with the specified population range. Secondly, we need to select the name and population of these districts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the district table and its columns 'District_name' and 'City_Population', we only need the 'district' table.\n\n<3> SQL Generation: Use 'where' to filter districts with population between 200000 and 2000000, and then select the name and population of these districts.\n\n",
        "predict": "SELECT District_name, City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000"
    },
    {
        "db_id": "store_product",
        "gold": "SELECT product FROM product WHERE max_page_size  =  \"A4\" OR pages_per_minute_color  <  5",
        "question": "What are the products with the maximum page size eqal to A4 or a pages per minute color less than 5?",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products with a maximum page size equal to A4. Secondly, we need to filter products with a pages per minute color less than 5. Finally, we need to combine the results of these two filters.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'product' table for this query.\n\n<3> SQL Generation: Use 'where' to filter products with a maximum page size equal to A4 or a pages per minute color less than 5.\n\n",
        "predict": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < 5"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(*) FROM Player WHERE HS  >  1000",
        "question": "How many different players trained for more than 1000 hours?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter players who trained for more than 1000 hours. Secondly, we need to count the number of different players who meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'Player' table, we only need to consider this table.\n\n<3> SQL Generation: Use 'where' to filter players who trained for more than 1000 hours, and then use 'count' to count the number of different players who meet this condition.\n\n",
        "predict": "SELECT COUNT(DISTINCT pID) FROM Player WHERE yCard > 1000"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(*) FROM tryout WHERE decision  =  'yes'",
        "question": "How many students got accepted after the tryout?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of students who got accepted after the tryout. We need to filter the tryout records where the decision is \"accepted\" and count the number of unique players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the pID column from the Player table and filter the Tryout table based on the decision column.\n\n<3> SQL Generation: Use 'where' to filter the tryout records where the decision is \"accepted\" and count the number of unique players using the COUNT and DISTINCT functions.\n\n",
        "predict": "SELECT COUNT(DISTINCT pID) FROM Tryout WHERE decision = 'accepted'"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'",
        "question": "How many students whose are playing the role of goalie?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on players who are playing the role of goalie. We need to filter players based on their position.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Player' table for this query.\n\n<3> SQL Generation: Use 'where' to filter players who are playing the role of goalie, and then use 'count' to calculate the number of selected players.\n\n",
        "predict": "SELECT COUNT(*) FROM Player WHERE pPos = 'goalie'"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'",
        "question": "What are the names of all students who successfully tried out for the position of striker?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the position of striker in the table 'Tryout' and returning the names of the students who successfully tried out.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires the names of the students, we only need the 'Player' table.\n\n<3> SQL Generation: Use 'where' to filter the rows in the 'Tryout' table where the position is 'striker' and the decision is 'successful'. Then, join the 'Player' table on the 'pID' column to retrieve the names of the students.\n\n",
        "predict": "SELECT pName FROM Player JOIN Tryout ON Player.pID = Tryout.pID WHERE Tryout.pPos = 'striker' AND Tryout.decision = 'successful'"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'",
        "question": "What is the average and maximum number of hours students who made the team practiced?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter players who made the team. Secondly, we need to calculate the average and maximum number of hours practiced by these players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select pID from table 'Player' where yCard = 'Y' and then join it with table 'Tryout' on pID to get the corresponding practice hours.\n\n<3> SQL Generation: Use 'where' to filter players who made the team, join the 'Player' and 'Tryout' tables on pID, and then calculate the average and maximum number of hours practiced.\n\n",
        "predict": "SELECT AVG(pPos), MAX(pPos) FROM Tryout JOIN Player ON Tryout.pID = Player.pID WHERE yCard = 'Y'"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "question": "Which college has any student who is a goalie and succeeded in the tryout.",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find students who are goalies and succeeded in the tryout. Secondly, we need to find the college that has any student meeting the criteria found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select pID from table 'Player' where pPos = 'goalie' and yCard = 'succeeded'. In the second step, we need to select cName from table 'Tryout' and filter by pID.\n\n<3> SQL Generation: Use 'where' to find students who are goalies and succeeded in the tryout, and then use 'where' to filter colleges that have any student meeting the criteria found in the first step.\n\n",
        "predict": "SELECT cName FROM Tryout WHERE pID IN (SELECT pID FROM Player WHERE pPos = 'goalie' AND yCard = 'succeeded')"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "question": "What college has a student who successfully made the team in the role of a goalie?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: The query requires finding a college that has a student who successfully made the team in the role of a goalie. Firstly, we need to filter tryouts based on the position 'goalie'. Secondly, we need to find the corresponding college for the selected tryouts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select pID from table 'tryout' where pPos = 'goalie'. In the second step, we need to select cName from table 'tryout' and find the corresponding college.\n\n<3> SQL Generation: Use 'where' to filter tryouts with the position 'goalie', and then use 'where' to find the corresponding college.\n\n",
        "predict": "SELECT cName FROM college WHERE cName IN (SELECT cName FROM tryout WHERE pPos = 'goalie' AND decision = 'successful')"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT sum(enr) FROM college WHERE cName NOT IN (SELECT cName FROM tryout WHERE pPos  =  \"goalie\")",
        "question": "What is the total number of enrollment of schools that do not have any goalie player?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the schools that do not have any goalie player. Secondly, we need to calculate the total enrollment of these schools.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select cName from table 'College' where there is no corresponding pID in table 'Player' with pPos = 'goalie'. In the second step, we need to sum the enr column from table 'College' for the selected schools.\n\n<3> SQL Generation: Use 'where' and 'not in' to find the schools that do not have any goalie player, and then use 'sum' to calculate the total enrollment of these schools.\n\n",
        "predict": "SELECT SUM(enr) FROM College WHERE cName NOT IN (SELECT cName FROM Tryout JOIN Player ON Tryout.pID = Player.pID WHERE pPos = 'goalie')"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(DISTINCT state) FROM college WHERE enr  >  (SELECT avg(enr) FROM college)",
        "question": "How many states have a college with more students than average?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average number of students in colleges. Secondly, we need to count the number of states that have a college with more students than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the state and enrollment from the 'College' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter colleges with more students than the average, and then count the number of states.\n\n",
        "predict": "SELECT COUNT(DISTINCT state) FROM College GROUP BY state HAVING enr > (SELECT AVG(enr) FROM College)"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(DISTINCT state) FROM college WHERE enr  <  (SELECT avg(enr) FROM college)",
        "question": "What is the number of states that has some colleges whose enrollment is smaller than the average enrollment?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average enrollment of colleges. Secondly, we need to find the states that have colleges with enrollment smaller than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select state and enrollment from table 'College'.\n\n<3> SQL Generation: Use 'avg' to calculate the average enrollment of colleges, and then use 'where' to filter colleges with enrollment smaller than the average. Finally, use 'distinct' to count the number of states.\n\n",
        "predict": "SELECT COUNT(DISTINCT state) FROM College WHERE enr < (SELECT AVG(enr) FROM College)"
    },
    {
        "db_id": "device",
        "gold": "SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1",
        "question": "What is the shop name corresponding to the shop that opened in the most recent year?",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the most recent year in the 'Open_Year' column of the 'shop' table. Secondly, we need to find the shop name corresponding to that year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'shop' table for this query.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the most recent year from the 'Open_Year' column of the 'shop' table, and then use 'where' to filter the shop name corresponding to that year.\n\n",
        "predict": "SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1"
    },
    {
        "db_id": "device",
        "gold": "SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock)",
        "question": "List the names of shops that have no devices in stock.",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding shops that have no devices in stock. Firstly, we need to identify the shops that have devices in stock. Secondly, we need to filter out the shops that do not have any devices in stock.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Shop_ID from table 'stock' and filter by Device_ID. Then, we need to select Shop_Name from table 'shop' and filter out the shops that do not have any devices in stock.\n\n<3> SQL Generation: Use 'distinct' to select the unique Shop_ID from table 'stock'. Then, use 'not in' to filter out the shops that have devices in stock. Finally, select the Shop_Name from table 'shop'.\n\n",
        "predict": "SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT DISTINCT Shop_ID FROM stock)"
    },
    {
        "db_id": "device",
        "gold": "SELECT Carrier FROM device WHERE Device_ID NOT IN (SELECT Device_ID FROM stock)",
        "question": "List the carriers of devices that have no devices in stock.",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the devices that have no devices in stock. Secondly, we need to list the carriers of those devices.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Device_ID from table 'stock' where Quantity = 0. In the second step, we need to select Carrier from table 'device' where Device_ID matches the selected Device_ID from the first step.\n\n<3> SQL Generation: Use 'where' to find the devices that have no devices in stock, and then use 'where' to select the carriers of those devices.\n\n",
        "predict": "SELECT Carrier FROM device WHERE Device_ID IN (SELECT Device_ID FROM stock WHERE Quantity = 0)"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "gold": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100",
        "question": "Give me the descriptions of the service types that cost more than 100.",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter service types based on their cost. Secondly, we need to retrieve the descriptions of the selected service types.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the descriptions of the service types, we can directly use the 'Ref_Service_Types' table.\n\n<3> SQL Generation: Use 'where' to filter service types with a cost greater than 100, and then select the descriptions of the selected service types.\n\n",
        "predict": "SELECT Service_Type_Description FROM Ref_Service_Types WHERE Service_Type_Code IN (SELECT Service_Type_Code FROM Services WHERE Product_Price > 100)"
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "gold": "SELECT sum(T1.Order_Quantity) FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_Name  =  \"photo\"",
        "question": "What are the total order quantities of photo products?",
        "fields": "Table Addresses, columns = [*,Address_ID,Line_1,Line_2,City_Town,State_County,Other_Details]\nTable Bookings, columns = [*,Booking_ID,Customer_ID,Workshop_Group_ID,Status_Code,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Bookings_Services, columns = [*,Order_ID,Product_ID]\nTable Clients, columns = [*,Client_ID,Address_ID,Customer_Email_Address,Customer_Name,Customer_Phone,Other_Details]\nTable Customer_Orders, columns = [*,Order_ID,Customer_ID,Store_ID,Order_Date,Planned_Delivery_Date,Actual_Delivery_Date,Other_Order_Details]\nTable Customers, columns = [*,Customer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Drama_Workshop_Groups, columns = [*,Workshop_Group_ID,Address_ID,Currency_Code,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\nTable Invoice_Items, columns = [*,Invoice_Item_ID,Invoice_ID,Order_ID,Order_Item_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Invoices, columns = [*,Invoice_ID,Order_ID,payment_method_code,Product_ID,Order_Quantity,Other_Item_Details,Order_Item_ID]\nTable Marketing_Regions, columns = [*,Marketing_Region_Code,Marketing_Region_Name,Marketing_Region_Descriptrion,Other_Details]\nTable Order_Items, columns = [*,Order_Item_ID,Order_ID,Product_ID,Order_Quantity,Other_Item_Details]\nTable Performers, columns = [*,Performer_ID,Address_ID,Customer_Name,Customer_Phone,Customer_Email_Address,Other_Details]\nTable Performers_in_Bookings, columns = [*,Order_ID,Performer_ID]\nTable Products, columns = [*,Product_ID,Product_Name,Product_Price,Product_Description,Other_Product_Service_Details]\nTable Ref_Payment_Methods, columns = [*,payment_method_code,payment_method_description]\nTable Ref_Service_Types, columns = [*,Service_Type_Code,Parent_Service_Type_Code,Service_Type_Description]\nTable Services, columns = [*,Service_ID,Service_Type_Code,Workshop_Group_ID,Product_Description,Product_Name,Product_Price,Other_Product_Service_Details]\nTable Stores, columns = [*,Store_ID,Address_ID,Marketing_Region_Code,Store_Name,Store_Phone,Store_Email_Address,Other_Details]\n",
        "foreign_keys": "Foreign_keys = [Clients.Address_ID = Addresses.Address_ID,Drama_Workshop_Groups.Address_ID = Addresses.Address_ID,Performers.Address_ID = Addresses.Address_ID,Customers.Address_ID = Addresses.Address_ID,Stores.Marketing_Region_Code = Marketing_Regions.Marketing_Region_Code,Stores.Address_ID = Addresses.Address_ID,Bookings.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings.Customer_ID = Clients.Client_ID,Performers_in_Bookings.Order_ID = Bookings.Booking_ID,Performers_in_Bookings.Performer_ID = Performers.Performer_ID,Customer_Orders.Store_ID = Stores.Store_ID,Customer_Orders.Customer_ID = Customers.Customer_ID,Order_Items.Product_ID = Products.Product_ID,Order_Items.Order_ID = Customer_Orders.Order_ID,Invoices.payment_method_code = Ref_Payment_Methods.payment_method_code,Invoices.Order_ID = Bookings.Booking_ID,Invoices.Order_ID = Customer_Orders.Order_ID,Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code,Services.Workshop_Group_ID = Drama_Workshop_Groups.Workshop_Group_ID,Bookings_Services.Product_ID = Services.Service_ID,Bookings_Services.Order_ID = Bookings.Booking_ID,Invoice_Items.Order_ID = Bookings_Services.Order_ID,Invoice_Items.Product_ID = Bookings_Services.Product_ID,Invoice_Items.Invoice_ID = Invoices.Invoice_ID,Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the photo products. Secondly, we need to calculate the total order quantities of these products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the order quantities from the 'Order_Items' table and join it with the 'Products' table on the 'Product_ID' column.\n\n<3> SQL Generation: Use 'join' to combine the 'Order_Items' and 'Products' tables on the 'Product_ID' column. Then, filter the rows where the 'Product_Description' contains the word 'photo'. Finally, calculate the sum of the 'Order_Quantity' column.\n\n",
        "predict": "SELECT SUM(Order_Items.Order_Quantity) FROM Order_Items JOIN Products ON Order_Items.Product_ID = Products.Product_ID WHERE Products.Product_Description LIKE '%photo%'"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Badlands\" AND T1.StagePosition  =  \"back\"",
        "question": "Who is performing in the back stage position for the song \"Badlands\"? Show the first name and the last name.",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Badlands\". Secondly, we need to find the bandmate performing in the back stage position for that song. Finally, we need to show their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Badlands\". In the second step, we need to select the BandmateId from the table 'Performance' where the SongId matches the one found in the first step. In the final step, we need to select the Firstname and Lastname from the table 'Band' where the Id matches the BandmateId found in the second step.\n\n<3> SQL Generation: Use 'where' to find the SongId for the song \"Badlands\", then use 'where' to find the BandmateId for the back stage position of that song, and finally use 'where' to find the Firstname and Lastname of the bandmate.\n\n",
        "predict": "SELECT Band.Firstname, Band.Lastname FROM Songs JOIN Performance ON Songs.SongId = Performance.SongId JOIN Band ON Performance.Bandmate = Band.Id WHERE Songs.Title = \"Badlands\" AND Performance.StagePosition = \"back stage\""
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Le Pop\"",
        "question": "What instrument did the musician with last name \"Heilo\" use in the song \"Le Pop\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the musician with last name \"Heilo\". Secondly, we need to find the song \"Le Pop\" and the corresponding musician's instrument.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'Band' where Lastname = \"Heilo\". In the second step, we need to find the SongId from table 'Songs' where Title = \"Le Pop\" and the corresponding BandmateId from table 'Instruments'.\n\n<3> SQL Generation: Use 'where' to find the musician with last name \"Heilo\", and then use 'where' to find the song \"Le Pop\" and the corresponding musician's instrument.\n\n",
        "predict": "SELECT Instrument FROM Instruments WHERE BandmateId = (SELECT Id FROM Band WHERE Lastname = \"Heilo\") AND SongId = (SELECT SongId FROM Songs WHERE Title = \"Le Pop\")"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "question": "How many instruments does the song \"Le Pop\" use?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Le Pop\". Secondly, we need to count the number of instruments used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Le Pop\". In the second step, we need to count the number of instruments from the table 'Instruments' where the SongId matches the SongId found in the first step.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Le Pop\", and then use 'count' to count the number of instruments in the table 'Instruments' where the SongId matches the SongId found in the first step.\n\n",
        "predict": "SELECT COUNT(*) FROM Instruments WHERE SongId = (SELECT SongId FROM Songs WHERE Title = 'Le Pop')"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "question": "How many different instruments are used in the song \"Le Pop\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Le Pop\". Secondly, we need to identify the different instruments used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the song_id from table 'Songs' where the title is \"Le Pop\". In the second step, we need to select the distinct instruments from table 'Instruments' based on the song_id.\n\n<3> SQL Generation: Use 'where' to find the song with the title \"Le Pop\", and then use 'distinct' to select the different instruments used in that song.\n\n",
        "predict": "SELECT COUNT(DISTINCT Instrument) FROM Instruments WHERE SongId = (SELECT SongId FROM Songs WHERE Title = 'Le Pop')"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN Band AS T2 ON T1.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\"",
        "question": "How many different instruments does the musician with the last name \"Heilo\" use?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the musician with the last name \"Heilo\". Secondly, we need to count the number of different instruments used by this musician.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'Band' where Lastname = \"Heilo\". In the second step, we need to select distinct Instrument from table 'Instruments' where BandmateId is the Id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the musician with the last name \"Heilo\", and then use 'where' and 'distinct' to count the number of different instruments used by this musician.\n\n",
        "predict": "SELECT COUNT(DISTINCT Instrument) FROM Instruments WHERE BandmateId = (SELECT Id FROM Band WHERE Lastname = \"Heilo\")"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "question": "How many songs have a lead vocal?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: We need to count the number of songs that have a lead vocal.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the SongId from the Vocals table where the Type is 'lead'.\n\n<3> SQL Generation: Use 'where' to filter the songs with a lead vocal and count them.\n\n",
        "predict": "SELECT COUNT(DISTINCT SongId) FROM Vocals WHERE Type = 'lead'"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "question": "How many songs have vocals of type lead?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of songs that have vocals of type lead.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the SongId from the Vocals table where the Type is lead.\n\n<3> SQL Generation: Use 'where' to filter the rows where the Type is lead in the Vocals table, and then count the number of distinct SongIds.\n\n",
        "predict": "SELECT COUNT(DISTINCT SongId) FROM Vocals WHERE Type = 'lead'"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid JOIN band AS T3 ON T1.bandmate  =  T3.id WHERE T3.firstname  =  \"Solveig\" AND T2.title  =  \"A Bar In Amsterdam\"",
        "question": "Which vocal type did the musician with first name \"Solveig\" played in the song with title \"A Bar in Amsterdam\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the musician with first name \"Solveig\". Secondly, we need to find the song with title \"A Bar in Amsterdam\" and the corresponding musician's vocal type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'Band' where Firstname = \"Solveig\". In the second step, we need to select SongId from table 'Songs' where Title = \"A Bar in Amsterdam\" and find the corresponding vocal type from table 'Vocals'.\n\n<3> SQL Generation: Use 'where' to find the musician with first name \"Solveig\", and then use 'where' to find the song with title \"A Bar in Amsterdam\" and the corresponding musician's vocal type.\n\n",
        "predict": "SELECT Vocals.Type FROM Vocals JOIN Band ON Vocals.Bandmate = Band.Id JOIN Songs ON Vocals.SongId = Songs.SongId WHERE Band.Firstname = \"Solveig\" AND Songs.Title = \"A Bar in Amsterdam\""
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Badlands\"",
        "question": "How many different instruments are used in the song \"Badlands\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Badlands\". Secondly, we need to identify the different instruments used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Badlands\". In the second step, we need to select the distinct instruments from the table 'Instruments' based on the SongId.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Badlands\", and then use 'distinct' to select the different instruments used in that song.\n\n",
        "predict": "SELECT COUNT(DISTINCT Instrument) FROM Instruments WHERE SongId = (SELECT SongId FROM Songs WHERE Title = 'Badlands')"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(*) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "question": "How many vocal types are used in the song \"Le Pop\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Le Pop\". Secondly, we need to count the number of unique vocal types used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Le Pop\". In the second step, we need to count the distinct vocal types from the table 'Vocals' based on the SongId.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Le Pop\", and then use 'count(distinct)' to count the number of unique vocal types based on the SongId.\n\n",
        "predict": "SELECT COUNT(DISTINCT Type) FROM Vocals WHERE SongId = (SELECT SongId FROM Songs WHERE Title = \"Le Pop\")"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"shared\"",
        "question": "How many different songs have shared vocals?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the songs that have shared vocals. Secondly, we need to count the number of different songs that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select distinct SongId from table 'Vocals'.\n\n<3> SQL Generation: Use 'distinct' and 'count' to select the number of different songs that have shared vocals.\n\n",
        "predict": "SELECT COUNT(DISTINCT SongId) FROM Vocals"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Der Kapitan\" AND T1.StagePosition  =  \"back\"",
        "question": "What is the first and last name of the artist who performed back stage for the song \"Der Kapitan\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song \"Der Kapitan\" in the table 'Songs'. Secondly, we need to find the bandmate who performed back stage for that song in the table 'Performance'. Finally, we need to find the first and last name of that bandmate in the table 'Band'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select SongId from table 'Songs' where Title = \"Der Kapitan\". In the second step, we need to select Bandmate from table 'Performance' where SongId matches the SongId found in the first step. In the final step, we need to select Firstname and Lastname from table 'Band' where Id matches the Bandmate found in the second step.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Der Kapitan\" in the table 'Songs'. Then, use 'where' to find the Bandmate who performed back stage for that song in the table 'Performance'. Finally, use 'where' to find the first and last name of that bandmate in the table 'Band'.\n\n",
        "predict": "SELECT Firstname, Lastname FROM Band WHERE Id = (SELECT Bandmate FROM Performance WHERE SongId = (SELECT SongId FROM Songs WHERE Title = \"Der Kapitan\") AND StagePosition = \"back stage\")"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT T3.title) FROM albums AS T1 JOIN tracklists AS T2 ON T1.aid  =  T2.albumid JOIN songs AS T3 ON T2.songid  =  T3.songid WHERE t1.type  =  \"Studio\"",
        "question": "How many songs appear in studio albums?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the songs that appear in studio albums. Secondly, we need to count the number of these songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are interested in studio albums, we need to select songs from the 'Songs' table that are included in studio albums. To determine if an album is a studio album, we can check the 'Type' column in the 'Albums' table.\n\n<3> SQL Generation: Use 'where' to filter songs that appear in studio albums and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM songs WHERE songId IN (SELECT songId FROM tracklists WHERE albumId IN (SELECT aId FROM albums WHERE type = 'studio'))"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT count(*) FROM manufacturers WHERE founder  =  'Andy'",
        "question": "How many companies were created by Andy?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies created by Andy. Secondly, we need to count the number of companies found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for companies created by Andy, we need to select the companies from the 'Manufacturers' table where the 'Founder' column is 'Andy'.\n\n<3> SQL Generation: Use 'where' to filter the companies created by Andy, and then use 'count' to count the number of companies.\n\n",
        "predict": "SELECT COUNT(*) FROM Manufacturers WHERE Founder = 'Andy'"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT sum(revenue) FROM manufacturers WHERE headquarter  =  'Austin'",
        "question": "What is the sum of revenue from companies with headquarters in Austin?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies with headquarters in Austin. Secondly, we need to calculate the sum of their revenue.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Manufacturers' table to filter companies with headquarters in Austin.\n\n<3> SQL Generation: Use 'where' to filter companies with headquarters in Austin, and then use 'sum' to calculate the sum of their revenue.\n\n",
        "predict": "SELECT SUM(Revenue) FROM Manufacturers WHERE Headquarter = 'Austin'"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name ,  headquarter ,  revenue FROM manufacturers ORDER BY revenue DESC",
        "question": "Find the name, headquarter and revenue of all manufacturers sorted by their revenue in the descending order.",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: We need to select the name, headquarter, and revenue of all manufacturers. Then, we need to sort them by revenue in descending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the name, headquarter, and revenue columns from the Manufacturers table.\n\n<3> SQL Generation: Use 'SELECT' to select the desired columns from the Manufacturers table. Then, use 'ORDER BY' to sort the results by revenue in descending order.\n\n",
        "predict": "SELECT Name, Headquarter, Revenue FROM Manufacturers ORDER BY Revenue DESC"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "question": "Find the name of companies whose revenue is greater than the average revenue of all companies.",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average revenue of all companies. Secondly, we need to filter companies based on their revenue being greater than the average revenue.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have two tables, 'Manufacturers' and 'Products', we only need the 'Manufacturers' table.\n\n<3> SQL Generation: Use 'select avg(revenue)' to calculate the average revenue of all companies, and then use 'where' to filter companies with revenue greater than the average revenue.\n\n",
        "predict": "SELECT Name FROM Manufacturers WHERE Revenue > (SELECT AVG(Revenue) FROM Manufacturers)"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "question": "What are the names of manufacturers with revenue greater than the average of all revenues?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average revenue of all manufacturers. Secondly, we need to filter manufacturers based on their revenue being greater than the average revenue.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Manufacturers' table for this query.\n\n<3> SQL Generation: Use 'select' to calculate the average revenue of all manufacturers, and then use 'where' to filter manufacturers based on their revenue being greater than the average revenue.\n\n",
        "predict": "SELECT Name FROM Manufacturers WHERE Revenue > (SELECT AVG(Revenue) FROM Manufacturers)"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT count(DISTINCT name) FROM products WHERE name NOT IN (SELECT T1.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code WHERE T2.name  =  'Sony')",
        "question": "How many products are not made by Sony?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on products that are not made by Sony. Firstly, we need to identify the products made by Sony. Secondly, we need to count the number of products that are not made by Sony.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Code from table 'Manufacturers' where Name = 'Sony'. In the second step, we need to filter products based on their Manufacturer column.\n\n<3> SQL Generation: Use 'where' to find the products made by Sony, and then use 'where' to filter products that are not made by Sony and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Products WHERE Manufacturer != (SELECT Code FROM Manufacturers WHERE Name = 'Sony')"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name FROM products WHERE price  <=  200",
        "question": "What are the names of products with price at most 200?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on products with a price at most 200. We need to select the names of these products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Products' table.\n\n<3> SQL Generation: Use 'where' to filter products with a price at most 200 and select their names.\n\n",
        "predict": "SELECT Name FROM Products WHERE Price <= 200"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT problem_log_id FROM problem_log ORDER BY log_entry_date DESC LIMIT 1",
        "question": "Which problem log was created most recently? Give me the log id.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the problem log that was created most recently. We need to identify the log entry date and log entry id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select log_entry_date and problem_log_id from table 'Problem_Log'.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the problem log with the most recent log entry date, and then select the corresponding log entry id.\n\n",
        "predict": "SELECT problem_log_id FROM Problem_Log ORDER BY log_entry_date DESC LIMIT 1"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT DISTINCT T2.problem_id ,  T2.problem_log_id FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"",
        "question": "Which problem id and log id are assigned to the staff named Rylan Homenick?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the staff with the name \"Rylan Homenick\". Secondly, we need to find the problem ids and log ids that are assigned to this staff.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select problem_id and log_id from table 'Problem_Log' where assigned_to_staff_id is the staff_id of the staff named \"Rylan Homenick\".\n\n<3> SQL Generation: Use 'where' to find the staff_id of the staff named \"Rylan Homenick\", and then use 'where' to filter problem_id and log_id from table 'Problem_Log' based on the staff_id.\n\n",
        "predict": "SELECT problem_id, problem_log_id FROM Problem_Log WHERE assigned_to_staff_id = (SELECT staff_id FROM Staff WHERE staff_first_name = 'Rylan' AND staff_last_name = 'Homenick')"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT count(*) FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id WHERE T1.product_name = \"voluptatem\"",
        "question": "How many problems are there for product voluptatem?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the product_id for the product \"voluptatem\". Secondly, we need to count the number of problems with that product_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Product' where product_name = \"voluptatem\". In the second step, we need to count the number of problems with the selected product_id from table 'Problems'.\n\n<3> SQL Generation: Use 'where' to find the product_id for the product \"voluptatem\", and then use 'where' to count the number of problems with that product_id.\n\n",
        "predict": "SELECT COUNT(*) FROM Problems WHERE product_id = (SELECT product_id FROM Product WHERE product_name = \"voluptatem\")"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT DISTINCT product_name FROM product ORDER BY product_name",
        "question": "List the names of all the distinct product names in alphabetical order?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: The query requires listing distinct product names in alphabetical order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'product_name' column, we can use the 'Product' table.\n\n<3> SQL Generation: Use 'SELECT DISTINCT' to select distinct product names from the 'Product' table and order them alphabetically.\n\n",
        "predict": "SELECT DISTINCT product_name FROM Product ORDER BY product_name ASC"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  <  ( SELECT min(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Lysanne\" AND T4.staff_last_name = \"Turcotte\" )",
        "question": "What are the ids of the problems reported before the date of any problem reported by Lysanne Turcotte?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the date of any problem reported by Lysanne Turcotte. Secondly, we need to filter problems with a date reported before the date found in the first step and select their ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select date_problem_reported from table 'Problems' where reported_by_staff_id = (select staff_id from Staff where staff_first_name = 'Lysanne' and staff_last_name = 'Turcotte'). In the second step, we need to filter problem_id from table 'Problems' based on the date_problem_reported.\n\n<3> SQL Generation: Use 'where' to find the date of any problem reported by Lysanne Turcotte, and then use 'where' to filter problems with a date reported before the date found in the first step and select their ids.\n\n",
        "predict": "SELECT problem_id FROM Problems WHERE date_problem_reported < (SELECT date_problem_reported FROM Problems WHERE reported_by_staff_id = (SELECT staff_id FROM Staff WHERE staff_first_name = 'Lysanne' AND staff_last_name = 'Turcotte'))"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "question": "What are the ids of the problems reported after the date of any problems reported by Rylan Homenick?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the date of problems reported by Rylan Homenick. Secondly, we need to filter problems reported after that date and select their ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select date_problem_reported from table 'Problems' where reported_by_staff_id = (select staff_id from Staff where staff_first_name = 'Rylan' and staff_last_name = 'Homenick'). In the second step, we need to filter problem_id from table 'Problems' based on the date_problem_reported.\n\n<3> SQL Generation: Use 'where' to find the date of problems reported by Rylan Homenick, and then use 'where' to filter problems reported after that date and select their ids.\n\n",
        "predict": "SELECT problem_id FROM Problems WHERE date_problem_reported > (SELECT date_problem_reported FROM Problems WHERE reported_by_staff_id = (SELECT staff_id FROM Staff WHERE staff_first_name = 'Rylan' AND staff_last_name = 'Homenick'))"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "question": "Find the ids of the problems reported after the date of any problems reported by the staff Rylan Homenick.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the date of problems reported by the staff Rylan Homenick. Secondly, we need to filter problems reported after that date and select their ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select date_problem_reported from table 'Problems' where reported_by_staff_id = (select staff_id from Staff where staff_first_name = 'Rylan' and staff_last_name = 'Homenick'). In the second step, we need to filter problem_id from table 'Problems' based on the date_problem_reported.\n\n<3> SQL Generation: Use 'where' to find the date of problems reported by the staff Rylan Homenick, and then use 'where' to filter problems reported after that date and select their ids.\n\n",
        "predict": "SELECT problem_id FROM Problems WHERE date_problem_reported > (SELECT date_problem_reported FROM Problems WHERE reported_by_staff_id = (SELECT staff_id FROM Staff WHERE staff_first_name = 'Rylan' AND staff_last_name = 'Homenick'))"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT count(*) FROM branch WHERE membership_amount  >  (SELECT avg(membership_amount) FROM branch)",
        "question": "What is the number of branches that have more than the average number of memberships?",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average number of memberships across all branches. Secondly, we need to count the number of branches that have more memberships than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the number of memberships from table 'membership_register_branch' and group them by branch. Then, we need to compare this count with the average count.\n\n<3> SQL Generation: Use 'group by' and 'having' to calculate the average number of memberships and count the number of branches that have more memberships than the average.\n\n",
        "predict": "SELECT COUNT(*) FROM (SELECT Branch_ID, COUNT(*) AS membership_count FROM membership_register_branch GROUP BY Branch_ID HAVING membership_count > (SELECT AVG(membership_count) FROM (SELECT Branch_ID, COUNT(*) AS membership_count FROM membership_register_branch GROUP BY Branch_ID) AS T)) AS T2"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT DISTINCT city FROM branch WHERE membership_amount  >=  100",
        "question": "Show all distinct city where branches with at least 100 memberships are located.",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find branches with at least 100 memberships. Secondly, we need to select the distinct cities where these branches are located.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Branch_ID from table 'membership_register_branch' where the count of Member_ID is greater than or equal to 100. Then, we need to select distinct City from table 'branch' where Branch_ID matches the selected Branch_IDs.\n\n<3> SQL Generation: Use 'group by' and 'having' to find branches with at least 100 memberships, and then use 'distinct' to select the cities where these branches are located.\n\n",
        "predict": "SELECT DISTINCT City FROM branch WHERE Branch_ID IN (SELECT Branch_ID FROM membership_register_branch GROUP BY Branch_ID HAVING COUNT(Member_ID) >= 100)"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)",
        "question": "List the branch name and city without any registered members.",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding branches without any registered members. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select branch name and city from the 'branch' table and check if there are any corresponding entries in the 'membership_register_branch' table.\n\n<3> SQL Generation: Use a left join to combine the 'branch' and 'membership_register_branch' tables on the 'Branch_ID' column. Then, filter the rows where the 'Member_ID' is null, indicating that there are no registered members for that branch.\n\n",
        "predict": "SELECT Name, City FROM branch LEFT JOIN membership_register_branch ON branch.Branch_ID = membership_register_branch.Branch_ID WHERE membership_register_branch.Member_ID IS NULL"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT sum(total_pounds) FROM purchase AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.city  =  'London' AND T1.year  =  2018",
        "question": "What is the sum of total pounds of purchase in year 2018 for all branches in London?",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter branches in London. Secondly, we need to filter purchases in year 2018. Finally, we need to calculate the sum of total pounds for the selected purchases.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Branch_ID from table 'branch' where City = 'London'. In the second step, we need to filter Total_pounds from table 'purchase' where Year = 2018. In the final step, we need to calculate the sum of Total_pounds.\n\n<3> SQL Generation: Use 'where' to filter branches in London, and then use 'where' to filter purchases in year 2018. Finally, use 'sum' to calculate the sum of Total_pounds.\n\n",
        "predict": "SELECT SUM(Total_pounds) FROM purchase WHERE Year = 2018 AND Branch_ID IN (SELECT Branch_ID FROM branch WHERE City = 'London')"
    },
    {
        "db_id": "voter_2",
        "gold": "SELECT Fname FROM STUDENT WHERE Age  >  22",
        "question": "What are the first names of all the students aged above 22?",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on students aged above 22. We need to select the first names of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table.\n\n<3> SQL Generation: Use 'where' to filter students aged above 22 and select their first names.\n\n",
        "predict": "SELECT Fname FROM Student WHERE Age > 22"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT product_name FROM products WHERE product_category_code  =  \"Spices\"",
        "question": "What are the names of products with category \"Spices\"?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on products with category \"Spices\". We need to select the names of these products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the product names from the 'Products' table where the product category is \"Spices\".\n\n<3> SQL Generation: Use 'where' to filter products with category \"Spices\" and select their names.\n\n",
        "predict": "SELECT product_name FROM Products WHERE product_category_code = (SELECT product_category_code FROM Ref_Product_Categories WHERE product_category_description = 'Spices')"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(*) FROM products WHERE product_category_code  =  \"Spices\" AND typical_buying_price  >  1000",
        "question": "How many products are in the 'Spices' category and have a typical price of over 1000?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their category, 'Spices'. Secondly, we need to filter the selected products based on their typical selling price, which should be over 1000. Finally, we need to count the number of products that meet both conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select product_id from table 'Products' where product_category_code = 'Spices' and typical_selling_price > 1000.\n\n<3> SQL Generation: Use 'where' to filter products based on their category and typical selling price, and then use 'count' to count the number of products that meet both conditions.\n\n",
        "predict": "SELECT COUNT(*) FROM Products WHERE product_category_code = 'Spices' AND typical_selling_price > 1000"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'",
        "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their product descriptions containing the letter 't'. Secondly, we need to find the corresponding product category codes for these products. Finally, we need to retrieve the descriptions of these product categories.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter product descriptions from table 'Products'. In the second step, we need to select product category codes from table 'Products' based on the filtered products. In the final step, we need to retrieve the descriptions of these product categories from table 'Ref_Product_Categories'.\n\n<3> SQL Generation: Use 'where' to filter products with product descriptions containing the letter 't', then use 'distinct' to select the corresponding product category codes. Finally, join the result with the 'Ref_Product_Categories' table to retrieve the descriptions of these product categories.\n\n",
        "predict": "SELECT DISTINCT product_category_description FROM Ref_Product_Categories JOIN Products ON Ref_Product_Categories.product_category_code = Products.product_category_code WHERE product_description LIKE '%t%'"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"sesame\"",
        "question": "Count the number of different characteristic names the product 'cumin' has.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the product_id of the product 'cumin'. Secondly, we need to find the characteristic_ids associated with the product_id. Finally, we count the number of different characteristic names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Products' where product_name = 'cumin'. In the second step, we need to select characteristic_ids from table 'Product_Characteristics' where product_id = the product_id found in the first step. In the final step, we need to select characteristic_names from table 'Characteristics' where characteristic_id = the characteristic_ids found in the second step.\n\n<3> SQL Generation: Use 'where' to find the product_id of the product 'cumin', then use 'where' to find the characteristic_ids associated with the product_id, and finally use 'count' and 'distinct' to count the number of different characteristic names.\n\n",
        "predict": "SELECT COUNT(DISTINCT characteristic_name) FROM Characteristics WHERE characteristic_id IN (SELECT characteristic_id FROM Product_Characteristics WHERE product_id = (SELECT product_id FROM Products WHERE product_name = 'cumin'))"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT product_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"red\" AND t3.characteristic_name  =  \"fast\"",
        "question": "What are the names of the products that have a color description of 'red' and the 'fast' characteristic?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the color code for the color description 'red'. Secondly, we need to find the characteristic_id for the characteristic 'fast'. Finally, we need to filter the products based on their color code and characteristic id, and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select color_code from table 'Ref_Colors' where color_description = 'red'. In the second step, we need to select characteristic_id from table 'Characteristics' where characteristic_name = 'fast'. In the final step, we need to filter product names from table 'Products' based on the color code and characteristic id.\n\n<3> SQL Generation: Use 'where' to find the color code for the color description 'red', and then use 'where' to find the characteristic id for the characteristic 'fast'. Finally, use 'where' to filter the products based on their color code and characteristic id, and select their names.\n\n",
        "predict": "SELECT product_name FROM Products WHERE color_code = (SELECT color_code FROM Ref_Colors WHERE color_description = 'red') AND product_id IN (SELECT product_id FROM Product_Characteristics WHERE characteristic_id = (SELECT characteristic_id FROM Characteristics WHERE characteristic_name = 'fast'))"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t3.characteristic_name  =  \"hot\"",
        "question": "How many products have the characteristic named \"hot\"?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the characteristic named \"hot\" and counting the number of products that have this characteristic.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the characteristic_id from the Characteristics table where the characteristic_name is \"hot\". Then, we need to count the number of products that have this characteristic in the Product_Characteristics table.\n\n<3> SQL Generation: Use 'where' to find the characteristic_id of the characteristic named \"hot\", and then use 'where' to filter the Product_Characteristics table and count the number of products.\n\n",
        "predict": "SELECT COUNT(DISTINCT product_id) FROM Product_Characteristics WHERE characteristic_id = (SELECT characteristic_id FROM Characteristics WHERE characteristic_name = 'hot')"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"white\" OR t3.characteristic_name  =  \"hot\"",
        "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their color described as 'white'. Secondly, we need to filter products based on their characteristic with the name 'hot'. Finally, we need to count the number of products that meet either of these conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter products based on their color and characteristic, we need tables ['Products', 'Ref_Colors', 'Characteristics'].\n\n<3> SQL Generation: We need to join the 'Products' table with the 'Ref_Colors' table on the 'color_code' column and filter the rows where the color description is 'white'. Then, we need to join the 'Products' table with the 'Characteristics' table using the 'Product_Characteristics' table as a bridge and filter the rows where the characteristic name is 'hot'. Finally, we count the number of distinct product IDs that meet either of these conditions.\n\n",
        "predict": "SELECT COUNT(DISTINCT Products.product_id) FROM Products LEFT JOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code LEFT JOIN Product_Characteristics ON Products.product_id = Product_Characteristics.product_id LEFT JOIN Characteristics ON Product_Characteristics.characteristic_id = Characteristics.characteristic_id WHERE Ref_Colors.color_description = 'white' OR Characteristics.characteristic_name = 'hot'"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )",
        "question": "Count the number of colors that are not used in any products.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find all the colors used in products. Secondly, we need to count the number of colors that are not used.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select color_code from table 'Products'.\n\n<3> SQL Generation: Use 'distinct' to select unique color codes from table 'Products', and then use 'not in' to filter colors that are not used. Finally, count the number of colors.\n\n",
        "predict": "SELECT COUNT(*) FROM Ref_Colors WHERE color_code NOT IN (SELECT DISTINCT color_code FROM Products)"
    },
    {
        "db_id": "swimming",
        "gold": "SELECT count(DISTINCT city) FROM stadium WHERE opening_year  <  2006",
        "question": "How many cities have a stadium that was opened before the year of 2006?",
        "fields": "Table event, columns = [*,ID,Name,Stadium_ID,Year]\nTable record, columns = [*,ID,Result,Swimmer_ID,Event_ID]\nTable stadium, columns = [*,ID,name,Capacity,City,Country,Opening_year]\nTable swimmer, columns = [*,ID,name,Nationality,meter_100,meter_200,meter_300,meter_400,meter_500,meter_600,meter_700,Time]\n",
        "foreign_keys": "Foreign_keys = [event.Stadium_ID = stadium.ID,record.Swimmer_ID = swimmer.ID,record.Event_ID = event.ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the stadiums that were opened before the year 2006. Secondly, we need to count the number of unique cities that have such stadiums.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the cities from table 'stadium' where the opening year is before 2006. In the second step, we need to count the number of unique cities from the first step.\n\n<3> SQL Generation: Use 'where' to find the stadiums that were opened before the year 2006, and then use 'count' and 'distinct' to count the number of unique cities.\n\n",
        "predict": "SELECT COUNT(DISTINCT city) FROM stadium WHERE opening_year < 2006"
    },
    {
        "db_id": "railway",
        "gold": "SELECT max(LEVEL) FROM manager WHERE Country != \"Australia\"",
        "question": "What is the maximum level of managers in countries that are not \"Australia\"?",
        "fields": "Table manager, columns = [*,Manager_ID,Name,Country,Working_year_starts,Age,Level]\nTable railway, columns = [*,Railway_ID,Railway,Builder,Built,Wheels,Location,ObjectNumber]\nTable railway_manage, columns = [*,Railway_ID,Manager_ID,From_Year]\nTable train, columns = [*,Train_ID,Train_Num,Name,From,Arrival,Railway_ID]\n",
        "foreign_keys": "Foreign_keys = [train.Railway_ID = railway.Railway_ID,railway_manage.Railway_ID = railway.Railway_ID,railway_manage.Manager_ID = manager.Manager_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter managers based on their countries, excluding \"Australia\". Secondly, we need to find the maximum level among the selected managers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'manager' table, we can directly use it.\n\n<3> SQL Generation: Use 'where' to filter managers from countries other than \"Australia\", and then use 'max' to find the maximum level among the selected managers.\n\n",
        "predict": "SELECT MAX(Level) FROM manager WHERE Country != 'Australia'"
    },
    {
        "db_id": "customers_and_products_contacts",
        "gold": "SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM customer_address_history)",
        "question": "Show names and phones of customers who do not have address information.",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Contacts, columns = [*,contact_id,customer_id,gender,first_name,last_name,contact_phone]\nTable Customer_Address_History, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\n",
        "foreign_keys": "Foreign_keys = [Customer_Address_History.address_id = Addresses.address_id,Customer_Address_History.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding customers who do not have address information. Firstly, we need to identify customers who do not have any address information. Secondly, we need to select their names and phones.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customers' where customer_address is null or empty. Then, we need to select customer_name and customer_phone from table 'Customers' based on the selected customer_id.\n\n<3> SQL Generation: Use 'where' to filter customers who do not have address information, and then select their names and phones.\n\n",
        "predict": "SELECT customer_name, customer_phone FROM Customers WHERE customer_address IS NULL OR customer_address = ''"
    },
    {
        "db_id": "customers_and_products_contacts",
        "gold": "SELECT count(*) FROM products WHERE product_price  >  (SELECT avg(product_price) FROM products)",
        "question": "How many products have a price higher than the average?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Contacts, columns = [*,contact_id,customer_id,gender,first_name,last_name,contact_phone]\nTable Customer_Address_History, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\n",
        "foreign_keys": "Foreign_keys = [Customer_Address_History.address_id = Addresses.address_id,Customer_Address_History.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average price of products. Secondly, we need to count the number of products with a price higher than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'product_price' column from the 'Products' table, we only need the 'Products' table.\n\n<3> SQL Generation: Use 'avg' to calculate the average price of products, and then use 'where' to filter products with a price higher than the average.\n\n",
        "predict": "SELECT COUNT(*) FROM Products WHERE product_price > (SELECT AVG(product_price) FROM Products)"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "question": "How many female students (sex is F) whose age is below 25?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their sex and age. Secondly, we need to count the number of selected female students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter students based on their sex and age, we only need the 'Student' table.\n\n<3> SQL Generation: Use 'where' to filter students based on their sex and age, and then use 'count' to calculate the number of selected female students.\n\n",
        "predict": "SELECT COUNT(*) FROM Student WHERE Sex = 'F' AND Age < 25"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "question": "How many girl students who are younger than 25?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter candidates using column 'Sex' in table 'Student' and column 'Age'. Secondly, we need to count the number of selected female students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need table 'Student' for filtering and counting, we only need this table.\n\n<3> SQL Generation: We need to filter the rows where 'Sex' is 'F' and 'Age' is less than 25. Finally, we count the number of rows that meet these conditions.\n\n",
        "predict": "SELECT COUNT(*) FROM Student WHERE Sex = 'F' AND Age < 25"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100",
        "question": "Find the name and gender type of the dorms whose capacity is greater than 300 or less than 100.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter dorms based on their capacity being greater than 300 or less than 100. Secondly, we need to select the name and gender type of the filtered dorms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select dorm_name and gender from table 'Dorm' and filter by capacity.\n\n<3> SQL Generation: Use 'where' to filter dorms based on their capacity being greater than 300 or less than 100, and then select the name and gender type of the filtered dorms.\n\n",
        "predict": "SELECT dorm_name, gender FROM Dorm WHERE student_capacity > 300 OR student_capacity < 100"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT amenity_name FROM dorm_amenity ORDER BY amenity_name",
        "question": "List in alphabetic order all different amenities.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires listing all different amenities. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is only focused on amenities, we only need the 'Dorm_amenity' table.\n\n<3> SQL Generation: Use 'SELECT DISTINCT' to select all different amenities from the 'Dorm_amenity' table and order them alphabetically.\n\n",
        "predict": "SELECT DISTINCT amenity_name FROM Dorm_amenity ORDER BY amenity_name ASC"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT fname ,  lname FROM student WHERE age  <  (SELECT avg(age) FROM student)",
        "question": "Find the first and last name of students whose age is younger than the average age.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average age of all students. Secondly, we need to filter students whose age is younger than the average age. Finally, we need to select the first and last name of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the first and last name of students, we only need the 'Student' table.\n\n<3> SQL Generation: Use 'avg' to calculate the average age of all students, and then use 'where' to filter students whose age is younger than the average age. Finally, select the first and last name of these students.\n\n",
        "predict": "SELECT Fname, LName FROM Student WHERE Age < (SELECT AVG(Age) FROM Student)"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall'",
        "question": "What are the first names of all students in Smith Hall?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the dorm with the name 'Smith Hall'. Secondly, we need to find the students who live in that dorm and retrieve their first names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dormid from table 'Dorm' where dorm_name = 'Smith Hall'. In the second step, we need to filter stuid and retrieve first names from table 'Student' based on the dormid found in the first step.\n\n<3> SQL Generation: Use 'where' to find the dorm with the name 'Smith Hall', and then use 'where' to filter students who live in that dorm and retrieve their first names.\n\n",
        "predict": "SELECT Fname FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid = (SELECT dormid FROM Dorm WHERE dorm_name = 'Smith Hall'))"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT avg(T1.age) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.student_capacity  =  (SELECT max(student_capacity) FROM dorm)",
        "question": "Find the average age of students who are living in the dorm with the largest capacity.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the dorm with the largest capacity. Secondly, we need to filter students based on their dorm and calculate the average age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dormid with the largest capacity from table 'Dorm'. In the second step, we need to filter students based on dormid from table 'Lives_in' and calculate the average age from table 'Student'.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select dorm with the largest capacity, and then use 'where' to filter students and calculate the average age.\n\n",
        "predict": "SELECT AVG(Age) FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid = (SELECT dormid FROM Dorm ORDER BY student_capacity DESC LIMIT 1))"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall' AND T1.sex  =  'F'",
        "question": "How many female students live in Smith Hall?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter female students from table 'Student'. Secondly, we need to filter students who live in Smith Hall from table 'Lives_in'. Finally, we count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where Sex = 'F'. In the second step, we need to filter StuID from table 'Lives_in' where dormid = 'Smith Hall'.\n\n<3> SQL Generation: Use 'where' to filter female students from table 'Student', and then use 'where' to filter students who live in Smith Hall from table 'Lives_in'. Finally, count the number of selected students.\n\n",
        "predict": "SELECT COUNT(*) FROM Student AS T1 JOIN Lives_in AS T2 ON T1.StuID = T2.stuid WHERE T1.Sex = 'F' AND T2.dormid = 'Smith Hall'"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "question": "Find the first name and age of students who are living in the dorms that do not have amenity TV Lounge.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the dorms that do not have the amenity \"TV Lounge\". Secondly, we need to find the students who are living in those dorms and retrieve their first name and age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dormid from table 'Dorm' where amenity_name != \"TV Lounge\". In the second step, we need to filter dormid from table 'Lives_in' and retrieve the corresponding first name and age from table 'Student'.\n\n<3> SQL Generation: Use 'where' to find the dorms that do not have the amenity \"TV Lounge\", and then use 'where' to filter students who are living in those dorms and select their first name and age.\n\n",
        "predict": "SELECT Student.Fname, Student.Age FROM Student JOIN Lives_in ON Student.StuID = Lives_in.stuid WHERE Lives_in.dormid NOT IN (SELECT dormid FROM Dorm_amenity JOIN Has_amenity ON Dorm_amenity.amenid = Has_amenity.amenid WHERE amenity_name = \"TV Lounge\")"
    },
    {
        "db_id": "customer_complaints",
        "gold": "SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints)",
        "question": "Find the prices of products which has never received a single complaint.",
        "fields": "Table Complaints, columns = [*,complaint_id,product_id,customer_id,complaint_outcome_code,complaint_status_code,complaint_type_code,date_complaint_raised,date_complaint_closed,staff_id]\nTable Customers, columns = [*,customer_id,customer_type_code,address_line_1,address_line_2,town_city,state,email_address,phone_number]\nTable Products, columns = [*,product_id,parent_product_id,product_category_code,date_product_first_available,date_product_discontinued,product_name,product_description,product_price]\nTable Staff, columns = [*,staff_id,gender,first_name,last_name,email_address,phone_number]\n",
        "foreign_keys": "Foreign_keys = [Complaints.customer_id = Customers.customer_id,Complaints.product_id = Products.product_id,Complaints.staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the products that have never received a single complaint. Secondly, we need to select the prices of those products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Complaints' and count the number of complaints for each product. In the second step, we need to select product_id and product_price from table 'Products'.\n\n<3> SQL Generation: Use 'group by' and 'having' to find the products that have never received a single complaint, and then select the prices of those products.\n\n",
        "predict": "SELECT product_price FROM Products WHERE product_id NOT IN (SELECT product_id FROM Complaints GROUP BY product_id HAVING COUNT(*) > 0)"
    },
    {
        "db_id": "workshop_paper",
        "gold": "SELECT Author FROM submission WHERE Submission_ID NOT IN (SELECT Submission_ID FROM acceptance)",
        "question": "List the authors who do not have submission to any workshop.",
        "fields": "Table Acceptance, columns = [*,Submission_ID,Workshop_ID,Result]\nTable submission, columns = [*,Submission_ID,Scores,Author,College]\nTable workshop, columns = [*,Workshop_ID,Date,Venue,Name]\n",
        "foreign_keys": "Foreign_keys = [Acceptance.Workshop_ID = workshop.Workshop_ID,Acceptance.Submission_ID = submission.Submission_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the authors who have submissions to workshops. Secondly, we need to filter out the authors who do not have any submissions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Author from table 'submission' and filter by Workshop_ID. Then, we need to filter out the authors who do not have any submissions from table 'submission'.\n\n<3> SQL Generation: Use 'where' to filter authors who have submissions to workshops, and then use 'not in' to filter out the authors who do not have any submissions.\n\n",
        "predict": "SELECT Author FROM submission WHERE Submission_ID NOT IN (SELECT Submission_ID FROM Acceptance)"
    },
    {
        "db_id": "tracking_share_transactions",
        "gold": "SELECT min(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code  =  \"PUR\" AND share_count  >  50",
        "question": "Show the minimum amount of transactions whose type code is \"PUR\" and whose share count is bigger than 50.",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter transactions with type code \"PUR\" and share count bigger than 50. Secondly, we need to find the minimum amount among these transactions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select amount_of_transaction from table 'Transactions' where transaction_type_code = \"PUR\" and share_count > 50.\n\n<3> SQL Generation: Use 'where' to filter transactions with type code \"PUR\" and share count bigger than 50, and then use 'min' to find the minimum amount among these transactions.\n\n",
        "predict": "SELECT MIN(amount_of_transaction) FROM Transactions WHERE transaction_type_code = \"PUR\" AND share_count > 50"
    },
    {
        "db_id": "tracking_share_transactions",
        "gold": "SELECT T1.sales_details ,  T2.date_of_transaction FROM SALES AS T1 JOIN TRANSACTIONS AS T2 ON T1.sales_transaction_id  =  T2.transaction_id WHERE T2.amount_of_transaction  <  3000",
        "question": "What are the sale details and dates of transactions with amount smaller than 3000?",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on transactions with amount smaller than 3000. We need to select the sale details and dates of these transactions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select sales_details and date_of_transaction from table 'Sales' and 'Transactions' respectively.\n\n<3> SQL Generation: Use 'where' to filter transactions with amount smaller than 3000, and then select the sale details and dates from the 'Sales' table.\n\n",
        "predict": "SELECT sales_details, date_of_transaction FROM Sales WHERE transaction_id IN (SELECT transaction_id FROM Transactions WHERE amount_of_transaction < 3000)"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "question": "Show the average price range of hotels that have 5 star ratings and allow pets.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter hotels that have 5 star ratings and allow pets. Secondly, we need to calculate the average price range of these hotels.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select price_range from table 'Hotels' where star_rating_code = 5 and pets_allowed_yn = 'Y'.\n\n<3> SQL Generation: Use 'where' to filter hotels that have 5 star ratings and allow pets, and then use 'avg' to calculate the average price range.\n\n",
        "predict": "SELECT AVG(price_range) FROM Hotels WHERE star_rating_code = 5 AND pets_allowed_yn = 'Y'"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT T1.Name ,  T3.Visit_Date FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Vincent\" OR T2.Tourist_Details  =  \"Vivian\"",
        "question": "For each tourist attraction, return its name and the date when the tourists named Vincent or Vivian visited there.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the tourists named Vincent or Vivian. Secondly, we need to find the tourist attractions they visited and the corresponding visit dates. Finally, we need to return the name of each tourist attraction and the visit dates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the name from the 'Tourist_Attractions' table, the tourist ID from the 'Visitors' table, and the visit date from the 'Visits' table.\n\n<3> SQL Generation: We need to join the 'Tourist_Attractions', 'Visitors', and 'Visits' tables on the corresponding foreign keys. Then, we filter the rows where the tourist name is either Vincent or Vivian. Finally, we select the name of each tourist attraction and the visit dates.\n\n",
        "predict": "SELECT Tourist_Attractions.Name, Visits.Visit_Date FROM Tourist_Attractions JOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID JOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID WHERE Visitors.Tourist_Details IN ('Vincent', 'Vivian')"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT T2.Name FROM Locations AS T1 JOIN Tourist_Attractions AS T2 ON T1.Location_ID  =  T2.Location_ID WHERE T1.Address  =  \"660 Shea Crescent\" OR T2.How_to_Get_There  =  \"walk\"",
        "question": "What are the names of tourist attractions that can be reached by walk or is at address 660 Shea Crescent?",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the tourist attractions that can be reached by walk. Secondly, we need to find the tourist attractions that have the address '660 Shea Crescent'. Finally, we need to combine the results from the two steps and select the names of the tourist attractions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Tourist_Attraction_ID from table 'Tourist_Attraction_Features' where Feature_ID is the ID of the feature representing 'walk'. In the second step, we need to select Tourist_Attraction_ID from table 'Locations' where Address is '660 Shea Crescent'. In the final step, we need to select the names of the tourist attractions from table 'Tourist_Attractions' based on the Tourist_Attraction_IDs obtained from the previous steps.\n\n<3> SQL Generation: Use 'where' to find the Tourist_Attraction_IDs of the tourist attractions that can be reached by walk and the tourist attractions with the address '660 Shea Crescent'. Then, use 'where' to filter the names of the tourist attractions based on the Tourist_Attraction_IDs obtained from the previous steps.\n\n",
        "predict": "SELECT Name FROM Tourist_Attractions WHERE Tourist_Attraction_ID IN (SELECT Tourist_Attraction_ID FROM Tourist_Attraction_Features WHERE Feature_ID = (SELECT Feature_ID FROM Features WHERE Feature_Details = 'walk')) OR Location_ID IN (SELECT Location_ID FROM Locations WHERE Address = '660 Shea Crescent')"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits )",
        "question": "How many tourists did not make any visit?",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding tourists who did not make any visit. We need to count the number of tourists who do not have any corresponding records in the 'Visits' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Tourist_ID' column from the 'Visitors' table and filter out the tourists who have corresponding records in the 'Visits' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Visitors' and 'Visits' tables on the 'Tourist_ID' column. Then, we can filter out the rows where the 'Visit_ID' is null (indicating no visit) and count the number of tourists.\n\n",
        "predict": "SELECT COUNT(*) FROM Visitors LEFT JOIN Visits ON Visitors.Tourist_ID = Visits.Tourist_ID WHERE Visits.Visit_ID IS NULL"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT gtype FROM Video_games WHERE gname  =  \"Call of Destiny\"",
        "question": "What type of game is Call of Destiny?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: We need to find the game type of \"Call of Destiny\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the game type from the \"Video_Games\" table where the game name is \"Call of Destiny\".\n\n<3> SQL Generation: Use 'where' to filter the game name and select the game type.\n\n",
        "predict": "SELECT GType FROM Video_Games WHERE GName = 'Call of Destiny'"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT count(*) FROM Video_games WHERE gtype  =  \"Massively multiplayer online game\"",
        "question": "How many video games have type Massively multiplayer online game?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: We need to filter video games based on their type and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Video_Games' table and its 'GType' column, we can directly use this table.\n\n<3> SQL Generation: Use 'where' to filter video games with type 'Massively multiplayer online game' and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Video_Games WHERE GType = 'Massively multiplayer online game'"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  \"David\" AND T2.Lname  =  \"Shieber\"",
        "question": "What is the total number of hours per work and number of games played by David Shieber?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the StuID of David Shieber by filtering on his name in the Student table. Secondly, we need to join the Plays_Games and SportsInfo tables on the StuID column and calculate the total number of hours per week and the number of games played.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from the Student table and join the Plays_Games and SportsInfo tables on the StuID column.\n\n<3> SQL Generation: Use 'where' to filter on the name 'David Shieber' in the Student table and select the corresponding StuID. Then, join the Plays_Games and SportsInfo tables on the StuID column. Finally, calculate the sum of HoursPerWeek and the count of GamesPlayed.\n\n",
        "predict": "SELECT SUM(SportsInfo.HoursPerWeek), COUNT(SportsInfo.GamesPlayed) FROM Student JOIN Plays_Games ON Student.StuID = Plays_Games.StuID JOIN SportsInfo ON Student.StuID = SportsInfo.StuID WHERE Student.LName = 'Shieber' AND Student.FName = 'David'"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  20",
        "question": "What is the total number of hours per week and number of games played by students under 20?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students who are under 20 years old. Secondly, we need to calculate the total number of hours per week and the number of games played by these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter students based on their age, we need the 'Student' table. We also need the 'Plays_Games' and 'SportsInfo' tables to calculate the total number of hours per week and the number of games played.\n\n<3> SQL Generation: We need to join the 'Student', 'Plays_Games', and 'SportsInfo' tables on the 'StuID' column. Then, we filter the rows where the age is less than 20. Finally, we calculate the sum of the 'Hours_Played' column and the count of the 'GameID' column.\n\n",
        "predict": "SELECT SUM(Plays_Games.Hours_Played), COUNT(Plays_Games.GameID) FROM Student JOIN Plays_Games ON Student.StuID = Plays_Games.StuID JOIN SportsInfo ON Student.StuID = SportsInfo.StuID WHERE Student.Age < 20"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT date_became_customer FROM customers WHERE customer_id BETWEEN 10 AND 20",
        "question": "Find the \"date became customers\" of the customers whose ID is between 10 and 20.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter customers based on their ID being between 10 and 20. Secondly, we need to select the \"date became customers\" for the selected customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the \"date became customers\" from table 'Customers', we only need this table.\n\n<3> SQL Generation: Use 'where' to filter customers based on their ID being between 10 and 20, and then select the \"date became customers\" for the selected customers.\n\n",
        "predict": "SELECT date_became_customer FROM Customers WHERE customer_id BETWEEN 10 AND 20"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT city FROM addresses WHERE city NOT IN ( SELECT DISTINCT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id)",
        "question": "Find the list of cities that no customer is living in.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: We need to find the list of cities that no customer is living in. This means we need to identify all cities and then filter out the cities where customers are living.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the distinct city column from the Addresses table and then filter out the cities where customers are living using the Customer_Addresses table.\n\n<3> SQL Generation: We can use a subquery to select the distinct cities from the Addresses table and then use a NOT IN clause to filter out the cities where customers are living based on the Customer_Addresses table.\n\n",
        "predict": "SELECT DISTINCT city FROM Addresses WHERE city NOT IN (SELECT DISTINCT city FROM Customer_Addresses)"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT count(DISTINCT t3.product_id) FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t1.customer_name  =  \"Rodrick Heaney\"",
        "question": "How many types of products have Rodrick Heaney bought in total?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of Rodrick Heaney. Secondly, we need to find the order_id of Rodrick Heaney's orders. Thirdly, we need to find the product_id of the products bought in Rodrick Heaney's orders. Finally, we need to count the number of distinct product types.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_name = 'Rodrick Heaney'. In the second step, we need to select order_id from table 'Customer_Orders' where customer_id = the customer_id found in the first step. In the third step, we need to select product_id from table 'Order_Items' where order_id = the order_id found in the second step. In the final step, we need to count the distinct product types from table 'Products' using the product_id found in the third step.\n\n<3> SQL Generation: Use 'where' to find the customer_id of Rodrick Heaney, and then use 'where' to find the order_id of Rodrick Heaney's orders. Next, use 'where' to find the product_id of the products bought in Rodrick Heaney's orders. Finally, use 'count(distinct)' to count the number of distinct product types.\n\n",
        "predict": "SELECT COUNT(DISTINCT product_id) FROM Products WHERE product_id IN (SELECT product_id FROM Order_Items WHERE order_id IN (SELECT order_id FROM Customer_Orders WHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_name = 'Rodrick Heaney')))"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT count(DISTINCT customer_id) FROM customer_orders WHERE order_status  =  \"Cancelled\"",
        "question": "How many customers have at least one order with status \"Cancelled\"?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders with status \"Cancelled\". Secondly, we need to count the number of customers who have at least one order with this status.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customer_Orders' where order_status = \"Cancelled\". Then, we count the distinct customer_ids.\n\n<3> SQL Generation: Use 'where' to filter orders with status \"Cancelled\", and then use 'count' and 'distinct' to count the number of customers.\n\n",
        "predict": "SELECT COUNT(DISTINCT customer_id) FROM Customer_Orders WHERE order_status = \"Cancelled\""
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT customer_name FROM customers WHERE payment_method != 'Cash'",
        "question": "What is the name of customers who do not use Cash as payment method.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on customers who do not use Cash as the payment method. We need to select the names of these customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the customer_name from the Customers table and filter by the payment_method column.\n\n<3> SQL Generation: Use 'where' to filter customers who do not use Cash as the payment method and select their names.\n\n",
        "predict": "SELECT customer_name FROM Customers WHERE payment_method != 'Cash'"
    },
    {
        "db_id": "roller_coaster",
        "gold": "SELECT Status FROM roller_coaster WHERE LENGTH  >  3300 OR Height  >  100",
        "question": "Show the statuses of roller coasters longer than 3300 or higher than 100.",
        "fields": "Table country, columns = [*,Country_ID,Name,Population,Area,Languages]\nTable roller_coaster, columns = [*,Roller_Coaster_ID,Name,Park,Country_ID,Length,Height,Speed,Opened,Status]\n",
        "foreign_keys": "Foreign_keys = [roller_coaster.Country_ID = country.Country_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter roller coasters based on their length and height. Secondly, we need to show the statuses of the selected roller coasters.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'roller_coaster' table, we only need this table.\n\n<3> SQL Generation: Use 'where' to filter roller coasters based on their length and height, and then select the 'status' column.\n\n",
        "predict": "SELECT status FROM roller_coaster WHERE length > 3300 OR height > 100"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "question": "what are the names and classes of the ships that do not have any captain yet?",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding ships that do not have any captain yet. Firstly, we need to identify the ships that have captains. Secondly, we need to filter out the ships that do not have any captain.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Ship_ID from table 'captain' and filter by Ship_ID. Then, we need to select Name and Class from table 'Ship' and filter by Ship_ID.\n\n<3> SQL Generation: Use 'where' to find the Ship_IDs that have captains, and then use 'where' to filter out the ships that do not have any captain. Finally, select the Name and Class of the remaining ships.\n\n",
        "predict": "SELECT Name, Class FROM Ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM captain)"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "question": "Return the names and classes of ships that do not have a captain?",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on ships that do not have a captain. Firstly, we need to identify the ships that do not have a captain. Secondly, we need to select the names and classes of those ships.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Ship_ID from table 'captain' and filter by Ship_ID. In the second step, we need to select Name and Class from table 'Ship' and filter by Ship_ID.\n\n<3> SQL Generation: Use 'where' to find the Ship_IDs of ships that do not have a captain, and then use 'where' to select the names and classes of those ships.\n\n",
        "predict": "SELECT Name, Class FROM Ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM captain)"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT count(*) FROM addresses WHERE state_province_county  =  \"Colorado\"",
        "question": "How many cities are there in state \"Colorado\"?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of cities in the state \"Colorado\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for cities in a specific state, we need to use the \"Addresses\" table and filter on the \"state_province_county\" column.\n\n<3> SQL Generation: Use the \"where\" clause to filter the rows where the \"state_province_county\" is \"Colorado\", and then use the \"count\" function to count the number of cities.\n\n",
        "predict": "SELECT COUNT(DISTINCT town_city) FROM Addresses WHERE state_province_county = 'Colorado'"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT organization_name FROM organizations WHERE organization_name LIKE \"%Party%\"",
        "question": "What are the names of organizations that contain the word \"Party\"?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering organizations based on their names containing the word \"Party\". We need to select the names of these organizations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Organizations' table and the 'organization_name' column.\n\n<3> SQL Generation: Use 'where' to filter organizations whose names contain the word \"Party\" and select their names.\n\n",
        "predict": "SELECT organization_name FROM Organizations WHERE organization_name LIKE '%Party%'"
    },
    {
        "db_id": "school_bus",
        "gold": "SELECT party FROM driver WHERE home_city  =  'Hartford' AND age  >  40",
        "question": "Show the party with drivers from Hartford and drivers older than 40.",
        "fields": "Table driver, columns = [*,Driver_ID,Name,Party,Home_city,Age]\nTable school, columns = [*,School_ID,Grade,School,Location,Type]\nTable school_bus, columns = [*,School_ID,Driver_ID,Years_Working,If_full_time]\n",
        "foreign_keys": "Foreign_keys = [school_bus.Driver_ID = driver.Driver_ID,school_bus.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter drivers based on their home city and age. Secondly, we need to find the party of the selected drivers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Driver_ID from table 'driver' where Home_city = 'Hartford' and Age > 40. In the second step, we need to select Party from table 'driver' based on the Driver_ID obtained in the first step.\n\n<3> SQL Generation: Use 'where' to filter drivers based on their home city and age, and then use 'select' to find the party of the selected drivers.\n\n",
        "predict": "SELECT Party FROM driver WHERE Home_city = 'Hartford' AND Age > 40"
    },
    {
        "db_id": "school_bus",
        "gold": "SELECT name FROM driver WHERE driver_id NOT IN (SELECT driver_id FROM school_bus)",
        "question": "Show the names of the drivers without a school bus.",
        "fields": "Table driver, columns = [*,Driver_ID,Name,Party,Home_city,Age]\nTable school, columns = [*,School_ID,Grade,School,Location,Type]\nTable school_bus, columns = [*,School_ID,Driver_ID,Years_Working,If_full_time]\n",
        "foreign_keys": "Foreign_keys = [school_bus.Driver_ID = driver.Driver_ID,school_bus.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding drivers without a school bus. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'driver' table in this case.\n\n<3> SQL Generation: Use 'where' to filter drivers without a school bus.\n\n",
        "predict": "SELECT Name FROM driver WHERE Driver_ID NOT IN (SELECT Driver_ID FROM school_bus)"
    },
    {
        "db_id": "school_bus",
        "gold": "SELECT school ,  TYPE FROM school WHERE school_id NOT IN (SELECT school_id FROM school_bus)",
        "question": "Show the school name and type for schools without a school bus.",
        "fields": "Table driver, columns = [*,Driver_ID,Name,Party,Home_city,Age]\nTable school, columns = [*,School_ID,Grade,School,Location,Type]\nTable school_bus, columns = [*,School_ID,Driver_ID,Years_Working,If_full_time]\n",
        "foreign_keys": "Foreign_keys = [school_bus.Driver_ID = driver.Driver_ID,school_bus.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding schools without a school bus. Firstly, we need to identify the schools that have a school bus. Secondly, we need to select the school name and type for schools that do not have a school bus.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'school' and table 'school_bus' have a direct foreign key relationship, we only need these two tables.\n\n<3> SQL Generation: We need to join the 'school' and 'school_bus' tables on the 'School_ID' column. Then, we filter the rows where there is no matching entry in the 'school_bus' table. Finally, we select the school name and type for these schools.\n\n",
        "predict": "SELECT school.School, school.Type FROM school LEFT JOIN school_bus ON school.School_ID = school_bus.School_ID WHERE school_bus.School_ID IS NULL"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT T3.ssn ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "question": "What are the SSN and names of scientists working on the project with the most hours?",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the project with the most hours. Secondly, we need to find the scientists working on that project and retrieve their SSN and names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the project code with the maximum hours from the 'Projects' table. In the second step, we need to join the 'AssignedTo' and 'Scientists' tables on the project code and scientist SSN, respectively, and retrieve the SSN and names of the scientists.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the project with the most hours, and then join the 'AssignedTo' and 'Scientists' tables on the project code and scientist SSN. Finally, select the SSN and names of the scientists.\n\n",
        "predict": "SELECT Scientists.SSN, Scientists.Name FROM AssignedTo JOIN Scientists ON AssignedTo.Scientist = Scientists.SSN WHERE AssignedTo.Project = (SELECT Code FROM Projects ORDER BY Hours DESC LIMIT 1)"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT Name FROM Projects WHERE Code NOT IN (SELECT Project FROM AssignedTo)",
        "question": "Select the project names which are not assigned yet.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: The query requires selecting project names that are not assigned yet. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to select project names, we only need the 'Projects' table.\n\n<3> SQL Generation: Use 'where' to filter projects that are not assigned yet.\n\n",
        "predict": "SELECT Name FROM Projects WHERE Code NOT IN (SELECT Project FROM AssignedTo)"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT Name FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "question": "Find the name of scientists who are not assigned to any project.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: The query requires finding scientists who are not assigned to any project. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of scientists from the 'Scientists' table who do not have corresponding entries in the 'AssignedTo' table.\n\n<3> SQL Generation: Use a left join to combine the 'Scientists' and 'AssignedTo' tables on the 'SSN' and 'Scientist' columns, respectively. Then, filter the rows where the 'Project' column is null (indicating that the scientist is not assigned to any project). Finally, select the names of the scientists.\n\n",
        "predict": "SELECT Name FROM Scientists LEFT JOIN AssignedTo ON Scientists.SSN = AssignedTo.Scientist WHERE AssignedTo.Project IS NULL"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "question": "How many scientists do not have any projects assigned to them?",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: We need to find scientists who do not have any projects assigned to them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select scientists from the 'Scientists' table and filter out those who have projects assigned to them in the 'AssignedTo' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Scientists' and 'AssignedTo' tables on the 'SSN' column. Then, we can filter out the rows where the 'Project' column is null, indicating that no project is assigned to the scientist. Finally, we can count the number of scientists who meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM Scientists LEFT JOIN AssignedTo ON Scientists.SSN = AssignedTo.Scientist WHERE AssignedTo.Project IS NULL"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  \"Monterey\" AND T2.price  <  50",
        "question": "What are the wines that have prices lower than 50 and have appelations in Monterey county?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines based on their prices being lower than 50. Secondly, we need to filter wines based on their appellation being in Monterey county.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select wines with prices lower than 50 from table 'wine'. In the second step, we need to select wines with appellations in Monterey county from table 'wine' and 'appellations'.\n\n<3> SQL Generation: Use 'where' to filter wines with prices lower than 50, and then use 'where' to filter wines with appellations in Monterey county.\n\n",
        "predict": "SELECT * FROM wine WHERE price < 50 AND appelation IN (SELECT Appelation FROM appellations WHERE County = 'Monterey')"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT DISTINCT Name FROM WINE WHERE YEAR  <  2000 OR YEAR  >  2010",
        "question": "Give the distinct names of wines made before 2000 or after 2010.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines based on their year, selecting wines made before 2000 or after 2010. Secondly, we need to select the distinct names of the filtered wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Name' column from the 'wine' table, we only need to use the 'wine' table.\n\n<3> SQL Generation: Use 'where' to filter wines based on their year, selecting wines made before 2000 or after 2010. Then, use 'distinct' to select the distinct names of the filtered wines.\n\n",
        "predict": "SELECT DISTINCT Name FROM wine WHERE Year < 2000 OR Year > 2010"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "question": "What are the average prices and cases of wines produced in the year of 2009 and made of Zinfandel grape?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines based on their year and grape. Secondly, we need to calculate the average prices and cases of the selected wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select wines with year = 2009 and grape = 'Zinfandel' from table 'wine'. In the second step, we need to calculate the average prices and cases from table 'wine'.\n\n<3> SQL Generation: Use 'where' to filter wines with year = 2009 and grape = 'Zinfandel', and then use 'avg' to calculate the average prices and cases.\n\n",
        "predict": "SELECT AVG(Price), AVG(Cases) FROM wine WHERE Year = 2009 AND Grape = 'Zinfandel'"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "question": "Give the average price and case of wines made from Zinfandel grapes in the year 2009.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines based on the grape variety 'Zinfandel' and the year '2009'. Secondly, we need to calculate the average price and case count of the selected wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select price and cases from table 'wine' where grape = 'Zinfandel' and year = 2009.\n\n<3> SQL Generation: Use 'where' to filter wines based on grape and year, and then use 'avg' to calculate the average price and 'sum' to calculate the total cases.\n\n",
        "predict": "SELECT AVG(Price), SUM(Cases) FROM wine WHERE Grape = 'Zinfandel' AND Year = 2009"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT Name FROM WINE WHERE YEAR  <  (SELECT min(YEAR) FROM WINE WHERE Winery  =  \"Brander\")",
        "question": "What are the names of wines whose production year are before the year of all wines by Brander winery?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the production year of all wines by Brander winery. Secondly, we need to filter wines whose production year is before the year found in the first step and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select production year from table 'wine' where winery = 'Brander'. In the second step, we need to filter wines based on their production year and select their names from table 'wine'.\n\n<3> SQL Generation: Use 'where' to find the production year of all wines by Brander winery, and then use 'where' to filter wines whose production year is before the year found in the first step and select their names.\n\n",
        "predict": "SELECT Name FROM wine WHERE Year < (SELECT MIN(Year) FROM wine WHERE Winery = 'Brander')"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "question": "Find the average price of wines that are not produced from Sonoma county.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines that are not produced from Sonoma county. Secondly, we need to calculate the average price of the selected wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'wine' table and the 'appellations' table, we will use these two tables.\n\n<3> SQL Generation: Use 'where' to filter wines that are not produced from Sonoma county, and then use 'avg' to calculate the average price of the selected wines.\n\n",
        "predict": "SELECT AVG(Price) FROM wine WHERE Appelation NOT IN (SELECT Appelation FROM appellations WHERE County = 'Sonoma')"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "question": "What is the average price for wines not produced in Sonoma county?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on wines not produced in Sonoma county. Firstly, we need to identify the wines produced in Sonoma county. Secondly, we need to calculate the average price for wines that are not produced in Sonoma county.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Appelation from table 'appellations' where County = 'Sonoma'. In the second step, we need to filter wines based on their Appelation and calculate the average price.\n\n<3> SQL Generation: Use 'where' to filter wines produced in Sonoma county, and then use 'where' to filter wines that are not produced in Sonoma county and calculate the average price.\n\n",
        "predict": "SELECT AVG(Price) FROM wine WHERE Appelation NOT IN (SELECT Appelation FROM appellations WHERE County = 'Sonoma')"
    },
    {
        "db_id": "train_station",
        "gold": "SELECT T2.name FROM train_station AS T1 JOIN train AS T2 ON T1.train_id  =  T2.train_id WHERE T1.station_id NOT IN (SELECT T4.station_id FROM train_station AS T3 JOIN station AS T4 ON T3.station_id  =  T4.station_id WHERE t4.location  =  \"London\")",
        "question": "Find the names of the trains that do not pass any station located in London.",
        "fields": "Table station, columns = [*,Station_ID,Name,Annual_entry_exit,Annual_interchanges,Total_Passengers,Location,Main_Services,Number_of_Platforms]\nTable train, columns = [*,Train_ID,Name,Time,Service]\nTable train_station, columns = [*,Train_ID,Station_ID]\n",
        "foreign_keys": "Foreign_keys = [train_station.Station_ID = station.Station_ID,train_station.Train_ID = train.Train_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the stations located in London. Secondly, we need to filter the trains that do not pass any of these stations. Finally, we need to retrieve the names of these trains.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Station_ID from table 'station' where Location = 'London'. We also need to select Train_ID from table 'train_station' and filter by Station_ID.\n\n<3> SQL Generation: Use 'where' to filter stations located in London, and then use 'not in' to filter trains that do not pass any of these stations. Finally, select the names of these trains.\n\n",
        "predict": "SELECT Name FROM train WHERE Train_ID NOT IN (SELECT Train_ID FROM train_station WHERE Station_ID IN (SELECT Station_ID FROM station WHERE Location = 'London'))"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT date_joined_staff FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";",
        "question": "When did the staff member with first name as Janessa and last name as Sawayn join the company?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the staff member with first name as Janessa and last name as Sawayn. Secondly, we need to retrieve the date they joined the company.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select date_joined_staff from table 'Staff' where first_name = Janessa and last_name = Sawayn.\n\n<3> SQL Generation: Use 'where' to find the staff member with first name as Janessa and last name as Sawayn, and then select the date they joined the company.\n\n",
        "predict": "SELECT date_joined_staff FROM Staff WHERE first_name = 'Janessa' AND last_name = 'Sawayn'"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Rylan\" AND T2.last_name = \"Goodwin\" AND T1.lesson_status_code = \"Completed\";",
        "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with first name 'Rylan' and last name 'Goodwin'. Secondly, we need to filter lessons based on the customer and lesson status code.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where first_name = 'Rylan' and last_name = 'Goodwin'. In the second step, we need to filter lesson_id from table 'Lessons' where customer_id matches the customer found in the first step and lesson_status_code is 'completed'.\n\n<3> SQL Generation: Use 'where' to find the customer with first name 'Rylan' and last name 'Goodwin', and then use 'where' to filter lessons based on the customer and lesson status code. Finally, count the number of lessons that meet these conditions.\n\n",
        "predict": "SELECT COUNT(*) FROM Lessons WHERE customer_id = (SELECT customer_id FROM Customers WHERE first_name = 'Rylan' AND last_name = 'Goodwin') AND lesson_status_code = 'completed'"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT count(*) FROM Lessons WHERE lesson_status_code = \"Cancelled\";",
        "question": "How many lessons were in cancelled state?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of lessons in the cancelled state.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the lesson_status_code from the Lessons table.\n\n<3> SQL Generation: Use 'where' to filter lessons with the lesson_status_code = 'cancelled' and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Lessons WHERE lesson_status_code = 'cancelled'"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT sum(lesson_time) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "question": "How long is the total lesson time taught by staff with first name as Janessa and last name as Sawayn?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the staff with first name 'Janessa' and last name 'Sawayn'. Secondly, we need to calculate the total lesson time taught by these staff.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select staff_id from table 'Staff' where first_name = 'Janessa' and last_name = 'Sawayn'. In the second step, we need to filter lesson_time from table 'Lessons' based on the staff_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the staff with first name 'Janessa' and last name 'Sawayn', and then use 'sum' to calculate the total lesson time taught by these staff.\n\n",
        "predict": "SELECT SUM(lesson_time) FROM Lessons WHERE staff_id = (SELECT staff_id FROM Staff WHERE first_name = 'Janessa' AND last_name = 'Sawayn')"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Ray\"",
        "question": "How many lesson does customer with first name Ray took?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with first name Ray. Secondly, we need to count the number of lessons taken by that customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where first_name = 'Ray'. In the second step, we need to count the number of rows in table 'Lessons' where customer_id matches the customer_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer with first name Ray, and then use 'count' to count the number of lessons taken by that customer.\n\n",
        "predict": "SELECT COUNT(*) FROM Lessons WHERE customer_id = (SELECT customer_id FROM Customers WHERE first_name = 'Ray')"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT count(*) FROM Faculty WHERE Sex  =  'F' AND Rank  =  \"Professor\"",
        "question": "How many female Professors do we have?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Decomposition: We need to filter the professors based on their gender.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Sex' column from the 'Faculty' table.\n\n<3> SQL Generation: Use 'where' to filter the professors based on their gender and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM Faculty WHERE Sex = 'Female' AND Rank = 'Professor'"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT count(*) FROM Faculty WHERE Rank  =  \"Professor\" AND building  =  \"NEB\"",
        "question": "How many Professors are in building NEB?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of professors in building NEB. Firstly, we need to identify the professors who are in building NEB. Secondly, we need to count the number of professors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for professors in a specific building, we need to select FacID from table 'Faculty' where Building = 'NEB'.\n\n<3> SQL Generation: Use 'where' to filter professors in building NEB, and then use 'count' to count the number of professors.\n\n",
        "predict": "SELECT COUNT(*) FROM Faculty WHERE Building = 'NEB'"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  \"Linda\" AND T2.lname  =  \"Smith\"",
        "question": "Who is the advisor of Linda Smith? Give me the first name and last name.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name 'Linda Smith'. Secondly, we need to find the advisor of the student found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to select Fname and Lname from table 'Faculty' where FacID is the advisor of the student found in the first step.\n\n<3> SQL Generation: Use 'where' to find the student with the name 'Linda Smith', and then use 'where' to find the advisor of the student and select their first name and last name.\n\n",
        "predict": "SELECT Fname, Lname FROM Faculty WHERE FacID = (SELECT Advisor FROM Student WHERE LName = 'Smith' AND Fname = 'Linda')"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  \"Michael\" AND T1.lname  =  \"Goodrich\"",
        "question": "Show first name and last name for all the students advised by Michael Goodrich.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students advised by Michael Goodrich. Secondly, we need to select their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where Advisor = 'Michael Goodrich'. In the second step, we need to select Fname and Lname from table 'Student'.\n\n<3> SQL Generation: Use 'where' to find the students advised by Michael Goodrich, and then select their first name and last name.\n\n",
        "predict": "SELECT Fname, Lname FROM Student WHERE Advisor = 'Michael Goodrich'"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "question": "What is the number of airlines based in Russia?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: We need to filter airlines based on their country, specifically Russia.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airlines' table and the 'country' column.\n\n<3> SQL Generation: Use 'where' to filter airlines based on their country being Russia, and then count the number of rows that meet this condition.\n\n",
        "predict": "SELECT COUNT(*) FROM airlines WHERE country = 'Russia'"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM airports WHERE name LIKE '%International%'",
        "question": "How many airports' names have the word Interanation in them?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on airport names that contain the word \"Interanation\". We need to find the airports with names that match this criteria.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airports' table and the 'name' column.\n\n<3> SQL Generation: Use the 'LIKE' operator with the '%' wildcard to search for airport names that contain the word \"Interanation\". Then, use the 'COUNT' function to count the number of airports that match this criteria.\n\n",
        "predict": "SELECT COUNT(*) FROM airports WHERE name LIKE '%Interanation%'"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "question": "In how many cities are there airports in the country of Greenland?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the airports in the country of Greenland. Secondly, we need to count the number of cities where these airports are located.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select apid from table 'airports' where country = 'Greenland'. In the second step, we need to select city from table 'airports' and count the distinct cities.\n\n<3> SQL Generation: Use 'where' to find the airports in the country of Greenland, and then use 'count' and 'distinct' to count the number of cities where these airports are located.\n\n",
        "predict": "SELECT COUNT(DISTINCT city) FROM airports WHERE country = 'Greenland'"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'",
        "question": "What is the number of routes that end at John F Kennedy International Airport?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: The query requires finding routes that end at John F Kennedy International Airport. We need to filter routes based on their destination airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select routes that have the destination airport ID matching the ID of John F Kennedy International Airport.\n\n<3> SQL Generation: Use 'where' to filter routes based on the destination airport ID matching the ID of John F Kennedy International Airport.\n\n",
        "predict": "SELECT COUNT(*) FROM routes WHERE dst_apid = (SELECT apid FROM airports WHERE name = 'John F Kennedy International Airport')"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "question": "Find the number of routes from the United States to Canada.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the airports in the United States and Canada. Secondly, we need to filter routes based on their source and destination airports.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select apid from table 'airports' where country = 'United States' or country = 'Canada'. In the second step, we need to filter routes based on src_apid and dst_apid from table 'routes'.\n\n<3> SQL Generation: Use 'where' to filter airports in the United States and Canada, and then use 'where' to filter routes based on their source and destination airports. Finally, count the number of routes that meet these conditions.\n\n",
        "predict": "SELECT COUNT(*) FROM routes WHERE src_apid IN (SELECT apid FROM airports WHERE country = 'United States') AND dst_apid IN (SELECT apid FROM airports WHERE country = 'Canada')"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T2.order_id ,  T2.order_status FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "question": "Give me a list of id and status of orders which belong to the customer named \"Jeramie\".",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of the customer named \"Jeramie\". Secondly, we need to filter orders based on their customer_id and select the id and status columns.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_name = \"Jeramie\". In the second step, we need to filter order_id and order_status from table 'Orders' based on the customer_id.\n\n<3> SQL Generation: Use 'where' to find the customer_id of the customer named \"Jeramie\", and then use 'where' to filter orders based on their customer_id and select the id and status columns.\n\n",
        "predict": "SELECT order_id, order_status FROM Orders WHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_name = \"Jeramie\")"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T2.date_order_placed FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "question": "Find the dates of orders which belong to the customer named \"Jeramie\".",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of the customer named \"Jeramie\". Secondly, we need to filter orders based on their customer_id and select the dates of those orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_name = \"Jeramie\". In the second step, we need to filter order_id and date_order_placed from table 'Orders'.\n\n<3> SQL Generation: Use 'where' to find the customer_id of the customer named \"Jeramie\", and then use 'where' to filter orders based on their customer_id and select the dates of those orders.\n\n",
        "predict": "SELECT date_order_placed FROM Orders WHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_name = \"Jeramie\")"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.date_order_placed >= \"2009-01-01\" AND T2.date_order_placed <= \"2010-01-01\"",
        "question": "Give me the names of customers who have placed orders between 2009-01-01 and 2010-01-01.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders based on their date_order_placed column, selecting only orders placed between 2009-01-01 and 2010-01-01. Secondly, we need to retrieve the names of the customers who placed these orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_name from the Customers table and filter orders based on the date_order_placed column in the Orders table.\n\n<3> SQL Generation: Use 'where' to filter orders placed between 2009-01-01 and 2010-01-01, and then join the Orders and Customers tables on the customer_id column to retrieve the customer names.\n\n",
        "predict": "SELECT customer_name FROM Customers JOIN Orders ON Customers.customer_id = Orders.customer_id WHERE date_order_placed >= '2009-01-01' AND date_order_placed <= '2010-01-01'"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT DISTINCT T2.product_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id WHERE T1.date_order_placed >= \"1975-01-01\" AND T1.date_order_placed <= \"1976-01-01\"",
        "question": "Give me a list of distinct product ids from orders placed between 1975-01-01 and 1976-01-01?",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders based on the date_order_placed column between 1975-01-01 and 1976-01-01. Secondly, we need to select distinct product_ids from the filtered orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select product_id from the Order_Items table and filter by the order_id from the Orders table.\n\n<3> SQL Generation: Use 'where' to filter orders placed between 1975-01-01 and 1976-01-01, and then use 'distinct' to select unique product_ids from the filtered orders.\n\n",
        "predict": "SELECT DISTINCT product_id FROM Order_Items WHERE order_id IN (SELECT order_id FROM Orders WHERE date_order_placed >= '1975-01-01' AND date_order_placed <= '1976-01-01')"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT order_id FROM shipments WHERE shipment_date > \"2000-01-01\"",
        "question": "Find the ids of orders which are shipped after 2000-01-01.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on orders that are shipped after a specific date. Firstly, we need to identify the orders that meet this condition. Secondly, we need to select the order ids of these orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select order_id from table 'Orders' and filter by shipment_date from table 'Shipments'.\n\n<3> SQL Generation: Use 'where' to filter orders that are shipped after 2000-01-01 and select the order ids.\n\n",
        "predict": "SELECT order_id FROM Orders WHERE order_id IN (SELECT order_id FROM Shipments WHERE shipment_date > '2000-01-01')"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT count(*) FROM architect WHERE gender  =  'female'",
        "question": "How many architects are female?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of female architects.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'architect' table and the 'gender' column.\n\n<3> SQL Generation: Use 'where' to filter architects with gender = 'female' and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM architect WHERE gender = 'female'"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT name ,  built_year FROM mill WHERE TYPE  =  'Grondzeiler'",
        "question": "What are the names and year of construction for the mills of 'Grondzeiler' type?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter mills based on their type, specifically 'Grondzeiler'. Secondly, we need to select the names and construction years of the filtered mills.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'mill' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter mills of type 'Grondzeiler', and then select the names and construction years of the filtered mills.\n\n",
        "predict": "SELECT name, built_year FROM mill WHERE type = 'Grondzeiler'"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT LOCATION FROM bridge WHERE name  =  'Kolob Arch' OR name  =  'Rainbow Bridge'",
        "question": "What is the location of the bridge named 'Kolob Arch' or 'Rainbow Bridge'?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the bridges with names 'Kolob Arch' or 'Rainbow Bridge'. Secondly, we need to find the location of these bridges.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are only interested in the location of the bridges, we only need the 'bridge' table.\n\n<3> SQL Generation: Use 'where' to filter bridges with names 'Kolob Arch' or 'Rainbow Bridge' and select their locations.\n\n",
        "predict": "SELECT location FROM bridge WHERE name = 'Kolob Arch' OR name = 'Rainbow Bridge'"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT DISTINCT T1.name FROM mill AS T1 JOIN architect AS t2 ON T1.architect_id  =  T2.id JOIN bridge AS T3 ON T3.architect_id  =  T2.id WHERE T3.length_meters  >  80",
        "question": "What are the distinct name of the mills built by the architects who have also built a bridge longer than 80 meters?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the architects who have built a bridge longer than 80 meters. Secondly, we need to find the mills built by these architects and select their distinct names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select architect_id from table 'bridge' where length_meters > 80. In the second step, we need to filter architect_id and name from table 'mill' and select distinct names.\n\n<3> SQL Generation: Use 'where' to find the architect_ids of the architects who have built a bridge longer than 80 meters. Then, use 'where' to filter mills built by these architects and select their distinct names.\n\n",
        "predict": "SELECT DISTINCT name FROM mill WHERE architect_id IN (SELECT architect_id FROM bridge WHERE length_meters > 80)"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT count(*) FROM architect WHERE id NOT IN ( SELECT architect_id FROM mill WHERE built_year  <  1850 );",
        "question": "How many architects haven't built a mill before year 1850?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the architects who haven't built a mill. Secondly, we need to filter architects who haven't built a mill before year 1850.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select architect_id from table 'mill'. In the second step, we need to filter architect_id from table 'architect' and count them.\n\n<3> SQL Generation: Use 'not in' to find the architects who haven't built a mill, and then use 'where' to filter architects who haven't built a mill before year 1850 and count them.\n\n",
        "predict": "SELECT COUNT(*) FROM architect WHERE id NOT IN (SELECT architect_id FROM mill) AND id NOT IN (SELECT architect_id FROM mill WHERE built_year < 1850)"
    },
    {
        "db_id": "culture_company",
        "gold": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000",
        "question": "Which directors had a movie in either 1999 or 2000?",
        "fields": "Table book_club, columns = [*,book_club_id,Year,Author_or_Editor,Book_Title,Publisher,Category,Result]\nTable culture_company, columns = [*,Company_name,Type,Incorporated_in,Group_Equity_Shareholding,book_club_id,movie_id]\nTable movie, columns = [*,movie_id,Title,Year,Director,Budget_million,Gross_worldwide]\n",
        "foreign_keys": "Foreign_keys = [culture_company.movie_id = movie.movie_id,culture_company.book_club_id = book_club.book_club_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter movies based on their release year, selecting movies released in either 1999 or 2000. Secondly, we need to find the directors of these movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information about movies and directors, we need tables ['movie', 'culture_company'].\n\n<3> SQL Generation: Use 'where' to filter movies released in either 1999 or 2000, and then select the directors of these movies.\n\n",
        "predict": "SELECT DISTINCT Director FROM movie WHERE Year = 1999 OR Year = 2000"
    },
    {
        "db_id": "culture_company",
        "gold": "SELECT avg(budget_million) ,  max(budget_million) ,  min(budget_million) FROM movie WHERE YEAR  <  2000",
        "question": "What is the average, maximum, and minimum budget for all movies before 2000.",
        "fields": "Table book_club, columns = [*,book_club_id,Year,Author_or_Editor,Book_Title,Publisher,Category,Result]\nTable culture_company, columns = [*,Company_name,Type,Incorporated_in,Group_Equity_Shareholding,book_club_id,movie_id]\nTable movie, columns = [*,movie_id,Title,Year,Director,Budget_million,Gross_worldwide]\n",
        "foreign_keys": "Foreign_keys = [culture_company.movie_id = movie.movie_id,culture_company.book_club_id = book_club.book_club_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter movies based on their release year. Secondly, we need to calculate the average, maximum, and minimum budget for the selected movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'movie' table, we can directly use it.\n\n<3> SQL Generation: Use 'where' to filter movies released before 2000, and then use 'avg', 'max', and 'min' functions to calculate the average, maximum, and minimum budget.\n\n",
        "predict": "SELECT AVG(budget_million), MAX(budget_million), MIN(budget_million) FROM movie WHERE year < 2000"
    }
]