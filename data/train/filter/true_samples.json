[
    {
        "db_id": "department_management",
        "gold": "SELECT count(*) FROM department WHERE department_id NOT IN (SELECT department_id FROM management);",
        "question": "How many departments are led by heads who are not mentioned?",
        "fields": "Table department, columns = [*,Department_ID,Name,Creation,Ranking,Budget_in_Billions,Num_Employees]\nTable head, columns = [*,head_ID,name,born_state,age]\nTable management, columns = [*,department_ID,head_ID,temporary_acting]\n",
        "foreign_keys": "Foreign_keys = [management.head_ID = head.head_ID,management.department_ID = department.Department_ID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of departments that are led by heads who are not mentioned. We need to filter departments based on the heads mentioned in the 'head' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the department_ID from the 'department' table and filter based on the head_ID mentioned in the 'head' table.\n\n<3> SQL Generation: Use 'where' to filter departments based on the head_ID mentioned in the 'head' table and count the number of departments.\n\nSQL query: SELECT count(*) FROM department WHERE department_id NOT IN (SELECT department_id FROM management);",
        "predict": "SELECT count(*) FROM department WHERE department_id NOT IN (SELECT department_id FROM management);",
        "hardness": "extra"
    },
    {
        "db_id": "farm",
        "gold": "SELECT Hosts FROM farm_competition WHERE Theme !=  'Aliens'",
        "question": "Return the hosts of competitions for which the theme is not Aliens?",
        "fields": "Table city, columns = [*,City_ID,Official_Name,Status,Area_km_2,Population,Census_Ranking]\nTable competition_record, columns = [*,Competition_ID,Farm_ID,Rank]\nTable farm, columns = [*,Farm_ID,Year,Total_Horses,Working_Horses,Total_Cattle,Oxen,Bulls,Cows,Pigs,Sheep_and_Goats]\nTable farm_competition, columns = [*,Competition_ID,Year,Theme,Host_city_ID,Hosts]\n",
        "foreign_keys": "Foreign_keys = [farm_competition.Host_city_ID = city.City_ID,competition_record.Farm_ID = farm.Farm_ID,competition_record.Competition_ID = farm_competition.Competition_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on column 'theme', so we should apply the 'where' to column 'theme' and then return the hosts of selected competition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'farm_competition' has columns 'Theme' and 'Hosts', we only need table 'farm_competition'.\n\n<3> SQL Generation: Directly write the sql using 'where'.\n\nSQL query: SELECT Hosts FROM farm_competition WHERE Theme !=  'Aliens'",
        "predict": "SELECT Hosts FROM farm_competition WHERE Theme !=  'Aliens'",
        "hardness": "easy"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "question": "What are the  ids of every student who has never attended a course?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the ids of all students. Secondly, we need to filter out the students who have attended a course. Finally, we need to return the ids of the remaining students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from table 'Students' and filter it based on the student_id in table 'Student_Course_Attendance'.\n\n<3> SQL Generation: Use 'where' to filter out the student_ids that appear in the 'Student_Course_Attendance' table, and then select the remaining student_ids.\n\nSQL query: SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "predict": "SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "hardness": "hard"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"English\"",
        "question": "How many students are attending English courses?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the course_id for English courses. Secondly, we need to count the number of students attending those courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'Courses' where course_name = 'English'. In the second step, we need to count the number of students from table 'Student_Course_Attendance' where course_id matches the course_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the course_id for English courses, and then use 'count' to count the number of students attending those courses.\n\nSQL query: SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"English\"",
        "predict": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"English\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "question": "How many courses do the student whose id is 171 attend?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with id 171. Secondly, we need to count the number of courses that the student attends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select student_id from table 'Students' where student_id = 171. In the second step, we need to count the number of courses from table 'Student_Course_Attendance' where student_id = 171.\n\n<3> SQL Generation: Use 'where' to find the student with id 171, and then use 'count' to count the number of courses that the student attends.\n\nSQL query: SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "predict": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "hardness": "medium"
    },
    {
        "db_id": "student_assessment",
        "gold": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "question": "How many courses does the student with id 171 actually attend?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,city,zip_postcode,state_province_county,country]\nTable Candidate_Assessments, columns = [*,candidate_id,qualification,assessment_date,asessment_outcome_code]\nTable Candidates, columns = [*,candidate_id,candidate_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable People, columns = [*,person_id,first_name,middle_name,last_name,cell_mobile_number,email_address,login_name,password]\nTable People_Addresses, columns = [*,person_address_id,person_id,address_id,date_from,date_to]\nTable Student_Course_Attendance, columns = [*,student_id,course_id,date_of_attendance]\nTable Student_Course_Registrations, columns = [*,student_id,course_id,registration_date]\nTable Students, columns = [*,student_id,student_details]\n",
        "foreign_keys": "Foreign_keys = [Students.student_id = People.person_id,People_Addresses.address_id = Addresses.address_id,People_Addresses.person_id = People.person_id,Student_Course_Registrations.course_id = Courses.course_id,Student_Course_Registrations.student_id = Students.student_id,Student_Course_Attendance.student_id = Student_Course_Registrations.student_id,Student_Course_Attendance.course_id = Student_Course_Registrations.course_id,Candidates.candidate_id = People.person_id,Candidate_Assessments.candidate_id = Candidates.candidate_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the courses that the student with id 171 is registered for. Secondly, we need to count the number of courses that the student actually attends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'Student_Course_Registrations' where student_id = 171. In the second step, we need to count the number of rows in table 'Student_Course_Attendance' where student_id = 171 and course_id is in the list of courses obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the courses that the student with id 171 is registered for, and then use 'where' and 'count' to count the number of courses that the student actually attends.\n\nSQL query: SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "predict": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "hardness": "medium"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT name FROM station WHERE lat  <  37.5",
        "question": "What are the names of stations that have latitude lower than 37.5?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on stations with latitude lower than 37.5. We need to select the names of these stations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'station' table and the 'name' column.\n\n<3> SQL Generation: Use 'where' to filter stations with latitude lower than 37.5 and select their names.\n\nSQL query: SELECT name FROM station WHERE lat  <  37.5",
        "predict": "SELECT name FROM station WHERE lat  <  37.5",
        "hardness": "easy"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT COUNT(*) FROM station WHERE city  =  \"Mountain View\"",
        "question": "How many stations does Mountain View city has?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of stations in Mountain View city.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'station' table and the 'city' column.\n\n<3> SQL Generation: Use 'where' to filter stations in Mountain View city and then use 'count' to calculate the number of stations.\n\nSQL query: SELECT COUNT(*) FROM station WHERE city  =  \"Mountain View\"",
        "predict": "SELECT COUNT(*) FROM station WHERE city  =  \"Mountain View\"",
        "hardness": "easy"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8",
        "question": "What is the number of days that had an average humity above 50 and an average visibility above 8?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter days with an average humidity above 50. Secondly, we need to filter days with an average visibility above 8. Finally, we need to count the number of days that meet both conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'weather' table for this query.\n\n<3> SQL Generation: Use 'where' to filter days with an average humidity above 50 and an average visibility above 8, and then use 'count' to calculate the number of days that meet both conditions.\n\nSQL query: SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8",
        "predict": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8",
        "hardness": "medium"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT T1.lat ,  T1.long ,  T1.city FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id ORDER BY T2.duration LIMIT 1",
        "question": "What is the latitude, longitude, and city of the station from which the trip with smallest duration started?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the trip with the smallest duration. Secondly, we need to identify the station from which this trip started. Finally, we need to retrieve the latitude, longitude, and city of this station.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the minimum duration from table 'trip'. In the second step, we need to filter the trip with the minimum duration and retrieve the start_station_id. In the final step, we need to select the latitude, longitude, and city from table 'station' based on the start_station_id.\n\n<3> SQL Generation: Use 'where' to find the trip with the smallest duration, and then use 'where' to filter the start_station_id and select the corresponding latitude, longitude, and city.\n\nSQL query: SELECT T1.lat ,  T1.long ,  T1.city FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id ORDER BY T2.duration LIMIT 1",
        "predict": "SELECT T1.lat ,  T1.long ,  T1.city FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id ORDER BY T2.duration LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "question": "What is the average bike availability in stations that are not located in Palo Alto?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires calculating the average bike availability in stations that are not located in Palo Alto. Firstly, we need to identify the stations located in Palo Alto. Secondly, we need to filter stations that are not located in Palo Alto. Finally, we calculate the average bike availability in the remaining stations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'station' and 'status' tables. \n\n<3> SQL Generation: Use 'where' to filter stations located in Palo Alto, and then use 'not in' to filter stations that are not located in Palo Alto. Finally, calculate the average bike availability in the remaining stations.\n\nSQL query: SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "predict": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "question": "What is the average bike availablility for stations not in Palo Alto?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on stations that are not in Palo Alto. Firstly, we need to identify the stations located in Palo Alto. Secondly, we need to calculate the average bike availability for stations that are not in Palo Alto.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'station' where city = 'Palo Alto'. In the second step, we need to select bikes_available from table 'status' and filter by station_id.\n\n<3> SQL Generation: Use 'where' to filter stations in Palo Alto, and then use 'not in' to filter stations that are not in Palo Alto. Finally, calculate the average bike availability for the selected stations.\n\nSQL query: SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "predict": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "hardness": "extra"
    },
    {
        "db_id": "bike_1",
        "gold": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != \"San Francisco\"",
        "question": "How many trips did not end in San Francisco?",
        "fields": "Table station, columns = [*,id,name,lat,long,dock_count,city,installation_date]\nTable status, columns = [*,station_id,bikes_available,docks_available,time]\nTable trip, columns = [*,id,duration,start_date,start_station_name,start_station_id,end_date,end_station_name,end_station_id,bike_id,subscription_type,zip_code]\nTable weather, columns = [*,date,max_temperature_f,mean_temperature_f,min_temperature_f,max_dew_point_f,mean_dew_point_f,min_dew_point_f,max_humidity,mean_humidity,min_humidity,max_sea_level_pressure_inches,mean_sea_level_pressure_inches,min_sea_level_pressure_inches,max_visibility_miles,mean_visibility_miles,min_visibility_miles,max_wind_Speed_mph,mean_wind_speed_mph,max_gust_speed_mph,precipitation_inches,cloud_cover,events,wind_dir_degrees,zip_code]\n",
        "foreign_keys": "Foreign_keys = [status.station_id = station.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on trips that did not end in San Francisco. Firstly, we need to identify the stations located in San Francisco. Secondly, we need to filter trips based on their end_station_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'station' where city = 'San Francisco'. In the second step, we need to select id from table 'trip' and filter by end_station_id.\n\n<3> SQL Generation: Use 'where' to filter stations in San Francisco, and then use 'not in' to filter trips that did not end in San Francisco.\n\nSQL query: SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != \"San Francisco\"",
        "predict": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != \"San Francisco\"",
        "hardness": "medium"
    },
    {
        "db_id": "book_2",
        "gold": "SELECT Title FROM book WHERE Writer != \"Elaine Lee\"",
        "question": "What are the titles of the books whose writer is not \"Elaine Lee\"?",
        "fields": "Table book, columns = [*,Book_ID,Title,Issues,Writer]\nTable publication, columns = [*,Publication_ID,Book_ID,Publisher,Publication_Date,Price]\n",
        "foreign_keys": "Foreign_keys = [publication.Book_ID = book.Book_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the writer column in the book table. We need to select the titles of the books that have a writer different from \"Elaine Lee\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the book table for this query.\n\n<3> SQL Generation: Use the 'where' clause to filter the books where the writer is not \"Elaine Lee\" and select the titles of those books.\n\nSQL query: SELECT Title FROM book WHERE Writer != \"Elaine Lee\"",
        "predict": "SELECT Title FROM book WHERE Writer != \"Elaine Lee\"",
        "hardness": "easy"
    },
    {
        "db_id": "book_2",
        "gold": "SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication)",
        "question": "List the titles of books that are not published.",
        "fields": "Table book, columns = [*,Book_ID,Title,Issues,Writer]\nTable publication, columns = [*,Publication_ID,Book_ID,Publisher,Publication_Date,Price]\n",
        "foreign_keys": "Foreign_keys = [publication.Book_ID = book.Book_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on books that are not published. We need to select the titles of these books.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'book' table.\n\n<3> SQL Generation: Use 'where' to filter books that are not published and select their titles.\n\nSQL query: SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication)",
        "predict": "SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication)",
        "hardness": "hard"
    },
    {
        "db_id": "musical",
        "gold": "SELECT Name FROM actor WHERE Age != 20",
        "question": "What are the names of actors who are not 20 years old?",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the age of actors. We need to select the names of actors who are not 20 years old.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'actor' table.\n\n<3> SQL Generation: Use 'where' to filter actors who are not 20 years old and select their names.\n\nSQL query: SELECT Name FROM actor WHERE Age != 20",
        "predict": "SELECT Name FROM actor WHERE Age != 20",
        "hardness": "easy"
    },
    {
        "db_id": "musical",
        "gold": "SELECT DISTINCT Nominee FROM musical WHERE Award != \"Tony Award\"",
        "question": "Return the different nominees of musicals that have an award that is not the Tony Award.",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on musicals that have an award that is not the Tony Award. Firstly, we need to identify the musicals with awards. Secondly, we need to filter the nominees of those musicals.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Musical_ID from table 'musical' where Award is not the Tony Award. In the second step, we need to filter the nominees from table 'musical'.\n\n<3> SQL Generation: Use 'where' to filter musicals with awards that are not the Tony Award, and then select the different nominees from those musicals.\n\nSQL query: SELECT DISTINCT Nominee FROM musical WHERE Award != \"Tony Award\"",
        "predict": "SELECT DISTINCT Nominee FROM musical WHERE Award != \"Tony Award\"",
        "hardness": "easy"
    },
    {
        "db_id": "musical",
        "gold": "SELECT Name FROM musical WHERE Musical_ID NOT IN (SELECT Musical_ID FROM actor)",
        "question": "List the name of musicals that do not have actors.",
        "fields": "Table actor, columns = [*,Actor_ID,Name,Musical_ID,Character,Duration,age]\nTable musical, columns = [*,Musical_ID,Name,Year,Award,Category,Nominee,Result]\n",
        "foreign_keys": "Foreign_keys = [actor.Musical_ID = actor.Actor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding musicals that do not have actors. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'musical' table for this query.\n\n<3> SQL Generation: Use 'where' to filter musicals that do not have actors.\n\nSQL query: SELECT Name FROM musical WHERE Musical_ID NOT IN (SELECT Musical_ID FROM actor)",
        "predict": "SELECT Name FROM musical WHERE Musical_ID NOT IN (SELECT Musical_ID FROM actor)",
        "hardness": "hard"
    },
    {
        "db_id": "twitter_1",
        "gold": "SELECT name ,  email FROM user_profiles WHERE followers  >  1000",
        "question": "Find the name and email of the users who have more than 1000 followers.",
        "fields": "Table follows, columns = [*,f1,f2]\nTable tweets, columns = [*,id,uid,text,createdate]\nTable user_profiles, columns = [*,uid,name,email,partitionid,followers]\n",
        "foreign_keys": "Foreign_keys = [follows.f2 = user_profiles.uid,follows.f1 = user_profiles.uid,tweets.uid = user_profiles.uid]\n",
        "reasoning": "<1> Decomposition: We need to filter users based on the number of followers they have, specifically those with more than 1000 followers. Then, we need to retrieve their name and email.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select name and email from table 'user_profiles' and filter by the number of followers.\n\n<3> SQL Generation: Use 'where' to filter users with more than 1000 followers, and then select their name and email.\n\nSQL query: SELECT name ,  email FROM user_profiles WHERE followers  >  1000",
        "predict": "SELECT name ,  email FROM user_profiles WHERE followers  >  1000",
        "hardness": "medium"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT aid FROM Aircraft WHERE distance  >  1000",
        "question": "Show ids for all aircrafts with more than 1000 distance.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on aircrafts with more than 1000 distance. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter on the 'distance' column, we only need the 'aircraft' table.\n\n<3> SQL Generation: Use 'where' to filter aircrafts with more than 1000 distance.\n\nSQL query: SELECT aid FROM Aircraft WHERE distance  >  1000",
        "predict": "SELECT aid FROM Aircraft WHERE distance  >  1000",
        "hardness": "easy"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000",
        "question": "What is the number of employees that have a salary between 100000 and 200000?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on employees with a salary between 100000 and 200000. We need to select employees based on their salary.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'employee' table for this query.\n\n<3> SQL Generation: Use 'where' to filter employees based on their salary range and count the number of employees that meet the condition.\n\nSQL query: SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000",
        "predict": "SELECT count(*) FROM Employee WHERE salary BETWEEN 100000 AND 200000",
        "hardness": "easy"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT name FROM Employee WHERE salary  >  (SELECT avg(salary) FROM Employee)",
        "question": "What are the names of all employees who have a salary higher than average?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average salary of all employees. Secondly, we need to filter employees based on their salary being higher than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'employee' table for this query, we can directly use it.\n\n<3> SQL Generation: Use 'avg' to calculate the average salary of all employees, and then use 'where' to filter employees with a salary higher than the average.\n\nSQL query: SELECT name FROM Employee WHERE salary  >  (SELECT avg(salary) FROM Employee)",
        "predict": "SELECT name FROM Employee WHERE salary  >  (SELECT avg(salary) FROM Employee)",
        "hardness": "hard"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "question": "Show me the departure date and arrival date for all flights from Los Angeles to Honolulu.",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter flights based on their origin and destination. Secondly, we need to select the departure date and arrival date for the filtered flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select departure_date and arrival_date from table 'flight' and filter by origin and destination.\n\n<3> SQL Generation: Use 'where' to filter flights from Los Angeles to Honolulu, and then select the departure date and arrival date.\n\nSQL query: SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "predict": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "hardness": "medium"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "question": "What are the departure and arrival dates of all flights from LA to Honolulu?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter flights based on their origin and destination. Secondly, we need to select the departure and arrival dates of the filtered flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select departure_date and arrival_date from table 'flight' and filter by origin = 'LA' and destination = 'Honolulu'.\n\n<3> SQL Generation: Use 'where' to filter flights with origin = 'LA' and destination = 'Honolulu', and then select the departure_date and arrival_date.\n\nSQL query: SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "predict": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  \"Los Angeles\" AND destination  =  \"Honolulu\"",
        "hardness": "medium"
    },
    {
        "db_id": "flight_1",
        "gold": "SELECT flno FROM Flight WHERE distance  >  2000",
        "question": "What are the numbers of all flights that can cover a distance of more than 2000?",
        "fields": "Table aircraft, columns = [*,aid,name,distance]\nTable certificate, columns = [*,eid,aid]\nTable employee, columns = [*,eid,name,salary]\nTable flight, columns = [*,flno,origin,destination,distance,departure_date,arrival_date,price,aid]\n",
        "foreign_keys": "Foreign_keys = [flight.aid = aircraft.aid,certificate.aid = aircraft.aid,certificate.eid = employee.eid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on flights that can cover a distance of more than 2000. We need to select the flight numbers that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'flight' table for this query.\n\n<3> SQL Generation: Use 'where' to filter flights with a distance greater than 2000, and select the flight numbers.\n\nSQL query: SELECT flno FROM Flight WHERE distance  >  2000",
        "predict": "SELECT flno FROM Flight WHERE distance  >  2000",
        "hardness": "easy"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Student WHERE age  =  18",
        "question": "How many students are 18 years old?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of students who are 18 years old.\n\n<2> Schema Linking: In this step, we identify the table and column that should be used based on the first step. We need to use the 'Student' table and the 'Age' column.\n\n<3> SQL Generation: Use 'where' to filter students who are 18 years old and then use 'count' to calculate the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM Student WHERE age  =  18",
        "predict": "SELECT count(*) FROM Student WHERE age  =  18",
        "hardness": "easy"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT StuID FROM Student WHERE age  >  20",
        "question": "What are the student ids for students over 20 years old?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on students over 20 years old. We need to select the student ids for these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table.\n\n<3> SQL Generation: Use 'where' to filter students with age greater than 20 and select their student ids.\n\nSQL query: SELECT StuID FROM Student WHERE age  >  20",
        "predict": "SELECT StuID FROM Student WHERE age  >  20",
        "hardness": "easy"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Student WHERE city_code  =  \"HKG\" OR city_code  =  \"CHI\"",
        "question": "How many students live in HKG or CHI?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their city_code, selecting only those who live in HKG or CHI. Secondly, we need to count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table and the 'city_code' column.\n\n<3> SQL Generation: Use 'where' to filter students who live in HKG or CHI, and then use 'count' to count the number of selected students.\n\nSQL query: SELECT count(*) FROM Student WHERE city_code  =  \"HKG\" OR city_code  =  \"CHI\"",
        "predict": "SELECT count(*) FROM Student WHERE city_code  =  \"HKG\" OR city_code  =  \"CHI\"",
        "hardness": "medium"
    },
    {
        "db_id": "allergy_1",
        "gold": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  \"Cat\"",
        "question": "How many students have cat allergies?",
        "fields": "Table Allergy_Type, columns = [*,Allergy,AllergyType]\nTable Has_Allergy, columns = [*,StuID,Allergy]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_Allergy.Allergy = Allergy_Type.Allergy,Has_Allergy.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: We need to filter students based on their allergies, specifically cat allergies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from the table 'Has_Allergy' where Allergy is 'cat'.\n\n<3> SQL Generation: Use 'where' to filter students with cat allergies and count them.\n\nSQL query: SELECT count(*) FROM Has_allergy WHERE Allergy  =  \"Cat\"",
        "predict": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  \"Cat\"",
        "hardness": "easy"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT T1.first_name ,  T1.last_name FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id ORDER BY T2.invoice_date DESC LIMIT 5;",
        "question": "What are the first and last names of the 5 customers who purchased something most recently?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the most recent purchase date. Secondly, we need to find the customers who made purchases on that date. Finally, we need to select the first and last names of those customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first and last names from the 'customers' table and filter by the most recent purchase date from the 'invoices' table.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the most recent purchase date from the 'invoices' table. Then, join the 'invoices' and 'customers' tables on the 'customer_id' column and filter by the most recent purchase date. Finally, select the first and last names of the customers.\n\nSQL query: SELECT T1.first_name ,  T1.last_name FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id ORDER BY T2.invoice_date DESC LIMIT 5;",
        "predict": "SELECT T1.first_name ,  T1.last_name FROM customers AS T1 JOIN invoices AS T2 ON T2.customer_id  =  T1.id ORDER BY T2.invoice_date DESC LIMIT 5;",
        "hardness": "hard"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM albums AS T1 JOIN artists AS T2 ON  T1.artist_id = T2.id WHERE T2.name = \"Billy Cobham\";",
        "question": "How many albums has Billy Cobam released?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the artist_id of Billy Cobam. Secondly, we need to count the number of albums released by Billy Cobam based on his artist_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'artists' where name = 'Billy Cobam'. In the second step, we need to count the number of albums from table 'albums' where artist_id matches the artist_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the artist_id of Billy Cobam, and then use 'count' to count the number of albums where artist_id matches the artist_id found in the first step.\n\nSQL query: SELECT count(*) FROM albums AS T1 JOIN artists AS T2 ON  T1.artist_id = T2.id WHERE T2.name = \"Billy Cobham\";",
        "predict": "SELECT count(*) FROM albums AS T1 JOIN artists AS T2 ON  T1.artist_id = T2.id WHERE T2.name = \"Billy Cobham\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "question": "What is Astrid Gruber's email and phone number?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: We need to find the email and phone number of Astrid Gruber.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select email and phone from table 'customers' where first_name = 'Astrid' and last_name = 'Gruber'.\n\n<3> SQL Generation: Use 'where' to filter customers with first_name = 'Astrid' and last_name = 'Gruber', and then select email and phone.\n\nSQL query: SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "predict": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "question": "What is the email and phone number of Astrid Gruber the customer?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with the name 'Astrid Gruber'. Secondly, we need to retrieve their email and phone number.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select email and phone from table 'customers' where first_name = 'Astrid' and last_name = 'Gruber'.\n\n<3> SQL Generation: Use 'where' to find the customer with the name 'Astrid Gruber', and then select their email and phone number.\n\nSQL query: SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "predict": "SELECT email ,  phone FROM customers WHERE first_name = \"Astrid\" AND last_name = \"Gruber\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers WHERE city = \"Prague\";",
        "question": "How many customers live in Prague city?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of customers who live in Prague city.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of customers from the 'customers' table where the city is Prague.\n\n<3> SQL Generation: Use 'where' to filter customers who live in Prague city and count them.\n\nSQL query: SELECT count(*) FROM customers WHERE city = \"Prague\";",
        "predict": "SELECT count(*) FROM customers WHERE city = \"Prague\";",
        "hardness": "easy"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "question": "How many customers in state of CA?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of customers in the state of CA.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the count of customers from the 'customers' table where the state is CA.\n\n<3> SQL Generation: Use 'where' to filter customers in the state of CA and count them.\n\nSQL query: SELECT count(*) FROM customers WHERE state = \"CA\";",
        "predict": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "hardness": "easy"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "question": "How many customers are from California?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: We need to count the number of customers who are from California.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'customers' table and the 'state' column.\n\n<3> SQL Generation: Use 'where' to filter customers from California and count them.\n\nSQL query: SELECT count(*) FROM customers WHERE state = \"CA\";",
        "predict": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "hardness": "easy"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT country FROM customers WHERE first_name = \"Roberto\" AND last_name = \"Almeida\";",
        "question": "In which country does Roberto Almeida?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: We need to find the country of Roberto Almeida. To do this, we need to identify the customer with the name \"Roberto Almeida\" and retrieve their country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the country from the customers table where the first_name is \"Roberto\" and the last_name is \"Almeida\".\n\n<3> SQL Generation: Use 'where' to filter the customers table based on the first_name and last_name, and then select the country.\n\nSQL query: SELECT country FROM customers WHERE first_name = \"Roberto\" AND last_name = \"Almeida\";",
        "predict": "SELECT country FROM customers WHERE first_name = \"Roberto\" AND last_name = \"Almeida\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM employees AS T1 JOIN customers AS T2 ON T2.support_rep_id = T1.id WHERE T1.first_name = \"Steve\" AND T1.last_name = \"Johnson\";",
        "question": "How many customers does Steve Johnson support?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the support_rep_id of Steve Johnson. Secondly, we need to count the number of customers with the support_rep_id found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'employees' where first_name = 'Steve' and last_name = 'Johnson'. In the second step, we need to count the number of customers with support_rep_id from table 'customers'.\n\n<3> SQL Generation: Use 'where' to find the support_rep_id of Steve Johnson, and then use 'count' to count the number of customers with the support_rep_id found in the first step.\n\nSQL query: SELECT count(*) FROM employees AS T1 JOIN customers AS T2 ON T2.support_rep_id = T1.id WHERE T1.first_name = \"Steve\" AND T1.last_name = \"Johnson\";",
        "predict": "SELECT count(*) FROM employees AS T1 JOIN customers AS T2 ON T2.support_rep_id = T1.id WHERE T1.first_name = \"Steve\" AND T1.last_name = \"Johnson\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT address FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "question": "What is the address of employee Nancy Edwards?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the address of employee Nancy Edwards.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the address from the 'employees' table where the first name is 'Nancy' and the last name is 'Edwards'.\n\n<3> SQL Generation: Use 'where' to filter the rows where the first name is 'Nancy' and the last name is 'Edwards', and then select the address.\n\nSQL query: SELECT address FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "predict": "SELECT address FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT phone FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "question": "What is employee Nancy Edwards's phone number?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the phone number of employee Nancy Edwards.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the phone number from the 'employees' table where the first name is 'Nancy' and the last name is 'Edwards'.\n\n<3> SQL Generation: Use 'where' to filter the rows where the first name is 'Nancy' and the last name is 'Edwards', and then select the phone number.\n\nSQL query: SELECT phone FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "predict": "SELECT phone FROM employees WHERE first_name = \"Nancy\" AND last_name = \"Edwards\";",
        "hardness": "medium"
    },
    {
        "db_id": "store_1",
        "gold": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "question": "How many orders does Luca Mancini have in his invoices?",
        "fields": "Table albums, columns = [*,id,title,artist_id]\nTable artists, columns = [*,id,name]\nTable customers, columns = [*,id,first_name,last_name,company,address,city,state,country,postal_code,phone,fax,email,support_rep_id]\nTable employees, columns = [*,id,last_name,first_name,title,reports_to,birth_date,hire_date,address,city,state,country,postal_code,phone,fax,email]\nTable genres, columns = [*,id,name]\nTable invoice_lines, columns = [*,id,invoice_id,track_id,unit_price,quantity]\nTable invoices, columns = [*,id,customer_id,invoice_date,billing_address,billing_city,billing_state,billing_country,billing_postal_code,total]\nTable media_types, columns = [*,id,name]\nTable playlist_tracks, columns = [*,playlist_id,track_id]\nTable playlists, columns = [*,id,name]\nTable sqlite_sequence, columns = [*,name,seq]\nTable tracks, columns = [*,id,name,album_id,media_type_id,genre_id,composer,milliseconds,bytes,unit_price]\n",
        "foreign_keys": "Foreign_keys = [albums.artist_id = artists.id,employees.reports_to = employees.id,customers.support_rep_id = employees.id,invoices.customer_id = customers.id,tracks.media_type_id = media_types.id,tracks.genre_id = genres.id,tracks.album_id = albums.id,invoice_lines.track_id = tracks.id,invoice_lines.invoice_id = invoices.id,playlist_tracks.track_id = tracks.id,playlist_tracks.playlist_id = playlists.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of Luca Mancini. Secondly, we need to count the number of orders in his invoices.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'customers' where first_name = 'Luca' and last_name = 'Mancini'. In the second step, we need to count the number of invoices where customer_id is the value found in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id of Luca Mancini, and then use 'where' to count the number of invoices where customer_id is the value found in the first step.\n\nSQL query: SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "predict": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "hardness": "medium"
    },
    {
        "db_id": "journal_committee",
        "gold": "SELECT Name FROM editor WHERE editor_id NOT IN (SELECT editor_id FROM journal_committee)",
        "question": "List the names of editors that are not on any journal committee.",
        "fields": "Table editor, columns = [*,Editor_ID,Name,Age]\nTable journal, columns = [*,Journal_ID,Date,Theme,Sales]\nTable journal_committee, columns = [*,Editor_ID,Journal_ID,Work_Type]\n",
        "foreign_keys": "Foreign_keys = [journal_committee.Journal_ID = journal.Journal_ID,journal_committee.Editor_ID = editor.Editor_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on editors who are not on any journal committee. Firstly, we need to identify the editors who are on journal committees. Secondly, we need to filter out the editors who are on journal committees and return the remaining editors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter editors who are on journal committees, we only need the 'editor' and 'journal_committee' tables.\n\n<3> SQL Generation: We can use a subquery to select the editor IDs of editors who are on journal committees. Then, we can use 'not in' to filter out the editors who are on journal committees and select their names.\n\nSQL query: SELECT Name FROM editor WHERE editor_id NOT IN (SELECT editor_id FROM journal_committee)",
        "predict": "SELECT Name FROM editor WHERE editor_id NOT IN (SELECT editor_id FROM journal_committee)",
        "hardness": "hard"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "question": "Show the number of all customers without an account.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding customers without an account. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customers' and check if there is a corresponding entry in the 'Accounts' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Customers' and 'Accounts' tables on the 'customer_id' column. Then, we can filter the rows where the 'account_id' is null (indicating no account exists for that customer). Finally, we can count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "predict": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "question": "How many customers do not have an account?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding customers who do not have an account.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customers' and check if it exists in the 'account_id' column of table 'Accounts'.\n\n<3> SQL Generation: Use 'where' to filter customers who do not have an account and count them.\n\nSQL query: SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "predict": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "question": "What is the phone and email for customer with first name Aniyah and last name Feest?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id for the customer with first name Aniyah and last name Feest. Secondly, we need to retrieve the phone and email for that customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_first_name = 'Aniyah' and customer_last_name = 'Feest'. In the second step, we need to retrieve customer_phone and customer_email from table 'Customers' using the customer_id obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id for the customer with first name Aniyah and last name Feest, and then use 'select' to retrieve the phone and email for that customer.\n\nSQL query: SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "predict": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "hardness": "medium"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "question": "Return the phone and email of the customer with the first name Aniyah and last name Feest.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with the first name 'Aniyah' and last name 'Feest'. Secondly, we need to select the phone and email of the selected customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the phone and email of the customer, we only need the 'Customers' table.\n\n<3> SQL Generation: Use 'where' to filter customers with the first name 'Aniyah' and last name 'Feest', and then select the phone and email columns.\n\nSQL query: SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "predict": "SELECT customer_phone ,  customer_email FROM Customers WHERE customer_first_name  =  \"Aniyah\" AND customer_last_name  =  \"Feest\"",
        "hardness": "medium"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "question": "How many cards does customer Art Turcotte have?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of customer Art Turcotte. Secondly, we need to count the number of cards associated with that customer_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_first_name = 'Art' and customer_last_name = 'Turcotte'. In the second step, we need to count the number of cards from table 'Customers_Cards' where customer_id matches the customer_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id of customer Art Turcotte, and then use 'count' to count the number of cards associated with that customer_id.\n\nSQL query: SELECT count(*) FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "predict": "SELECT count(*) FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "hardness": "medium"
    },
    {
        "db_id": "customers_card_transactions",
        "gold": "SELECT count(*) FROM Customers_cards WHERE card_type_code  =  \"Debit\"",
        "question": "How many debit cards do we have?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_last_name,customer_address,customer_phone,customer_email,other_customer_details]\nTable Customers_Cards, columns = [*,card_id,customer_id,card_type_code,card_number,date_valid_from,date_valid_to,other_card_details]\nTable Financial_Transactions, columns = [*,transaction_id,previous_transaction_id,account_id,card_id,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\n",
        "foreign_keys": "Foreign_keys = [Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.card_id = Customers_Cards.card_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of debit cards. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the card_type_code from the Customers_Cards table.\n\n<3> SQL Generation: Use 'where' to filter the rows where card_type_code is 'debit' and count the number of rows.\n\nSQL query: SELECT count(*) FROM Customers_cards WHERE card_type_code  =  \"Debit\"",
        "predict": "SELECT count(*) FROM Customers_cards WHERE card_type_code  =  \"Debit\"",
        "hardness": "easy"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name ,  seating FROM track WHERE year_opened  >  2000 ORDER BY seating",
        "question": "What are the names and seatings for all tracks opened after 2000, ordered by seating?",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter tracks that were opened after 2000. Secondly, we need to select the names and seatings of these tracks. Finally, we need to order the results by seating.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'track' table for this query.\n\n<3> SQL Generation: Use 'where' to filter tracks that were opened after 2000, and then select the names and seatings of these tracks. Finally, order the results by seating.\n\nSQL query: SELECT name ,  seating FROM track WHERE year_opened  >  2000 ORDER BY seating",
        "predict": "SELECT name ,  seating FROM track WHERE year_opened  >  2000 ORDER BY seating",
        "hardness": "medium"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "question": "Show all track names that have had no races.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: We need to find the track names that have had no races.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'track' table.\n\n<3> SQL Generation: We can use a subquery to find the track IDs that have had races, and then select the track names that are not in that list.\n\nSQL query: SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "predict": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "hardness": "hard"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "question": "Return the names of tracks that have no had any races.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding tracks that have not had any races. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'track' table.\n\n<3> SQL Generation: We can use a subquery to find the track IDs that have had races, and then use a 'not in' clause to select tracks that are not in that list.\n\nSQL query: SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "predict": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "hardness": "hard"
    },
    {
        "db_id": "race_track",
        "gold": "SELECT year_opened FROM track WHERE seating BETWEEN 4000 AND 5000",
        "question": "Show year where a track with a seating at least 5000 opened and a track with seating no more than 4000 opened.",
        "fields": "Table race, columns = [*,Race_ID,Name,Class,Date,Track_ID]\nTable track, columns = [*,Track_ID,Name,Location,Seating,Year_Opened]\n",
        "foreign_keys": "Foreign_keys = [race.Track_ID = track.Track_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find tracks with seating at least 5000 and tracks with seating no more than 4000. Secondly, we need to select the years when these tracks were opened.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Year_Opened column from the track table.\n\n<3> SQL Generation: Use 'where' to filter tracks with seating at least 5000 and tracks with seating no more than 4000, and then select the corresponding years.\n\nSQL query: SELECT year_opened FROM track WHERE seating BETWEEN 4000 AND 5000",
        "predict": "SELECT year_opened FROM track WHERE seating BETWEEN 4000 AND 5000",
        "hardness": "easy"
    },
    {
        "db_id": "coffee_shop",
        "gold": "SELECT shop_id ,  address FROM shop WHERE score  <  (SELECT avg(score) FROM shop)",
        "question": "Find the id and address of the shops whose score is below the average score.",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average score of all shops. Secondly, we need to filter shops based on their score being below the average score. Finally, we need to select the id and address of the filtered shops.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'shop' table for this query, we can directly use it.\n\n<3> SQL Generation: Use 'select' to calculate the average score of all shops. Then, use 'where' to filter shops with a score below the average score and select their id and address.\n\nSQL query: SELECT shop_id ,  address FROM shop WHERE score  <  (SELECT avg(score) FROM shop)",
        "predict": "SELECT shop_id ,  address FROM shop WHERE score  <  (SELECT avg(score) FROM shop)",
        "hardness": "extra"
    },
    {
        "db_id": "coffee_shop",
        "gold": "SELECT address ,  num_of_staff FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM happy_hour)",
        "question": "Find the address and staff number of the shops that do not have any happy hour.",
        "fields": "Table happy_hour, columns = [*,HH_ID,Shop_ID,Month,Num_of_shaff_in_charge]\nTable happy_hour_member, columns = [*,HH_ID,Member_ID,Total_amount]\nTable member, columns = [*,Member_ID,Name,Membership_card,Age,Time_of_purchase,Level_of_membership,Address]\nTable shop, columns = [*,Shop_ID,Address,Num_of_staff,Score,Open_Year]\n",
        "foreign_keys": "Foreign_keys = [happy_hour.Shop_ID = shop.Shop_ID,happy_hour_member.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the shops that do not have any happy hour. Secondly, we need to select the address and staff number of those shops.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are only interested in the address and staff number of the shops, we only need the 'shop' table.\n\n<3> SQL Generation: Use 'where' to filter the shops that do not have any happy hour, and then select the address and staff number from the 'shop' table.\n\nSQL query: SELECT address ,  num_of_staff FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM happy_hour)",
        "predict": "SELECT address ,  num_of_staff FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM happy_hour)",
        "hardness": "extra"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT COUNT(*) FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId WHERE T2.Name  =  \"Metallica\"",
        "question": "Find the number of albums by the artist \"Metallica\".",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the artist_id of \"Metallica\" from table 'Artist'. Secondly, we need to count the number of albums with the artist_id found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select artist_id from table 'Artist' where name = \"Metallica\". In the second step, we need to count the number of albums from table 'Album' where artist_id is the value found in the first step.\n\n<3> SQL Generation: Use 'where' to find the artist_id of \"Metallica\", and then use 'where' to count the number of albums with the artist_id found in the first step.\n\nSQL query: SELECT COUNT(*) FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId WHERE T2.Name  =  \"Metallica\"",
        "predict": "SELECT COUNT(*) FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId WHERE T2.Name  =  \"Metallica\"",
        "hardness": "medium"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT COUNT(*) FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId WHERE T1.Name  =  \"AAC audio file\"",
        "question": "How many tracks are in the AAC audio file media type?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the media type with the name 'AAC audio file'. Secondly, we need to count the number of tracks that have this media type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for tracks with a specific media type, we need to select the 'MediaTypeId' from the 'MediaType' table. Then, we need to count the number of tracks that have this media type, so we need to select the 'TrackId' from the 'Track' table.\n\n<3> SQL Generation: Use 'where' to find the media type with the name 'AAC audio file', and then use 'where' to filter tracks with this media type and count them.\n\nSQL query: SELECT COUNT(*) FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId WHERE T1.Name  =  \"AAC audio file\"",
        "predict": "SELECT COUNT(*) FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId WHERE T1.Name  =  \"AAC audio file\"",
        "hardness": "medium"
    },
    {
        "db_id": "chinook_1",
        "gold": "SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM)",
        "question": "How many artists do not have any album?",
        "fields": "Table Album, columns = [*,AlbumId,Title,ArtistId]\nTable Artist, columns = [*,ArtistId,Name]\nTable Customer, columns = [*,CustomerId,FirstName,LastName,Company,Address,City,State,Country,PostalCode,Phone,Fax,Email,SupportRepId]\nTable Employee, columns = [*,EmployeeId,LastName,FirstName,Title,ReportsTo,BirthDate,HireDate,Address,City,State,Country,PostalCode,Phone,Fax,Email]\nTable Genre, columns = [*,GenreId,Name]\nTable Invoice, columns = [*,InvoiceId,CustomerId,InvoiceDate,BillingAddress,BillingCity,BillingState,BillingCountry,BillingPostalCode,Total]\nTable InvoiceLine, columns = [*,InvoiceLineId,InvoiceId,TrackId,UnitPrice,Quantity]\nTable MediaType, columns = [*,MediaTypeId,Name]\nTable Playlist, columns = [*,PlaylistId,Name]\nTable PlaylistTrack, columns = [*,PlaylistId,TrackId]\nTable Track, columns = [*,TrackId,Name,AlbumId,MediaTypeId,GenreId,Composer,Milliseconds,Bytes,UnitPrice]\n",
        "foreign_keys": "Foreign_keys = [Album.ArtistId = Artist.ArtistId,Customer.SupportRepId = Employee.EmployeeId,Employee.ReportsTo = Employee.EmployeeId,Invoice.CustomerId = Customer.CustomerId,InvoiceLine.TrackId = Track.TrackId,InvoiceLine.InvoiceId = Invoice.InvoiceId,PlaylistTrack.TrackId = Track.TrackId,PlaylistTrack.PlaylistId = Playlist.PlaylistId,Track.MediaTypeId = MediaType.MediaTypeId,Track.GenreId = Genre.GenreId,Track.AlbumId = Album.AlbumId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the artists who do not have any albums. Secondly, we need to count the number of artists found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for artists who do not have any albums, we only need the 'Artist' table.\n\n<3> SQL Generation: Use 'left join' to combine the 'Artist' table with the 'Album' table on the 'ArtistId' column. Then, filter the rows where the 'AlbumId' is null (indicating that the artist does not have any albums). Finally, count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM)",
        "predict": "SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM)",
        "hardness": "extra"
    },
    {
        "db_id": "insurance_fnol",
        "gold": "SELECT count(*) FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "question": "How many policies are listed for the customer named \"Dayana Robel\"?",
        "fields": "Table Available_Policies, columns = [*,Policy_ID,policy_type_code,Customer_Phone]\nTable Claims, columns = [*,Claim_ID,FNOL_ID,Effective_Date]\nTable Customers, columns = [*,Customer_ID,Customer_name]\nTable Customers_Policies, columns = [*,Customer_ID,Policy_ID,Date_Opened,Date_Closed]\nTable First_Notification_of_Loss, columns = [*,FNOL_ID,Customer_ID,Policy_ID,Service_ID]\nTable Services, columns = [*,Service_ID,Service_name]\nTable Settlements, columns = [*,Settlement_ID,Claim_ID,Effective_Date,Settlement_Amount]\n",
        "foreign_keys": "Foreign_keys = [Customers_Policies.Policy_ID = Available_Policies.Policy_ID,Customers_Policies.Customer_ID = Customers.Customer_ID,First_Notification_of_Loss.Customer_ID = Customers_Policies.Customer_ID,First_Notification_of_Loss.Policy_ID = Customers_Policies.Policy_ID,First_Notification_of_Loss.Service_ID = Services.Service_ID,Claims.FNOL_ID = First_Notification_of_Loss.FNOL_ID,Settlements.Claim_ID = Claims.Claim_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with the name \"Dayana Robel\". Secondly, we need to count the number of policies listed for that customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Customer_ID from table 'Customers' where Customer_name = \"Dayana Robel\". In the second step, we need to count the number of policies listed for that customer in table 'Customers_Policies'.\n\n<3> SQL Generation: Use 'where' to find the customer with the name \"Dayana Robel\", and then use 'count' to count the number of policies listed for that customer.\n\nSQL query: SELECT count(*) FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "predict": "SELECT count(*) FROM customers AS t1 JOIN customers_policies AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  \"Dayana Robel\"",
        "hardness": "medium"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id  =  T3.id WHERE T3.name  =  'Amisulpride' AND T2.interaction_type  =  'inhibitor'",
        "question": "What are the names of the enzymes used in the medicine  Amisulpride that acts as inhibitors?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the medicine with the name 'Amisulpride'. Secondly, we need to find the enzymes that are used in this medicine and act as inhibitors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'medicine' where name = 'Amisulpride'. In the second step, we need to select name from table 'enzyme' based on the enzyme_id in table 'medicine_enzyme_interaction'.\n\n<3> SQL Generation: Use 'where' to find the medicine with the name 'Amisulpride', and then use 'join' to link the 'medicine_enzyme_interaction' and 'enzyme' tables based on the enzyme_id. Finally, filter the rows where the interaction_type is 'inhibitor' and select the enzyme names.\n\nSQL query: SELECT T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id  =  T3.id WHERE T3.name  =  'Amisulpride' AND T2.interaction_type  =  'inhibitor'",
        "predict": "SELECT T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id JOIN medicine AS T3 ON T2.medicine_id  =  T3.id WHERE T3.name  =  'Amisulpride' AND T2.interaction_type  =  'inhibitor'",
        "hardness": "hard"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT T1.interaction_type FROM medicine_enzyme_interaction AS T1 JOIN medicine AS T2 ON T1.medicine_id  =  T2.id JOIN enzyme AS T3 ON T1.enzyme_id  =  T3.id WHERE T3.name  =  'ALA synthase' AND T2.name  =  'Aripiprazole'",
        "question": "What is the interaction type of the enzyme named 'ALA synthase' and the medicine named 'Aripiprazole'?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the enzyme with the name 'ALA synthase'. Secondly, we need to find the medicine with the name 'Aripiprazole'. Finally, we need to find the interaction type between these two entities.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the interaction_type from the table 'medicine_enzyme_interaction' where enzyme_id corresponds to the enzyme with the name 'ALA synthase' and medicine_id corresponds to the medicine with the name 'Aripiprazole'.\n\n<3> SQL Generation: Use 'where' to find the enzyme with the name 'ALA synthase' and the medicine with the name 'Aripiprazole', and then use 'where' to filter the interaction_type between these two entities.\n\nSQL query: SELECT T1.interaction_type FROM medicine_enzyme_interaction AS T1 JOIN medicine AS T2 ON T1.medicine_id  =  T2.id JOIN enzyme AS T3 ON T1.enzyme_id  =  T3.id WHERE T3.name  =  'ALA synthase' AND T2.name  =  'Aripiprazole'",
        "predict": "SELECT T1.interaction_type FROM medicine_enzyme_interaction AS T1 JOIN medicine AS T2 ON T1.medicine_id  =  T2.id JOIN enzyme AS T3 ON T1.enzyme_id  =  T3.id WHERE T3.name  =  'ALA synthase' AND T2.name  =  'Aripiprazole'",
        "hardness": "hard"
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "gold": "SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );",
        "question": "How many enzymes do not have any interactions?",
        "fields": "Table enzyme, columns = [*,id,name,Location,Product,Chromosome,OMIM,Porphyria]\nTable medicine, columns = [*,id,name,Trade_Name,FDA_approved]\nTable medicine_enzyme_interaction, columns = [*,enzyme_id,medicine_id,interaction_type]\n",
        "foreign_keys": "Foreign_keys = [medicine_enzyme_interaction.medicine_id = medicine.id,medicine_enzyme_interaction.enzyme_id = enzyme.id]\n",
        "reasoning": "<1> Decomposition: The query requires finding enzymes that do not have any interactions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select enzyme_id from table 'enzyme' and filter by enzyme_id in table 'medicine_enzyme_interaction'.\n\n<3> SQL Generation: Use 'where' to filter enzymes that do not have any interactions and count them.\n\nSQL query: SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );",
        "predict": "SELECT count(*) FROM enzyme WHERE id NOT IN ( SELECT enzyme_id FROM medicine_enzyme_interaction );",
        "hardness": "extra"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT founded FROM university WHERE affiliation != 'Public' ORDER BY founded DESC LIMIT 1",
        "question": "What is the founded year of the non public school that was founded most recently?",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter non-public schools. Secondly, we need to find the school with the most recent founded year among the filtered schools. Finally, we need to select the founded year of that school.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'university' table to filter non-public schools and select the founded year.\n\n<3> SQL Generation: Use 'where' to filter non-public schools, and then use 'order by' and 'desc' to select the school with the most recent founded year. Finally, select the founded year of that school.\n\nSQL query: SELECT founded FROM university WHERE affiliation != 'Public' ORDER BY founded DESC LIMIT 1",
        "predict": "SELECT founded FROM university WHERE affiliation != 'Public' ORDER BY founded DESC LIMIT 1",
        "hardness": "hard"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "question": "How many schools do not participate in the basketball match?",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding schools that do not participate in the basketball match. We need to count the number of schools that do not have any entries in the basketball_match table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the university table to count the number of schools.\n\n<3> SQL Generation: We can use a left join between the university table and the basketball_match table, and then count the number of rows where the basketball_match columns are null.\n\nSQL query: SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "predict": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "hardness": "extra"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "question": "Count the number of universities that do not participate in the baketball match.",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of universities that do not participate in the basketball match. We need to filter out universities that do participate in the basketball match.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select School_ID from table 'university' and filter out School_ID from table 'basketball_match'.\n\n<3> SQL Generation: Use 'where' to filter out universities that participate in the basketball match, and then use 'count' to count the number of universities that do not participate.\n\nSQL query: SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "predict": "SELECT count(*) FROM university WHERE school_id NOT IN (SELECT school_id FROM basketball_match)",
        "hardness": "extra"
    },
    {
        "db_id": "university_basketball",
        "gold": "SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "question": "Find how many school locations have the word 'NY'.",
        "fields": "Table basketball_match, columns = [*,Team_ID,School_ID,Team_Name,ACC_Regular_Season,ACC_Percent,ACC_Home,ACC_Road,All_Games,All_Games_Percent,All_Home,All_Road,All_Neutral]\nTable university, columns = [*,School_ID,School,Location,Founded,Affiliation,Enrollment,Nickname,Primary_conference]\n",
        "foreign_keys": "Foreign_keys = [basketball_match.School_ID = university.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter school locations that have the word 'NY'. Secondly, we need to count the number of unique school locations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires information from the 'university' table, we only need to use the 'university' table.\n\n<3> SQL Generation: Use 'where' to filter school locations that have the word 'NY', and then use 'count' to count the number of unique school locations.\n\nSQL query: SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "predict": "SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "hardness": "medium"
    },
    {
        "db_id": "phone_1",
        "gold": "SELECT count(*) FROM phone WHERE Company_name = \"Nokia Corporation\";",
        "question": "How many phone hardware models are produced by the company named \"Nokia Corporation\"?",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter phone hardware models produced by the company named \"Nokia Corporation\". Secondly, we need to count the number of unique hardware models.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter by the company name in the 'phone' table, we only need the 'phone' table.\n\n<3> SQL Generation: Use 'where' to filter phone hardware models produced by the company named \"Nokia Corporation\", and then use 'count' to count the number of unique hardware models.\n\nSQL query: SELECT count(*) FROM phone WHERE Company_name = \"Nokia Corporation\";",
        "predict": "SELECT count(*) FROM phone WHERE Company_name = \"Nokia Corporation\";",
        "hardness": "easy"
    },
    {
        "db_id": "phone_1",
        "gold": "SELECT avg(RAM_MiB) FROM chip_model WHERE model_name NOT IN (SELECT chip_model FROM phone)",
        "question": "Find the average ram mib size of the chip models that are never used by any phone.",
        "fields": "Table chip_model, columns = [*,Model_name,Launch_year,RAM_MiB,ROM_MiB,Slots,WiFi,Bluetooth]\nTable phone, columns = [*,Company_name,Hardware_Model_name,Accreditation_type,Accreditation_level,Date,chip_model,screen_mode]\nTable screen_mode, columns = [*,Graphics_mode,Char_cells,Pixels,Hardware_colours,used_kb,map,Type]\n",
        "foreign_keys": "Foreign_keys = [phone.chip_model = chip_model.Model_name,phone.screen_mode = screen_mode.Graphics_mode]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the chip models that are never used by any phone. Secondly, we need to calculate the average RAM_MiB size of those chip models.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Model_name from table 'chip_model' where Model_name does not exist in the 'chip_model' column of table 'phone'. In the second step, we need to calculate the average RAM_MiB size from table 'chip_model'.\n\n<3> SQL Generation: Use 'where not exists' to find the chip models that are never used by any phone, and then use 'avg' to calculate the average RAM_MiB size of those chip models.\n\nSQL query: SELECT avg(RAM_MiB) FROM chip_model WHERE model_name NOT IN (SELECT chip_model FROM phone)",
        "predict": "SELECT avg(RAM_MiB) FROM chip_model WHERE model_name NOT IN (SELECT chip_model FROM phone)",
        "hardness": "extra"
    },
    {
        "db_id": "match_season",
        "gold": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "question": "What are the names of teams that do no have match season record?",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding teams that do not have match season records.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is about teams and match seasons, we need tables ['team', 'match_season'].\n\n<3> SQL Generation: We need to use a left join to combine the 'team' and 'match_season' tables on the 'Team_id' column. Then, we filter the rows where the 'Season' column is null (indicating no match season record). Finally, we select the 'Name' column from the 'team' table.\n\nSQL query: SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "predict": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "hardness": "hard"
    },
    {
        "db_id": "match_season",
        "gold": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "question": "Return the names of teams that have no match season record.",
        "fields": "Table country, columns = [*,Country_id,Country_name,Capital,Official_native_language]\nTable match_season, columns = [*,Season,Player,Position,Country,Team,Draft_Pick_Number,Draft_Class,College]\nTable player, columns = [*,Player_ID,Player,Years_Played,Total_WL,Singles_WL,Doubles_WL,Team]\nTable team, columns = [*,Team_id,Name]\n",
        "foreign_keys": "Foreign_keys = [match_season.Team = team.Team_id,match_season.Country = country.Country_id,player.Team = team.Team_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding teams that have no match season record.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find teams that have no match season record, we only need the 'team' table.\n\n<3> SQL Generation: We can use a 'left join' to join the 'team' table with the 'match_season' table on the 'Team_id' column. Then, we can filter the rows where the 'match_season' columns are null, indicating that there is no match season record for that team. Finally, we can select the 'Name' column from the 'team' table.\n\nSQL query: SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "predict": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "hardness": "hard"
    },
    {
        "db_id": "climbing",
        "gold": "SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber)",
        "question": "What are the names of countains that no climber has climbed?",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the mountains that no climber has climbed. Secondly, we need to retrieve the names of those mountains.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Mountain_ID from table 'mountain' where there is no corresponding entry in the 'climber' table.\n\n<3> SQL Generation: Use 'where not exists' to find the mountains that no climber has climbed, and then select the names of those mountains.\n\nSQL query: SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber)",
        "predict": "SELECT Name FROM mountain WHERE Mountain_ID NOT IN (SELECT Mountain_ID FROM climber)",
        "hardness": "hard"
    },
    {
        "db_id": "climbing",
        "gold": "SELECT Name FROM mountain WHERE Height  >  5000 OR Prominence  >  1000",
        "question": "What are the names of mountains that have a height of over 5000 or a prominence of over 1000?",
        "fields": "Table climber, columns = [*,Climber_ID,Name,Country,Time,Points,Mountain_ID]\nTable mountain, columns = [*,Mountain_ID,Name,Height,Prominence,Range,Country]\n",
        "foreign_keys": "Foreign_keys = [climber.Mountain_ID = mountain.Mountain_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on mountains with a height over 5000 or a prominence over 1000. We need to select the names of these mountains.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'mountain' table.\n\n<3> SQL Generation: Use 'where' to filter mountains with a height over 5000 or a prominence over 1000, and select their names.\n\nSQL query: SELECT Name FROM mountain WHERE Height  >  5000 OR Prominence  >  1000",
        "predict": "SELECT Name FROM mountain WHERE Height  >  5000 OR Prominence  >  1000",
        "hardness": "medium"
    },
    {
        "db_id": "body_builder",
        "gold": "SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Total  >  300",
        "question": "What are the names of body builders whose total score is higher than 300?",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on body builders whose total score is higher than 300. Firstly, we need to identify the body builders with a total score higher than 300. Secondly, we need to retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the total score is in the 'body_builder' table and the names are in the 'people' table, we need to use these two tables.\n\n<3> SQL Generation: Use 'where' to filter body builders with a total score higher than 300, and then select their names.\n\nSQL query: SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Total  >  300",
        "predict": "SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Total  >  300",
        "hardness": "medium"
    },
    {
        "db_id": "body_builder",
        "gold": "SELECT count(*) FROM people WHERE people_id NOT IN (SELECT People_ID FROM body_builder)",
        "question": "How many persons are not body builders?",
        "fields": "Table body_builder, columns = [*,Body_Builder_ID,People_ID,Snatch,Clean_Jerk,Total]\nTable people, columns = [*,People_ID,Name,Height,Weight,Birth_Date,Birth_Place]\n",
        "foreign_keys": "Foreign_keys = [body_builder.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding persons who are not body builders. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find persons who are not body builders, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter out persons who are body builders and count the remaining persons.\n\nSQL query: SELECT count(*) FROM people WHERE people_id NOT IN (SELECT People_ID FROM body_builder)",
        "predict": "SELECT count(*) FROM people WHERE people_id NOT IN (SELECT People_ID FROM body_builder)",
        "hardness": "extra"
    },
    {
        "db_id": "election_representative",
        "gold": "SELECT T2.Name FROM election AS T1 JOIN representative AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE Votes  >  10000",
        "question": "What are the names of representatives with more than 10000 votes in election?",
        "fields": "Table election, columns = [*,Election_ID,Representative_ID,Date,Votes,Vote_Percent,Seats,Place]\nTable representative, columns = [*,Representative_ID,Name,State,Party,Lifespan]\n",
        "foreign_keys": "Foreign_keys = [election.Representative_ID = representative.Representative_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on representatives with more than 10000 votes in an election. Firstly, we need to identify the representatives who received more than 10000 votes. Secondly, we need to retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the filtering is based on the 'Votes' column in the 'election' table, we only need the 'election' table.\n\n<3> SQL Generation: Use 'where' to filter representatives with more than 10000 votes and select their names.\n\nSQL query: SELECT T2.Name FROM election AS T1 JOIN representative AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE Votes  >  10000",
        "predict": "SELECT T2.Name FROM election AS T1 JOIN representative AS T2 ON T1.Representative_ID  =  T2.Representative_ID WHERE Votes  >  10000",
        "hardness": "medium"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "question": "How many apartments do not have any facility?",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding apartments that do not have any facility. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select apt_id from table 'Apartments' and apt_id from table 'Apartment_Facilities'.\n\n<3> SQL Generation: We can use a left join to combine the 'Apartments' table with the 'Apartment_Facilities' table on the apt_id column. Then, we can filter the rows where the facility_code is null, indicating that the apartment does not have any facility. Finally, we can count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "predict": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "hardness": "extra"
    },
    {
        "db_id": "apartment_rentals",
        "gold": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "question": "Find the number of apartments that have no facility.",
        "fields": "Table Apartment_Bookings, columns = [*,apt_booking_id,apt_id,guest_id,booking_status_code,booking_start_date,booking_end_date]\nTable Apartment_Buildings, columns = [*,building_id,building_short_name,building_full_name,building_description,building_address,building_manager,building_phone]\nTable Apartment_Facilities, columns = [*,apt_id,facility_code]\nTable Apartments, columns = [*,apt_id,building_id,apt_type_code,apt_number,bathroom_count,bedroom_count,room_count]\nTable Guests, columns = [*,guest_id,gender_code,guest_first_name,guest_last_name,date_of_birth]\nTable View_Unit_Status, columns = [*,apt_id,apt_booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Apartments.building_id = Apartment_Buildings.building_id,Apartment_Facilities.apt_id = Apartments.apt_id,Apartment_Bookings.guest_id = Guests.guest_id,Apartment_Bookings.apt_id = Apartments.apt_id,View_Unit_Status.apt_booking_id = Apartment_Bookings.apt_booking_id,View_Unit_Status.apt_id = Apartments.apt_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding apartments that have no facility. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select apt_id from table 'Apartments' and filter by apt_id in table 'Apartment_Facilities'.\n\n<3> SQL Generation: We can use a left join to combine the 'Apartments' and 'Apartment_Facilities' tables on the 'apt_id' column. Then, we can filter the rows where the 'facility_code' is null (indicating no facility) and count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "predict": "SELECT count(*) FROM Apartments WHERE apt_id NOT IN (SELECT apt_id FROM Apartment_Facilities)",
        "hardness": "extra"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT count(*) FROM game WHERE season  >  2007",
        "question": "How many games are held after season 2007?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on games held after season 2007. Firstly, we need to identify the games that have a season greater than 2007. Secondly, we need to count the number of games that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the filtering is based on the 'Season' column in the 'game' table, we only need the 'game' table.\n\n<3> SQL Generation: Use 'where' to filter games with a season greater than 2007, and then use 'count' to count the number of games that meet this condition.\n\nSQL query: SELECT count(*) FROM game WHERE season  >  2007",
        "predict": "SELECT count(*) FROM game WHERE season  >  2007",
        "hardness": "easy"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT player ,  number_of_matches ,  SOURCE FROM injury_accident WHERE injury != 'Knee problem'",
        "question": "What are the player name, number of matches, and information source for players who do not suffer from injury of 'Knee problem'?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter players who do not suffer from the injury of 'Knee problem'. Secondly, we need to select the player name, number of matches, and information source for the selected players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the injury information is stored in the 'injury_accident' table, we need to join the 'injury_accident' table with the 'game' table on the 'game_id' column. Then, we can filter the rows where the injury is not 'Knee problem' and select the player name, number of matches, and information source from the 'injury_accident' table.\n\n<3> SQL Generation: Use 'join' to link the 'injury_accident' and 'game' tables on the 'game_id' column. Then, use 'where' to filter the rows where the injury is not 'Knee problem'. Finally, select the player name, number of matches, and information source from the 'injury_accident' table.\n\nSQL query: SELECT player ,  number_of_matches ,  SOURCE FROM injury_accident WHERE injury != 'Knee problem'",
        "predict": "SELECT player ,  number_of_matches ,  SOURCE FROM injury_accident WHERE injury != 'Knee problem'",
        "hardness": "medium"
    },
    {
        "db_id": "game_injury",
        "gold": "SELECT count(DISTINCT T1.injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id  =  T2.id WHERE T2.season  >  2010",
        "question": "How many distinct kinds of injuries happened after season 2010?",
        "fields": "Table game, columns = [*,stadium_id,id,Season,Date,Home_team,Away_team,Score,Competition]\nTable injury_accident, columns = [*,game_id,id,Player,Injury,Number_of_matches,Source]\nTable stadium, columns = [*,id,name,Home_Games,Average_Attendance,Total_Attendance,Capacity_Percentage]\n",
        "foreign_keys": "Foreign_keys = [game.stadium_id = stadium.id,injury_accident.game_id = game.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter injuries that happened after season 2010. Secondly, we need to count the distinct kinds of injuries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter game_id from table 'injury_accident' based on the season from table 'game'. In the second step, we need to select distinct kinds of injuries from table 'injury_accident'.\n\n<3> SQL Generation: Use 'where' to filter injuries that happened after season 2010, and then use 'count' and 'distinct' to count the distinct kinds of injuries.\n\nSQL query: SELECT count(DISTINCT T1.injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id  =  T2.id WHERE T2.season  >  2010",
        "predict": "SELECT count(DISTINCT T1.injury) FROM injury_accident AS T1 JOIN game AS T2 ON T1.game_id  =  T2.id WHERE T2.season  >  2010",
        "hardness": "medium"
    },
    {
        "db_id": "soccer_1",
        "gold": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  \"right\"",
        "question": "List the names of all players who have a crossing score higher than 90 and prefer their right foot.",
        "fields": "Table Country, columns = [*,id,name]\nTable League, columns = [*,id,country_id,name]\nTable Player, columns = [*,id,player_api_id,player_name,player_fifa_api_id,birthday,height,weight]\nTable Player_Attributes, columns = [*,id,player_fifa_api_id,player_api_id,date,overall_rating,potential,preferred_foot,attacking_work_rate,defensive_work_rate,crossing,finishing,heading_accuracy,short_passing,volleys,dribbling,curve,free_kick_accuracy,long_passing,ball_control,acceleration,sprint_speed,agility,reactions,balance,shot_power,jumping,stamina,strength,long_shots,aggression,interceptions,positioning,vision,penalties,marking,standing_tackle,sliding_tackle,gk_diving,gk_handling,gk_kicking,gk_positioning,gk_reflexes]\nTable Team, columns = [*,id,team_api_id,team_fifa_api_id,team_long_name,team_short_name]\nTable Team_Attributes, columns = [*,id,team_fifa_api_id,team_api_id,date,buildUpPlaySpeed,buildUpPlaySpeedClass,buildUpPlayDribbling,buildUpPlayDribblingClass,buildUpPlayPassing,buildUpPlayPassingClass,buildUpPlayPositioningClass,chanceCreationPassing,chanceCreationPassingClass,chanceCreationCrossing,chanceCreationCrossingClass,chanceCreationShooting,chanceCreationShootingClass,chanceCreationPositioningClass,defencePressure,defencePressureClass,defenceAggression,defenceAggressionClass,defenceTeamWidth,defenceTeamWidthClass,defenceDefenderLineClass]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "foreign_keys": "Foreign_keys = [Player_Attributes.player_api_id = Player.player_api_id,Player_Attributes.player_fifa_api_id = Player.player_fifa_api_id,League.country_id = Country.id,Team_Attributes.team_api_id = Team.team_api_id,Team_Attributes.team_fifa_api_id = Team.team_fifa_api_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter players based on their crossing score and preferred foot. Secondly, we need to select the names of the filtered players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select player_name from table 'Player' and filter based on crossing score from table 'Player_Attributes'.\n\n<3> SQL Generation: Use 'where' to filter players based on their crossing score and preferred foot, and then select the names of the filtered players.\n\nSQL query: SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  \"right\"",
        "predict": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  \"right\"",
        "hardness": "medium"
    },
    {
        "db_id": "performance_attendance",
        "gold": "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM member_attendance)",
        "question": "List the names of members who did not attend any performance.",
        "fields": "Table member, columns = [*,Member_ID,Name,Nationality,Role]\nTable member_attendance, columns = [*,Member_ID,Performance_ID,Num_of_Pieces]\nTable performance, columns = [*,Performance_ID,Date,Host,Location,Attendance]\n",
        "foreign_keys": "Foreign_keys = [member_attendance.Performance_ID = performance.Performance_ID,member_attendance.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding members who did not attend any performance. Firstly, we need to identify all members who attended performances. Secondly, we need to filter out members who attended performances and return the names of the remaining members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Member_ID from table 'member_attendance' and filter by Performance_ID. Then, we need to select Name from table 'member' and filter out the members who attended performances.\n\n<3> SQL Generation: Use 'where' to filter members who attended performances, and then use 'not in' to filter out those members and select their names.\n\nSQL query: SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM member_attendance)",
        "predict": "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM member_attendance)",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "question": "Count the number of rooms that are not in the Lamberton building.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of rooms that are not in the Lamberton building. We need to filter out the rooms in the Lamberton building and count the remaining rooms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the rooms from the 'classroom' table and filter by the building column.\n\n<3> SQL Generation: Use 'where' to filter out the rooms in the Lamberton building and count the remaining rooms.\n\nSQL query: SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "predict": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "hardness": "easy"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "question": "How many classrooms are not in Lamberton?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of classrooms that are not in Lamberton.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'classroom' table.\n\n<3> SQL Generation: Use 'where' to filter classrooms that are not in Lamberton and count them.\n\nSQL query: SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "predict": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "hardness": "easy"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT i_id FROM advisor AS T1 JOIN student AS T2 ON T1.s_id  =  T2.id WHERE T2.dept_name  =  'History'",
        "question": "Give id of the instructor who advises students in the History department.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the department with the name 'History'. Secondly, we need to find the instructor who advises students in that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dept_name from table 'department' where dept_name = 'History'. In the second step, we need to select i_ID from table 'advisor' where s_ID is the same as the ID of the students in the History department.\n\n<3> SQL Generation: Use 'where' to find the department with the name 'History', and then use 'where' to find the instructor who advises students in that department.\n\nSQL query: SELECT i_id FROM advisor AS T1 JOIN student AS T2 ON T1.s_id  =  T2.id WHERE T2.dept_name  =  'History'",
        "predict": "SELECT i_id FROM advisor AS T1 JOIN student AS T2 ON T1.s_id  =  T2.id WHERE T2.dept_name  =  'History'",
        "hardness": "medium"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester  =  'Spring')",
        "question": "What are the names of instructors who didn't teach courses in the Spring?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the instructors who taught courses in the Spring. Secondly, we need to filter out the instructors who didn't teach courses in the Spring and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select distinct ID from table 'teaches' where semester = 'Spring'. In the second step, we need to select name from table 'instructor' and filter out the instructors whose ID is not in the result of the first step.\n\n<3> SQL Generation: Use 'where' to find the instructors who taught courses in the Spring, and then use 'where' to filter out the instructors who didn't teach courses in the Spring and select their names.\n\nSQL query: SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester  =  'Spring')",
        "predict": "SELECT name FROM instructor WHERE id NOT IN (SELECT id FROM teaches WHERE semester  =  'Spring')",
        "hardness": "hard"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE T2.course_id IN (SELECT T4.prereq_id FROM course AS T3 JOIN prereq AS T4 ON T3.course_id  =  T4.course_id WHERE T3.title  =  'International Finance')",
        "question": "Find the name of students who have taken the prerequisite course of the course with title International Finance.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the course_id of the course with title International Finance. Secondly, we need to find the prerequisite course_id for the course found in the first step. Thirdly, we need to find the names of students who have taken the prerequisite course.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'course' where title = 'International Finance'. In the second step, we need to select prereq_id from table 'prereq' where course_id is the value found in the first step. In the third step, we need to select name from table 'student' where ID is the value found in the second step.\n\n<3> SQL Generation: Use 'where' to find the course_id of the course with title International Finance. Then, use 'where' to find the prerequisite course_id for the course found in the first step. Finally, use 'where' to find the names of students who have taken the prerequisite course.\n\nSQL query: SELECT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE T2.course_id IN (SELECT T4.prereq_id FROM course AS T3 JOIN prereq AS T4 ON T3.course_id  =  T4.course_id WHERE T3.title  =  'International Finance')",
        "predict": "SELECT T1.name FROM student AS T1 JOIN takes AS T2 ON T1.id  =  T2.id WHERE T2.course_id IN (SELECT T4.prereq_id FROM course AS T3 JOIN prereq AS T4 ON T3.course_id  =  T4.course_id WHERE T3.title  =  'International Finance')",
        "hardness": "extra"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "question": "Find the names of all instructors in Comp. Sci. department with salary > 80000.",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter instructors based on their department and salary. Secondly, we need to select the names of the filtered instructors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter instructors based on their department, we need the 'instructor' and 'department' tables. We also need the 'salary' column from the 'instructor' table.\n\n<3> SQL Generation: Use 'where' to filter instructors in the Comp. Sci. department with a salary greater than 80000, and then select their names.\n\nSQL query: SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "predict": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "hardness": "medium"
    },
    {
        "db_id": "college_2",
        "gold": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "question": "What are the names of the instructors in the Comp. Sci. department who earn more than 80000?",
        "fields": "Table advisor, columns = [*,s_ID,i_ID]\nTable classroom, columns = [*,building,room_number,capacity]\nTable course, columns = [*,course_id,title,dept_name,credits]\nTable department, columns = [*,dept_name,building,budget]\nTable instructor, columns = [*,ID,name,dept_name,salary]\nTable prereq, columns = [*,course_id,prereq_id]\nTable section, columns = [*,course_id,sec_id,semester,year,building,room_number,time_slot_id]\nTable student, columns = [*,ID,name,dept_name,tot_cred]\nTable takes, columns = [*,ID,course_id,sec_id,semester,year,grade]\nTable teaches, columns = [*,ID,course_id,sec_id,semester,year]\nTable time_slot, columns = [*,time_slot_id,day,start_hr,start_min,end_hr,end_min]\n",
        "foreign_keys": "Foreign_keys = [course.dept_name = department.dept_name,instructor.dept_name = department.dept_name,section.building = classroom.building,section.room_number = classroom.room_number,section.course_id = course.course_id,teaches.ID = instructor.ID,teaches.course_id = section.course_id,teaches.sec_id = section.sec_id,teaches.semester = section.semester,teaches.year = section.year,student.dept_name = department.dept_name,takes.ID = student.ID,takes.course_id = section.course_id,takes.sec_id = section.sec_id,takes.semester = section.semester,takes.year = section.year,advisor.s_ID = student.ID,advisor.i_ID = instructor.ID,prereq.prereq_id = course.course_id,prereq.course_id = course.course_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter instructors based on their department and salary. Secondly, we need to select the names of the filtered instructors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ID and name from table 'instructor' where dept_name = 'Comp. Sci.' and salary > 80000.\n\n<3> SQL Generation: Use 'where' to filter instructors based on their department and salary, and then select their names.\n\nSQL query: SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "predict": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'  AND salary  >  80000",
        "hardness": "medium"
    },
    {
        "db_id": "debate",
        "gold": "SELECT Name FROM  people WHERE Age  =  35 OR Age  =  36",
        "question": "Show the names of people aged either 35 or 36.",
        "fields": "Table debate, columns = [*,Debate_ID,Date,Venue,Num_of_Audience]\nTable debate_people, columns = [*,Debate_ID,Affirmative,Negative,If_Affirmative_Win]\nTable people, columns = [*,People_ID,District,Name,Party,Age]\n",
        "foreign_keys": "Foreign_keys = [debate_people.Negative = people.People_ID,debate_people.Affirmative = people.People_ID,debate_people.Debate_ID = debate.Debate_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on people with age 35 or 36. We need to select the names of these people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter people with age 35 or 36 and select their names.\n\nSQL query: SELECT Name FROM  people WHERE Age  =  35 OR Age  =  36",
        "predict": "SELECT Name FROM  people WHERE Age  =  35 OR Age  =  36",
        "hardness": "medium"
    },
    {
        "db_id": "debate",
        "gold": "SELECT T3.Name FROM debate_people AS T1 JOIN debate AS T2 ON T1.Debate_ID  =  T2.Debate_ID JOIN people AS T3 ON T1.Affirmative  =  T3.People_ID WHERE T2.Num_of_Audience  >  200",
        "question": "Show the names of people that are on affirmative side of debates with number of audience bigger than 200.",
        "fields": "Table debate, columns = [*,Debate_ID,Date,Venue,Num_of_Audience]\nTable debate_people, columns = [*,Debate_ID,Affirmative,Negative,If_Affirmative_Win]\nTable people, columns = [*,People_ID,District,Name,Party,Age]\n",
        "foreign_keys": "Foreign_keys = [debate_people.Negative = people.People_ID,debate_people.Affirmative = people.People_ID,debate_people.Debate_ID = debate.Debate_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter debates with number of audience bigger than 200. Secondly, we need to find the names of people on the affirmative side of these debates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter Debate_ID from table 'debate' where Num_of_Audience > 200. In the second step, we need to select Name from table 'people' where People_ID is in the affirmative column of table 'debate_people'.\n\n<3> SQL Generation: Use 'where' to filter debates with number of audience bigger than 200, and then use 'where' and 'join' to select the names of people on the affirmative side of these debates.\n\nSQL query: SELECT T3.Name FROM debate_people AS T1 JOIN debate AS T2 ON T1.Debate_ID  =  T2.Debate_ID JOIN people AS T3 ON T1.Affirmative  =  T3.People_ID WHERE T2.Num_of_Audience  >  200",
        "predict": "SELECT T3.Name FROM debate_people AS T1 JOIN debate AS T2 ON T1.Debate_ID  =  T2.Debate_ID JOIN people AS T3 ON T1.Affirmative  =  T3.People_ID WHERE T2.Num_of_Audience  >  200",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "question": "How many customers don't have an account?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding customers who don't have an account.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customers' and check if it exists in table 'Accounts'.\n\n<3> SQL Generation: Use 'where' to filter customers who don't have an account and count them.\n\nSQL query: SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "predict": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT transaction_id FROM Financial_transactions WHERE transaction_amount  >  (SELECT avg(transaction_amount) FROM Financial_transactions)",
        "question": "What are the ids for transactions that have an amount greater than the average amount of a transaction?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average amount of a transaction. Secondly, we need to filter transactions with an amount greater than the average amount.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select transaction_amount from table 'Financial_Transactions'.\n\n<3> SQL Generation: Use 'where' to filter transactions with an amount greater than the average amount.\n\nSQL query: SELECT transaction_id FROM Financial_transactions WHERE transaction_amount  >  (SELECT avg(transaction_amount) FROM Financial_transactions)",
        "predict": "SELECT transaction_id FROM Financial_transactions WHERE transaction_amount  >  (SELECT avg(transaction_amount) FROM Financial_transactions)",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "question": "How many products were not included in any order?",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the products that were included in orders. Secondly, we need to count the products that were not included in any order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Order_Items'. In the second step, we need to select product_id from table 'Products' and count them.\n\n<3> SQL Generation: Use 'distinct' to select unique product_id from table 'Order_Items', and then use 'where' to filter products that were not included in any order and count them.\n\nSQL query: SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "predict": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "hardness": "extra"
    },
    {
        "db_id": "customers_and_invoices",
        "gold": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "question": "Count the number of products that were never ordered.",
        "fields": "Table Accounts, columns = [*,account_id,customer_id,date_account_opened,account_name,other_account_details]\nTable Customers, columns = [*,customer_id,customer_first_name,customer_middle_initial,customer_last_name,gender,email_address,login_name,login_password,phone_number,town_city,state_county_province,country]\nTable Financial_Transactions, columns = [*,transaction_id,account_id,invoice_number,transaction_type,transaction_date,transaction_amount,transaction_comment,other_transaction_details]\nTable Invoice_Line_Items, columns = [*,order_item_id,invoice_number,product_id,product_title,product_quantity,product_price,derived_product_cost,derived_vat_payable,derived_total_cost]\nTable Invoices, columns = [*,invoice_number,order_id,invoice_date]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,product_quantity,other_order_item_details]\nTable Orders, columns = [*,order_id,customer_id,date_order_placed,order_details]\nTable Product_Categories, columns = [*,production_type_code,product_type_description,vat_rating]\nTable Products, columns = [*,product_id,parent_product_id,production_type_code,unit_price,product_name,product_color,product_size]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Invoices.order_id = Orders.order_id,Accounts.customer_id = Customers.customer_id,Products.production_type_code = Product_Categories.production_type_code,Financial_Transactions.account_id = Accounts.account_id,Financial_Transactions.invoice_number = Invoices.invoice_number,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Invoice_Line_Items.product_id = Products.product_id,Invoice_Line_Items.invoice_number = Invoices.invoice_number,Invoice_Line_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: We need to find the products that were never ordered. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select product_id from the 'Products' table and filter out the products that have corresponding entries in the 'Order_Items' table.\n\n<3> SQL Generation: We can use a left join between the 'Products' and 'Order_Items' tables and filter out the rows where the 'order_item_id' is null. Then, we can count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "predict": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "hardness": "extra"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT count(*) FROM Church WHERE Open_Date  <  1850",
        "question": "How many churches opened before 1850 are there?",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on churches that opened before 1850. We need to filter churches based on their open date and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'church' table and its 'Open_Date' column.\n\n<3> SQL Generation: Use 'where' to filter churches that opened before 1850 and count them.\n\nSQL query: SELECT count(*) FROM Church WHERE Open_Date  <  1850",
        "predict": "SELECT count(*) FROM Church WHERE Open_Date  <  1850",
        "hardness": "easy"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT count(*) FROM people WHERE is_male  =  'F' AND age  >  30",
        "question": "How many female people are older than 30 in our record?",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter people based on their gender and age. Secondly, we need to count the number of selected female people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'people' table to filter based on gender and age, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter people based on their gender and age, and then use 'count' to calculate the number of selected female people.\n\nSQL query: SELECT count(*) FROM people WHERE is_male  =  'F' AND age  >  30",
        "predict": "SELECT count(*) FROM people WHERE is_male  =  'F' AND age  >  30",
        "hardness": "medium"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT T2.name ,  T3.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id WHERE T1.year  >  2014",
        "question": "Show the pair of male and female names in all weddings after year 2014",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter weddings that happened after year 2014. Secondly, we need to find the names of the male and female participants in those weddings.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Church_ID from table 'wedding' where Year > 2014. In the second step, we need to select Male_ID and Female_ID from table 'wedding' and join them with table 'people' to get the corresponding names.\n\n<3> SQL Generation: Use 'where' to filter weddings that happened after year 2014, and then use 'join' to connect the Male_ID and Female_ID with the People_ID in table 'people' to get the names of the participants.\n\nSQL query: SELECT T2.name ,  T3.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id WHERE T1.year  >  2014",
        "predict": "SELECT T2.name ,  T3.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id WHERE T1.year  >  2014",
        "hardness": "hard"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT T4.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id JOIN church AS T4 ON T4.church_id  =  T1.church_id WHERE T2.age  >  30 OR T3.age  >  30",
        "question": "Show the church names for the weddings of all people older than 30.",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter people based on their age being older than 30. Secondly, we need to find the church names for the weddings of these people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter People_ID from table 'people' where Age > 30. In the second step, we need to select Church_ID from table 'wedding' and filter by Male_ID and Female_ID from the filtered people in the first step.\n\n<3> SQL Generation: Use 'where' to filter people with age older than 30, and then use 'join' to link the 'wedding' table with the filtered people based on Male_ID and Female_ID. Finally, select the church names from the 'church' table.\n\nSQL query: SELECT T4.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id JOIN church AS T4 ON T4.church_id  =  T1.church_id WHERE T2.age  >  30 OR T3.age  >  30",
        "predict": "SELECT T4.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id JOIN church AS T4 ON T4.church_id  =  T1.church_id WHERE T2.age  >  30 OR T3.age  >  30",
        "hardness": "extra"
    },
    {
        "db_id": "wedding",
        "gold": "SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR  =  2016",
        "question": "How many churches have a wedding in year 2016?",
        "fields": "Table church, columns = [*,Church_ID,Name,Organized_by,Open_Date,Continuation_of]\nTable people, columns = [*,People_ID,Name,Country,Is_Male,Age]\nTable wedding, columns = [*,Church_ID,Male_ID,Female_ID,Year]\n",
        "foreign_keys": "Foreign_keys = [wedding.Female_ID = people.People_ID,wedding.Male_ID = people.People_ID,wedding.Church_ID = church.Church_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter weddings based on the year 2016. Secondly, we need to count the number of unique churches that have weddings in that year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Church_ID from table 'wedding' where Year = 2016. Then, we need to count the number of unique Church_IDs.\n\n<3> SQL Generation: Use 'where' to filter weddings in the year 2016, and then use 'count' and 'distinct' to count the number of unique Church_IDs.\n\nSQL query: SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR  =  2016",
        "predict": "SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR  =  2016",
        "hardness": "easy"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT name ,  year_join FROM artist WHERE country != 'United States'",
        "question": "What are the names and year of joining for artists that do not have the country \"United States\"?",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter artists based on their country not being \"United States\". Secondly, we need to select the names and year of joining for the filtered artists.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'artist' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter artists based on their country not being \"United States\", and then select the names and year of joining for the filtered artists.\n\nSQL query: SELECT name ,  year_join FROM artist WHERE country != 'United States'",
        "predict": "SELECT name ,  year_join FROM artist WHERE country != 'United States'",
        "hardness": "medium"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "question": "How many artists are above age 46 and joined after 1990?",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter artists based on their age and year of joining. Secondly, we need to count the number of selected artists.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'artist' table to filter artists based on age and year of joining, we only need the 'artist' table.\n\n<3> SQL Generation: Use 'where' to filter artists based on age and year of joining, and then use 'count' to count the number of selected artists.\n\nSQL query: SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "predict": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "hardness": "medium"
    },
    {
        "db_id": "theme_gallery",
        "gold": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "question": "Count the number of artists who are older than 46 and joined after 1990.",
        "fields": "Table artist, columns = [*,Artist_ID,Name,Country,Year_Join,Age]\nTable exhibition, columns = [*,Exhibition_ID,Year,Theme,Artist_ID,Ticket_Price]\nTable exhibition_record, columns = [*,Exhibition_ID,Date,Attendance]\n",
        "foreign_keys": "Foreign_keys = [exhibition.Artist_ID = artist.Artist_ID,exhibition_record.Exhibition_ID = exhibition.Exhibition_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter artists based on their age and year of joining. Secondly, we need to count the number of selected artists.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'artist' table to filter artists based on age and year of joining, we only need the 'artist' table.\n\n<3> SQL Generation: Use 'where' to filter artists based on age and year of joining, and then use 'count' to count the number of selected artists.\n\nSQL query: SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "predict": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990",
        "hardness": "medium"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "question": "Find the number of items that did not receive any review.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding items that did not receive any review. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find items that did not receive any review, we only need the 'item' and 'review' tables.\n\n<3> SQL Generation: We can use a left join to combine the 'item' and 'review' tables on the 'i_id' column. Then, we can filter the rows where the 'rating' column is null (indicating no review) and count the number of rows.\n\nSQL query: SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "predict": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "question": "Find the number of users who did not write any review.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Decomposition: We need to find the users who did not write any review. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select u_id from table 'useracct' and filter out the u_id values that appear in the 'review' table.\n\n<3> SQL Generation: We can use a left join to combine the 'useracct' and 'review' tables on the 'u_id' column. Then, we can filter out the rows where the 'i_id' column is null (indicating that the user did not write any review). Finally, we can count the number of distinct 'u_id' values.\n\nSQL query: SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "predict": "SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "hardness": "extra"
    },
    {
        "db_id": "epinions_1",
        "gold": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "question": "Find the number of items without any review.",
        "fields": "Table item, columns = [*,i_id,title]\nTable review, columns = [*,a_id,u_id,i_id,rating,rank]\nTable trust, columns = [*,source_u_id,target_u_id,trust]\nTable useracct, columns = [*,u_id,name]\n",
        "foreign_keys": "Foreign_keys = [review.i_id = item.i_id,review.u_id = useracct.u_id,trust.target_u_id = useracct.u_id,trust.source_u_id = useracct.u_id]\n",
        "reasoning": "<1> Decomposition: We need to find the items that do not have any reviews.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'item' and 'review' tables.\n\n<3> SQL Generation: We can use a left join to combine the 'item' and 'review' tables on the 'i_id' column. Then, we can filter the rows where the 'review' table's 'i_id' is null, indicating that there are no reviews for that item. Finally, we can count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "predict": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "hardness": "extra"
    },
    {
        "db_id": "riding_club",
        "gold": "SELECT Player_name FROM player ORDER BY Votes ASC",
        "question": "List the names of players in ascending order of votes.",
        "fields": "Table club, columns = [*,Club_ID,Club_name,Region,Start_year]\nTable coach, columns = [*,Coach_ID,Coach_name,Gender,Club_ID,Rank]\nTable match_result, columns = [*,Rank,Club_ID,Gold,Big_Silver,Small_Silver,Bronze,Points]\nTable player, columns = [*,Player_ID,Sponsor_name,Player_name,Gender,Residence,Occupation,Votes,Rank]\nTable player_coach, columns = [*,Player_ID,Coach_ID,Starting_year]\n",
        "foreign_keys": "Foreign_keys = [coach.Club_ID = club.Club_ID,player_coach.Coach_ID = coach.Coach_ID,player_coach.Player_ID = player.Player_ID,match_result.Club_ID = club.Club_ID]\n",
        "reasoning": "<1> Decomposition: We need to retrieve the names of players and sort them in ascending order based on their votes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'player' table for this query.\n\n<3> SQL Generation: We can directly select the 'Player_name' column from the 'player' table and order the results by the 'Votes' column in ascending order.\n\nSQL query: SELECT Player_name FROM player ORDER BY Votes ASC",
        "predict": "SELECT Player_name FROM player ORDER BY Votes ASC",
        "hardness": "easy"
    },
    {
        "db_id": "gymnast",
        "gold": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T2.Hometown != \"Santo Domingo\"",
        "question": "What are the names of gymnasts whose hometown is not \"Santo Domingo\"?",
        "fields": "Table gymnast, columns = [*,Gymnast_ID,Floor_Exercise_Points,Pommel_Horse_Points,Rings_Points,Vault_Points,Parallel_Bars_Points,Horizontal_Bar_Points,Total_Points]\nTable people, columns = [*,People_ID,Name,Age,Height,Hometown]\n",
        "foreign_keys": "Foreign_keys = [gymnast.Gymnast_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on gymnasts whose hometown is not \"Santo Domingo\". We need to select the names of these gymnasts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names from the 'people' table and filter based on the 'hometown' column. We also need to join the 'gymnast' table with the 'people' table using the 'Gymnast_ID' and 'People_ID' columns.\n\n<3> SQL Generation: Use 'where' to filter gymnasts whose hometown is not \"Santo Domingo\" and select their names.\n\nSQL query: SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T2.Hometown != \"Santo Domingo\"",
        "predict": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T2.Hometown != \"Santo Domingo\"",
        "hardness": "medium"
    },
    {
        "db_id": "small_bank_1",
        "gold": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)",
        "question": "What are the names of customers with checking balances lower than the average checking balance?",
        "fields": "Table ACCOUNTS, columns = [*,custid,name]\nTable CHECKING, columns = [*,custid,balance]\nTable SAVINGS, columns = [*,custid,balance]\n",
        "foreign_keys": "Foreign_keys = [SAVINGS.custid = ACCOUNTS.custid,CHECKING.custid = ACCOUNTS.custid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average checking balance. Secondly, we need to filter customers with checking balances lower than the average and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'ACCOUNTS' and 'CHECKING' tables.\n\n<3> SQL Generation: Use 'avg' to calculate the average checking balance, and then use 'where' to filter customers with checking balances lower than the average and select their names.\n\nSQL query: SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)",
        "predict": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)",
        "hardness": "extra"
    },
    {
        "db_id": "wrestler",
        "gold": "SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1",
        "question": "What is the name of the wrestler with the fewest days held?",
        "fields": "Table Elimination, columns = [*,Elimination_ID,Wrestler_ID,Team,Eliminated_By,Elimination_Move,Time]\nTable wrestler, columns = [*,Wrestler_ID,Name,Reign,Days_held,Location,Event]\n",
        "foreign_keys": "Foreign_keys = [Elimination.Wrestler_ID = wrestler.Wrestler_ID]\n",
        "reasoning": "<1> Decomposition: We need to find the wrestler with the fewest days held. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'wrestler' table.\n\n<3> SQL Generation: We can use the 'MIN' function to find the minimum value of 'Days_held' in the 'wrestler' table and then select the corresponding wrestler's name.\n\nSQL query: SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1",
        "predict": "SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1",
        "hardness": "medium"
    },
    {
        "db_id": "wrestler",
        "gold": "SELECT Name FROM wrestler WHERE Days_held  <  100",
        "question": "What are the names of wrestlers days held less than 100?",
        "fields": "Table Elimination, columns = [*,Elimination_ID,Wrestler_ID,Team,Eliminated_By,Elimination_Move,Time]\nTable wrestler, columns = [*,Wrestler_ID,Name,Reign,Days_held,Location,Event]\n",
        "foreign_keys": "Foreign_keys = [Elimination.Wrestler_ID = wrestler.Wrestler_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on wrestlers with days held less than 100. We need to select the names of these wrestlers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'wrestler' table.\n\n<3> SQL Generation: Use 'where' to filter wrestlers with days held less than 100 and select their names.\n\nSQL query: SELECT Name FROM wrestler WHERE Days_held  <  100",
        "predict": "SELECT Name FROM wrestler WHERE Days_held  <  100",
        "hardness": "easy"
    },
    {
        "db_id": "school_finance",
        "gold": "SELECT count(DISTINCT T1.donator_name) FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Glenn\"",
        "question": "How many donors have endowment for school named \"Glenn\"?",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the school with the name \"Glenn\". Secondly, we need to count the number of donors who have an endowment for that school.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select School_id from table 'School' where School_name = \"Glenn\". In the second step, we need to count the number of distinct donors from table 'endowment' where School_id matches the School_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the School_id for the school named \"Glenn\", and then use 'count' to count the number of distinct donors from the 'endowment' table where School_id matches the School_id found in the first step.\n\nSQL query: SELECT count(DISTINCT T1.donator_name) FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Glenn\"",
        "predict": "SELECT count(DISTINCT T1.donator_name) FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  \"Glenn\"",
        "hardness": "medium"
    },
    {
        "db_id": "school_finance",
        "gold": "SELECT count(*) FROM budget WHERE budgeted  <  invested",
        "question": "How many budget record has a budget amount smaller than the invested amount?",
        "fields": "Table School, columns = [*,School_id,School_name,Location,Mascot,Enrollment,IHSAA_Class,IHSAA_Football_Class,County]\nTable budget, columns = [*,School_id,Year,Budgeted,total_budget_percent_budgeted,Invested,total_budget_percent_invested,Budget_invested_percent]\nTable endowment, columns = [*,endowment_id,School_id,donator_name,amount]\n",
        "foreign_keys": "Foreign_keys = [budget.School_id = School.School_id,endowment.School_id = School.School_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on budget records where the budget amount is smaller than the invested amount. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'budget' table for this query.\n\n<3> SQL Generation: Use 'where' to filter budget records where the budget amount is smaller than the invested amount, and then count the number of records that meet this condition.\n\nSQL query: SELECT count(*) FROM budget WHERE budgeted  <  invested",
        "predict": "SELECT count(*) FROM budget WHERE budgeted  <  invested",
        "hardness": "easy"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT name FROM building WHERE height_feet  >=  200 AND floors  >=  20",
        "question": "List the names of buildings with at least 200 feet of height and with at least 20 floors.",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on buildings with at least 200 feet of height and at least 20 floors. We need to select the names of these buildings.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'building' table.\n\n<3> SQL Generation: Use 'where' to filter buildings with at least 200 feet of height and at least 20 floors, and then select the names of these buildings.\n\nSQL query: SELECT name FROM building WHERE height_feet  >=  200 AND floors  >=  20",
        "predict": "SELECT name FROM building WHERE height_feet  >=  200 AND floors  >=  20",
        "hardness": "medium"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT TYPE FROM institution WHERE founded  >  1990 AND enrollment  >=  1000",
        "question": "Show the institution type with an institution founded after 1990 and an institution with at least 1000 enrollment.",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter institutions based on their founding year and enrollment. Secondly, we need to select the institution type for the filtered institutions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the institution type from table 'Institution' and filter by founding year and enrollment.\n\n<3> SQL Generation: Use 'where' to filter institutions founded after 1990 and with at least 1000 enrollment, and then select the institution type.\n\nSQL query: SELECT TYPE FROM institution WHERE founded  >  1990 AND enrollment  >=  1000",
        "predict": "SELECT TYPE FROM institution WHERE founded  >  1990 AND enrollment  >=  1000",
        "hardness": "medium"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id WHERE T1.founded  >  1880 OR T1.type  =  'Private'",
        "question": "How many proteins are associated with an institution founded after 1880 or an institution with type \"Private\"?",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter institutions founded after 1880. Secondly, we need to filter institutions with type \"Private\". Finally, we need to count the number of proteins associated with these filtered institutions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter Institution_id from table 'Institution' where Founded > 1880. In the second step, we need to filter Institution_id from table 'Institution' where Type = \"Private\". In the final step, we need to count the number of proteins associated with the filtered Institution_id.\n\n<3> SQL Generation: Use 'where' to filter institutions founded after 1880 and institutions with type \"Private\". Then, use 'where' to filter proteins associated with the filtered Institution_id and count them.\n\nSQL query: SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id WHERE T1.founded  >  1880 OR T1.type  =  'Private'",
        "predict": "SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id WHERE T1.founded  >  1880 OR T1.type  =  'Private'",
        "hardness": "hard"
    },
    {
        "db_id": "protein_institute",
        "gold": "SELECT count(*) FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM protein)",
        "question": "How many institutions do not have an associated protein in our record?",
        "fields": "Table Institution, columns = [*,Institution_id,Institution,Location,Founded,Type,Enrollment,Team,Primary_Conference,building_id]\nTable building, columns = [*,building_id,Name,Street_address,Years_as_tallest,Height_feet,Floors]\nTable protein, columns = [*,common_name,protein_name,divergence_from_human_lineage,accession_number,sequence_length,sequence_identity_to_human_protein,Institution_id]\n",
        "foreign_keys": "Foreign_keys = [Institution.building_id = building.building_id,protein.Institution_id = Institution.Institution_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding institutions that do not have an associated protein in the record.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Institution_id from table 'Institution' and check if there is a corresponding Institution_id in table 'protein'.\n\n<3> SQL Generation: Use 'where' to filter institutions that do not have a corresponding Institution_id in the 'protein' table, and then count the number of institutions.\n\nSQL query: SELECT count(*) FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM protein)",
        "predict": "SELECT count(*) FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM protein)",
        "hardness": "extra"
    },
    {
        "db_id": "cinema",
        "gold": "SELECT title ,  directed_by FROM film WHERE film_id NOT IN (SELECT film_id FROM schedule)",
        "question": "What are the title and director of the films without any schedule?",
        "fields": "Table cinema, columns = [*,Cinema_ID,Name,Openning_year,Capacity,Location]\nTable film, columns = [*,Film_ID,Rank_in_series,Number_in_season,Title,Directed_by,Original_air_date,Production_code]\nTable schedule, columns = [*,Cinema_ID,Film_ID,Date,Show_times_per_day,Price]\n",
        "foreign_keys": "Foreign_keys = [schedule.Cinema_ID = cinema.Cinema_ID,schedule.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the films that do not have any schedule. Secondly, we need to select the title and director of those films.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'film' table to select the title and director.\n\n<3> SQL Generation: Use 'not in' to find the films that do not have any schedule, and then select the title and director from the 'film' table.\n\nSQL query: SELECT title ,  directed_by FROM film WHERE film_id NOT IN (SELECT film_id FROM schedule)",
        "predict": "SELECT title ,  directed_by FROM film WHERE film_id NOT IN (SELECT film_id FROM schedule)",
        "hardness": "extra"
    },
    {
        "db_id": "products_for_hire",
        "gold": "SELECT count(*) FROM Products_for_hire WHERE product_id NOT IN ( SELECT product_id FROM products_booked WHERE booked_amount  >  200 )",
        "question": "How many products are never booked with amount higher than 200?",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the products that are never booked with an amount higher than 200. Secondly, we need to count the number of such products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select product_id from table 'Products_for_Hire' where booked_amount <= 200 and then count the number of distinct product_ids.\n\n<3> SQL Generation: Use 'where' to filter products that are never booked with an amount higher than 200, and then use 'count' to count the number of distinct product_ids.\n\nSQL query: SELECT count(*) FROM Products_for_hire WHERE product_id NOT IN ( SELECT product_id FROM products_booked WHERE booked_amount  >  200 )",
        "predict": "SELECT count(*) FROM Products_for_hire WHERE product_id NOT IN ( SELECT product_id FROM products_booked WHERE booked_amount  >  200 )",
        "hardness": "extra"
    },
    {
        "db_id": "products_for_hire",
        "gold": "SELECT payment_date FROM payments WHERE amount_paid  >  300 OR payment_type_code  =  'Check'",
        "question": "What are the payment date of the payment with amount paid higher than 300 or with payment type is 'Check'",
        "fields": "Table Bookings, columns = [*,booking_id,customer_id,booking_status_code,returned_damaged_yn,booking_start_date,booking_end_date,count_hired,amount_payable,amount_of_discount,amount_outstanding,amount_of_refund]\nTable Customers, columns = [*,customer_id,coupon_id,good_or_bad_customer,first_name,last_name,gender_mf,date_became_customer,date_last_hire]\nTable Discount_Coupons, columns = [*,coupon_id,date_issued,coupon_amount]\nTable Payments, columns = [*,payment_id,booking_id,customer_id,payment_type_code,amount_paid_in_full_yn,payment_date,amount_due,amount_paid]\nTable Products_Booked, columns = [*,booking_id,product_id,returned_yn,returned_late_yn,booked_count,booked_amount]\nTable Products_for_Hire, columns = [*,product_id,product_type_code,daily_hire_cost,product_name,product_description]\nTable View_Product_Availability, columns = [*,product_id,booking_id,status_date,available_yn]\n",
        "foreign_keys": "Foreign_keys = [Customers.coupon_id = Discount_Coupons.coupon_id,Bookings.customer_id = Customers.customer_id,Payments.customer_id = Customers.customer_id,Payments.booking_id = Bookings.booking_id,Products_Booked.product_id = Products_for_Hire.product_id,Products_Booked.booking_id = Bookings.booking_id,View_Product_Availability.product_id = Products_for_Hire.product_id,View_Product_Availability.booking_id = Bookings.booking_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter payments with amount paid higher than 300. Secondly, we need to filter payments with payment type 'Check'. Finally, we need to select the payment dates of the filtered payments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select payment_date from table 'Payments' and filter by amount_paid or payment_type_code.\n\n<3> SQL Generation: Use 'where' to filter payments with amount paid higher than 300 or with payment type 'Check', and then select the payment dates.\n\nSQL query: SELECT payment_date FROM payments WHERE amount_paid  >  300 OR payment_type_code  =  'Check'",
        "predict": "SELECT payment_date FROM payments WHERE amount_paid  >  300 OR payment_type_code  =  'Check'",
        "hardness": "medium"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "question": "Show the company name and the main industry for all companies whose headquarters are not from USA.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on companies whose headquarters are not from the USA. We need to select the company name and main industry for these companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select company name and main industry from table 'company' where headquarters is not from the USA.\n\n<3> SQL Generation: Use 'where' to filter companies whose headquarters are not from the USA, and then select the company name and main industry.\n\nSQL query: SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "predict": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "hardness": "medium"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "question": "What are the companies and main industries of all companies that are not headquartered in the United States?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on companies that are not headquartered in the United States. Firstly, we need to identify the companies that are not headquartered in the United States. Secondly, we need to select the company name and main industry of these companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'company' table, we only need to consider this table.\n\n<3> SQL Generation: Use 'where' to filter companies that are not headquartered in the United States, and then select the company name and main industry.\n\nSQL query: SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "predict": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'",
        "hardness": "medium"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT count(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005",
        "question": "How many gas station are opened between 2000 and 2005?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on gas stations that were opened between 2000 and 2005.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'gas_station' table.\n\n<3> SQL Generation: Use 'where' to filter gas stations that were opened between 2000 and 2005, and then count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005",
        "predict": "SELECT count(*) FROM gas_station WHERE open_year BETWEEN 2000 AND 2005",
        "hardness": "easy"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "question": "Show company name and main industry without a gas station.",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding companies without a gas station. We need to select the company name and main industry from the 'company' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'company' table.\n\n<3> SQL Generation: We can use a left join to combine the 'company' table with the 'station_company' table on the 'Company_ID' column. Then, we can filter the rows where the 'Station_ID' is null, indicating that the company does not have a gas station. Finally, we select the company name and main industry from the resulting rows.\n\nSQL query: SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "predict": "SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "hardness": "extra"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "question": "What are the main industries of the companies without gas stations and what are the companies?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies without gas stations. Secondly, we need to identify the main industries of these companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Company_ID from table 'company' where Company_ID does not exist in table 'station_company'. In the second step, we need to select Main_Industry and Company from table 'company' based on the Company_IDs found in the first step.\n\n<3> SQL Generation: Use 'where' and 'not in' to find the Company_IDs that do not exist in table 'station_company', and then select Main_Industry and Company based on these Company_IDs.\n\nSQL query: SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "predict": "SELECT company ,  main_industry FROM company WHERE company_id NOT IN (SELECT company_id FROM station_company)",
        "hardness": "extra"
    },
    {
        "db_id": "gas_company",
        "gold": "SELECT T3.location FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.market_value  >  100",
        "question": "What are the locations that have gas stations owned by a company with a market value greater than 100?",
        "fields": "Table company, columns = [*,Company_ID,Rank,Company,Headquarters,Main_Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value]\nTable gas_station, columns = [*,Station_ID,Open_Year,Location,Manager_Name,Vice_Manager_Name,Representative_Name]\nTable station_company, columns = [*,Station_ID,Company_ID,Rank_of_the_Year]\n",
        "foreign_keys": "Foreign_keys = [station_company.Company_ID = company.Company_ID,station_company.Station_ID = gas_station.Station_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies with a market value greater than 100. Secondly, we need to filter gas stations based on their ownership by these companies and select their locations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Company_ID from table 'company' where Market_Value > 100. In the second step, we need to filter Station_ID and Location from table 'gas_station' based on the ownership by the selected companies.\n\n<3> SQL Generation: Use 'where' to find the companies with a market value greater than 100, and then use 'where' to filter gas stations owned by these companies and select their locations.\n\nSQL query: SELECT T3.location FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.market_value  >  100",
        "predict": "SELECT T3.location FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id JOIN gas_station AS T3 ON T1.station_id  =  T3.station_id WHERE T2.market_value  >  100",
        "hardness": "hard"
    },
    {
        "db_id": "party_people",
        "gold": "SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "question": "Show names of parties that does not have any members.",
        "fields": "Table member, columns = [*,Member_ID,Member_Name,Party_ID,In_office]\nTable party, columns = [*,Party_ID,Minister,Took_office,Left_office,Region_ID,Party_name]\nTable party_events, columns = [*,Event_ID,Event_Name,Party_ID,Member_in_charge_ID]\nTable region, columns = [*,Region_ID,Region_name,Date,Label,Format,Catalogue]\n",
        "foreign_keys": "Foreign_keys = [party.Region_ID = region.Region_ID,member.Party_ID = party.Party_ID,party_events.Member_in_charge_ID = member.Member_ID,party_events.Party_ID = party.Party_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding parties that do not have any members. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select party_name from table 'party' and filter parties that do not have any members.\n\n<3> SQL Generation: Use 'where' and 'not exists' to filter parties that do not have any members.\n\nSQL query: SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "predict": "SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Control_Systems",
        "gold": "SELECT Ref_Document_Status.document_status_description FROM Ref_Document_Status JOIN Documents ON Documents.document_status_code = Ref_Document_Status.document_status_code WHERE Documents.document_id = 1;",
        "question": "What is the document status description of the document with id 1?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Circulation_History, columns = [*,document_id,draft_number,copy_number,employee_id]\nTable Document_Drafts, columns = [*,document_id,draft_number,draft_details]\nTable Documents, columns = [*,document_id,document_status_code,document_type_code,shipping_agent_code,receipt_date,receipt_number,other_details]\nTable Documents_Mailed, columns = [*,document_id,mailed_to_address_id,mailing_date]\nTable Draft_Copies, columns = [*,document_id,draft_number,copy_number]\nTable Employees, columns = [*,employee_id,role_code,employee_name,other_details]\nTable Ref_Document_Status, columns = [*,document_status_code,document_status_description]\nTable Ref_Document_Types, columns = [*,document_type_code,document_type_description]\nTable Ref_Shipping_Agents, columns = [*,shipping_agent_code,shipping_agent_name,shipping_agent_description]\nTable Roles, columns = [*,role_code,role_description]\n",
        "foreign_keys": "Foreign_keys = [Documents.shipping_agent_code = Ref_Shipping_Agents.shipping_agent_code,Documents.document_status_code = Ref_Document_Status.document_status_code,Documents.document_type_code = Ref_Document_Types.document_type_code,Employees.role_code = Roles.role_code,Document_Drafts.document_id = Documents.document_id,Draft_Copies.document_id = Document_Drafts.document_id,Draft_Copies.draft_number = Document_Drafts.draft_number,Circulation_History.employee_id = Employees.employee_id,Circulation_History.document_id = Draft_Copies.document_id,Circulation_History.draft_number = Draft_Copies.draft_number,Circulation_History.copy_number = Draft_Copies.copy_number,Documents_Mailed.mailed_to_address_id = Addresses.address_id,Documents_Mailed.document_id = Documents.document_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the document status description of the document with id 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the document status description from the 'Ref_Document_Status' table based on the document id.\n\n<3> SQL Generation: Use 'where' to filter the document with id 1 and select the document status description.\n\nSQL query: SELECT Ref_Document_Status.document_status_description FROM Ref_Document_Status JOIN Documents ON Documents.document_status_code = Ref_Document_Status.document_status_code WHERE Documents.document_id = 1;",
        "predict": "SELECT Ref_Document_Status.document_status_description FROM Ref_Document_Status JOIN Documents ON Documents.document_status_code = Ref_Document_Status.document_status_code WHERE Documents.document_id = 1;",
        "hardness": "medium"
    },
    {
        "db_id": "company_1",
        "gold": "SELECT count(*) FROM dependent WHERE sex  =  'F'",
        "question": "how many female dependents are there?",
        "fields": "Table department, columns = [*,Dname,Dnumber,Mgr_ssn,Mgr_start_date]\nTable dependent, columns = [*,Essn,Dependent_name,Sex,Bdate,Relationship]\nTable dept_locations, columns = [*,Dnumber,Dlocation]\nTable employee, columns = [*,Fname,Minit,Lname,Ssn,Bdate,Address,Sex,Salary,Super_ssn,Dno]\nTable project, columns = [*,Pname,Pnumber,Plocation,Dnum]\nTable works_on, columns = [*,Essn,Pno,Hours]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of female dependents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is about dependents, we need the 'dependent' table.\n\n<3> SQL Generation: Use 'where' to filter dependents by sex and count the number of rows.\n\nSQL query: SELECT count(*) FROM dependent WHERE sex  =  'F'",
        "predict": "SELECT count(*) FROM dependent WHERE sex  =  'F'",
        "hardness": "easy"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT count(*) FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid WHERE T2.name = \"Australian Grand Prix\" AND YEAR = 2009",
        "question": "How many drivers were in the Australian Grand Prix held in 2009?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the raceId of the Australian Grand Prix held in 2009. Secondly, we need to count the number of drivers in that race.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select raceId from table 'races' where name = 'Australian Grand Prix' and year = 2009. In the second step, we need to count the distinct driverId from table 'results' where raceId matches the raceId found in the first step.\n\n<3> SQL Generation: Use 'where' to find the raceId of the Australian Grand Prix held in 2009, and then use 'count(distinct)' to count the number of drivers in that race.\n\nSQL query: SELECT count(*) FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid WHERE T2.name = \"Australian Grand Prix\" AND YEAR = 2009",
        "predict": "SELECT count(*) FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid WHERE T2.name = \"Australian Grand Prix\" AND YEAR = 2009",
        "hardness": "medium"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011",
        "question": "What are the names of races held between 2009 and 2011?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter races based on their years, selecting races held between 2009 and 2011. Secondly, we need to retrieve the names of the selected races.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'races' table and its 'name' column.\n\n<3> SQL Generation: Use 'where' to filter races based on their years, and then select the names of the selected races.\n\nSQL query: SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011",
        "predict": "SELECT name FROM races WHERE YEAR BETWEEN 2009 AND 2011",
        "hardness": "easy"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT name FROM races WHERE TIME > \"12:00:00\" OR TIME < \"09:00:00\"",
        "question": "What are the names of all races that occurred after 12:00:00 or before 09:00:00?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on races that occurred after 12:00:00 or before 09:00:00. Firstly, we need to identify the races that occurred after 12:00:00. Secondly, we need to identify the races that occurred before 09:00:00. Finally, we need to combine the results from the two steps.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'races' table and the 'time' column.\n\n<3> SQL Generation: Use 'where' to filter races that occurred after 12:00:00 or before 09:00:00.\n\nSQL query: SELECT name FROM races WHERE TIME > \"12:00:00\" OR TIME < \"09:00:00\"",
        "predict": "SELECT name FROM races WHERE TIME > \"12:00:00\" OR TIME < \"09:00:00\"",
        "hardness": "medium"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the race with the name 'Monaco Grand Prix' in the year 2008. Secondly, we need to find the maximum fastest lap speed in that race.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select raceId from table 'races' where name = 'Monaco Grand Prix' and year = 2008. In the second step, we need to select the maximum fastest lap speed from table 'results' where raceId matches the raceId found in the first step.\n\n<3> SQL Generation: Use 'where' to find the race with the name 'Monaco Grand Prix' in the year 2008, and then use 'where' and 'max' to find the maximum fastest lap speed in that race.\n\nSQL query: SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "predict": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "hardness": "medium"
    },
    {
        "db_id": "formula_1",
        "gold": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?",
        "fields": "Table circuits, columns = [*,circuitId,circuitRef,name,location,country,lat,lng,alt,url]\nTable constructorResults, columns = [*,constructorResultsId,raceId,constructorId,points,status]\nTable constructorStandings, columns = [*,constructorStandingsId,raceId,constructorId,points,position,positionText,wins]\nTable constructors, columns = [*,constructorId,constructorRef,name,nationality,url]\nTable driverStandings, columns = [*,driverStandingsId,raceId,driverId,points,position,positionText,wins]\nTable drivers, columns = [*,driverId,driverRef,number,code,forename,surname,dob,nationality,url]\nTable lapTimes, columns = [*,raceId,driverId,lap,position,time,milliseconds]\nTable pitStops, columns = [*,raceId,driverId,stop,lap,time,duration,milliseconds]\nTable qualifying, columns = [*,qualifyId,raceId,driverId,constructorId,number,position,q1,q2,q3]\nTable races, columns = [*,raceId,year,round,circuitId,name,date,time,url]\nTable results, columns = [*,resultId,raceId,driverId,constructorId,number,grid,position,positionText,positionOrder,points,laps,time,milliseconds,fastestLap,rank,fastestLapTime,fastestLapSpeed,statusId]\nTable seasons, columns = [*,year,url]\nTable status, columns = [*,statusId,status]\n",
        "foreign_keys": "Foreign_keys = [races.circuitId = circuits.circuitId,constructorStandings.raceId = races.raceId,constructorStandings.constructorId = constructors.constructorId,results.driverId = drivers.driverId,results.raceId = races.raceId,results.constructorId = constructors.constructorId,driverStandings.driverId = drivers.driverId,driverStandings.raceId = races.raceId,constructorResults.raceId = races.raceId,constructorResults.constructorId = constructors.constructorId,qualifying.driverId = drivers.driverId,qualifying.raceId = races.raceId,qualifying.constructorId = constructors.constructorId,pitStops.driverId = drivers.driverId,pitStops.raceId = races.raceId,lapTimes.driverId = drivers.driverId,lapTimes.raceId = races.raceId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter races based on the race name 'Monaco Grand Prix' and the year '2008'. Secondly, we need to find the maximum fastest lap speed in the selected race.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select raceId from table 'races' where name = 'Monaco Grand Prix' and year = 2008. In the second step, we need to select the maximum fastest lap speed from table 'results' where raceId matches the selected raceId.\n\n<3> SQL Generation: Use 'where' to filter races based on the race name 'Monaco Grand Prix' and the year '2008', and then use 'where' and 'max' to find the maximum fastest lap speed in the selected race.\n\nSQL query: SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "predict": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "hardness": "medium"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "question": "List the name of technicians whose team is not \"NYY\".",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the 'team' column in the 'technician' table. We need to select the names of technicians whose team is not \"NYY\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'technician' table and its 'name' and 'team' columns, we can directly use this table.\n\n<3> SQL Generation: Use 'where' to filter technicians whose team is not \"NYY\" and select their names.\n\nSQL query: SELECT Name FROM technician WHERE Team != \"NYY\"",
        "predict": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "hardness": "easy"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "question": "What is the name of the technician whose team is not 'NYY'?",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the team of the technician. We need to find the technician whose team is not 'NYY' and retrieve their name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the technician's name and team, we can directly use the 'technician' table.\n\n<3> SQL Generation: Use 'where' to filter technicians whose team is not 'NYY' and select their names.\n\nSQL query: SELECT Name FROM technician WHERE Team != \"NYY\"",
        "predict": "SELECT Name FROM technician WHERE Team != \"NYY\"",
        "hardness": "easy"
    },
    {
        "db_id": "machine_repair",
        "gold": "SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment)",
        "question": "List the names of technicians who have not been assigned to repair machines.",
        "fields": "Table machine, columns = [*,Machine_ID,Making_Year,Class,Team,Machine_series,value_points,quality_rank]\nTable repair, columns = [*,repair_ID,name,Launch_Date,Notes]\nTable repair_assignment, columns = [*,technician_id,repair_ID,Machine_ID]\nTable technician, columns = [*,technician_id,Name,Team,Starting_Year,Age]\n",
        "foreign_keys": "Foreign_keys = [repair_assignment.Machine_ID = machine.Machine_ID,repair_assignment.repair_ID = repair.repair_ID,repair_assignment.technician_id = technician.technician_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding technicians who have not been assigned to repair machines. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find technicians who have not been assigned to repair machines, we need to select the names of technicians from the 'technician' table.\n\n<3> SQL Generation: We can use a left join to combine the 'technician' table with the 'repair_assignment' table on the 'technician_id' column. Then, we can filter the rows where the 'Machine_ID' is null, indicating that the technician has not been assigned to repair machines.\n\nSQL query: SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment)",
        "predict": "SELECT Name FROM technician WHERE technician_id NOT IN (SELECT technician_id FROM repair_assignment)",
        "hardness": "hard"
    },
    {
        "db_id": "entrepreneur",
        "gold": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)",
        "question": "What are the names of people who are not entrepreneurs?",
        "fields": "Table entrepreneur, columns = [*,Entrepreneur_ID,People_ID,Company,Money_Requested,Investor]\nTable people, columns = [*,People_ID,Name,Height,Weight,Date_of_Birth]\n",
        "foreign_keys": "Foreign_keys = [entrepreneur.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding people who are not entrepreneurs. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find people who are not entrepreneurs, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter out people who are entrepreneurs.\n\nSQL query: SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)",
        "predict": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)",
        "hardness": "hard"
    },
    {
        "db_id": "perpetrator",
        "gold": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)",
        "question": "List the names of people that are not perpetrators.",
        "fields": "Table people, columns = [*,People_ID,Name,Height,Weight,Home Town]\nTable perpetrator, columns = [*,Perpetrator_ID,People_ID,Date,Year,Location,Country,Killed,Injured]\n",
        "foreign_keys": "Foreign_keys = [perpetrator.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on people who are not perpetrators. We need to select the names of those people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter out the perpetrators and select their names.\n\nSQL query: SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)",
        "predict": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM perpetrator)",
        "hardness": "hard"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "question": "What campuses are located in the county of Los Angeles?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires finding campuses located in the county of Los Angeles. Firstly, we need to identify the campuses with the county name 'Los Angeles'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Id' column from the 'Campuses' table where the 'County' column is 'Los Angeles'.\n\n<3> SQL Generation: Use 'where' to filter campuses with the county name 'Los Angeles'.\n\nSQL query: SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "predict": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "hardness": "easy"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE YEAR  >=  1935 AND YEAR  <=  1939",
        "question": "Which campus was opened between 1935 and 1939?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires finding campuses that were opened between 1935 and 1939. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information about the campuses, we only need the 'Campuses' table.\n\n<3> SQL Generation: Use 'where' to filter campuses that were opened between 1935 and 1939.\n\nSQL query: SELECT campus FROM campuses WHERE YEAR  >=  1935 AND YEAR  <=  1939",
        "predict": "SELECT campus FROM campuses WHERE YEAR  >=  1935 AND YEAR  <=  1939",
        "hardness": "medium"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "question": "Find the count of universities whose campus fee is greater than the average campus fee.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average campus fee. Secondly, we need to count the number of universities whose campus fee is greater than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Campus' and 'CampusFee' columns from the 'csu_fees' table, we only need this table.\n\n<3> SQL Generation: Use 'select' and 'avg' to calculate the average campus fee, and then use 'where' to filter universities whose campus fee is greater than the average. Finally, use 'count' to count the number of universities.\n\nSQL query: SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "predict": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "hardness": "hard"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "question": "How many universities have a campus fee higher than average?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average campus fee. Secondly, we need to count the number of universities with a campus fee higher than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'csu_fees' table to calculate the average campus fee and count the number of universities.\n\n<3> SQL Generation: Use 'avg' to calculate the average campus fee, and then use 'where' to filter universities with a campus fee higher than the average. Finally, use 'count' to count the number of universities.\n\nSQL query: SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "predict": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "hardness": "hard"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "question": "Find the count of universities whose campus fee is greater than the average campus fee.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average campus fee. Secondly, we need to count the number of universities whose campus fee is greater than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Campus' and 'CampusFee' columns from the 'csu_fees' table, we only need this table.\n\n<3> SQL Generation: Use 'select avg' to calculate the average campus fee, and then use 'where' to filter universities whose campus fee is greater than the average. Finally, use 'count' to count the number of universities.\n\nSQL query: SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "predict": "SELECT count(*) FROM csu_fees WHERE campusfee  >  (SELECT avg(campusfee) FROM csu_fees)",
        "hardness": "hard"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT count(*) FROM campuses WHERE county  =  \"Los Angeles\"",
        "question": "How many campuses are there in Los Angeles county?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of campuses in Los Angeles county.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the campuses from the 'Campuses' table where the county is 'Los Angeles'.\n\n<3> SQL Generation: Use 'where' to filter the campuses in Los Angeles county and count them.\n\nSQL query: SELECT count(*) FROM campuses WHERE county  =  \"Los Angeles\"",
        "predict": "SELECT count(*) FROM campuses WHERE county  =  \"Los Angeles\"",
        "hardness": "easy"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "question": "List the campuses in Los Angeles county.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on campuses in Los Angeles county. We need to select the campuses located in Los Angeles county.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Campus' column from the 'Campuses' table and filter by 'County' column where it is equal to 'Los Angeles'.\n\n<3> SQL Generation: Use 'where' to filter campuses in Los Angeles county.\n\nSQL query: SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "predict": "SELECT campus FROM campuses WHERE county  =  \"Los Angeles\"",
        "hardness": "easy"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  \"San Francisco State University\" AND t2.year  =  2001",
        "question": "What are the degrees conferred in \"San Francisco State University\" in 2001.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the campus ID for \"San Francisco State University\". Secondly, we need to filter the degrees based on the campus ID and the year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the ID from the \"Campuses\" table where the campus name is \"San Francisco State University\". In the second step, we need to filter the degrees based on the campus ID and the year.\n\n<3> SQL Generation: Use 'where' to find the campus ID for \"San Francisco State University\", and then use 'where' to filter the degrees based on the campus ID and the year.\n\nSQL query: SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  \"San Francisco State University\" AND t2.year  =  2001",
        "predict": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  \"San Francisco State University\" AND t2.year  =  2001",
        "hardness": "medium"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004",
        "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter campuses based on the number of faculty lines. Secondly, we need to filter campuses based on the year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Campus from table 'faculty' and filter by the number of faculty lines. We also need to filter campuses based on the year from table 'Campuses'.\n\n<3> SQL Generation: Use 'where' to filter campuses based on the number of faculty lines and the year.\n\nSQL query: SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004",
        "predict": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004",
        "hardness": "medium"
    },
    {
        "db_id": "csu_1",
        "gold": "SELECT t1.campusfee FROM csu_fees AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t2.campus  =  \"San Francisco State University\" AND t1.year  =  2000",
        "question": "What is the campus fee of \"San Francisco State University\" in year 2000?",
        "fields": "Table Campuses, columns = [*,Id,Campus,Location,County,Year]\nTable csu_fees, columns = [*,Campus,Year,CampusFee]\nTable degrees, columns = [*,Year,Campus,Degrees]\nTable discipline_enrollments, columns = [*,Campus,Discipline,Year,Undergraduate,Graduate]\nTable enrollments, columns = [*,Campus,Year,TotalEnrollment_AY,FTE_AY]\nTable faculty, columns = [*,Campus,Year,Faculty]\n",
        "foreign_keys": "Foreign_keys = [csu_fees.Campus = Campuses.Id,degrees.Campus = Campuses.Id,discipline_enrollments.Campus = Campuses.Id,enrollments.Campus = Campuses.Id,faculty.Campus = Campuses.Id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the campus ID of \"San Francisco State University\". Secondly, we need to filter the campus fee based on the campus ID and year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the ID from the \"Campuses\" table where the campus name is \"San Francisco State University\". In the second step, we need to select the campus fee from the \"csu_fees\" table based on the campus ID and year.\n\n<3> SQL Generation: Use 'where' to find the campus ID of \"San Francisco State University\", and then use 'where' to filter the campus fee based on the campus ID and year.\n\nSQL query: SELECT t1.campusfee FROM csu_fees AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t2.campus  =  \"San Francisco State University\" AND t1.year  =  2000",
        "predict": "SELECT t1.campusfee FROM csu_fees AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t2.campus  =  \"San Francisco State University\" AND t1.year  =  2000",
        "hardness": "medium"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT name FROM people WHERE height  >  200 OR height  <  190",
        "question": "find the names of people who are taller than 200 or lower than 190.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on people's height, so we should apply the 'where' condition to the 'Height' column and then return the names of selected people.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'people' table to filter on height and retrieve names, we only need the 'people' table.\n\n<3> SQL Generation: Use 'where' to filter people based on their height and select their names.\n\nSQL query: SELECT name FROM people WHERE height  >  200 OR height  <  190",
        "predict": "SELECT name FROM people WHERE height  >  200 OR height  <  190",
        "hardness": "medium"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "question": "what are the names of people who did not participate in the candidate election.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding the names of people who did not participate in the candidate election. Firstly, we need to identify the people who participated in the candidate election. Secondly, we need to filter out the names of people who did not participate.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'people' table to retrieve the names of people.\n\n<3> SQL Generation: Use 'not in' to filter out the people who participated in the candidate election and select their names.\n\nSQL query: SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "predict": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "hardness": "hard"
    },
    {
        "db_id": "candidate_poll",
        "gold": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "question": "Give the names of people who did not participate in the candidate election.",
        "fields": "Table candidate, columns = [*,Candidate_ID,People_ID,Poll_Source,Date,Support_rate,Consider_rate,Oppose_rate,Unsure_rate]\nTable people, columns = [*,People_ID,Sex,Name,Date_of_Birth,Height,Weight]\n",
        "foreign_keys": "Foreign_keys = [candidate.People_ID = people.People_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding people who did not participate in the candidate election. Firstly, we need to identify the people who participated in the candidate election. Secondly, we need to select the names of people who did not participate.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select People_ID from table 'candidate'. In the second step, we need to select Name from table 'people' and filter by People_ID.\n\n<3> SQL Generation: Use 'where' to find the People_ID of people who participated in the candidate election, and then use 'not in' to select the names of people who did not participate.\n\nSQL query: SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "predict": "SELECT name FROM people WHERE people_id NOT IN (SELECT people_id FROM candidate)",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "question": "How many movies were made before 2000?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on movies made before 2000. We need to select movies based on their year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' table and the 'year' column.\n\n<3> SQL Generation: Use 'where' to filter movies made before 2000 and count them.\n\nSQL query: SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "predict": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "hardness": "easy"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "question": "How many movies were made before 2000?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on movies made before 2000. We need to select movies based on their year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' table and the 'year' column.\n\n<3> SQL Generation: Use 'where' to filter movies made before 2000 and count them.\n\nSQL query: SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "predict": "SELECT count(*) FROM Movie WHERE YEAR  <  2000",
        "hardness": "easy"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT count(*) FROM Rating WHERE stars  >  3",
        "question": "What is the total number of ratings that has more than 3 stars?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on ratings with more than 3 stars. We need to count the number of ratings that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rating' table for this query.\n\n<3> SQL Generation: Use 'where' to filter ratings with more than 3 stars, and then use 'count' to calculate the total number of ratings that meet this condition.\n\nSQL query: SELECT count(*) FROM Rating WHERE stars  >  3",
        "predict": "SELECT count(*) FROM Rating WHERE stars  >  3",
        "hardness": "easy"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT YEAR FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  >=  4 ORDER BY T1.year",
        "question": "In what years did a movie receive a 4 or 5 star rating, and list the years from oldest to most recently?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter movies that received a 4 or 5 star rating. Secondly, we need to list the years of these movies from oldest to most recently.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the year from table 'Movie' and filter by movies that have a 4 or 5 star rating in table 'Rating'.\n\n<3> SQL Generation: Use 'where' to filter movies that received a 4 or 5 star rating, and then use 'order by' to list the years from oldest to most recently.\n\nSQL query: SELECT DISTINCT YEAR FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  >=  4 ORDER BY T1.year",
        "predict": "SELECT DISTINCT YEAR FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID WHERE T2.stars  >=  4 ORDER BY T1.year",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT avg(T1.stars) ,  T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.year  =  (SELECT min(YEAR) FROM Movie)",
        "question": "For the oldest movie listed, what is its average rating and title?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the oldest movie listed. Secondly, we need to calculate the average rating for that movie. Finally, we need to retrieve the title of the movie.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the minimum year from the 'Movie' table and then join it with the 'Rating' table on the 'mID' column to calculate the average rating. We also need to retrieve the title from the 'Movie' table.\n\n<3> SQL Generation: Use 'where' to find the minimum year from the 'Movie' table. Then, join the 'Movie' and 'Rating' tables on the 'mID' column. Calculate the average rating using 'avg' and retrieve the title from the 'Movie' table.\n\nSQL query: SELECT avg(T1.stars) ,  T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.year  =  (SELECT min(YEAR) FROM Movie)",
        "predict": "SELECT avg(T1.stars) ,  T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T2.year  =  (SELECT min(YEAR) FROM Movie)",
        "hardness": "extra"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Sarah Martinez'",
        "question": "Find the names of all directors whose movies are rated by Sarah Martinez.",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the movies that are rated by Sarah Martinez. Secondly, we need to find the directors of those movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select mID from table 'Rating' where rID = (select rID from Reviewer where name = 'Sarah Martinez'). In the second step, we need to select director from table 'Movie' where mID is in the result of the first step.\n\n<3> SQL Generation: Use 'where' to find the rID of Sarah Martinez, and then use 'where' and 'in' to filter movies rated by her and select the directors.\n\nSQL query: SELECT DISTINCT T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Sarah Martinez'",
        "predict": "SELECT DISTINCT T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T3.name  =  'Sarah Martinez'",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT DISTINCT T3.name ,  T2.title ,  T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.director  =  T3.name",
        "question": "What are the different reviewer names, movie titles, and stars for every rating where the reviewer had the same name as the director?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the ratings where the reviewer had the same name as the director. Secondly, we need to retrieve the reviewer names, movie titles, and stars for those ratings.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the tables 'Rating', 'Reviewer', and 'Movie' on the corresponding foreign keys.\n\n<3> SQL Generation: Use 'join' to combine the tables based on the foreign key relationships. Then, use 'where' to filter the rows where the reviewer name is the same as the director's name. Finally, select the reviewer name, movie title, and stars from the resulting rows.\n\nSQL query: SELECT DISTINCT T3.name ,  T2.title ,  T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.director  =  T3.name",
        "predict": "SELECT DISTINCT T3.name ,  T2.title ,  T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.director  =  T3.name",
        "hardness": "hard"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5",
        "question": "What are the titles of all movies that have between 3 and 5 stars?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on movies with a rating between 3 and 5 stars. We need to select the titles of these movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' and 'Rating' tables.\n\n<3> SQL Generation: We need to join the 'Movie' and 'Rating' tables on the 'mID' column. Then, we filter the rows where the 'stars' column is between 3 and 5. Finally, we select the 'title' column from the 'Movie' table.\n\nSQL query: SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5",
        "predict": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5",
        "hardness": "medium"
    },
    {
        "db_id": "movie_1",
        "gold": "SELECT title FROM Movie WHERE director  =  \"James Cameron\" OR YEAR   <  1980",
        "question": "What are the names of all movies made before 1980 or had James Cameron as the director?",
        "fields": "Table Movie, columns = [*,mID,title,year,director]\nTable Rating, columns = [*,rID,mID,stars,ratingDate]\nTable Reviewer, columns = [*,rID,name]\n",
        "foreign_keys": "Foreign_keys = [Rating.rID = Reviewer.rID,Rating.mID = Movie.mID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter movies made before 1980. Secondly, we need to filter movies with James Cameron as the director. Finally, we need to select the names of the movies that meet either of these conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Movie' table for this query.\n\n<3> SQL Generation: Use 'where' to filter movies made before 1980 or with James Cameron as the director, and then select the names of the movies.\n\nSQL query: SELECT title FROM Movie WHERE director  =  \"James Cameron\" OR YEAR   <  1980",
        "predict": "SELECT title FROM Movie WHERE director  =  \"James Cameron\" OR YEAR   <  1980",
        "hardness": "medium"
    },
    {
        "db_id": "county_public_safety",
        "gold": "SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population  >  20000)",
        "question": "Show the number of cities in counties that have a population more than 20000.",
        "fields": "Table city, columns = [*,City_ID,County_ID,Name,White,Black,Amerindian,Asian,Multiracial,Hispanic]\nTable county_public_safety, columns = [*,County_ID,Name,Population,Police_officers,Residents_per_officer,Case_burden,Crime_rate,Police_force,Location]\n",
        "foreign_keys": "Foreign_keys = [city.County_ID = county_public_safety.County_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on counties with a population more than 20000. Firstly, we need to identify the counties with a population more than 20000. Secondly, we need to count the number of cities in those counties.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select County_ID from table 'county_public_safety' where Population > 20000. In the second step, we need to count the number of cities from table 'city' where County_ID is in the selected County_IDs.\n\n<3> SQL Generation: Use 'where' to filter counties with a population more than 20000, and then use 'where' and 'count' to count the number of cities in those counties.\n\nSQL query: SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population  >  20000)",
        "predict": "SELECT count(*) FROM city WHERE county_ID IN (SELECT county_ID FROM county_public_safety WHERE population  >  20000)",
        "hardness": "hard"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT roomName FROM Rooms WHERE basePrice  <  160 AND beds =  2 AND decor  =  'modern';",
        "question": "What are the names of modern rooms that have a base price lower than $160 and two beds.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter rooms based on their decor, base price, and number of beds. Secondly, we need to select the names of the filtered rooms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rooms' table for this query.\n\n<3> SQL Generation: Use 'where' to filter rooms with decor = 'modern', base price < $160, and beds = 2. Then, select the room names.\n\nSQL query: SELECT roomName FROM Rooms WHERE basePrice  <  160 AND beds =  2 AND decor  =  'modern';",
        "predict": "SELECT roomName FROM Rooms WHERE basePrice  <  160 AND beds =  2 AND decor  =  'modern';",
        "hardness": "medium"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT roomName ,  RoomId FROM Rooms WHERE basePrice  >  160 AND maxOccupancy  >  2;",
        "question": "Find all the rooms that have a price higher than 160 and can accommodate more than 2 people. Report room names and ids.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter rooms based on their price being higher than 160 and their maximum occupancy being more than 2. Secondly, we need to select the room names and ids of the filtered rooms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rooms' table for this query.\n\n<3> SQL Generation: Use 'where' to filter rooms based on their price and maximum occupancy, and then select the room names and ids.\n\nSQL query: SELECT roomName ,  RoomId FROM Rooms WHERE basePrice  >  160 AND maxOccupancy  >  2;",
        "predict": "SELECT roomName ,  RoomId FROM Rooms WHERE basePrice  >  160 AND maxOccupancy  >  2;",
        "hardness": "medium"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT Adults FROM Reservations WHERE CheckIn  =  \"2010-10-23\" AND FirstName  =  \"CONRAD\" AND LastName  =  \"SELBIG\";",
        "question": "Find the number of adults for the room reserved and checked in by CONRAD SELBIG on Oct 23, 2010.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the reservation made by CONRAD SELBIG on Oct 23, 2010. Secondly, we need to retrieve the room reserved and checked in by CONRAD SELBIG. Finally, we need to find the number of adults for that room.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the reservation code from table 'Reservations' where LastName = 'SELBIG', FirstName = 'CONRAD', and CheckIn = '2010-10-23'. In the second step, we need to retrieve the room number from table 'Reservations' based on the reservation code. In the final step, we need to find the number of adults for that room from table 'Reservations'.\n\n<3> SQL Generation: Use 'where' to find the reservation made by CONRAD SELBIG on Oct 23, 2010. Then, retrieve the room number reserved and checked in by CONRAD SELBIG. Finally, find the number of adults for that room.\n\nSQL query: SELECT Adults FROM Reservations WHERE CheckIn  =  \"2010-10-23\" AND FirstName  =  \"CONRAD\" AND LastName  =  \"SELBIG\";",
        "predict": "SELECT Adults FROM Reservations WHERE CheckIn  =  \"2010-10-23\" AND FirstName  =  \"CONRAD\" AND LastName  =  \"SELBIG\";",
        "hardness": "medium"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;",
        "question": "List how many times the number of people in the room reached the maximum occupancy of the room. The number of people include adults and kids.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the total number of people (adults + kids) in each reservation. Secondly, we need to count the number of times the total number of people reached the maximum occupancy of the room.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Room' column from the 'Reservations' table and the 'maxOccupancy' column from the 'Rooms' table.\n\n<3> SQL Generation: We need to join the 'Reservations' and 'Rooms' tables on the 'Room' column. Then, we calculate the total number of people (adults + kids) in each reservation by summing the 'Adults' and 'Kids' columns. Finally, we count the number of times the total number of people reached the maximum occupancy of the room.\n\nSQL query: SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;",
        "predict": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;",
        "hardness": "medium"
    },
    {
        "db_id": "inn_1",
        "gold": "SELECT count(*) FROM rooms WHERE roomid NOT IN (SELECT DISTINCT room FROM reservations)",
        "question": "Find the number of rooms that do not have any reservation.",
        "fields": "Table Reservations, columns = [*,Code,Room,CheckIn,CheckOut,Rate,LastName,FirstName,Adults,Kids]\nTable Rooms, columns = [*,RoomId,roomName,beds,bedType,maxOccupancy,basePrice,decor]\n",
        "foreign_keys": "Foreign_keys = [Reservations.Room = Rooms.RoomId]\n",
        "reasoning": "<1> Decomposition: We need to find the rooms that do not have any reservation.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Rooms' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Rooms' table with the 'Reservations' table, and then filter the rows where the reservation code is null (indicating no reservation). Finally, we count the number of rooms that meet this condition.\n\nSQL query: SELECT count(*) FROM rooms WHERE roomid NOT IN (SELECT DISTINCT room FROM reservations)",
        "predict": "SELECT count(*) FROM rooms WHERE roomid NOT IN (SELECT DISTINCT room FROM reservations)",
        "hardness": "extra"
    },
    {
        "db_id": "party_host",
        "gold": "SELECT Name FROM HOST WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host)",
        "question": "List the names of hosts who did not serve as a host of any party in our record.",
        "fields": "Table host, columns = [*,Host_ID,Name,Nationality,Age]\nTable party, columns = [*,Party_ID,Party_Theme,Location,First_year,Last_year,Number_of_hosts]\nTable party_host, columns = [*,Party_ID,Host_ID,Is_Main_in_Charge]\n",
        "foreign_keys": "Foreign_keys = [party_host.Party_ID = party.Party_ID,party_host.Host_ID = host.Host_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding hosts who did not serve as a host of any party in the record. Firstly, we need to identify the hosts who served as hosts in the record. Secondly, we need to filter out the hosts who did not serve as hosts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Host_ID from table 'party_host' and filter by Host_ID in table 'host'.\n\n<3> SQL Generation: Use 'where' to select Host_ID from table 'party_host' and then use 'not in' to filter out the hosts who served as hosts.\n\nSQL query: SELECT Name FROM HOST WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host)",
        "predict": "SELECT Name FROM HOST WHERE Host_ID NOT IN (SELECT Host_ID FROM party_host)",
        "hardness": "hard"
    },
    {
        "db_id": "storm_record",
        "gold": "SELECT avg(damage_millions_USD) ,  max(damage_millions_USD) FROM storm WHERE max_speed  >  1000",
        "question": "What is the average and maximum damage in millions for storms that had a max speed over 1000?",
        "fields": "Table affected_region, columns = [*,Region_id,Storm_ID,Number_city_affected]\nTable region, columns = [*,Region_id,Region_code,Region_name]\nTable storm, columns = [*,Storm_ID,Name,Dates_active,Max_speed,Damage_millions_USD,Number_Deaths]\n",
        "foreign_keys": "Foreign_keys = [affected_region.Storm_ID = storm.Storm_ID,affected_region.Region_id = region.Region_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter storms based on their maximum speed being over 1000. Secondly, we need to calculate the average and maximum damage in millions for the selected storms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'storm' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter storms with a maximum speed over 1000, and then use 'avg' and 'max' to calculate the average and maximum damage in millions for the selected storms.\n\nSQL query: SELECT avg(damage_millions_USD) ,  max(damage_millions_USD) FROM storm WHERE max_speed  >  1000",
        "predict": "SELECT avg(damage_millions_USD) ,  max(damage_millions_USD) FROM storm WHERE max_speed  >  1000",
        "hardness": "medium"
    },
    {
        "db_id": "election",
        "gold": "SELECT count(DISTINCT T2.Delegate) FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District WHERE T1.Population  >  50000",
        "question": "How many distinct delegates are from counties with population larger than 50000?",
        "fields": "Table county, columns = [*,County_Id,County_name,Population,Zip_code]\nTable election, columns = [*,Election_ID,Counties_Represented,District,Delegate,Party,First_Elected,Committee]\nTable party, columns = [*,Party_ID,Year,Party,Governor,Lieutenant_Governor,Comptroller,Attorney_General,US_Senate]\n",
        "foreign_keys": "Foreign_keys = [election.District = county.County_Id,election.Party = party.Party_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter counties with population larger than 50000. Secondly, we need to count the distinct delegates from these counties.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select County_Id from table 'county' where Population > 50000. In the second step, we need to filter Counties_Represented from table 'election' and count the distinct delegates.\n\n<3> SQL Generation: Use 'where' to filter counties with population larger than 50000, and then use 'count(distinct)' to count the distinct delegates from these counties.\n\nSQL query: SELECT count(DISTINCT T2.Delegate) FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District WHERE T1.Population  >  50000",
        "predict": "SELECT count(DISTINCT T2.Delegate) FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District WHERE T1.Population  >  50000",
        "hardness": "medium"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major = 600;",
        "question": "Which student's age is older than 18 and is majoring in 600? List each student's first and last name.",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their age and major. Secondly, we need to select the first and last name of the selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table for this query.\n\n<3> SQL Generation: Use 'where' to filter students based on their age and major, and then select the first and last name of the selected students.\n\nSQL query: SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major = 600;",
        "predict": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major = 600;",
        "hardness": "medium"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major != 600 AND Sex = 'F';",
        "question": "List all female students age is older than 18 who is not majoring in 600. List students' first name and last name.",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their gender, age, and major. Secondly, we need to select the first name and last name of the filtered students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select LName and Fname from table 'Student' and filter by Sex, Age, and Major.\n\n<3> SQL Generation: Use 'where' to filter students based on their gender, age, and major, and then select their first name and last name.\n\nSQL query: SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major != 600 AND Sex = 'F';",
        "predict": "SELECT Fname , Lname FROM Student WHERE Age  >  18 AND Major != 600 AND Sex = 'F';",
        "hardness": "medium"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT count(*) FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "question": "How many times has the student Linda Smith visited Subway?",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name 'Linda Smith'. Secondly, we need to find the restaurant with the name 'Subway'. Finally, we need to count the number of times Linda Smith has visited Subway.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to select ResID from table 'Restaurant' where ResName = 'Subway'. In the final step, we need to count the number of rows in table 'Visits_Restaurant' where StuID matches Linda Smith's StuID and ResID matches Subway's ResID.\n\n<3> SQL Generation: Use 'where' to find the StuID of Linda Smith and the ResID of Subway, and then use 'where' to filter rows in 'Visits_Restaurant' where StuID matches Linda Smith's StuID and ResID matches Subway's ResID. Finally, count the number of rows that meet these conditions.\n\nSQL query: SELECT count(*) FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "predict": "SELECT count(*) FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "hardness": "hard"
    },
    {
        "db_id": "restaurant_1",
        "gold": "SELECT TIME FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "question": "When did Linda Smith visit Subway?",
        "fields": "Table Restaurant, columns = [*,ResID,ResName,Address,Rating]\nTable Restaurant_Type, columns = [*,ResTypeID,ResTypeName,ResTypeDescription]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Type_Of_Restaurant, columns = [*,ResID,ResTypeID]\nTable Visits_Restaurant, columns = [*,StuID,ResID,Time,Spent]\n",
        "foreign_keys": "Foreign_keys = [Type_Of_Restaurant.ResTypeID = Restaurant_Type.ResTypeID,Type_Of_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.ResID = Restaurant.ResID,Visits_Restaurant.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the StuID of Linda Smith from table 'Student'. Secondly, we need to find the Time when Linda Smith visited Subway from table 'Visits_Restaurant'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to select Time from table 'Visits_Restaurant' where StuID is the StuID found in the first step and ResID is the ResID of Subway.\n\n<3> SQL Generation: Use 'where' to find the StuID of Linda Smith from table 'Student', and then use 'where' to find the Time when Linda Smith visited Subway from table 'Visits_Restaurant'.\n\nSQL query: SELECT TIME FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "predict": "SELECT TIME FROM Student JOIN Visits_Restaurant ON Student.StuID = Visits_Restaurant.StuID JOIN Restaurant ON Visits_Restaurant.ResID = Restaurant.ResID WHERE Student.Fname = \"Linda\" AND Student.Lname = \"Smith\" AND Restaurant.ResName = \"Subway\";",
        "hardness": "hard"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT DISTINCT t3.name FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t1.fname  =  \"Matthias\" AND t1.lname  =  \"Blume\"",
        "question": "What is the name of the institution that \"Matthias Blume\" belongs to?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the authID of \"Matthias Blume\" in table 'Authors'. Secondly, we need to find the instID associated with the authID in table 'Authorship'. Finally, we need to find the name of the institution associated with the instID in table 'Inst'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select authID from table 'Authors' where lname = 'Blume' and fname = 'Matthias'. In the second step, we need to select instID from table 'Authorship' where authID matches the value found in the first step. In the final step, we need to select name from table 'Inst' where instID matches the value found in the second step.\n\n<3> SQL Generation: Use 'where' to find the authID of \"Matthias Blume\" in table 'Authors', then use 'where' to find the instID associated with the authID in table 'Authorship', and finally use 'where' to find the name of the institution associated with the instID in table 'Inst'.\n\nSQL query: SELECT DISTINCT t3.name FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t1.fname  =  \"Matthias\" AND t1.lname  =  \"Blume\"",
        "predict": "SELECT DISTINCT t3.name FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t1.fname  =  \"Matthias\" AND t1.lname  =  \"Blume\"",
        "hardness": "hard"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT count(DISTINCT t1.title) FROM papers AS t1 JOIN authorship AS t2 ON t1.paperid  =  t2.paperid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"University of Pennsylvania\"",
        "question": "How many papers are written by authors from the institution \"University of Pennsylvania\"?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the institution with the name \"University of Pennsylvania\". Secondly, we need to filter authorship records based on the institution and count the number of papers written by those authors.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select instID from table 'Inst' where name = \"University of Pennsylvania\". In the second step, we need to filter authID from table 'Authorship' based on the instID found in the first step and count the number of distinct paperIDs.\n\n<3> SQL Generation: Use 'where' to find the institution with the name \"University of Pennsylvania\", and then use 'where' to filter authorship records based on the institution and count the number of distinct paperIDs.\n\nSQL query: SELECT count(DISTINCT t1.title) FROM papers AS t1 JOIN authorship AS t2 ON t1.paperid  =  t2.paperid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"University of Pennsylvania\"",
        "predict": "SELECT count(DISTINCT t1.title) FROM papers AS t1 JOIN authorship AS t2 ON t1.paperid  =  t2.paperid JOIN inst AS t3 ON t2.instid  =  t3.instid WHERE t3.name  =  \"University of Pennsylvania\"",
        "hardness": "hard"
    },
    {
        "db_id": "icfp_1",
        "gold": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid JOIN inst AS t4 ON t2.instid  =  t4.instid WHERE t4.country  =  \"USA\" AND t2.authorder  =  2 AND t1.lname  =  \"Turon\"",
        "question": "Which paper is published in an institution in \"USA\" and have \"Turon\" as its second author?",
        "fields": "Table Authors, columns = [*,authID,lname,fname]\nTable Authorship, columns = [*,authID,instID,paperID,authOrder]\nTable Inst, columns = [*,instID,name,country]\nTable Papers, columns = [*,paperID,title]\n",
        "foreign_keys": "Foreign_keys = [Authorship.paperID = Papers.paperID,Authorship.instID = Inst.instID,Authorship.authID = Authors.authID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the institution with the country \"USA\". Secondly, we need to find the paper with \"Turon\" as its second author.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select instID from table 'Inst' where country = \"USA\". In the second step, we need to find the paperID from table 'Authorship' where authOrder = 2 and authID corresponds to \"Turon\".\n\n<3> SQL Generation: Use 'where' to find the institution with the country \"USA\", and then use 'join' to connect the tables 'Authorship', 'Authors', and 'Papers' based on the foreign key relationships. Finally, use 'where' to filter the rows where authOrder = 2 and the author's name is \"Turon\".\n\nSQL query: SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid JOIN inst AS t4 ON t2.instid  =  t4.instid WHERE t4.country  =  \"USA\" AND t2.authorder  =  2 AND t1.lname  =  \"Turon\"",
        "predict": "SELECT t3.title FROM authors AS t1 JOIN authorship AS t2 ON t1.authid  =  t2.authid JOIN papers AS t3 ON t2.paperid  =  t3.paperid JOIN inst AS t4 ON t2.instid  =  t4.instid WHERE t4.country  =  \"USA\" AND t2.authorder  =  2 AND t1.lname  =  \"Turon\"",
        "hardness": "extra"
    },
    {
        "db_id": "sakila_1",
        "gold": "SELECT count(*) FROM customer WHERE active = '1'",
        "question": "How many customers have an active value of 1?",
        "fields": "Table actor, columns = [*,actor_id,first_name,last_name,last_update]\nTable address, columns = [*,address_id,address,address2,district,city_id,postal_code,phone,last_update]\nTable category, columns = [*,category_id,name,last_update]\nTable city, columns = [*,city_id,city,country_id,last_update]\nTable country, columns = [*,country_id,country,last_update]\nTable customer, columns = [*,customer_id,store_id,first_name,last_name,email,address_id,active,create_date,last_update]\nTable film, columns = [*,film_id,title,description,release_year,language_id,original_language_id,rental_duration,rental_rate,length,replacement_cost,rating,special_features,last_update]\nTable film_actor, columns = [*,actor_id,film_id,last_update]\nTable film_category, columns = [*,film_id,category_id,last_update]\nTable film_text, columns = [*,film_id,title,description]\nTable inventory, columns = [*,inventory_id,film_id,store_id,last_update]\nTable language, columns = [*,language_id,name,last_update]\nTable payment, columns = [*,payment_id,customer_id,staff_id,rental_id,amount,payment_date,last_update]\nTable rental, columns = [*,rental_id,rental_date,inventory_id,customer_id,return_date,staff_id,last_update]\nTable staff, columns = [*,staff_id,first_name,last_name,address_id,picture,email,store_id,active,username,password,last_update]\nTable store, columns = [*,store_id,manager_staff_id,address_id,last_update]\n",
        "foreign_keys": "Foreign_keys = [address.city_id = city.city_id,city.country_id = country.country_id,customer.store_id = store.store_id,customer.address_id = address.address_id,film.original_language_id = language.language_id,film.language_id = language.language_id,film_actor.film_id = film.film_id,film_actor.actor_id = actor.actor_id,film_category.category_id = category.category_id,film_category.film_id = film.film_id,inventory.film_id = film.film_id,inventory.store_id = store.store_id,payment.staff_id = staff.staff_id,payment.customer_id = customer.customer_id,payment.rental_id = rental.rental_id,rental.customer_id = customer.customer_id,rental.inventory_id = inventory.inventory_id,rental.staff_id = staff.staff_id,staff.address_id = address.address_id,store.address_id = address.address_id,store.manager_staff_id = staff.staff_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of customers with an active value of 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'customer' table and the 'active' column.\n\n<3> SQL Generation: Use 'where' to filter customers with an active value of 1 and count them.\n\nSQL query: SELECT count(*) FROM customer WHERE active = '1'",
        "predict": "SELECT count(*) FROM customer WHERE active = '1'",
        "hardness": "easy"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name ,  acc_bal FROM customer WHERE cust_name LIKE '%a%'",
        "question": "Find the name and account balance of the customer whose name includes the letter a.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter customers whose name includes the letter 'a'. Secondly, we need to select the name and account balance of the filtered customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'customer' table, we only need to consider this table.\n\n<3> SQL Generation: Use 'where' to filter customers whose name includes the letter 'a', and then select the name and account balance of the filtered customers.\n\nSQL query: SELECT cust_name ,  acc_bal FROM customer WHERE cust_name LIKE '%a%'",
        "predict": "SELECT cust_name ,  acc_bal FROM customer WHERE cust_name LIKE '%a%'",
        "hardness": "medium"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1",
        "question": "What is the name of the customer with the worst credit score?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: We need to find the customer with the worst credit score.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the cust_name from the customer table.\n\n<3> SQL Generation: We can use the MIN function to find the minimum credit score and then select the cust_name of the customer with that score.\n\nSQL query: SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1",
        "predict": "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1",
        "hardness": "medium"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE amount  >  3000",
        "question": "What are the names of customers who have a loan of more than 3000 in amount?",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on loans with an amount greater than 3000. We need to identify the customers who have these loans and retrieve their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of customers from the 'customer' table who have loans with an amount greater than 3000 from the 'loan' table.\n\n<3> SQL Generation: Use 'where' to filter loans with an amount greater than 3000, join the 'customer' and 'loan' tables on the 'cust_ID' column, and select the names of the customers.\n\nSQL query: SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE amount  >  3000",
        "predict": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE amount  >  3000",
        "hardness": "medium"
    },
    {
        "db_id": "loan_1",
        "gold": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "question": "Find the average credit score of the customers who do not have any loan.",
        "fields": "Table bank, columns = [*,branch_ID,bname,no_of_customers,city,state]\nTable customer, columns = [*,cust_ID,cust_name,acc_type,acc_bal,no_of_loans,credit_score,branch_ID,state]\nTable loan, columns = [*,loan_ID,loan_type,cust_ID,branch_ID,amount]\n",
        "foreign_keys": "Foreign_keys = [customer.branch_ID = bank.branch_ID,loan.branch_ID = bank.branch_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customers who do not have any loan. Secondly, we need to calculate the average credit score of those customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select cust_ID from table 'loan' and filter by cust_ID. In the second step, we need to select credit_score from table 'customer' and filter by cust_ID.\n\n<3> SQL Generation: Use 'where' to filter customers who do not have any loan, and then use 'avg' to calculate the average credit score of those customers.\n\nSQL query: SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "predict": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "hardness": "extra"
    },
    {
        "db_id": "behavior_monitoring",
        "gold": "SELECT count(*) FROM STUDENTS WHERE student_id NOT IN ( SELECT student_id FROM Behavior_Incident )",
        "question": "How many students are not involved in any behavior incident?",
        "fields": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Assessment_Notes, columns = [*,notes_id,student_id,teacher_id,date_of_notes,text_of_notes,other_details]\nTable Behavior_Incident, columns = [*,incident_id,incident_type_code,student_id,date_incident_start,date_incident_end,incident_summary,recommendations,other_details]\nTable Detention, columns = [*,detention_id,detention_type_code,teacher_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]\nTable Ref_Address_Types, columns = [*,address_type_code,address_type_description]\nTable Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]\nTable Ref_Incident_Type, columns = [*,incident_type_code,incident_type_description]\nTable Student_Addresses, columns = [*,student_id,address_id,date_address_from,date_address_to,monthly_rental,other_details]\nTable Students, columns = [*,student_id,address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,date_first_rental,date_left_university,other_student_details]\nTable Students_in_Detention, columns = [*,student_id,detention_id,incident_id]\nTable Teachers, columns = [*,teacher_id,address_id,first_name,middle_name,last_name,gender,cell_mobile_number,email_address,other_details]\n",
        "foreign_keys": "Foreign_keys = [Students.address_id = Addresses.address_id,Teachers.address_id = Addresses.address_id,Assessment_Notes.teacher_id = Teachers.teacher_id,Assessment_Notes.student_id = Students.student_id,Behavior_Incident.student_id = Students.student_id,Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code,Detention.teacher_id = Teachers.teacher_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Student_Addresses.student_id = Students.student_id,Student_Addresses.address_id = Addresses.address_id,Students_in_Detention.student_id = Students.student_id,Students_in_Detention.detention_id = Detention.detention_id,Students_in_Detention.incident_id = Behavior_Incident.incident_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who are involved in behavior incidents. Secondly, we need to count the number of students who are not involved in any behavior incident.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from table 'Behavior_Incident'.\n\n<3> SQL Generation: Use 'where' to select student_id from table 'Behavior_Incident', and then use 'not in' to filter students who are not involved in any behavior incident and count them.\n\nSQL query: SELECT count(*) FROM STUDENTS WHERE student_id NOT IN ( SELECT student_id FROM Behavior_Incident )",
        "predict": "SELECT count(*) FROM STUDENTS WHERE student_id NOT IN ( SELECT student_id FROM Behavior_Incident )",
        "hardness": "extra"
    },
    {
        "db_id": "assets_maintenance",
        "gold": "SELECT first_name ,  last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits)",
        "question": "Which engineers have never visited to maintain the assets? List the engineer first name and last name.",
        "fields": "Table Asset_Parts, columns = [*,asset_id,part_id]\nTable Assets, columns = [*,asset_id,maintenance_contract_id,supplier_company_id,asset_details,asset_make,asset_model,asset_acquired_date,asset_disposed_date,other_asset_details]\nTable Engineer_Skills, columns = [*,engineer_id,skill_id]\nTable Engineer_Visits, columns = [*,engineer_visit_id,contact_staff_id,engineer_id,fault_log_entry_id,fault_status,visit_start_datetime,visit_end_datetime,other_visit_details]\nTable Fault_Log, columns = [*,fault_log_entry_id,asset_id,recorded_by_staff_id,fault_log_entry_datetime,fault_description,other_fault_details]\nTable Fault_Log_Parts, columns = [*,fault_log_entry_id,part_fault_id,fault_status]\nTable Maintenance_Contracts, columns = [*,maintenance_contract_id,maintenance_contract_company_id,contract_start_date,contract_end_date,other_contract_details]\nTable Maintenance_Engineers, columns = [*,engineer_id,company_id,first_name,last_name,other_details]\nTable Part_Faults, columns = [*,part_fault_id,part_id,fault_short_name,fault_description,other_fault_details]\nTable Parts, columns = [*,part_id,part_name,chargeable_yn,chargeable_amount,other_part_details]\nTable Skills, columns = [*,skill_id,skill_code,skill_description]\nTable Skills_Required_To_Fix, columns = [*,part_fault_id,skill_id]\nTable Staff, columns = [*,staff_id,staff_name,gender,other_staff_details]\nTable Third_Party_Companies, columns = [*,company_id,company_type,company_name,company_address,other_company_details]\n",
        "foreign_keys": "Foreign_keys = [Maintenance_Contracts.maintenance_contract_company_id = Third_Party_Companies.company_id,Assets.supplier_company_id = Third_Party_Companies.company_id,Assets.maintenance_contract_id = Maintenance_Contracts.maintenance_contract_id,Asset_Parts.asset_id = Assets.asset_id,Asset_Parts.part_id = Parts.part_id,Maintenance_Engineers.company_id = Third_Party_Companies.company_id,Engineer_Skills.skill_id = Skills.skill_id,Engineer_Skills.engineer_id = Maintenance_Engineers.engineer_id,Fault_Log.recorded_by_staff_id = Staff.staff_id,Fault_Log.asset_id = Assets.asset_id,Engineer_Visits.contact_staff_id = Staff.staff_id,Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id,Engineer_Visits.fault_log_entry_id = Fault_Log.fault_log_entry_id,Part_Faults.part_id = Parts.part_id,Fault_Log_Parts.fault_log_entry_id = Fault_Log.fault_log_entry_id,Fault_Log_Parts.part_fault_id = Part_Faults.part_fault_id,Skills_Required_To_Fix.skill_id = Skills.skill_id,Skills_Required_To_Fix.part_fault_id = Part_Faults.part_fault_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the engineers who have visited to maintain the assets. Secondly, we need to filter out the engineers who have never visited and list their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select engineer_id from table 'Engineer_Visits' and engineer_id from table 'Maintenance_Engineers'.\n\n<3> SQL Generation: Use 'where' to find the engineers who have visited to maintain the assets, and then use 'not in' to filter out the engineers who have never visited. Finally, select their first name and last name.\n\nSQL query: SELECT first_name ,  last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits)",
        "predict": "SELECT first_name ,  last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits)",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  \"ACCT-211\"",
        "question": "How many professors teach a class with the code ACCT-211?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the class with the code ACCT-211. Secondly, we need to find the professors who teach that class and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CLASS_CODE from table 'CLASS' where CRS_CODE = 'ACCT-211'. In the second step, we need to filter PROF_NUM from table 'CLASS'.\n\n<3> SQL Generation: Use 'where' to find the class with the code ACCT-211, and then use 'where' to filter professors who teach that class and count them.\n\nSQL query: SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  \"ACCT-211\"",
        "predict": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  \"ACCT-211\"",
        "hardness": "easy"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'",
        "question": "How many classes does the professor whose last name is Graztevski teach?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the professor with the last name 'Graztevski'. Secondly, we need to count the number of classes taught by this professor.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select EMP_NUM from table 'EMPLOYEE' where EMP_LNAME = 'Graztevski'. In the second step, we need to count CLASS_CODE from table 'CLASS' where PROF_NUM is the value found in the first step.\n\n<3> SQL Generation: Use 'where' to find the professor with the last name 'Graztevski', and then use 'where' to count the number of classes taught by this professor.\n\nSQL query: SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'",
        "predict": "SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'",
        "hardness": "medium"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "question": "How many courses are offered by the Computer Info. Systems department?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the department with the department name 'Computer Info. Systems'. Secondly, we need to count the number of courses offered by that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for courses offered by the 'Computer Info. Systems' department, we need to select courses from the 'COURSE' table where the department code matches the department code of the 'Computer Info. Systems' department.\n\n<3> SQL Generation: Use 'where' to filter the courses with the department code of the 'Computer Info. Systems' department, and then use 'count' to calculate the number of courses.\n\nSQL query: SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "predict": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "hardness": "medium"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "question": "How many courses does the department of Computer Information Systmes offer?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the department code for the department of Computer Information Systems. Secondly, we need to count the number of courses offered by that department.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select DEPT_CODE from table 'DEPARTMENT' where DEPT_NAME = 'Computer Information Systems'. In the second step, we need to count the number of courses from table 'COURSE' where DEPT_CODE matches the department code found in the first step.\n\n<3> SQL Generation: Use 'where' to find the department code for the department of Computer Information Systems, and then use 'where' to count the number of courses offered by that department.\n\nSQL query: SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "predict": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  \"Computer Info. Systems\"",
        "hardness": "medium"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.'",
        "question": "How many professors do have a Ph.D. degree?",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: We need to filter professors who have a Ph.D. degree.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select professors with a Ph.D. degree from the 'PROFESSOR' table.\n\n<3> SQL Generation: Use 'where' to filter professors with a Ph.D. degree and count them.\n\nSQL query: SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.'",
        "predict": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.'",
        "hardness": "easy"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT stu_fname ,  stu_gpa FROM student WHERE stu_gpa  <  (SELECT avg(stu_gpa) FROM student)",
        "question": "Find the first name and gpa of the students whose gpa is lower than the average gpa of all students.",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average gpa of all students. Secondly, we need to filter students whose gpa is lower than the average gpa and select their first name and gpa.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select gpa from table 'STUDENT' and calculate the average. Then, we need to filter gpa, first name from table 'STUDENT'.\n\n<3> SQL Generation: Use 'select avg(gpa)' to calculate the average gpa of all students. Then, use 'where' to filter students whose gpa is lower than the average gpa and select their first name and gpa.\n\nSQL query: SELECT stu_fname ,  stu_gpa FROM student WHERE stu_gpa  <  (SELECT avg(stu_gpa) FROM student)",
        "predict": "SELECT stu_fname ,  stu_gpa FROM student WHERE stu_gpa  <  (SELECT avg(stu_gpa) FROM student)",
        "hardness": "extra"
    },
    {
        "db_id": "college_1",
        "gold": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'",
        "question": "Find the name of department that offers the class whose description has the word \"Statistics\".",
        "fields": "Table CLASS, columns = [*,CLASS_CODE,CRS_CODE,CLASS_SECTION,CLASS_TIME,CLASS_ROOM,PROF_NUM]\nTable COURSE, columns = [*,CRS_CODE,DEPT_CODE,CRS_DESCRIPTION,CRS_CREDIT]\nTable DEPARTMENT, columns = [*,DEPT_CODE,DEPT_NAME,SCHOOL_CODE,EMP_NUM,DEPT_ADDRESS,DEPT_EXTENSION]\nTable EMPLOYEE, columns = [*,EMP_NUM,EMP_LNAME,EMP_FNAME,EMP_INITIAL,EMP_JOBCODE,EMP_HIREDATE,EMP_DOB]\nTable ENROLL, columns = [*,CLASS_CODE,STU_NUM,ENROLL_GRADE]\nTable PROFESSOR, columns = [*,EMP_NUM,DEPT_CODE,PROF_OFFICE,PROF_EXTENSION,PROF_HIGH_DEGREE]\nTable STUDENT, columns = [*,STU_NUM,STU_LNAME,STU_FNAME,STU_INIT,STU_DOB,STU_HRS,STU_CLASS,STU_GPA,STU_TRANSFER,DEPT_CODE,STU_PHONE,PROF_NUM]\n",
        "foreign_keys": "Foreign_keys = [CLASS.PROF_NUM = EMPLOYEE.EMP_NUM,CLASS.CRS_CODE = COURSE.CRS_CODE,COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE,DEPARTMENT.EMP_NUM = EMPLOYEE.EMP_NUM,ENROLL.STU_NUM = STUDENT.STU_NUM,ENROLL.CLASS_CODE = CLASS.CLASS_CODE,PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE,PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM,STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the class with the description containing the word \"Statistics\". Secondly, we need to find the department that offers this class.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CRS_CODE from table 'COURSE' where CRS_DESCRIPTION contains the word \"Statistics\". In the second step, we need to select DEPT_NAME from table 'DEPARTMENT' where DEPT_CODE matches the DEPT_CODE of the selected class.\n\n<3> SQL Generation: Use 'where' to find the class with the description containing the word \"Statistics\", and then use 'where' to find the department that offers this class.\n\nSQL query: SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'",
        "predict": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'",
        "hardness": "hard"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != \"null\" OR  department_id != 40",
        "question": "display all the information of employees whose salary is in the range of 8000 and 12000 and commission is not null or department number does not equal to 40.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter employees based on their salary range and commission. Secondly, we need to filter employees based on their department number.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select all columns from table 'employees' and filter based on salary and commission. We also need to filter based on department number from table 'departments'.\n\n<3> SQL Generation: Use 'where' to filter employees based on their salary range and commission, and use 'or' to filter employees based on their department number.\n\nSQL query: SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != \"null\" OR  department_id != 40",
        "predict": "SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != \"null\" OR  department_id != 40",
        "hardness": "medium"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT salary ,  manager_id FROM employees WHERE manager_id != \"null\"",
        "question": "What are the salaries and manager ids for employees who have managers?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: The query requires retrieving salaries and manager ids for employees who have managers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select salaries and manager ids from the 'employees' table.\n\n<3> SQL Generation: Use 'where' to filter employees who have managers and select their salaries and manager ids.\n\nSQL query: SELECT salary ,  manager_id FROM employees WHERE manager_id != \"null\"",
        "predict": "SELECT salary ,  manager_id FROM employees WHERE manager_id != \"null\"",
        "hardness": "medium"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000",
        "question": "What is all the job history info done by employees earning a salary greater than or equal to 12000?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter employees based on their salary being greater than or equal to 12000. Secondly, we need to retrieve the job history information for these employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select job history information from table 'job_history' and filter employees based on their salary from table 'employees'.\n\n<3> SQL Generation: Use 'where' to filter employees with salary greater than or equal to 12000, and then join the 'job_history' table on the 'EMPLOYEE_ID' column to retrieve the job history information for these employees.\n\nSQL query: SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000",
        "predict": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000",
        "hardness": "medium"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)",
        "question": "Find the employee id for all employees who earn more than the average salary.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average salary. Secondly, we need to filter employees based on their salary being higher than the average salary.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'employees' table for this query, we don't need to consider any foreign key relationships.\n\n<3> SQL Generation: Use 'select' to calculate the average salary from the 'employees' table. Then, use 'where' to filter employees whose salary is higher than the average salary.\n\nSQL query: SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)",
        "predict": "SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)",
        "hardness": "hard"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "question": "display all the information of those employees who did not have any job in the past.",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find employees who did not have any job in the past. Secondly, we need to display all the information of those employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select employee_id from table 'job_history'. In the second step, we need to select all columns from table 'employees'.\n\n<3> SQL Generation: Use 'not in' to find employees who did not have any job in the past, and then select all columns from table 'employees'.\n\nSQL query: SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "predict": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "hardness": "hard"
    },
    {
        "db_id": "hr_1",
        "gold": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "question": "What is all the information about employees who have never had a job in the past?",
        "fields": "Table countries, columns = [*,COUNTRY_ID,COUNTRY_NAME,REGION_ID]\nTable departments, columns = [*,DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID]\nTable employees, columns = [*,EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID]\nTable job_history, columns = [*,EMPLOYEE_ID,START_DATE,END_DATE,JOB_ID,DEPARTMENT_ID]\nTable jobs, columns = [*,JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY]\nTable locations, columns = [*,LOCATION_ID,STREET_ADDRESS,POSTAL_CODE,CITY,STATE_PROVINCE,COUNTRY_ID]\nTable regions, columns = [*,REGION_ID,REGION_NAME]\n",
        "foreign_keys": "Foreign_keys = [countries.REGION_ID = regions.REGION_ID,employees.JOB_ID = jobs.JOB_ID,employees.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.JOB_ID = jobs.JOB_ID,job_history.DEPARTMENT_ID = departments.DEPARTMENT_ID,job_history.EMPLOYEE_ID = employees.EMPLOYEE_ID,locations.COUNTRY_ID = countries.COUNTRY_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find employees who have never had a job in the past. Secondly, we need to retrieve all the information about those employees.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select all columns from table 'employees' and filter by employees who do not have any records in table 'job_history'.\n\n<3> SQL Generation: Use 'where' to filter employees who do not have any records in table 'job_history' and select all columns from table 'employees'.\n\nSQL query: SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "predict": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)",
        "hardness": "hard"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT DISTINCT T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.resolution  <  800",
        "question": "What are the file sizes and formats for all songs with a resolution lower than 800?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter songs based on their resolution being lower than 800. Secondly, we need to select the file sizes and formats for the filtered songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select file_size and formats from table 'files' for the filtered songs.\n\n<3> SQL Generation: Use 'where' to filter songs with resolution lower than 800, and then select file_size and formats from table 'files' for the filtered songs.\n\nSQL query: SELECT DISTINCT T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.resolution  <  800",
        "predict": "SELECT DISTINCT T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.resolution  <  800",
        "hardness": "medium"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT count(*) FROM artist WHERE country  =  \"Bangladesh\"",
        "question": "How many Bangladeshi artists are listed?",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: We need to filter artists based on their country being Bangladesh.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'artist' table.\n\n<3> SQL Generation: Use 'where' to filter artists with country = 'Bangladesh' and count them.\n\nSQL query: SELECT count(*) FROM artist WHERE country  =  \"Bangladesh\"",
        "predict": "SELECT count(*) FROM artist WHERE country  =  \"Bangladesh\"",
        "hardness": "easy"
    },
    {
        "db_id": "music_1",
        "gold": "SELECT g_name ,  rating FROM genre ORDER BY g_name",
        "question": "List the names of all genres in alphabetical oder, together with its ratings.",
        "fields": "Table artist, columns = [*,artist_name,country,gender,preferred_genre]\nTable files, columns = [*,f_id,artist_name,file_size,duration,formats]\nTable genre, columns = [*,g_name,rating,most_popular_in]\nTable song, columns = [*,song_name,artist_name,country,f_id,genre_is,rating,languages,releasedate,resolution]\n",
        "foreign_keys": "Foreign_keys = [artist.preferred_genre = genre.g_name,files.artist_name = artist.artist_name,song.genre_is = genre.g_name,song.f_id = files.f_id,song.artist_name = artist.artist_name]\n",
        "reasoning": "<1> Decomposition: We need to select the names and ratings of all genres.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'genre' table.\n\n<3> SQL Generation: We can directly select the 'g_name' and 'rating' columns from the 'genre' table and order them by 'g_name' in alphabetical order.\n\nSQL query: SELECT g_name ,  rating FROM genre ORDER BY g_name",
        "predict": "SELECT g_name ,  rating FROM genre ORDER BY g_name",
        "hardness": "medium"
    },
    {
        "db_id": "baseball_1",
        "gold": "SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;",
        "question": "Compute the total salary that the player with first name Len and last name Barker received between 1985 to 1990.",
        "fields": "Table all_star, columns = [*,player_id,year,game_num,game_id,team_id,league_id,gp,starting_pos]\nTable appearances, columns = [*,year,team_id,league_id,player_id,g_all,gs,g_batting,g_defense,g_p,g_c,g_1b,g_2b,g_3b,g_ss,g_lf,g_cf,g_rf,g_of,g_dh,g_ph,g_pr]\nTable batting, columns = [*,player_id,year,stint,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable batting_postseason, columns = [*,year,round,player_id,team_id,league_id,g,ab,r,h,double,triple,hr,rbi,sb,cs,bb,so,ibb,hbp,sh,sf,g_idp]\nTable college, columns = [*,college_id,name_full,city,state,country]\nTable fielding, columns = [*,player_id,year,stint,team_id,league_id,pos,g,gs,inn_outs,po,a,e,dp,pb,wp,sb,cs,zr]\nTable fielding_outfield, columns = [*,player_id,year,stint,glf,gcf,grf]\nTable fielding_postseason, columns = [*,player_id,year,team_id,league_id,round,pos,g,gs,inn_outs,po,a,e,dp,tp,pb,sb,cs]\nTable hall_of_fame, columns = [*,player_id,yearid,votedby,ballots,needed,votes,inducted,category,needed_note]\nTable home_game, columns = [*,year,league_id,team_id,park_id,span_first,span_last,games,openings,attendance]\nTable manager, columns = [*,player_id,year,team_id,league_id,inseason,g,w,l,rank,plyr_mgr]\nTable manager_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable manager_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable manager_half, columns = [*,player_id,year,team_id,league_id,inseason,half,g,w,l,rank]\nTable park, columns = [*,park_id,park_name,park_alias,city,state,country]\nTable pitching, columns = [*,player_id,year,stint,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable pitching_postseason, columns = [*,player_id,year,round,team_id,league_id,w,l,g,gs,cg,sho,sv,ipouts,h,er,hr,bb,so,baopp,era,ibb,wp,hbp,bk,bfp,gf,r,sh,sf,g_idp]\nTable player, columns = [*,player_id,birth_year,birth_month,birth_day,birth_country,birth_state,birth_city,death_year,death_month,death_day,death_country,death_state,death_city,name_first,name_last,name_given,weight,height,bats,throws,debut,final_game,retro_id,bbref_id]\nTable player_award, columns = [*,player_id,award_id,year,league_id,tie,notes]\nTable player_award_vote, columns = [*,award_id,year,league_id,player_id,points_won,points_max,votes_first]\nTable player_college, columns = [*,player_id,college_id,year]\nTable postseason, columns = [*,year,round,team_id_winner,league_id_winner,team_id_loser,league_id_loser,wins,losses,ties]\nTable salary, columns = [*,year,team_id,league_id,player_id,salary]\nTable team, columns = [*,year,league_id,team_id,franchise_id,div_id,rank,g,ghome,w,l,div_win,wc_win,lg_win,ws_win,r,ab,h,double,triple,hr,bb,so,sb,cs,hbp,sf,ra,er,era,cg,sho,sv,ipouts,ha,hra,bba,soa,e,dp,fp,name,park,attendance,bpf,ppf,team_id_br,team_id_lahman45,team_id_retro]\nTable team_franchise, columns = [*,franchise_id,franchise_name,active,na_assoc]\nTable team_half, columns = [*,year,league_id,team_id,half,div_id,div_win,rank,g,w,l]\n",
        "foreign_keys": "Foreign_keys = [all_star.player_id = player.player_id,appearances.player_id = player.player_id,appearances.team_id = team.team_id,manager_award.player_id = player.player_id,player_award.player_id = player.player_id,player_award_vote.player_id = player.player_id,batting.player_id = player.player_id,batting_postseason.team_id = team.team_id,batting_postseason.player_id = player.player_id,player_college.college_id = college.college_id,player_college.player_id = player.player_id,fielding.player_id = player.player_id,fielding_outfield.player_id = player.player_id,fielding_postseason.player_id = player.player_id,hall_of_fame.player_id = player.player_id,home_game.park_id = park.park_id,home_game.team_id = team.team_id,manager.team_id = team.team_id,manager_half.team_id = team.team_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the player with first name Len and last name Barker. Secondly, we need to filter the salary of the player between 1985 to 1990 and compute the total.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select player_id from table 'player' where name_first = 'Len' and name_last = 'Barker'. In the second step, we need to filter salary from table 'salary' where player_id matches the player found in the first step and the year is between 1985 to 1990.\n\n<3> SQL Generation: Use 'where' to find the player with first name Len and last name Barker, and then use 'where' to filter the salary of the player between 1985 to 1990. Finally, compute the total salary.\n\nSQL query: SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;",
        "predict": "SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;",
        "hardness": "medium"
    },
    {
        "db_id": "mountain_photos",
        "gold": "SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos )",
        "question": "How many camera lenses are not used in taking any photos?",
        "fields": "Table camera_lens, columns = [*,id,brand,name,focal_length_mm,max_aperture]\nTable mountain, columns = [*,id,name,Height,Prominence,Range,Country]\nTable photos, columns = [*,id,camera_lens_id,mountain_id,color,name]\n",
        "foreign_keys": "Foreign_keys = [photos.mountain_id = mountain.id,photos.camera_lens_id = camera_lens.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the camera lenses that are not used in taking any photos. Secondly, we need to count the number of camera lenses found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'camera_lens' that do not have a corresponding entry in the 'camera_lens_id' column of table 'photos'. \n\n<3> SQL Generation: Use 'where' and 'not in' to find the camera lenses that are not used in taking any photos, and then use 'count' to count the number of camera lenses found.\n\nSQL query: SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos )",
        "predict": "SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos )",
        "hardness": "extra"
    },
    {
        "db_id": "mountain_photos",
        "gold": "SELECT count(DISTINCT T2.camera_lens_id) FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.country  =  'Ethiopia'",
        "question": "How many distinct kinds of camera lenses are used to take photos of mountains in the country 'Ethiopia'?",
        "fields": "Table camera_lens, columns = [*,id,brand,name,focal_length_mm,max_aperture]\nTable mountain, columns = [*,id,name,Height,Prominence,Range,Country]\nTable photos, columns = [*,id,camera_lens_id,mountain_id,color,name]\n",
        "foreign_keys": "Foreign_keys = [photos.mountain_id = mountain.id,photos.camera_lens_id = camera_lens.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter mountains based on the country 'Ethiopia'. Secondly, we need to find the distinct camera lenses used to take photos of these mountains and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select id from table 'mountain' where country = 'Ethiopia'. In the second step, we need to join table 'photos' and 'camera_lens' on the 'mountain_id' and 'camera_lens_id' columns, and then select distinct camera_lens_id.\n\n<3> SQL Generation: Use 'where' to filter mountains in Ethiopia, join 'photos' and 'camera_lens' tables on the corresponding columns, select distinct camera_lens_id, and count them.\n\nSQL query: SELECT count(DISTINCT T2.camera_lens_id) FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.country  =  'Ethiopia'",
        "predict": "SELECT count(DISTINCT T2.camera_lens_id) FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.country  =  'Ethiopia'",
        "hardness": "medium"
    },
    {
        "db_id": "program_share",
        "gold": "SELECT name FROM program WHERE origin != 'Beijing'",
        "question": "Which programs' origins are not \"Beijing\"? Give me the program names.",
        "fields": "Table broadcast, columns = [*,Channel_ID,Program_ID,Time_of_day]\nTable broadcast_share, columns = [*,Channel_ID,Program_ID,Date,Share_in_percent]\nTable channel, columns = [*,Channel_ID,Name,Owner,Share_in_percent,Rating_in_percent]\nTable program, columns = [*,Program_ID,Name,Origin,Launch,Owner]\n",
        "foreign_keys": "Foreign_keys = [broadcast.Program_ID = program.Program_ID,broadcast.Channel_ID = channel.Channel_ID,broadcast_share.Program_ID = program.Program_ID,broadcast_share.Channel_ID = channel.Channel_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on programs whose origins are not \"Beijing\". We need to select the program names that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'program' table for this query.\n\n<3> SQL Generation: Use 'where' to filter programs whose origins are not \"Beijing\" and select the program names.\n\nSQL query: SELECT name FROM program WHERE origin != 'Beijing'",
        "predict": "SELECT name FROM program WHERE origin != 'Beijing'",
        "hardness": "easy"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name =  \"Cathrine\"",
        "question": "Return the addresses of the course authors or tutors whose personal name is \"Cathrine\".",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the personal name column in the Course_Authors_and_Tutors table. We need to select the addresses of the course authors or tutors whose personal name is \"Cathrine\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the Course_Authors_and_Tutors table.\n\n<3> SQL Generation: Use 'where' to filter the rows where the personal name is \"Cathrine\" and select the corresponding addresses.\n\nSQL query: SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name =  \"Cathrine\"",
        "predict": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name =  \"Cathrine\"",
        "hardness": "easy"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT count(*) FROM Student_Tests_Taken WHERE test_result  =  \"Fail\"",
        "question": "How many tests have result \"Fail\"?",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of tests with a result of \"Fail\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the test_result column from the Student_Tests_Taken table.\n\n<3> SQL Generation: Use 'where' to filter tests with a result of \"Fail\" and count them.\n\nSQL query: SELECT count(*) FROM Student_Tests_Taken WHERE test_result  =  \"Fail\"",
        "predict": "SELECT count(*) FROM Student_Tests_Taken WHERE test_result  =  \"Fail\"",
        "hardness": "easy"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT T1.login_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  \"advanced database\"",
        "question": "Find the login name of the course author that teaches the course with name \"advanced database\".",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the course_id of the course with name \"advanced database\". Secondly, we need to find the author_id of the course author that teaches this course. Finally, we need to find the login name of the course author.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'Courses' where course_name = \"advanced database\". In the second step, we need to select author_id from table 'Courses' where course_id matches the course_id found in the first step. In the final step, we need to select login_name from table 'Course_Authors_and_Tutors' where author_id matches the author_id found in the second step.\n\n<3> SQL Generation: Use 'where' to find the course_id of the course with name \"advanced database\", and then use 'where' to find the author_id of the course author that teaches this course. Finally, use 'where' to find the login name of the course author.\n\nSQL query: SELECT T1.login_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  \"advanced database\"",
        "predict": "SELECT T1.login_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  \"advanced database\"",
        "hardness": "medium"
    },
    {
        "db_id": "e_learning",
        "gold": "SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)",
        "question": "How many students did not have any course enrollment?",
        "fields": "Table Course_Authors_and_Tutors, columns = [*,author_id,author_tutor_ATB,login_name,password,personal_name,middle_name,family_name,gender_mf,address_line_1]\nTable Courses, columns = [*,course_id,author_id,subject_id,course_name,course_description]\nTable Student_Course_Enrolment, columns = [*,registration_id,student_id,course_id,date_of_enrolment,date_of_completion]\nTable Student_Tests_Taken, columns = [*,registration_id,date_test_taken,test_result]\nTable Students, columns = [*,student_id,date_of_registration,date_of_latest_logon,login_name,password,personal_name,middle_name,family_name]\nTable Subjects, columns = [*,subject_id,subject_name]\n",
        "foreign_keys": "Foreign_keys = [Courses.subject_id = Subjects.subject_id,Courses.author_id = Course_Authors_and_Tutors.author_id,Student_Course_Enrolment.student_id = Students.student_id,Student_Course_Enrolment.course_id = Courses.course_id,Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding students who did not have any course enrollment. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select student_id from the 'Students' table and check if there are any corresponding entries in the 'Student_Course_Enrolment' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Students' table with the 'Student_Course_Enrolment' table on the 'student_id' column. Then, we can filter the rows where the 'course_id' is null (indicating no course enrollment) and count the number of students.\n\nSQL query: SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)",
        "predict": "SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)",
        "hardness": "extra"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT DISTINCT T1.name ,  T1.position FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.Brand  =  \"X\"",
        "question": "Which physicians prescribe a medication of brand X? Tell me the name and position of those physicians.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the physicians who prescribe a medication of brand X. Secondly, we need to retrieve the name and position of those physicians.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select physicians from table 'Physician' who prescribe a medication of brand X from table 'Prescribes'. We also need to retrieve the name and position of those physicians.\n\n<3> SQL Generation: Use 'where' to filter physicians who prescribe a medication of brand X, and then select the name and position of those physicians.\n\nSQL query: SELECT DISTINCT T1.name ,  T1.position FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.Brand  =  \"X\"",
        "predict": "SELECT DISTINCT T1.name ,  T1.position FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.Brand  =  \"X\"",
        "hardness": "hard"
    },
    {
        "db_id": "hospital_1",
        "gold": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1",
        "question": "List the names of departments where some physicians are primarily affiliated with.",
        "fields": "Table Affiliated_With, columns = [*,Physician,Department,PrimaryAffiliation]\nTable Appointment, columns = [*,AppointmentID,Patient,PrepNurse,Physician,Start,End,ExaminationRoom]\nTable Block, columns = [*,BlockFloor,BlockCode]\nTable Department, columns = [*,DepartmentID,Name,Head]\nTable Medication, columns = [*,Code,Name,Brand,Description]\nTable Nurse, columns = [*,EmployeeID,Name,Position,Registered,SSN]\nTable On_Call, columns = [*,Nurse,BlockFloor,BlockCode,OnCallStart,OnCallEnd]\nTable Patient, columns = [*,SSN,Name,Address,Phone,InsuranceID,PCP]\nTable Physician, columns = [*,EmployeeID,Name,Position,SSN]\nTable Prescribes, columns = [*,Physician,Patient,Medication,Date,Appointment,Dose]\nTable Procedures, columns = [*,Code,Name,Cost]\nTable Room, columns = [*,RoomNumber,RoomType,BlockFloor,BlockCode,Unavailable]\nTable Stay, columns = [*,StayID,Patient,Room,StayStart,StayEnd]\nTable Trained_In, columns = [*,Physician,Treatment,CertificationDate,CertificationExpires]\nTable Undergoes, columns = [*,Patient,Procedures,Stay,DateUndergoes,Physician,AssistingNurse]\n",
        "foreign_keys": "Foreign_keys = [Department.Head = Physician.EmployeeID,Affiliated_With.Department = Department.DepartmentID,Affiliated_With.Physician = Physician.EmployeeID,Trained_In.Treatment = Procedures.Code,Trained_In.Physician = Physician.EmployeeID,Patient.PCP = Physician.EmployeeID,Appointment.Physician = Physician.EmployeeID,Appointment.PrepNurse = Nurse.EmployeeID,Appointment.Patient = Patient.SSN,Prescribes.Appointment = Appointment.AppointmentID,Prescribes.Medication = Medication.Code,Prescribes.Patient = Patient.SSN,Prescribes.Physician = Physician.EmployeeID,Room.BlockFloor = Block.BlockFloor,Room.BlockCode = Block.BlockCode,On_Call.BlockFloor = Block.BlockFloor,On_Call.BlockCode = Block.BlockCode,On_Call.Nurse = Nurse.EmployeeID,Stay.Room = Room.RoomNumber,Stay.Patient = Patient.SSN,Undergoes.AssistingNurse = Nurse.EmployeeID,Undergoes.Physician = Physician.EmployeeID,Undergoes.Stay = Stay.StayID,Undergoes.Procedures = Procedures.Code,Undergoes.Patient = Patient.SSN]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the physicians who are primarily affiliated with some departments. Secondly, we need to list the names of those departments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select distinct Department from table 'Affiliated_With' where PrimaryAffiliation is not null. In the second step, we need to select Name from table 'Department' where DepartmentID matches the departments found in the first step.\n\n<3> SQL Generation: Use 'where' to filter the physicians who are primarily affiliated with some departments, and then use 'distinct' to select the departments. Finally, join the 'Department' table to get the names of those departments.\n\nSQL query: SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1",
        "predict": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1",
        "hardness": "medium"
    },
    {
        "db_id": "ship_mission",
        "gold": "SELECT Name FROM ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM mission)",
        "question": "What are the names of the ships that are not involved in any missions?",
        "fields": "Table mission, columns = [*,Mission_ID,Ship_ID,Code,Launched_Year,Location,Speed_knots,Fate]\nTable ship, columns = [*,Ship_ID,Name,Type,Nationality,Tonnage]\n",
        "foreign_keys": "Foreign_keys = [mission.Ship_ID = ship.Ship_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding ships that are not involved in any missions. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find ships that are not involved in any missions, we only need the 'ship' table.\n\n<3> SQL Generation: We can use a 'left join' to join the 'ship' table with the 'mission' table on the 'Ship_ID' column. Then, we can filter the rows where the 'Mission_ID' is null, indicating that the ship is not involved in any missions. Finally, we can select the 'Name' column from the resulting rows.\n\nSQL query: SELECT Name FROM ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM mission)",
        "predict": "SELECT Name FROM ship WHERE Ship_ID NOT IN (SELECT Ship_ID FROM mission)",
        "hardness": "hard"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "question": "Which students study under the teacher named OTHA MOYER? Give me the first and last names of the students.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name 'OTHA MOYER'. Secondly, we need to find the students who study under that teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no explicit foreign key relationship mentioned in the given information, we can assume that the 'Classroom' column in both tables can be used to link the tables.\n\n<3> SQL Generation: Use 'where' to find the teacher with the name 'OTHA MOYER', and then use 'where' to filter the students who study under that teacher and select their first and last names.\n\nSQL query: SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "predict": "SELECT T1.firstname ,  T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"OTHA\" AND T2.lastname  =  \"MOYER\"",
        "hardness": "extra"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT T2.firstname ,  T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"EVELINA\" AND T1.lastname  =  \"BROMLEY\"",
        "question": "Find the first and last name of all the teachers that teach EVELINA BROMLEY.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name 'EVELINA BROMLEY'. Secondly, we need to select the first and last name of the teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no foreign key relationship mentioned in the question, we only need the 'teachers' table.\n\n<3> SQL Generation: Use 'where' to filter the teacher with the name 'EVELINA BROMLEY', and then select the first and last name of the teacher.\n\nSQL query: SELECT T2.firstname ,  T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"EVELINA\" AND T1.lastname  =  \"BROMLEY\"",
        "predict": "SELECT T2.firstname ,  T2.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"EVELINA\" AND T1.lastname  =  \"BROMLEY\"",
        "hardness": "extra"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"LORIA\" AND T2.lastname  =  \"ONDERSMA\"",
        "question": "Count the number of students the teacher LORIA ONDERSMA teaches.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of students taught by a specific teacher. Firstly, we need to identify the teacher with the name \"LORIA ONDERSMA\". Secondly, we need to count the number of students in the teacher's classroom.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the teacher's name is in the 'teachers' table and the classroom information is in the 'list' table, we need to use both tables.\n\n<3> SQL Generation: Use 'where' to filter the teacher with the name \"LORIA ONDERSMA\" in the 'teachers' table. Then, join the 'teachers' and 'list' tables on the 'Classroom' column and count the number of students in the teacher's classroom.\n\nSQL query: SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"LORIA\" AND T2.lastname  =  \"ONDERSMA\"",
        "predict": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"LORIA\" AND T2.lastname  =  \"ONDERSMA\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"KAWA\" AND T2.lastname  =  \"GORDON\"",
        "question": "How many students does KAWA GORDON teaches?",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name \"KAWA GORDON\". Secondly, we need to count the number of students taught by that teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have the 'teachers' table, we need to select the rows where the 'LastName' is \"KAWA\" and the 'FirstName' is \"GORDON\".\n\n<3> SQL Generation: Use 'where' to filter the rows where 'LastName' is \"KAWA\" and 'FirstName' is \"GORDON\", and then count the number of rows.\n\nSQL query: SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"KAWA\" AND T2.lastname  =  \"GORDON\"",
        "predict": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"KAWA\" AND T2.lastname  =  \"GORDON\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"TARRING\" AND T2.lastname  =  \"LEIA\"",
        "question": "Find the number of students taught by TARRING LEIA.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the teacher with the name 'TARRING LEIA'. Secondly, we need to count the number of students taught by that teacher.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the teacher's information from table 'teachers' where the first name is 'LEIA' and the last name is 'TARRING'. In the second step, we need to count the number of students from table 'list' where the classroom matches the classroom of the teacher found in the first step.\n\n<3> SQL Generation: Use 'where' to find the teacher with the name 'TARRING LEIA', and then use 'where' to filter students based on the teacher's classroom and count them.\n\nSQL query: SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"TARRING\" AND T2.lastname  =  \"LEIA\"",
        "predict": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T2.firstname  =  \"TARRING\" AND T2.lastname  =  \"LEIA\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "question": "How many teachers does the student named MADLOCK RAY have?",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name \"MADLOCK RAY\". Secondly, we need to count the number of teachers in the same classroom as the student.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no explicit foreign key relationship mentioned in the question, we can assume that the classroom column in both tables can be used to link the student and teacher.\n\n<3> SQL Generation: Use 'where' to find the student with the name \"MADLOCK RAY\", and then use 'where' to filter teachers in the same classroom and count them.\n\nSQL query: SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "predict": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "question": "Find the number of teachers who teach the student called MADLOCK RAY.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name 'MADLOCK RAY'. Secondly, we need to find the teachers who teach this student.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the student with the name 'MADLOCK RAY' from table 'list'. Then, we need to find the teachers who teach this student by matching the classroom.\n\n<3> SQL Generation: Use 'where' to find the student with the name 'MADLOCK RAY' and select the corresponding classroom. Then, use 'where' to find the teachers who teach this student by matching the classroom.\n\nSQL query: SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "predict": "SELECT count(*) FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.firstname  =  \"MADLOCK\" AND T1.lastname  =  \"RAY\"",
        "hardness": "medium"
    },
    {
        "db_id": "student_1",
        "gold": "SELECT DISTINCT T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.grade  =  3 AND T2.firstname != \"COVIN\" AND T2.lastname != \"JEROME\"",
        "question": "Find the last names of the students in third grade that are not taught by COVIN JEROME.",
        "fields": "Table list, columns = [*,LastName,FirstName,Grade,Classroom]\nTable teachers, columns = [*,LastName,FirstName,Classroom]\n",
        "foreign_keys": "Foreign_keys = ]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students in third grade. Secondly, we need to filter out the students taught by COVIN JEROME. Finally, we need to select the last names of the remaining students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since there is no explicit foreign key relationship mentioned in the question, we only need the 'list' table.\n\n<3> SQL Generation: Use 'where' to filter students in third grade and not taught by COVIN JEROME, and then select their last names.\n\nSQL query: SELECT DISTINCT T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.grade  =  3 AND T2.firstname != \"COVIN\" AND T2.lastname != \"JEROME\"",
        "predict": "SELECT DISTINCT T1.lastname FROM list AS T1 JOIN teachers AS T2 ON T1.classroom  =  T2.classroom WHERE T1.grade  =  3 AND T2.firstname != \"COVIN\" AND T2.lastname != \"JEROME\"",
        "hardness": "medium"
    },
    {
        "db_id": "company_employee",
        "gold": "SELECT count(*) FROM company WHERE Headquarters  =  'USA'",
        "question": "How many companies are headquartered in the US?",
        "fields": "Table company, columns = [*,Company_ID,Name,Headquarters,Industry,Sales_in_Billion,Profits_in_Billion,Assets_in_Billion,Market_Value_in_Billion]\nTable employment, columns = [*,Company_ID,People_ID,Year_working]\nTable people, columns = [*,People_ID,Age,Name,Nationality,Graduation_College]\n",
        "foreign_keys": "Foreign_keys = [employment.People_ID = people.People_ID,employment.Company_ID = company.Company_ID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of companies that are headquartered in the US.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information about the companies, we only need the 'company' table.\n\n<3> SQL Generation: Use 'where' to filter companies that are headquartered in the US, and then use 'count' to calculate the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM company WHERE Headquarters  =  'USA'",
        "predict": "SELECT count(*) FROM company WHERE Headquarters  =  'USA'",
        "hardness": "easy"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT TYPE FROM film_market_estimation WHERE YEAR  =  1995",
        "question": "Return the types of film market estimations in 1995.",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the year 1995, so we should apply the 'where' to column 'Year' and then return the types of film market estimations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'film_market_estimation' has column 'Type', we only need table 'film_market_estimation'.\n\n<3> SQL Generation: Directly write the sql using 'where'.\n\nSQL query: SELECT TYPE FROM film_market_estimation WHERE YEAR  =  1995",
        "predict": "SELECT TYPE FROM film_market_estimation WHERE YEAR  =  1995",
        "hardness": "easy"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000",
        "question": "What is the average number of cities of markets with low film market estimate bigger than 10000?",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter markets with low film market estimate bigger than 10000. Secondly, we need to calculate the average number of cities for these markets.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Market_ID from table 'film_market_estimation' where Low_Estimate > 10000. In the second step, we need to select Number_cities from table 'market' and calculate the average.\n\n<3> SQL Generation: Use 'where' to filter markets with low film market estimate bigger than 10000, and then use 'avg' to calculate the average number of cities.\n\nSQL query: SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000",
        "predict": "SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000",
        "hardness": "medium"
    },
    {
        "db_id": "film_rank",
        "gold": "SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)",
        "question": "What are the titles of films that do not have a film market estimation?",
        "fields": "Table film, columns = [*,Film_ID,Title,Studio,Director,Gross_in_dollar]\nTable film_market_estimation, columns = [*,Estimation_ID,Low_Estimate,High_Estimate,Film_ID,Type,Market_ID,Year]\nTable market, columns = [*,Market_ID,Country,Number_cities]\n",
        "foreign_keys": "Foreign_keys = [film_market_estimation.Market_ID = market.Market_ID,film_market_estimation.Film_ID = film.Film_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding films that do not have a film market estimation. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is about films and film market estimations, we need to use the tables 'film' and 'film_market_estimation'.\n\n<3> SQL Generation: We can use a left join to combine the 'film' and 'film_market_estimation' tables, and then filter the rows where the estimation ID is null (indicating that there is no film market estimation). Finally, we select the titles of the films that meet this condition.\n\nSQL query: SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)",
        "predict": "SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)",
        "hardness": "hard"
    },
    {
        "db_id": "cre_Doc_Tracking_DB",
        "gold": "SELECT count(*) FROM All_documents WHERE document_type_code  =  \"CV\" OR document_type_code  =  \"BK\"",
        "question": "How many documents have document type code CV or BK?",
        "fields": "Table All_Documents, columns = [*,Document_ID,Date_Stored,Document_Type_Code,Document_Name,Document_Description,Other_Details]\nTable Document_Locations, columns = [*,Document_ID,Location_Code,Date_in_Location_From,Date_in_Locaton_To]\nTable Documents_to_be_Destroyed, columns = [*,Document_ID,Destruction_Authorised_by_Employee_ID,Destroyed_by_Employee_ID,Planned_Destruction_Date,Actual_Destruction_Date,Other_Details]\nTable Employees, columns = [*,Employee_ID,Role_Code,Employee_Name,Gender_MFU,Date_of_Birth,Other_Details]\nTable Ref_Calendar, columns = [*,Calendar_Date,Day_Number]\nTable Ref_Document_Types, columns = [*,Document_Type_Code,Document_Type_Name,Document_Type_Description]\nTable Ref_Locations, columns = [*,Location_Code,Location_Name,Location_Description]\nTable Roles, columns = [*,Role_Code,Role_Name,Role_Description]\n",
        "foreign_keys": "Foreign_keys = [All_Documents.Date_Stored = Ref_Calendar.Calendar_Date,All_Documents.Document_Type_Code = Ref_Document_Types.Document_Type_Code,Employees.Role_Code = Roles.Role_Code,Document_Locations.Document_ID = All_Documents.Document_ID,Document_Locations.Date_in_Locaton_To = Ref_Calendar.Calendar_Date,Document_Locations.Date_in_Location_From = Ref_Calendar.Calendar_Date,Document_Locations.Location_Code = Ref_Locations.Location_Code,Documents_to_be_Destroyed.Document_ID = All_Documents.Document_ID,Documents_to_be_Destroyed.Actual_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Planned_Destruction_Date = Ref_Calendar.Calendar_Date,Documents_to_be_Destroyed.Destruction_Authorised_by_Employee_ID = Employees.Employee_ID,Documents_to_be_Destroyed.Destroyed_by_Employee_ID = Employees.Employee_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter documents based on their document type code, selecting documents with document type code 'CV' or 'BK'. Secondly, we need to count the number of selected documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter documents based on their document type code, we only need the 'All_Documents' table.\n\n<3> SQL Generation: Use 'where' to filter documents with document type code 'CV' or 'BK', and then use 'count' to count the number of selected documents.\n\nSQL query: SELECT count(*) FROM All_documents WHERE document_type_code  =  \"CV\" OR document_type_code  =  \"BK\"",
        "predict": "SELECT count(*) FROM All_documents WHERE document_type_code  =  \"CV\" OR document_type_code  =  \"BK\"",
        "hardness": "medium"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "question": "Find the number of members of club \"Pen and Paper Gaming\".",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Pen and Paper Gaming\". Secondly, we need to count the number of members in that club.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Pen and Paper Gaming\". In the second step, we need to count the number of rows in table 'Member_of_club' where ClubID matches the ClubID found in the first step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of the club \"Pen and Paper Gaming\", and then use 'count' to count the number of members in that club.\n\nSQL query: SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "question": "How many people have membership in the club \"Pen and Paper Gaming\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Pen and Paper Gaming\". Secondly, we need to count the number of people who have membership in that club.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Pen and Paper Gaming\". In the second step, we need to count the number of rows in table 'Member_of_club' where ClubID matches the ClubID found in the first step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of the club \"Pen and Paper Gaming\", and then use 'count' to count the number of rows in table 'Member_of_club' where ClubID matches the ClubID found in the first step.\n\nSQL query: SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Pen and Paper Gaming\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Linda\" AND t3.lname  =  \"Smith\"",
        "question": "How many clubs does \"Linda Smith\" belong to?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the StuID of \"Linda Smith\" in table 'Student'. Secondly, we need to count the number of clubs that Linda Smith belongs to based on her StuID in table 'Member_of_club'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to count the number of rows in table 'Member_of_club' where StuID matches the StuID of Linda Smith.\n\n<3> SQL Generation: Use 'where' to find the StuID of Linda Smith in table 'Student', and then use 'where' to count the number of rows in table 'Member_of_club' where StuID matches the StuID of Linda Smith.\n\nSQL query: SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Linda\" AND t3.lname  =  \"Smith\"",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  \"Linda\" AND t3.lname  =  \"Smith\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.sex  =  \"F\"",
        "question": "Find all the female members of club \"Bootup Baltimore\". Show the first name and last name.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Bootup Baltimore\". Secondly, we need to filter members based on their club and gender. Finally, we need to select the first name and last name of the female members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Bootup Baltimore\". In the second step, we need to filter StuID from table 'Member_of_club' where ClubID matches the value found in the first step. In the final step, we need to select Fname and LName from table 'Student' where StuID matches the values found in the second step and Sex is 'F'.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Bootup Baltimore\", then use 'where' to filter members based on their club and gender, and finally select the first name and last name of the female members.\n\nSQL query: SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.sex  =  \"F\"",
        "predict": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.sex  =  \"F\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t3.sex  =  \"M\"",
        "question": "What are the first name and last name of each male member in club \"Hopkins Student Enterprises\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter members based on their club name. Secondly, we need to select the first name and last name of male members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Hopkins Student Enterprises\". In the second step, we need to join table 'Member_of_club' and table 'Student' on StuID and filter by ClubID and Sex.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Hopkins Student Enterprises\", and then use 'join' to join 'Member_of_club' and 'Student' tables on StuID. Finally, filter by ClubID and Sex = 'M' and select the first name and last name.\n\nSQL query: SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t3.sex  =  \"M\"",
        "predict": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t3.sex  =  \"M\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT clublocation FROM club WHERE clubname  =  \"Pen and Paper Gaming\"",
        "question": "Where is the club \"Pen and Paper Gaming\" located?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires finding the location of the club \"Pen and Paper Gaming\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to find the location of the club, we only need the 'Club' table.\n\n<3> SQL Generation: Use 'where' to filter the club with the name \"Pen and Paper Gaming\" and select its location.\n\nSQL query: SELECT clublocation FROM club WHERE clubname  =  \"Pen and Paper Gaming\"",
        "predict": "SELECT clublocation FROM club WHERE clubname  =  \"Pen and Paper Gaming\"",
        "hardness": "easy"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "question": "Who is the \"CTO\" of club \"Hopkins Student Enterprises\"? Show the first name and last name.",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Hopkins Student Enterprises\". Secondly, we need to find the member of the club with the position \"CTO\" and retrieve their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Hopkins Student Enterprises\". In the second step, we need to select StuID from table 'Member_of_club' where ClubID matches the ClubID found in the first step and Position = \"CTO\". Finally, we need to retrieve the first name and last name of the student from table 'Student' using the StuID found in the second step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Hopkins Student Enterprises\", then use 'where' to find the StuID of the member with the position \"CTO\" in the club, and finally select the first name and last name of the student using the StuID.\n\nSQL query: SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "predict": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "question": "Find the first name and last name for the \"CTO\" of the club \"Hopkins Student Enterprises\"?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Hopkins Student Enterprises\". Secondly, we need to find the member of the club with the position \"CTO\" and retrieve their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Hopkins Student Enterprises\". In the second step, we need to select StuID from table 'Member_of_club' where ClubID matches the ClubID found in the first step and Position = \"CTO\". Finally, we need to retrieve the first name and last name from table 'Student' using the StuID found in the second step.\n\n<3> SQL Generation: Use 'where' to find the ClubID for the club \"Hopkins Student Enterprises\", and then use 'where' to find the StuID for the member with the position \"CTO\". Finally, join the 'Student' table to retrieve the first name and last name.\n\nSQL query: SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "predict": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Hopkins Student Enterprises\" AND t2.position  =  \"CTO\"",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  >  18",
        "question": "How many members of \"Bootup Baltimore\" are older than 18?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the club with the name \"Bootup Baltimore\". Secondly, we need to filter members of that club who are older than 18. Finally, we need to count the number of members who meet these criteria.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubName = \"Bootup Baltimore\". In the second step, we need to filter StuID from table 'Member_of_club' based on the ClubID obtained in the first step. In the third step, we need to filter Age from table 'Student' based on the StuID obtained in the second step.\n\n<3> SQL Generation: Use 'where' to find the ClubID of \"Bootup Baltimore\", then use 'where' to filter members of that club who are older than 18, and finally use 'count' to count the number of members who meet these criteria.\n\nSQL query: SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  >  18",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  >  18",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  <  18",
        "question": "How many members of club \"Bootup Baltimore\" are younger than 18?",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter members of club \"Bootup Baltimore\" from table 'Member_of_club'. Secondly, we need to filter members who are younger than 18 based on their age from table 'Student'. Finally, we count the number of selected members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'Member_of_club' and table 'Student' have direct foreign keys, so we need tables ['Member_of_club', 'Student'].\n\n<3> SQL Generation: We need to join the 'Member_of_club' and 'Student' tables on the 'StuID' column. Then, we filter the rows where 'ClubName' is 'Bootup Baltimore' and 'Age' is less than 18. Finally, we count the number of rows that meet these conditions.\n\nSQL query: SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  <  18",
        "predict": "SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  \"Bootup Baltimore\" AND t3.age  <  18",
        "hardness": "hard"
    },
    {
        "db_id": "club_1",
        "gold": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.city_code  =  \"BAL\"",
        "question": "Find the names of all the clubs that have at least a member from the city with city code \"BAL\".",
        "fields": "Table Club, columns = [*,ClubID,ClubName,ClubDesc,ClubLocation]\nTable Member_of_club, columns = [*,StuID,ClubID,Position]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of_club.ClubID = Club.ClubID,Member_of_club.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the city with city code \"BAL\". Secondly, we need to find the clubs that have at least one member from that city and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ClubID from table 'Club' where ClubLocation = \"BAL\". In the second step, we need to filter ClubID from table 'Member_of_club' and select the corresponding ClubName from table 'Club'.\n\n<3> SQL Generation: Use 'where' to find the ClubID of the clubs that have at least one member from the city with city code \"BAL\", and then use 'where' to filter the ClubName from table 'Club'.\n\nSQL query: SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.city_code  =  \"BAL\"",
        "predict": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.city_code  =  \"BAL\"",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_grants_for_research",
        "gold": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )",
        "question": "List the project details of the projects which did not hire any staff for a researcher role.",
        "fields": "Table Document_Types, columns = [*,document_type_code,document_description]\nTable Documents, columns = [*,document_id,document_type_code,grant_id,sent_date,response_received_date,other_details]\nTable Grants, columns = [*,grant_id,organisation_id,grant_amount,grant_start_date,grant_end_date,other_details]\nTable Organisation_Types, columns = [*,organisation_type,organisation_type_description]\nTable Organisations, columns = [*,organisation_id,organisation_type,organisation_details]\nTable Project_Outcomes, columns = [*,project_id,outcome_code,outcome_details]\nTable Project_Staff, columns = [*,staff_id,project_id,role_code,date_from,date_to,other_details]\nTable Projects, columns = [*,project_id,organisation_id,project_details]\nTable Research_Outcomes, columns = [*,outcome_code,outcome_description]\nTable Research_Staff, columns = [*,staff_id,employer_organisation_id,staff_details]\nTable Staff_Roles, columns = [*,role_code,role_description]\nTable Tasks, columns = [*,task_id,project_id,task_details,eg Agree Objectives]\n",
        "foreign_keys": "Foreign_keys = [Documents.grant_id = Grants.grant_id,Documents.document_type_code = Document_Types.document_type_code,Grants.organisation_id = Organisations.organisation_id,Organisations.organisation_type = Organisation_Types.organisation_type,Project_Outcomes.outcome_code = Research_Outcomes.outcome_code,Project_Outcomes.project_id = Projects.project_id,Project_Staff.role_code = Staff_Roles.role_code,Project_Staff.project_id = Projects.project_id,Projects.organisation_id = Organisations.organisation_id,Research_Staff.employer_organisation_id = Organisations.organisation_id,Tasks.project_id = Projects.project_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the projects that did not hire any staff for a researcher role. Secondly, we need to list the project details of those projects.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select project_id from table 'Projects' where there are no entries in table 'Project_Staff' with role_code = 'researcher' for that project_id. In the second step, we need to select project_details from table 'Projects' for the projects found in the first step.\n\n<3> SQL Generation: Use 'where not exists' to find the projects that did not hire any staff for a researcher role, and then select the project details for those projects.\n\nSQL query: SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )",
        "predict": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )",
        "hardness": "hard"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT count(*) FROM Person WHERE gender  =  'female'",
        "question": "How many females are in the network?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter the network based on gender, selecting only females. Secondly, we need to count the number of females in the network.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have one table 'Person' and the gender column is directly available in that table, we only need to use the 'Person' table.\n\n<3> SQL Generation: Use 'where' to filter the network based on gender, selecting only females. Then, use 'count' to count the number of females in the network.\n\nSQL query: SELECT count(*) FROM Person WHERE gender  =  'female'",
        "predict": "SELECT count(*) FROM Person WHERE gender  =  'female'",
        "hardness": "easy"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "question": "How old is the doctor named Zach?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: The query requires finding the age of a person named Zach who has the job title of doctor.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this case, we only need the 'Person' table.\n\n<3> SQL Generation: Use 'where' to filter the rows where the name is 'Zach' and the job is 'doctor', and then select the age.\n\nSQL query: SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "predict": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "hardness": "medium"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "question": "What is the age of the doctor named Zach?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: The query requires finding the age of a doctor named Zach.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires information from the 'Person' table, we only need to use that table.\n\n<3> SQL Generation: Use 'where' to filter the rows where the name is 'Zach' and the job is 'doctor', and then select the age.\n\nSQL query: SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "predict": "SELECT age FROM Person WHERE job  =  'doctor' AND name  =  'Zach'",
        "hardness": "medium"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT count(*) FROM Person WHERE age  >  30 AND job  =  'engineer'",
        "question": "HOw many engineers are older than 30?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter candidates based on their job and age. Secondly, we need to count the number of selected engineers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have one table 'Person' and the query does not require any additional information, we only need table 'Person'.\n\n<3> SQL Generation: Use 'where' to filter engineers with age greater than 30, and then use 'count' to calculate the number of selected engineers.\n\nSQL query: SELECT count(*) FROM Person WHERE age  >  30 AND job  =  'engineer'",
        "predict": "SELECT count(*) FROM Person WHERE age  >  30 AND job  =  'engineer'",
        "hardness": "medium"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "question": "Find the female friends of Alice.",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Alice. Secondly, we need to filter the friends who are female.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select friend from table 'PersonFriend' where name = 'Alice'. In the second step, we need to filter the selected friends by their gender from table 'Person'.\n\n<3> SQL Generation: Use 'where' to find the friends of Alice, and then use 'where' to filter the friends who are female.\n\nSQL query: SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "predict": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "hardness": "medium"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "question": "What are all the friends of Alice who are female?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Alice. Secondly, we need to filter the friends who are female.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the friends from table 'PersonFriend' where name = 'Alice'. In the second step, we need to filter the friends who are female from table 'Person'.\n\n<3> SQL Generation: Use 'where' to find the friends of Alice, and then use 'where' to filter the friends who are female.\n\nSQL query: SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "predict": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name  =  'Alice' AND T1.gender  =  'female'",
        "hardness": "medium"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)",
        "question": "Who has friends that are younger than the average age?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average age of all people. Secondly, we need to find people who have friends younger than the average age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we only need the 'age' column from the 'Person' table. In the second step, we need to join the 'Person' table with the 'PersonFriend' table on the 'name' column and filter based on the age of friends.\n\n<3> SQL Generation: Use 'avg' to calculate the average age from the 'Person' table. Then, join the 'Person' table with the 'PersonFriend' table on the 'name' column. Finally, filter the rows where the age of the friend is less than the average age.\n\nSQL query: SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)",
        "predict": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)",
        "hardness": "extra"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "question": "Who is the friend of Zach with longest year relationship?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Zach. Secondly, we need to filter the friends based on the longest year relationship.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select friend from table 'PersonFriend' where name = 'Zach'. In the second step, we need to filter friend and year from table 'PersonFriend'.\n\n<3> SQL Generation: Use 'where' to find the friends of Zach, and then use 'order by' and 'desc' to select the friend with the longest year relationship.\n\nSQL query: SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "predict": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "hardness": "extra"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name =  'Zach' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "question": "What is the age of the friend of Zach with longest year relationship?",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friend of Zach. Secondly, we need to find the longest year relationship for each friend. Finally, we need to find the age of the friend with the longest year relationship.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the age from table 'Person' where the name is the friend of Zach.\n\n<3> SQL Generation: Use 'where' to find the friend of Zach, then use 'order by' and 'desc' to find the friend with the longest year relationship, and finally select the age of that friend.\n\nSQL query: SELECT T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name =  'Zach' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "predict": "SELECT T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T2.name =  'Zach' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')",
        "hardness": "extra"
    },
    {
        "db_id": "network_2",
        "gold": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "question": "Find the name, age, and job title of persons who are friends with Alice for the longest years.",
        "fields": "Table Person, columns = [*,name,age,city,gender,job]\nTable PersonFriend, columns = [*,name,friend,year]\n",
        "foreign_keys": "Foreign_keys = [PersonFriend.friend = Person.name,PersonFriend.name = Person.name]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the friends of Alice. Secondly, we need to calculate the number of years each person has been friends with Alice. Finally, we need to select the person with the longest friendship and retrieve their name, age, and job title.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the tables 'Person' and 'PersonFriend' to retrieve the necessary information.\n\n<3> SQL Generation: We need to join the 'Person' and 'PersonFriend' tables on the 'name' column. Then, we filter the rows where the friend is 'Alice'. Next, we group the rows by the person's name, age, and job title and calculate the maximum number of years using the 'MAX' function. Finally, we select the person with the longest friendship and retrieve their name, age, and job title.\n\nSQL query: SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "predict": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')",
        "hardness": "extra"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "question": "Find all the name of documents without any sections.",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the documents that do not have any sections. Secondly, we need to retrieve the names of those documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select document_code from table 'Documents' where there are no corresponding entries in table 'Document_Sections'. Then, we need to retrieve the document names from table 'Documents'.\n\n<3> SQL Generation: Use 'not exists' to find the documents that do not have any sections, and then select the document names.\n\nSQL query: SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "predict": "SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "hardness": "hard"
    },
    {
        "db_id": "document_management",
        "gold": "SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "question": "What are the names of documents that do not have any sections?",
        "fields": "Table Document_Functional_Areas, columns = [*,document_code,functional_area_code]\nTable Document_Sections, columns = [*,section_id,document_code,section_sequence,section_code,section_title]\nTable Document_Sections_Images, columns = [*,section_id,image_id]\nTable Document_Structures, columns = [*,document_structure_code,parent_document_structure_code,document_structure_description]\nTable Documents, columns = [*,document_code,document_structure_code,document_type_code,access_count,document_name]\nTable Functional_Areas, columns = [*,functional_area_code,parent_functional_area_code,functional_area_description]\nTable Images, columns = [*,image_id,image_alt_text,image_name,image_url]\nTable Roles, columns = [*,role_code,role_description]\nTable Users, columns = [*,user_id,role_code,user_name,user_login,password]\n",
        "foreign_keys": "Foreign_keys = [Users.role_code = Roles.role_code,Documents.document_structure_code = Document_Structures.document_structure_code,Document_Functional_Areas.functional_area_code = Functional_Areas.functional_area_code,Document_Functional_Areas.document_code = Documents.document_code,Document_Sections.document_code = Documents.document_code,Document_Sections_Images.image_id = Images.image_id,Document_Sections_Images.section_id = Document_Sections.section_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the documents that do not have any sections. Secondly, we need to retrieve the names of those documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select document_code from table 'Documents' where there are no corresponding entries in table 'Document_Sections'. Then, we need to retrieve the document names from table 'Documents'.\n\n<3> SQL Generation: Use 'where' and 'not exists' to find the documents that do not have any sections, and then select the document names.\n\nSQL query: SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "predict": "SELECT document_name FROM documents WHERE document_code NOT IN (SELECT document_code FROM document_sections)",
        "hardness": "hard"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT name FROM Companies ORDER BY Market_Value_billion DESC",
        "question": "Sort the company names in descending order of the company's market value.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Decomposition: We need to sort the company names based on their market value in descending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Companies' table for this query.\n\n<3> SQL Generation: Use 'order by' and 'desc' to sort the company names based on their market value in descending order.\n\nSQL query: SELECT name FROM Companies ORDER BY Market_Value_billion DESC",
        "predict": "SELECT name FROM Companies ORDER BY Market_Value_billion DESC",
        "hardness": "easy"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations)",
        "question": "List the names of buildings that have no company office.",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Decomposition: We need to find the buildings that have no company office.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of buildings from the 'buildings' table where there is no corresponding entry in the 'Office_locations' table.\n\n<3> SQL Generation: We can use a left join to combine the 'buildings' and 'Office_locations' tables, and then filter the rows where the 'company_id' is null. Finally, we select the names of the buildings.\n\nSQL query: SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations)",
        "predict": "SELECT name FROM buildings WHERE id NOT IN (SELECT building_id FROM Office_locations)",
        "hardness": "hard"
    },
    {
        "db_id": "company_office",
        "gold": "SELECT count(*) FROM Companies WHERE Industry  =  \"Banking\" OR Industry  =  \"Conglomerate\"",
        "question": "How many companies are in either \"Banking\" industry or \"Conglomerate\" industry?",
        "fields": "Table Companies, columns = [*,id,name,Headquarters,Industry,Sales_billion,Profits_billion,Assets_billion,Market_Value_billion]\nTable Office_locations, columns = [*,building_id,company_id,move_in_year]\nTable buildings, columns = [*,id,name,City,Height,Stories,Status]\n",
        "foreign_keys": "Foreign_keys = [Office_locations.company_id = Companies.id,Office_locations.building_id = buildings.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter companies based on their industry, selecting companies in the \"Banking\" industry or \"Conglomerate\" industry. Secondly, we need to count the number of selected companies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Companies' table and the 'Industry' column.\n\n<3> SQL Generation: Use 'where' to filter companies in the \"Banking\" industry or \"Conglomerate\" industry, and then use 'count' to count the number of selected companies.\n\nSQL query: SELECT count(*) FROM Companies WHERE Industry  =  \"Banking\" OR Industry  =  \"Conglomerate\"",
        "predict": "SELECT count(*) FROM Companies WHERE Industry  =  \"Banking\" OR Industry  =  \"Conglomerate\"",
        "hardness": "medium"
    },
    {
        "db_id": "solvency_ii",
        "gold": "SELECT Product_Name FROM Products ORDER BY Product_Price ASC",
        "question": "List the name of products in ascending order of price.",
        "fields": "Table Addresses, columns = [*,Address_ID,address_details]\nTable Agreements, columns = [*,Document_ID,Event_ID]\nTable Assets, columns = [*,Asset_ID,Other_Details]\nTable Assets_in_Events, columns = [*,Asset_ID,Event_ID]\nTable Channels, columns = [*,Channel_ID,Other_Details]\nTable Events, columns = [*,Event_ID,Address_ID,Channel_ID,Event_Type_Code,Finance_ID,Location_ID]\nTable Finances, columns = [*,Finance_ID,Other_Details]\nTable Locations, columns = [*,Location_ID,Other_Details]\nTable Parties, columns = [*,Party_ID,Party_Details]\nTable Parties_in_Events, columns = [*,Party_ID,Event_ID,Role_Code]\nTable Products, columns = [*,Product_ID,Product_Type_Code,Product_Name,Product_Price]\nTable Products_in_Events, columns = [*,Product_in_Event_ID,Event_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [Events.Finance_ID = Finances.Finance_ID,Events.Address_ID = Addresses.Address_ID,Events.Location_ID = Locations.Location_ID,Products_in_Events.Product_ID = Products.Product_ID,Products_in_Events.Event_ID = Events.Event_ID,Parties_in_Events.Event_ID = Events.Event_ID,Parties_in_Events.Party_ID = Parties.Party_ID,Agreements.Event_ID = Events.Event_ID,Assets_in_Events.Event_ID = Events.Event_ID,Assets_in_Events.Event_ID = Events.Event_ID]\n",
        "reasoning": "<1> Decomposition: We need to retrieve the names of products and sort them in ascending order of price.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Products' table for this query.\n\n<3> SQL Generation: We can directly select the 'Product_Name' column from the 'Products' table and order the results by the 'Product_Price' column in ascending order.\n\nSQL query: SELECT Product_Name FROM Products ORDER BY Product_Price ASC",
        "predict": "SELECT Product_Name FROM Products ORDER BY Product_Price ASC",
        "hardness": "easy"
    },
    {
        "db_id": "entertainment_awards",
        "gold": "SELECT Name FROM artwork WHERE TYPE != \"Program Talent Show\"",
        "question": "List the name of artworks whose type is not \"Program Talent Show\".",
        "fields": "Table artwork, columns = [*,Artwork_ID,Type,Name]\nTable festival_detail, columns = [*,Festival_ID,Festival_Name,Chair_Name,Location,Year,Num_of_Audience]\nTable nomination, columns = [*,Artwork_ID,Festival_ID,Result]\n",
        "foreign_keys": "Foreign_keys = [nomination.Festival_ID = festival_detail.Festival_ID,nomination.Artwork_ID = artwork.Artwork_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the type of artwork, so we should apply the 'where' clause to the column 'Type' and then return the names of the selected artworks.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires the names of the artworks, we only need the 'artwork' table.\n\n<3> SQL Generation: Directly write the SQL query using 'where'.\n\nSQL query: SELECT Name FROM artwork WHERE TYPE != \"Program Talent Show\"",
        "predict": "SELECT Name FROM artwork WHERE TYPE != \"Program Talent Show\"",
        "hardness": "easy"
    },
    {
        "db_id": "entertainment_awards",
        "gold": "SELECT Name FROM Artwork WHERE Artwork_ID NOT IN (SELECT Artwork_ID FROM nomination)",
        "question": "List the name of artworks that are not nominated.",
        "fields": "Table artwork, columns = [*,Artwork_ID,Type,Name]\nTable festival_detail, columns = [*,Festival_ID,Festival_Name,Chair_Name,Location,Year,Num_of_Audience]\nTable nomination, columns = [*,Artwork_ID,Festival_ID,Result]\n",
        "foreign_keys": "Foreign_keys = [nomination.Festival_ID = festival_detail.Festival_ID,nomination.Artwork_ID = artwork.Artwork_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on artworks that are not nominated. We need to select the names of artworks that do not have corresponding entries in the 'nomination' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'artwork' table to select the names of artworks.\n\n<3> SQL Generation: Use 'where not exists' to filter artworks that do not have corresponding entries in the 'nomination' table and select their names.\n\nSQL query: SELECT Name FROM Artwork WHERE Artwork_ID NOT IN (SELECT Artwork_ID FROM nomination)",
        "predict": "SELECT Name FROM Artwork WHERE Artwork_ID NOT IN (SELECT Artwork_ID FROM nomination)",
        "hardness": "hard"
    },
    {
        "db_id": "customers_campaigns_ecommerce",
        "gold": "SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM mailshot_customers)",
        "question": "Show the name and phone of the customer without any mailshot.",
        "fields": "Table Customer_Addresses, columns = [*,customer_id,premise_id,date_address_from,address_type_code,date_address_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,shipping_method_code,order_placed_datetime,order_delivered_datetime,order_shipping_charges]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,customer_address,customer_login,customer_password]\nTable Mailshot_Campaigns, columns = [*,mailshot_id,product_category,mailshot_name,mailshot_start_date,mailshot_end_date]\nTable Mailshot_Customers, columns = [*,mailshot_id,customer_id,outcome_code,mailshot_customer_date]\nTable Order_Items, columns = [*,item_id,order_item_status_code,order_id,product_id,item_status_code,item_delivered_datetime,item_order_quantity]\nTable Premises, columns = [*,premise_id,premises_type,premise_details]\nTable Products, columns = [*,product_id,product_category,product_name]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.premise_id = Premises.premise_id,Customer_Orders.customer_id = Customers.customer_id,Mailshot_Customers.mailshot_id = Mailshot_Campaigns.mailshot_id,Mailshot_Customers.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customers who did not receive any mailshot. Secondly, we need to select the name and phone of those customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Mailshot_Customers' where outcome_code is not equal to 'Sent'. In the second step, we need to select customer_name and customer_phone from table 'Customers' based on the customer_id obtained in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer_id from table 'Mailshot_Customers' where outcome_code is not equal to 'Sent', and then use 'where' to select the name and phone of those customers from table 'Customers'.\n\nSQL query: SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM mailshot_customers)",
        "predict": "SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM mailshot_customers)",
        "hardness": "extra"
    },
    {
        "db_id": "customers_campaigns_ecommerce",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE shipping_method_code  =  'FedEx' AND order_status_code  =  'Paid'",
        "question": "Show the names of customers having an order with shipping method FedEx and order status Paid.",
        "fields": "Table Customer_Addresses, columns = [*,customer_id,premise_id,date_address_from,address_type_code,date_address_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,shipping_method_code,order_placed_datetime,order_delivered_datetime,order_shipping_charges]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,customer_phone,customer_email,customer_address,customer_login,customer_password]\nTable Mailshot_Campaigns, columns = [*,mailshot_id,product_category,mailshot_name,mailshot_start_date,mailshot_end_date]\nTable Mailshot_Customers, columns = [*,mailshot_id,customer_id,outcome_code,mailshot_customer_date]\nTable Order_Items, columns = [*,item_id,order_item_status_code,order_id,product_id,item_status_code,item_delivered_datetime,item_order_quantity]\nTable Premises, columns = [*,premise_id,premises_type,premise_details]\nTable Products, columns = [*,product_id,product_category,product_name]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.premise_id = Premises.premise_id,Customer_Orders.customer_id = Customers.customer_id,Mailshot_Customers.mailshot_id = Mailshot_Campaigns.mailshot_id,Mailshot_Customers.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders with shipping method FedEx. Secondly, we need to filter orders with order status Paid. Finally, we need to select the names of customers who have orders that meet both conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_name from table 'Customers' and filter by customer_id from table 'Customer_Orders'. We also need to filter by shipping_method_code and order_status_code from table 'Customer_Orders'.\n\n<3> SQL Generation: Use 'where' to filter orders with shipping method FedEx and order status Paid, and then select the customer names.\n\nSQL query: SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE shipping_method_code  =  'FedEx' AND order_status_code  =  'Paid'",
        "predict": "SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE shipping_method_code  =  'FedEx' AND order_status_code  =  'Paid'",
        "hardness": "medium"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT count(*) FROM COURSE WHERE Credits  >  2",
        "question": "How many courses have more than 2 credits?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on courses with more than 2 credits. We need to select courses based on their credit value.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Course' table and the 'Credits' column.\n\n<3> SQL Generation: Use 'where' to filter courses with more than 2 credits and count them.\n\nSQL query: SELECT count(*) FROM COURSE WHERE Credits  >  2",
        "predict": "SELECT count(*) FROM COURSE WHERE Credits  >  2",
        "hardness": "easy"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT count(*) FROM DEPARTMENT WHERE Division  =  \"AS\"",
        "question": "How many departments are in the division AS?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of departments in the division AS.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the departments from the table 'Department' where the division is AS.\n\n<3> SQL Generation: Use 'where' to filter departments with the division AS, and then use 'count' to calculate the number of departments.\n\nSQL query: SELECT count(*) FROM DEPARTMENT WHERE Division  =  \"AS\"",
        "predict": "SELECT count(*) FROM DEPARTMENT WHERE Division  =  \"AS\"",
        "hardness": "easy"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade  =  \"B\"",
        "question": "How many students have had at least one \"B\" grade?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students who have at least one \"B\" grade. Secondly, we need to count the number of selected students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select StuID from table 'Enrolled_in' where Grade = \"B\".\n\n<3> SQL Generation: Use 'where' to filter students who have at least one \"B\" grade, and then use 'count' to count the number of selected students.\n\nSQL query: SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade  =  \"B\"",
        "predict": "SELECT COUNT(DISTINCT StuID) FROM ENROLLED_IN WHERE Grade  =  \"B\"",
        "hardness": "easy"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Room FROM FACULTY WHERE Rank  =  \"Professor\" AND Building  =  \"NEB\"",
        "question": "What are the rooms for members of the faculty who are professors and who live in building NEB?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter members of the faculty who are professors. Secondly, we need to filter members of the faculty who live in building NEB. Finally, we need to select the rooms for the filtered faculty members.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the rooms from table 'Faculty' where the rank is 'professor' and the building is 'NEB'.\n\n<3> SQL Generation: Use 'where' to filter members of the faculty who are professors and who live in building NEB, and then select the rooms for the filtered faculty members.\n\nSQL query: SELECT Room FROM FACULTY WHERE Rank  =  \"Professor\" AND Building  =  \"NEB\"",
        "predict": "SELECT Room FROM FACULTY WHERE Rank  =  \"Professor\" AND Building  =  \"NEB\"",
        "hardness": "medium"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT T2.Dname ,  T2.Room FROM COURSE AS T1 JOIN DEPARTMENT AS T2 ON T1.DNO  =  T2.DNO WHERE T1.CName  =  \"INTRODUCTION TO COMPUTER SCIENCE\"",
        "question": "What are the department name and room for the course INTRODUCTION TO COMPUTER SCIENCE?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the course with the name 'INTRODUCTION TO COMPUTER SCIENCE'. Secondly, we need to find the department name and room for that course.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select CID from table 'Course' where CName = 'INTRODUCTION TO COMPUTER SCIENCE'. In the second step, we need to select DName and Room from table 'Department' where DNO matches the DNO in the Course table.\n\n<3> SQL Generation: Use 'where' to find the course with the name 'INTRODUCTION TO COMPUTER SCIENCE', and then use 'where' to find the department name and room for that course.\n\nSQL query: SELECT T2.Dname ,  T2.Room FROM COURSE AS T1 JOIN DEPARTMENT AS T2 ON T1.DNO  =  T2.DNO WHERE T1.CName  =  \"INTRODUCTION TO COMPUTER SCIENCE\"",
        "predict": "SELECT T2.Dname ,  T2.Room FROM COURSE AS T1 JOIN DEPARTMENT AS T2 ON T1.DNO  =  T2.DNO WHERE T1.CName  =  \"INTRODUCTION TO COMPUTER SCIENCE\"",
        "hardness": "medium"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT max(T2.gradepoint) ,  min(T2.gradepoint) FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T3.city_code  =  \"NYC\"",
        "question": "What is the maximum and minimum grade point of students who live in NYC?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who live in NYC. Secondly, we need to calculate the maximum and minimum grade point of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where city_code = 'NYC'. In the second step, we need to select gradepoint from table 'Gradeconversion' and filter by lettergrade from table 'Enrolled_in' where StuID is from the first step.\n\n<3> SQL Generation: Use 'where' to find the students who live in NYC, and then use 'where' to filter the grade points of these students and calculate the maximum and minimum values.\n\nSQL query: SELECT max(T2.gradepoint) ,  min(T2.gradepoint) FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T3.city_code  =  \"NYC\"",
        "predict": "SELECT max(T2.gradepoint) ,  min(T2.gradepoint) FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T3.city_code  =  \"NYC\"",
        "hardness": "hard"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "question": "Find the first name of students not enrolled in any course.",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires finding students who are not enrolled in any course. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first name from the 'Student' table and filter out students who have entries in the 'Enrolled_in' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Student' and 'Enrolled_in' tables on the 'StuID' column. Then, we can filter out the rows where the 'CID' column is null, indicating that the student is not enrolled in any course. Finally, we can select the first name of these students.\n\nSQL query: SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "predict": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "hardness": "hard"
    },
    {
        "db_id": "college_3",
        "gold": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "question": "What are the first names of all students that are not enrolled in courses?",
        "fields": "Table Course, columns = [*,CID,CName,Credits,Instructor,Days,Hours,DNO]\nTable Department, columns = [*,DNO,Division,DName,Room,Building,DPhone]\nTable Enrolled_in, columns = [*,StuID,CID,Grade]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Gradeconversion, columns = [*,lettergrade,gradepoint]\nTable Member_of, columns = [*,FacID,DNO,Appt_Type]\nTable Minor_in, columns = [*,StuID,DNO]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Member_of.DNO = Department.DNO,Member_of.FacID = Faculty.FacID,Course.DNO = Department.DNO,Course.Instructor = Faculty.FacID,Minor_in.DNO = Department.DNO,Minor_in.StuID = Student.StuID,Enrolled_in.Grade = Gradeconversion.lettergrade,Enrolled_in.CID = Course.CID,Enrolled_in.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires finding students who are not enrolled in any courses and retrieving their first names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select first names from the 'Student' table and filter out the students who have entries in the 'Enrolled_in' table.\n\n<3> SQL Generation: We can use a left join between the 'Student' and 'Enrolled_in' tables on the 'StuID' column. Then, we can filter out the rows where the 'CID' column is null (indicating that the student is not enrolled in any courses). Finally, we can select the first names of these students.\n\nSQL query: SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "predict": "SELECT Fname FROM STUDENT WHERE StuID NOT IN (SELECT StuID FROM ENROLLED_IN)",
        "hardness": "hard"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT T1.product_id FROM product_suppliers AS T1 JOIN products AS T2 ON T1.product_id  =  T2.product_id WHERE T1.supplier_id  =  2 AND T2.product_price  >  (SELECT avg(product_price) FROM products)",
        "question": "Return ids of all the products that are supplied by supplier id 2 and are more expensive than the average price of all products.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the average price of all products. Secondly, we need to filter products that are supplied by supplier id 2 and have a price higher than the average price.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the average product price from table 'Products'. In the second step, we need to filter product ids from table 'Product_Suppliers' based on supplier id 2 and price higher than the average price.\n\n<3> SQL Generation: Use 'where' to find the average product price, and then use 'where' to filter product ids that are supplied by supplier id 2 and have a price higher than the average price.\n\nSQL query: SELECT T1.product_id FROM product_suppliers AS T1 JOIN products AS T2 ON T1.product_id  =  T2.product_id WHERE T1.supplier_id  =  2 AND T2.product_price  >  (SELECT avg(product_price) FROM products)",
        "predict": "SELECT T1.product_id FROM product_suppliers AS T1 JOIN products AS T2 ON T1.product_id  =  T2.product_id WHERE T1.supplier_id  =  2 AND T2.product_price  >  (SELECT avg(product_price) FROM products)",
        "hardness": "extra"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT product_name ,  product_id FROM products WHERE product_price BETWEEN 600 AND 700",
        "question": "What are the names and ids of products costing between 600 and 700?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their cost. Secondly, we need to select the names and ids of the filtered products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information about products, we only need the 'Products' table.\n\n<3> SQL Generation: Use 'where' to filter products based on their cost, and then select the names and ids of the filtered products.\n\nSQL query: SELECT product_name ,  product_id FROM products WHERE product_price BETWEEN 600 AND 700",
        "predict": "SELECT product_name ,  product_id FROM products WHERE product_price BETWEEN 600 AND 700",
        "hardness": "medium"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT product_id ,  product_name FROM products WHERE product_price  <  600 OR product_price  >  900",
        "question": "What are id and name of the products whose price is lower than 600 or higher than 900?",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their price being lower than 600 or higher than 900. Secondly, we need to select the id and name of the filtered products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Products' table for this query, we can directly use it.\n\n<3> SQL Generation: Use 'where' to filter products based on their price being lower than 600 or higher than 900, and then select the id and name of the filtered products.\n\nSQL query: SELECT product_id ,  product_name FROM products WHERE product_price  <  600 OR product_price  >  900",
        "predict": "SELECT product_id ,  product_name FROM products WHERE product_price  <  600 OR product_price  >  900",
        "hardness": "extra"
    },
    {
        "db_id": "department_store",
        "gold": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE \"%WY%\" AND payment_method_code != \"Credit Card\"",
        "question": "Find the id and name of customers whose address contains WY state and do not use credit card for payment.",
        "fields": "Table Addresses, columns = [*,address_id,address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status_code,order_date]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_code,customer_name,customer_address,customer_phone,customer_email]\nTable Department_Store_Chain, columns = [*,dept_store_chain_id,dept_store_chain_name]\nTable Department_Stores, columns = [*,dept_store_id,dept_store_chain_id,store_name,store_address,store_phone,store_email]\nTable Departments, columns = [*,department_id,dept_store_id,department_name]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id]\nTable Product_Suppliers, columns = [*,product_id,supplier_id,date_supplied_from,date_supplied_to,total_amount_purchased,total_value_purchased]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\nTable Staff, columns = [*,staff_id,staff_gender,staff_name]\nTable Staff_Department_Assignments, columns = [*,staff_id,department_id,date_assigned_from,job_title_code,date_assigned_to]\nTable Supplier_Addresses, columns = [*,supplier_id,address_id,date_from,date_to]\nTable Suppliers, columns = [*,supplier_id,supplier_name,supplier_phone]\n",
        "foreign_keys": "Foreign_keys = [Supplier_Addresses.supplier_id = Suppliers.supplier_id,Supplier_Addresses.address_id = Addresses.address_id,Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Orders.customer_id = Customers.customer_id,Department_Stores.dept_store_chain_id = Department_Store_Chain.dept_store_chain_id,Departments.dept_store_id = Department_Stores.dept_store_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id,Product_Suppliers.product_id = Products.product_id,Product_Suppliers.supplier_id = Suppliers.supplier_id,Staff_Department_Assignments.staff_id = Staff.staff_id,Staff_Department_Assignments.department_id = Departments.department_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter customers whose address contains WY state. Secondly, we need to filter customers who do not use credit card for payment. Finally, we need to select the id and name of the filtered customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id and customer_name from table 'Customers' and filter by customer_address from table 'Addresses'. We also need to filter by payment_method_code from table 'Customers'.\n\n<3> SQL Generation: Use 'like' to filter customers whose address contains WY state, and then use 'not in' to filter customers who do not use credit card for payment. Finally, select the id and name of the filtered customers.\n\nSQL query: SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE \"%WY%\" AND payment_method_code != \"Credit Card\"",
        "predict": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE \"%WY%\" AND payment_method_code != \"Credit Card\"",
        "hardness": "extra"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT Name FROM pilot WHERE Age  <=  30 ORDER BY Name DESC",
        "question": "List names of all pilot aged 30 or younger in descending alphabetical order.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter pilots based on their age being 30 or younger. Secondly, we need to sort the names of the selected pilots in descending alphabetical order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'pilot' table and the 'Name' column, we can directly use the 'pilot' table.\n\n<3> SQL Generation: Use 'where' to filter pilots with age 30 or younger, and then use 'order by' and 'desc' to sort the names in descending alphabetical order.\n\nSQL query: SELECT Name FROM pilot WHERE Age  <=  30 ORDER BY Name DESC",
        "predict": "SELECT Name FROM pilot WHERE Age  <=  30 ORDER BY Name DESC",
        "hardness": "medium"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "question": "find the name of pilots who did not win the matches held in the country of Australia.",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the matches held in the country of Australia. Secondly, we need to filter out the winning pilots from those matches. Finally, we need to find the names of pilots who did not win.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select matches from table 'match' where country = 'Australia'. In the second step, we need to filter winning pilots from table 'match'. In the final step, we need to select names of pilots from table 'pilot' who did not win.\n\n<3> SQL Generation: Use 'where' to find matches held in the country of Australia, and then use 'not in' to filter winning pilots. Finally, select the names of pilots who did not win.\n\nSQL query: SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "predict": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "hardness": "hard"
    },
    {
        "db_id": "aircraft",
        "gold": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "question": "What are the names of the pilots that have not won any matches in Australia?",
        "fields": "Table aircraft, columns = [*,Aircraft_ID,Aircraft,Description,Max_Gross_Weight,Total_disk_area,Max_disk_Loading]\nTable airport, columns = [*,Airport_ID,Airport_Name,Total_Passengers,%_Change_2007,International_Passengers,Domestic_Passengers,Transit_Passengers,Aircraft_Movements,Freight_Metric_Tonnes]\nTable airport_aircraft, columns = [*,ID,Airport_ID,Aircraft_ID]\nTable match, columns = [*,Round,Location,Country,Date,Fastest_Qualifying,Winning_Pilot,Winning_Aircraft]\nTable pilot, columns = [*,Pilot_Id,Name,Age]\n",
        "foreign_keys": "Foreign_keys = [match.Winning_Pilot = pilot.Pilot_Id,match.Winning_Aircraft = aircraft.Aircraft_ID,airport_aircraft.Aircraft_ID = aircraft.Aircraft_ID,airport_aircraft.Airport_ID = airport.Airport_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter matches that took place in Australia. Secondly, we need to find the pilots who did not win any matches in Australia.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to filter matches based on the 'Country' column. In the second step, we need to select the names of pilots who did not win any matches.\n\n<3> SQL Generation: Use 'where' to filter matches that took place in Australia, and then use 'not in' to filter the pilots who did not win any matches.\n\nSQL query: SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "predict": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "hardness": "hard"
    },
    {
        "db_id": "school_player",
        "gold": "SELECT LOCATION FROM school WHERE School_ID NOT IN (SELECT School_ID FROM Player)",
        "question": "Which schools do not have any player? Give me the school locations.",
        "fields": "Table player, columns = [*,Player_ID,Player,Team,Age,Position,School_ID]\nTable school, columns = [*,School_ID,School,Location,Enrollment,Founded,Denomination,Boys_or_Girls,Day_or_Boarding,Year_Entered_Competition,School_Colors]\nTable school_details, columns = [*,School_ID,Nickname,Colors,League,Class,Division]\nTable school_performance, columns = [*,School_Id,School_Year,Class_A,Class_AA]\n",
        "foreign_keys": "Foreign_keys = [school_details.School_ID = school.School_ID,school_performance.School_Id = school.School_ID,player.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the schools that do not have any player. Secondly, we need to retrieve the locations of those schools.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select School_ID from table 'player' and filter the schools that do not have any player. Then, we need to retrieve the School_ID and Location from table 'school'.\n\n<3> SQL Generation: Use 'where' to filter the schools that do not have any player, and then select the School_ID and Location from table 'school'.\n\nSQL query: SELECT LOCATION FROM school WHERE School_ID NOT IN (SELECT School_ID FROM Player)",
        "predict": "SELECT LOCATION FROM school WHERE School_ID NOT IN (SELECT School_ID FROM Player)",
        "hardness": "hard"
    },
    {
        "db_id": "store_product",
        "gold": "SELECT District_name ,  City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000",
        "question": "Find the name and population of district with population between 200000 and 2000000",
        "fields": "Table district, columns = [*,District_ID,District_name,Headquartered_City,City_Population,City_Area]\nTable product, columns = [*,product_id,product,dimensions,dpi,pages_per_minute_color,max_page_size,interface]\nTable store, columns = [*,Store_ID,Store_Name,Type,Area_size,Number_of_product_category,Ranking]\nTable store_district, columns = [*,Store_ID,District_ID]\nTable store_product, columns = [*,Store_ID,Product_ID]\n",
        "foreign_keys": "Foreign_keys = [store_product.Store_ID = store.Store_ID,store_district.District_ID = district.District_ID,store_district.Store_ID = store.Store_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on districts with population between 200000 and 2000000. Firstly, we need to identify the districts with the specified population range. Secondly, we need to select the name and population of these districts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the district table and its columns 'District_name' and 'City_Population', we only need the 'district' table.\n\n<3> SQL Generation: Use 'where' to filter districts with population between 200000 and 2000000, and then select the name and population of these districts.\n\nSQL query: SELECT District_name ,  City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000",
        "predict": "SELECT District_name ,  City_Population FROM district WHERE City_Population BETWEEN 200000 AND 2000000",
        "hardness": "medium"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(*) FROM tryout WHERE decision  =  'yes'",
        "question": "How many students got accepted after the tryout?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of students who got accepted after the tryout. We need to filter the tryout records where the decision is \"accepted\" and count the number of unique players.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the pID column from the Player table and filter the Tryout table based on the decision column.\n\n<3> SQL Generation: Use 'where' to filter the tryout records where the decision is \"accepted\" and count the number of unique players using the COUNT and DISTINCT functions.\n\nSQL query: SELECT count(*) FROM tryout WHERE decision  =  'yes'",
        "predict": "SELECT count(*) FROM tryout WHERE decision  =  'yes'",
        "hardness": "easy"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'",
        "question": "What are the names of all students who successfully tried out for the position of striker?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on the position of striker in the table 'Tryout' and returning the names of the students who successfully tried out.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query only requires the names of the students, we only need the 'Player' table.\n\n<3> SQL Generation: Use 'where' to filter the rows in the 'Tryout' table where the position is 'striker' and the decision is 'successful'. Then, join the 'Player' table on the 'pID' column to retrieve the names of the students.\n\nSQL query: SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'",
        "predict": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'",
        "hardness": "medium"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "question": "Which college has any student who is a goalie and succeeded in the tryout.",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find students who are goalies and succeeded in the tryout. Secondly, we need to find the college that has any student meeting the criteria found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select pID from table 'Player' where pPos = 'goalie' and yCard = 'succeeded'. In the second step, we need to select cName from table 'Tryout' and filter by pID.\n\n<3> SQL Generation: Use 'where' to find students who are goalies and succeeded in the tryout, and then use 'where' to filter colleges that have any student meeting the criteria found in the first step.\n\nSQL query: SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "predict": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "hardness": "medium"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "question": "What college has a student who successfully made the team in the role of a goalie?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: The query requires finding a college that has a student who successfully made the team in the role of a goalie. Firstly, we need to filter tryouts based on the position 'goalie'. Secondly, we need to find the corresponding college for the selected tryouts.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select pID from table 'tryout' where pPos = 'goalie'. In the second step, we need to select cName from table 'tryout' and find the corresponding college.\n\n<3> SQL Generation: Use 'where' to filter tryouts with the position 'goalie', and then use 'where' to find the corresponding college.\n\nSQL query: SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "predict": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'",
        "hardness": "medium"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT sum(enr) FROM college WHERE cName NOT IN (SELECT cName FROM tryout WHERE pPos  =  \"goalie\")",
        "question": "What is the total number of enrollment of schools that do not have any goalie player?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the schools that do not have any goalie player. Secondly, we need to calculate the total enrollment of these schools.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select cName from table 'College' where there is no corresponding pID in table 'Player' with pPos = 'goalie'. In the second step, we need to sum the enr column from table 'College' for the selected schools.\n\n<3> SQL Generation: Use 'where' and 'not in' to find the schools that do not have any goalie player, and then use 'sum' to calculate the total enrollment of these schools.\n\nSQL query: SELECT sum(enr) FROM college WHERE cName NOT IN (SELECT cName FROM tryout WHERE pPos  =  \"goalie\")",
        "predict": "SELECT sum(enr) FROM college WHERE cName NOT IN (SELECT cName FROM tryout WHERE pPos  =  \"goalie\")",
        "hardness": "extra"
    },
    {
        "db_id": "soccer_2",
        "gold": "SELECT count(DISTINCT state) FROM college WHERE enr  <  (SELECT avg(enr) FROM college)",
        "question": "What is the number of states that has some colleges whose enrollment is smaller than the average enrollment?",
        "fields": "Table College, columns = [*,cName,state,enr]\nTable Player, columns = [*,pID,pName,yCard,HS]\nTable Tryout, columns = [*,pID,cName,pPos,decision]\n",
        "foreign_keys": "Foreign_keys = [Tryout.cName = College.cName,Tryout.pID = Player.pID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average enrollment of colleges. Secondly, we need to find the states that have colleges with enrollment smaller than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select state and enrollment from table 'College'.\n\n<3> SQL Generation: Use 'avg' to calculate the average enrollment of colleges, and then use 'where' to filter colleges with enrollment smaller than the average. Finally, use 'distinct' to count the number of states.\n\nSQL query: SELECT count(DISTINCT state) FROM college WHERE enr  <  (SELECT avg(enr) FROM college)",
        "predict": "SELECT count(DISTINCT state) FROM college WHERE enr  <  (SELECT avg(enr) FROM college)",
        "hardness": "hard"
    },
    {
        "db_id": "device",
        "gold": "SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1",
        "question": "What is the shop name corresponding to the shop that opened in the most recent year?",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the most recent year in the 'Open_Year' column of the 'shop' table. Secondly, we need to find the shop name corresponding to that year.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'shop' table for this query.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the most recent year from the 'Open_Year' column of the 'shop' table, and then use 'where' to filter the shop name corresponding to that year.\n\nSQL query: SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1",
        "predict": "SELECT Shop_Name FROM shop ORDER BY Open_Year DESC LIMIT 1",
        "hardness": "medium"
    },
    {
        "db_id": "device",
        "gold": "SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock)",
        "question": "List the names of shops that have no devices in stock.",
        "fields": "Table device, columns = [*,Device_ID,Device,Carrier,Package_Version,Applications,Software_Platform]\nTable shop, columns = [*,Shop_ID,Shop_Name,Location,Open_Date,Open_Year]\nTable stock, columns = [*,Shop_ID,Device_ID,Quantity]\n",
        "foreign_keys": "Foreign_keys = [stock.Device_ID = device.Device_ID,stock.Shop_ID = shop.Shop_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding shops that have no devices in stock. Firstly, we need to identify the shops that have devices in stock. Secondly, we need to filter out the shops that do not have any devices in stock.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Shop_ID from table 'stock' and filter by Device_ID. Then, we need to select Shop_Name from table 'shop' and filter out the shops that do not have any devices in stock.\n\n<3> SQL Generation: Use 'distinct' to select the unique Shop_ID from table 'stock'. Then, use 'not in' to filter out the shops that have devices in stock. Finally, select the Shop_Name from table 'shop'.\n\nSQL query: SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock)",
        "predict": "SELECT Shop_Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM stock)",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Badlands\" AND T1.StagePosition  =  \"back\"",
        "question": "Who is performing in the back stage position for the song \"Badlands\"? Show the first name and the last name.",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Badlands\". Secondly, we need to find the bandmate performing in the back stage position for that song. Finally, we need to show their first name and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Badlands\". In the second step, we need to select the BandmateId from the table 'Performance' where the SongId matches the one found in the first step. In the final step, we need to select the Firstname and Lastname from the table 'Band' where the Id matches the BandmateId found in the second step.\n\n<3> SQL Generation: Use 'where' to find the SongId for the song \"Badlands\", then use 'where' to find the BandmateId for the back stage position of that song, and finally use 'where' to find the Firstname and Lastname of the bandmate.\n\nSQL query: SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Badlands\" AND T1.StagePosition  =  \"back\"",
        "predict": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Badlands\" AND T1.StagePosition  =  \"back\"",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Le Pop\"",
        "question": "What instrument did the musician with last name \"Heilo\" use in the song \"Le Pop\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the musician with last name \"Heilo\". Secondly, we need to find the song \"Le Pop\" and the corresponding musician's instrument.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'Band' where Lastname = \"Heilo\". In the second step, we need to find the SongId from table 'Songs' where Title = \"Le Pop\" and the corresponding BandmateId from table 'Instruments'.\n\n<3> SQL Generation: Use 'where' to find the musician with last name \"Heilo\", and then use 'where' to find the song \"Le Pop\" and the corresponding musician's instrument.\n\nSQL query: SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Le Pop\"",
        "predict": "SELECT T4.instrument FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId JOIN Instruments AS T4 ON T4.songid  =  T3.songid AND T4.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\" AND T3.title  =  \"Le Pop\"",
        "hardness": "extra"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "question": "How many instruments does the song \"Le Pop\" use?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Le Pop\". Secondly, we need to count the number of instruments used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Le Pop\". In the second step, we need to count the number of instruments from the table 'Instruments' where the SongId matches the SongId found in the first step.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Le Pop\", and then use 'count' to count the number of instruments in the table 'Instruments' where the SongId matches the SongId found in the first step.\n\nSQL query: SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "predict": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "question": "How many different instruments are used in the song \"Le Pop\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Le Pop\". Secondly, we need to identify the different instruments used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the song_id from table 'Songs' where the title is \"Le Pop\". In the second step, we need to select the distinct instruments from table 'Instruments' based on the song_id.\n\n<3> SQL Generation: Use 'where' to find the song with the title \"Le Pop\", and then use 'distinct' to select the different instruments used in that song.\n\nSQL query: SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "predict": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN Band AS T2 ON T1.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\"",
        "question": "How many different instruments does the musician with the last name \"Heilo\" use?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the musician with the last name \"Heilo\". Secondly, we need to count the number of different instruments used by this musician.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'Band' where Lastname = \"Heilo\". In the second step, we need to select distinct Instrument from table 'Instruments' where BandmateId is the Id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the musician with the last name \"Heilo\", and then use 'where' and 'distinct' to count the number of different instruments used by this musician.\n\nSQL query: SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN Band AS T2 ON T1.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\"",
        "predict": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN Band AS T2 ON T1.bandmateid  =  T2.id WHERE T2.lastname  =  \"Heilo\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "question": "How many songs have a lead vocal?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: We need to count the number of songs that have a lead vocal.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the SongId from the Vocals table where the Type is 'lead'.\n\n<3> SQL Generation: Use 'where' to filter the songs with a lead vocal and count them.\n\nSQL query: SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "predict": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "question": "How many songs have vocals of type lead?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of songs that have vocals of type lead.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the SongId from the Vocals table where the Type is lead.\n\n<3> SQL Generation: Use 'where' to filter the rows where the Type is lead in the Vocals table, and then count the number of distinct SongIds.\n\nSQL query: SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "predict": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"lead\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid JOIN band AS T3 ON T1.bandmate  =  T3.id WHERE T3.firstname  =  \"Solveig\" AND T2.title  =  \"A Bar In Amsterdam\"",
        "question": "Which vocal type did the musician with first name \"Solveig\" played in the song with title \"A Bar in Amsterdam\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the musician with first name \"Solveig\". Secondly, we need to find the song with title \"A Bar in Amsterdam\" and the corresponding musician's vocal type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'Band' where Firstname = \"Solveig\". In the second step, we need to select SongId from table 'Songs' where Title = \"A Bar in Amsterdam\" and find the corresponding vocal type from table 'Vocals'.\n\n<3> SQL Generation: Use 'where' to find the musician with first name \"Solveig\", and then use 'where' to find the song with title \"A Bar in Amsterdam\" and the corresponding musician's vocal type.\n\nSQL query: SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid JOIN band AS T3 ON T1.bandmate  =  T3.id WHERE T3.firstname  =  \"Solveig\" AND T2.title  =  \"A Bar In Amsterdam\"",
        "predict": "SELECT TYPE FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid JOIN band AS T3 ON T1.bandmate  =  T3.id WHERE T3.firstname  =  \"Solveig\" AND T2.title  =  \"A Bar In Amsterdam\"",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Badlands\"",
        "question": "How many different instruments are used in the song \"Badlands\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Badlands\". Secondly, we need to identify the different instruments used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Badlands\". In the second step, we need to select the distinct instruments from the table 'Instruments' based on the SongId.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Badlands\", and then use 'distinct' to select the different instruments used in that song.\n\nSQL query: SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Badlands\"",
        "predict": "SELECT count(DISTINCT instrument) FROM instruments AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Badlands\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(*) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "question": "How many vocal types are used in the song \"Le Pop\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song with the title \"Le Pop\". Secondly, we need to count the number of unique vocal types used in that song.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the SongId from the table 'Songs' where the title is \"Le Pop\". In the second step, we need to count the distinct vocal types from the table 'Vocals' based on the SongId.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Le Pop\", and then use 'count(distinct)' to count the number of unique vocal types based on the SongId.\n\nSQL query: SELECT count(*) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "predict": "SELECT count(*) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  \"Le Pop\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"shared\"",
        "question": "How many different songs have shared vocals?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the songs that have shared vocals. Secondly, we need to count the number of different songs that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select distinct SongId from table 'Vocals'.\n\n<3> SQL Generation: Use 'distinct' and 'count' to select the number of different songs that have shared vocals.\n\nSQL query: SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"shared\"",
        "predict": "SELECT count(DISTINCT title) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE TYPE  =  \"shared\"",
        "hardness": "medium"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Der Kapitan\" AND T1.StagePosition  =  \"back\"",
        "question": "What is the first and last name of the artist who performed back stage for the song \"Der Kapitan\"?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the song \"Der Kapitan\" in the table 'Songs'. Secondly, we need to find the bandmate who performed back stage for that song in the table 'Performance'. Finally, we need to find the first and last name of that bandmate in the table 'Band'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select SongId from table 'Songs' where Title = \"Der Kapitan\". In the second step, we need to select Bandmate from table 'Performance' where SongId matches the SongId found in the first step. In the final step, we need to select Firstname and Lastname from table 'Band' where Id matches the Bandmate found in the second step.\n\n<3> SQL Generation: Use 'where' to find the SongId of the song \"Der Kapitan\" in the table 'Songs'. Then, use 'where' to find the Bandmate who performed back stage for that song in the table 'Performance'. Finally, use 'where' to find the first and last name of that bandmate in the table 'Band'.\n\nSQL query: SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Der Kapitan\" AND T1.StagePosition  =  \"back\"",
        "predict": "SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  \"Der Kapitan\" AND T1.StagePosition  =  \"back\"",
        "hardness": "hard"
    },
    {
        "db_id": "music_2",
        "gold": "SELECT count(DISTINCT T3.title) FROM albums AS T1 JOIN tracklists AS T2 ON T1.aid  =  T2.albumid JOIN songs AS T3 ON T2.songid  =  T3.songid WHERE t1.type  =  \"Studio\"",
        "question": "How many songs appear in studio albums?",
        "fields": "Table Albums, columns = [*,AId,Title,Year,Label,Type]\nTable Band, columns = [*,Id,Firstname,Lastname]\nTable Instruments, columns = [*,SongId,BandmateId,Instrument]\nTable Performance, columns = [*,SongId,Bandmate,StagePosition]\nTable Songs, columns = [*,SongId,Title]\nTable Tracklists, columns = [*,AlbumId,Position,SongId]\nTable Vocals, columns = [*,SongId,Bandmate,Type]\n",
        "foreign_keys": "Foreign_keys = [Instruments.BandmateId = Band.Id,Instruments.SongId = Songs.SongId,Performance.Bandmate = Band.Id,Performance.SongId = Songs.SongId,Tracklists.AlbumId = Albums.AId,Tracklists.SongId = Songs.SongId,Vocals.Bandmate = Band.Id,Vocals.SongId = Songs.SongId]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the songs that appear in studio albums. Secondly, we need to count the number of these songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are interested in studio albums, we need to select songs from the 'Songs' table that are included in studio albums. To determine if an album is a studio album, we can check the 'Type' column in the 'Albums' table.\n\n<3> SQL Generation: Use 'where' to filter songs that appear in studio albums and count them.\n\nSQL query: SELECT count(DISTINCT T3.title) FROM albums AS T1 JOIN tracklists AS T2 ON T1.aid  =  T2.albumid JOIN songs AS T3 ON T2.songid  =  T3.songid WHERE t1.type  =  \"Studio\"",
        "predict": "SELECT count(DISTINCT T3.title) FROM albums AS T1 JOIN tracklists AS T2 ON T1.aid  =  T2.albumid JOIN songs AS T3 ON T2.songid  =  T3.songid WHERE t1.type  =  \"Studio\"",
        "hardness": "hard"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT count(*) FROM manufacturers WHERE founder  =  'Andy'",
        "question": "How many companies were created by Andy?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies created by Andy. Secondly, we need to count the number of companies found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for companies created by Andy, we need to select the companies from the 'Manufacturers' table where the 'Founder' column is 'Andy'.\n\n<3> SQL Generation: Use 'where' to filter the companies created by Andy, and then use 'count' to count the number of companies.\n\nSQL query: SELECT count(*) FROM manufacturers WHERE founder  =  'Andy'",
        "predict": "SELECT count(*) FROM manufacturers WHERE founder  =  'Andy'",
        "hardness": "easy"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT sum(revenue) FROM manufacturers WHERE headquarter  =  'Austin'",
        "question": "What is the sum of revenue from companies with headquarters in Austin?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the companies with headquarters in Austin. Secondly, we need to calculate the sum of their revenue.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Manufacturers' table to filter companies with headquarters in Austin.\n\n<3> SQL Generation: Use 'where' to filter companies with headquarters in Austin, and then use 'sum' to calculate the sum of their revenue.\n\nSQL query: SELECT sum(revenue) FROM manufacturers WHERE headquarter  =  'Austin'",
        "predict": "SELECT sum(revenue) FROM manufacturers WHERE headquarter  =  'Austin'",
        "hardness": "easy"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name ,  headquarter ,  revenue FROM manufacturers ORDER BY revenue DESC",
        "question": "Find the name, headquarter and revenue of all manufacturers sorted by their revenue in the descending order.",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: We need to select the name, headquarter, and revenue of all manufacturers. Then, we need to sort them by revenue in descending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the name, headquarter, and revenue columns from the Manufacturers table.\n\n<3> SQL Generation: Use 'SELECT' to select the desired columns from the Manufacturers table. Then, use 'ORDER BY' to sort the results by revenue in descending order.\n\nSQL query: SELECT name ,  headquarter ,  revenue FROM manufacturers ORDER BY revenue DESC",
        "predict": "SELECT name ,  headquarter ,  revenue FROM manufacturers ORDER BY revenue DESC",
        "hardness": "medium"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "question": "Find the name of companies whose revenue is greater than the average revenue of all companies.",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average revenue of all companies. Secondly, we need to filter companies based on their revenue being greater than the average revenue.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only have two tables, 'Manufacturers' and 'Products', we only need the 'Manufacturers' table.\n\n<3> SQL Generation: Use 'select avg(revenue)' to calculate the average revenue of all companies, and then use 'where' to filter companies with revenue greater than the average revenue.\n\nSQL query: SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "predict": "SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "hardness": "hard"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "question": "What are the names of manufacturers with revenue greater than the average of all revenues?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average revenue of all manufacturers. Secondly, we need to filter manufacturers based on their revenue being greater than the average revenue.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Manufacturers' table for this query.\n\n<3> SQL Generation: Use 'select' to calculate the average revenue of all manufacturers, and then use 'where' to filter manufacturers based on their revenue being greater than the average revenue.\n\nSQL query: SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "predict": "SELECT name FROM manufacturers WHERE revenue  >  (SELECT avg(revenue) FROM manufacturers)",
        "hardness": "hard"
    },
    {
        "db_id": "manufactory_1",
        "gold": "SELECT name FROM products WHERE price  <=  200",
        "question": "What are the names of products with price at most 200?",
        "fields": "Table Manufacturers, columns = [*,Code,Name,Headquarter,Founder,Revenue]\nTable Products, columns = [*,Code,Name,Price,Manufacturer]\n",
        "foreign_keys": "Foreign_keys = [Products.Manufacturer = Manufacturers.Code]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on products with a price at most 200. We need to select the names of these products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Products' table.\n\n<3> SQL Generation: Use 'where' to filter products with a price at most 200 and select their names.\n\nSQL query: SELECT name FROM products WHERE price  <=  200",
        "predict": "SELECT name FROM products WHERE price  <=  200",
        "hardness": "easy"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT problem_log_id FROM problem_log ORDER BY log_entry_date DESC LIMIT 1",
        "question": "Which problem log was created most recently? Give me the log id.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the problem log that was created most recently. We need to identify the log entry date and log entry id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select log_entry_date and problem_log_id from table 'Problem_Log'.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the problem log with the most recent log entry date, and then select the corresponding log entry id.\n\nSQL query: SELECT problem_log_id FROM problem_log ORDER BY log_entry_date DESC LIMIT 1",
        "predict": "SELECT problem_log_id FROM problem_log ORDER BY log_entry_date DESC LIMIT 1",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT DISTINCT T2.problem_id ,  T2.problem_log_id FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"",
        "question": "Which problem id and log id are assigned to the staff named Rylan Homenick?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the staff with the name \"Rylan Homenick\". Secondly, we need to find the problem ids and log ids that are assigned to this staff.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select problem_id and log_id from table 'Problem_Log' where assigned_to_staff_id is the staff_id of the staff named \"Rylan Homenick\".\n\n<3> SQL Generation: Use 'where' to find the staff_id of the staff named \"Rylan Homenick\", and then use 'where' to filter problem_id and log_id from table 'Problem_Log' based on the staff_id.\n\nSQL query: SELECT DISTINCT T2.problem_id ,  T2.problem_log_id FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"",
        "predict": "SELECT DISTINCT T2.problem_id ,  T2.problem_log_id FROM staff AS T1 JOIN problem_log AS T2 ON T1.staff_id = T2.assigned_to_staff_id WHERE T1.staff_first_name = \"Rylan\" AND T1.staff_last_name = \"Homenick\"",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT count(*) FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id WHERE T1.product_name = \"voluptatem\"",
        "question": "How many problems are there for product voluptatem?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the product_id for the product \"voluptatem\". Secondly, we need to count the number of problems with that product_id.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Product' where product_name = \"voluptatem\". In the second step, we need to count the number of problems with the selected product_id from table 'Problems'.\n\n<3> SQL Generation: Use 'where' to find the product_id for the product \"voluptatem\", and then use 'where' to count the number of problems with that product_id.\n\nSQL query: SELECT count(*) FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id WHERE T1.product_name = \"voluptatem\"",
        "predict": "SELECT count(*) FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id WHERE T1.product_name = \"voluptatem\"",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT DISTINCT product_name FROM product ORDER BY product_name",
        "question": "List the names of all the distinct product names in alphabetical order?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: The query requires listing distinct product names in alphabetical order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'product_name' column, we can use the 'Product' table.\n\n<3> SQL Generation: Use 'SELECT DISTINCT' to select distinct product names from the 'Product' table and order them alphabetically.\n\nSQL query: SELECT DISTINCT product_name FROM product ORDER BY product_name",
        "predict": "SELECT DISTINCT product_name FROM product ORDER BY product_name",
        "hardness": "easy"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "question": "What are the ids of the problems reported after the date of any problems reported by Rylan Homenick?",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the date of problems reported by Rylan Homenick. Secondly, we need to filter problems reported after that date and select their ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select date_problem_reported from table 'Problems' where reported_by_staff_id = (select staff_id from Staff where staff_first_name = 'Rylan' and staff_last_name = 'Homenick'). In the second step, we need to filter problem_id from table 'Problems' based on the date_problem_reported.\n\n<3> SQL Generation: Use 'where' to find the date of problems reported by Rylan Homenick, and then use 'where' to filter problems reported after that date and select their ids.\n\nSQL query: SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "predict": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_software_problems",
        "gold": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "question": "Find the ids of the problems reported after the date of any problems reported by the staff Rylan Homenick.",
        "fields": "Table Problem_Category_Codes, columns = [*,problem_category_code,problem_category_description]\nTable Problem_Log, columns = [*,problem_log_id,assigned_to_staff_id,problem_id,problem_category_code,problem_status_code,log_entry_date,log_entry_description,log_entry_fix,other_log_details]\nTable Problem_Status_Codes, columns = [*,problem_status_code,problem_status_description]\nTable Problems, columns = [*,problem_id,product_id,closure_authorised_by_staff_id,reported_by_staff_id,date_problem_reported,date_problem_closed,problem_description,other_problem_details]\nTable Product, columns = [*,product_id,product_name,product_details]\nTable Staff, columns = [*,staff_id,staff_first_name,staff_last_name,other_staff_details]\n",
        "foreign_keys": "Foreign_keys = [Problem_Log.problem_status_code = Problem_Status_Codes.problem_status_code,Problem_Log.problem_id = Problems.problem_id,Problem_Log.assigned_to_staff_id = Staff.staff_id,Problem_Log.problem_category_code = Problem_Category_Codes.problem_category_code,Problems.reported_by_staff_id = Staff.staff_id,Problems.product_id = Product.product_id,Problems.closure_authorised_by_staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the date of problems reported by the staff Rylan Homenick. Secondly, we need to filter problems reported after that date and select their ids.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select date_problem_reported from table 'Problems' where reported_by_staff_id = (select staff_id from Staff where staff_first_name = 'Rylan' and staff_last_name = 'Homenick'). In the second step, we need to filter problem_id from table 'Problems' based on the date_problem_reported.\n\n<3> SQL Generation: Use 'where' to find the date of problems reported by the staff Rylan Homenick, and then use 'where' to filter problems reported after that date and select their ids.\n\nSQL query: SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "predict": "SELECT T1.problem_id FROM problems AS T1 JOIN staff AS T2 ON T1.reported_by_staff_id = T2.staff_id WHERE date_problem_reported  >  ( SELECT max(date_problem_reported) FROM problems AS T3 JOIN staff AS T4 ON T3.reported_by_staff_id = T4.staff_id WHERE T4.staff_first_name = \"Rylan\" AND T4.staff_last_name = \"Homenick\" )",
        "hardness": "extra"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)",
        "question": "List the branch name and city without any registered members.",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding branches without any registered members. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select branch name and city from the 'branch' table and check if there are any corresponding entries in the 'membership_register_branch' table.\n\n<3> SQL Generation: Use a left join to combine the 'branch' and 'membership_register_branch' tables on the 'Branch_ID' column. Then, filter the rows where the 'Member_ID' is null, indicating that there are no registered members for that branch.\n\nSQL query: SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)",
        "predict": "SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)",
        "hardness": "extra"
    },
    {
        "db_id": "shop_membership",
        "gold": "SELECT sum(total_pounds) FROM purchase AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.city  =  'London' AND T1.year  =  2018",
        "question": "What is the sum of total pounds of purchase in year 2018 for all branches in London?",
        "fields": "Table branch, columns = [*,Branch_ID,Name,Open_year,Address_road,City,membership_amount]\nTable member, columns = [*,Member_ID,Card_Number,Name,Hometown,Level]\nTable membership_register_branch, columns = [*,Member_ID,Branch_ID,Register_Year]\nTable purchase, columns = [*,Member_ID,Branch_ID,Year,Total_pounds]\n",
        "foreign_keys": "Foreign_keys = [membership_register_branch.Branch_ID = branch.Branch_ID,membership_register_branch.Member_ID = member.Member_ID,purchase.Branch_ID = branch.Branch_ID,purchase.Member_ID = member.Member_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter branches in London. Secondly, we need to filter purchases in year 2018. Finally, we need to calculate the sum of total pounds for the selected purchases.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Branch_ID from table 'branch' where City = 'London'. In the second step, we need to filter Total_pounds from table 'purchase' where Year = 2018. In the final step, we need to calculate the sum of Total_pounds.\n\n<3> SQL Generation: Use 'where' to filter branches in London, and then use 'where' to filter purchases in year 2018. Finally, use 'sum' to calculate the sum of Total_pounds.\n\nSQL query: SELECT sum(total_pounds) FROM purchase AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.city  =  'London' AND T1.year  =  2018",
        "predict": "SELECT sum(total_pounds) FROM purchase AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.city  =  'London' AND T1.year  =  2018",
        "hardness": "medium"
    },
    {
        "db_id": "voter_2",
        "gold": "SELECT Fname FROM STUDENT WHERE Age  >  22",
        "question": "What are the first names of all the students aged above 22?",
        "fields": "Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Voting_record, columns = [*,StuID,Registration_Date,Election_Cycle,President_Vote,Vice_President_Vote,Secretary_Vote,Treasurer_Vote,Class_President_Vote,Class_Senator_Vote]\n",
        "foreign_keys": "Foreign_keys = [Voting_record.Class_Senator_Vote = Student.StuID,Voting_record.Class_President_Vote = Student.StuID,Voting_record.Treasurer_Vote = Student.StuID,Voting_record.Secretary_Vote = Student.StuID,Voting_record.Vice_President_Vote = Student.StuID,Voting_record.President_Vote = Student.StuID,Voting_record.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on students aged above 22. We need to select the first names of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Student' table.\n\n<3> SQL Generation: Use 'where' to filter students aged above 22 and select their first names.\n\nSQL query: SELECT Fname FROM STUDENT WHERE Age  >  22",
        "predict": "SELECT Fname FROM STUDENT WHERE Age  >  22",
        "hardness": "easy"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT product_name FROM products WHERE product_category_code  =  \"Spices\"",
        "question": "What are the names of products with category \"Spices\"?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on products with category \"Spices\". We need to select the names of these products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the product names from the 'Products' table where the product category is \"Spices\".\n\n<3> SQL Generation: Use 'where' to filter products with category \"Spices\" and select their names.\n\nSQL query: SELECT product_name FROM products WHERE product_category_code  =  \"Spices\"",
        "predict": "SELECT product_name FROM products WHERE product_category_code  =  \"Spices\"",
        "hardness": "easy"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"sesame\"",
        "question": "Count the number of different characteristic names the product 'cumin' has.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the product_id of the product 'cumin'. Secondly, we need to find the characteristic_ids associated with the product_id. Finally, we count the number of different characteristic names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Products' where product_name = 'cumin'. In the second step, we need to select characteristic_ids from table 'Product_Characteristics' where product_id = the product_id found in the first step. In the final step, we need to select characteristic_names from table 'Characteristics' where characteristic_id = the characteristic_ids found in the second step.\n\n<3> SQL Generation: Use 'where' to find the product_id of the product 'cumin', then use 'where' to find the characteristic_ids associated with the product_id, and finally use 'count' and 'distinct' to count the number of different characteristic names.\n\nSQL query: SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"sesame\"",
        "predict": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  \"sesame\"",
        "hardness": "hard"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t3.characteristic_name  =  \"hot\"",
        "question": "How many products have the characteristic named \"hot\"?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: The query requires finding the characteristic named \"hot\" and counting the number of products that have this characteristic.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the characteristic_id from the Characteristics table where the characteristic_name is \"hot\". Then, we need to count the number of products that have this characteristic in the Product_Characteristics table.\n\n<3> SQL Generation: Use 'where' to find the characteristic_id of the characteristic named \"hot\", and then use 'where' to filter the Product_Characteristics table and count the number of products.\n\nSQL query: SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t3.characteristic_name  =  \"hot\"",
        "predict": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t3.characteristic_name  =  \"hot\"",
        "hardness": "hard"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"white\" OR t3.characteristic_name  =  \"hot\"",
        "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter products based on their color described as 'white'. Secondly, we need to filter products based on their characteristic with the name 'hot'. Finally, we need to count the number of products that meet either of these conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to filter products based on their color and characteristic, we need tables ['Products', 'Ref_Colors', 'Characteristics'].\n\n<3> SQL Generation: We need to join the 'Products' table with the 'Ref_Colors' table on the 'color_code' column and filter the rows where the color description is 'white'. Then, we need to join the 'Products' table with the 'Characteristics' table using the 'Product_Characteristics' table as a bridge and filter the rows where the characteristic name is 'hot'. Finally, we count the number of distinct product IDs that meet either of these conditions.\n\nSQL query: SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"white\" OR t3.characteristic_name  =  \"hot\"",
        "predict": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  \"white\" OR t3.characteristic_name  =  \"hot\"",
        "hardness": "extra"
    },
    {
        "db_id": "products_gen_characteristics",
        "gold": "SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )",
        "question": "Count the number of colors that are not used in any products.",
        "fields": "Table Characteristics, columns = [*,characteristic_id,characteristic_type_code,characteristic_data_type,characteristic_name,other_characteristic_details]\nTable Product_Characteristics, columns = [*,product_id,characteristic_id,product_characteristic_value]\nTable Products, columns = [*,product_id,color_code,product_category_code,product_name,typical_buying_price,typical_selling_price,product_description,other_product_details]\nTable Ref_Characteristic_Types, columns = [*,characteristic_type_code,characteristic_type_description]\nTable Ref_Colors, columns = [*,color_code,color_description]\nTable Ref_Product_Categories, columns = [*,product_category_code,product_category_description,unit_of_measure]\n",
        "foreign_keys": "Foreign_keys = [Characteristics.characteristic_type_code = Ref_Characteristic_Types.characteristic_type_code,Products.color_code = Ref_Colors.color_code,Products.product_category_code = Ref_Product_Categories.product_category_code,Product_Characteristics.product_id = Products.product_id,Product_Characteristics.characteristic_id = Characteristics.characteristic_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find all the colors used in products. Secondly, we need to count the number of colors that are not used.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select color_code from table 'Products'.\n\n<3> SQL Generation: Use 'distinct' to select unique color codes from table 'Products', and then use 'not in' to filter colors that are not used. Finally, count the number of colors.\n\nSQL query: SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )",
        "predict": "SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )",
        "hardness": "extra"
    },
    {
        "db_id": "swimming",
        "gold": "SELECT count(DISTINCT city) FROM stadium WHERE opening_year  <  2006",
        "question": "How many cities have a stadium that was opened before the year of 2006?",
        "fields": "Table event, columns = [*,ID,Name,Stadium_ID,Year]\nTable record, columns = [*,ID,Result,Swimmer_ID,Event_ID]\nTable stadium, columns = [*,ID,name,Capacity,City,Country,Opening_year]\nTable swimmer, columns = [*,ID,name,Nationality,meter_100,meter_200,meter_300,meter_400,meter_500,meter_600,meter_700,Time]\n",
        "foreign_keys": "Foreign_keys = [event.Stadium_ID = stadium.ID,record.Swimmer_ID = swimmer.ID,record.Event_ID = event.ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the stadiums that were opened before the year 2006. Secondly, we need to count the number of unique cities that have such stadiums.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the cities from table 'stadium' where the opening year is before 2006. In the second step, we need to count the number of unique cities from the first step.\n\n<3> SQL Generation: Use 'where' to find the stadiums that were opened before the year 2006, and then use 'count' and 'distinct' to count the number of unique cities.\n\nSQL query: SELECT count(DISTINCT city) FROM stadium WHERE opening_year  <  2006",
        "predict": "SELECT count(DISTINCT city) FROM stadium WHERE opening_year  <  2006",
        "hardness": "easy"
    },
    {
        "db_id": "railway",
        "gold": "SELECT max(LEVEL) FROM manager WHERE Country != \"Australia\"",
        "question": "What is the maximum level of managers in countries that are not \"Australia\"?",
        "fields": "Table manager, columns = [*,Manager_ID,Name,Country,Working_year_starts,Age,Level]\nTable railway, columns = [*,Railway_ID,Railway,Builder,Built,Wheels,Location,ObjectNumber]\nTable railway_manage, columns = [*,Railway_ID,Manager_ID,From_Year]\nTable train, columns = [*,Train_ID,Train_Num,Name,From,Arrival,Railway_ID]\n",
        "foreign_keys": "Foreign_keys = [train.Railway_ID = railway.Railway_ID,railway_manage.Railway_ID = railway.Railway_ID,railway_manage.Manager_ID = manager.Manager_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter managers based on their countries, excluding \"Australia\". Secondly, we need to find the maximum level among the selected managers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'manager' table, we can directly use it.\n\n<3> SQL Generation: Use 'where' to filter managers from countries other than \"Australia\", and then use 'max' to find the maximum level among the selected managers.\n\nSQL query: SELECT max(LEVEL) FROM manager WHERE Country != \"Australia\"",
        "predict": "SELECT max(LEVEL) FROM manager WHERE Country != \"Australia\"",
        "hardness": "easy"
    },
    {
        "db_id": "customers_and_products_contacts",
        "gold": "SELECT count(*) FROM products WHERE product_price  >  (SELECT avg(product_price) FROM products)",
        "question": "How many products have a price higher than the average?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Contacts, columns = [*,contact_id,customer_id,gender,first_name,last_name,contact_phone]\nTable Customer_Address_History, columns = [*,customer_id,address_id,date_from,date_to]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]\nTable Customers, columns = [*,customer_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]\nTable Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_type_code,product_name,product_price]\n",
        "foreign_keys": "Foreign_keys = [Customer_Address_History.address_id = Addresses.address_id,Customer_Address_History.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average price of products. Secondly, we need to count the number of products with a price higher than the average.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'product_price' column from the 'Products' table, we only need the 'Products' table.\n\n<3> SQL Generation: Use 'avg' to calculate the average price of products, and then use 'where' to filter products with a price higher than the average.\n\nSQL query: SELECT count(*) FROM products WHERE product_price  >  (SELECT avg(product_price) FROM products)",
        "predict": "SELECT count(*) FROM products WHERE product_price  >  (SELECT avg(product_price) FROM products)",
        "hardness": "hard"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "question": "How many female students (sex is F) whose age is below 25?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their sex and age. Secondly, we need to count the number of selected female students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter students based on their sex and age, we only need the 'Student' table.\n\n<3> SQL Generation: Use 'where' to filter students based on their sex and age, and then use 'count' to calculate the number of selected female students.\n\nSQL query: SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "predict": "SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "hardness": "medium"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "question": "How many girl students who are younger than 25?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter candidates using column 'Sex' in table 'Student' and column 'Age'. Secondly, we need to count the number of selected female students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need table 'Student' for filtering and counting, we only need this table.\n\n<3> SQL Generation: We need to filter the rows where 'Sex' is 'F' and 'Age' is less than 25. Finally, we count the number of rows that meet these conditions.\n\nSQL query: SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "predict": "SELECT count(*) FROM student WHERE sex  =  'F' AND age  <  25",
        "hardness": "medium"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100",
        "question": "Find the name and gender type of the dorms whose capacity is greater than 300 or less than 100.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter dorms based on their capacity being greater than 300 or less than 100. Secondly, we need to select the name and gender type of the filtered dorms.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select dorm_name and gender from table 'Dorm' and filter by capacity.\n\n<3> SQL Generation: Use 'where' to filter dorms based on their capacity being greater than 300 or less than 100, and then select the name and gender type of the filtered dorms.\n\nSQL query: SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100",
        "predict": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT amenity_name FROM dorm_amenity ORDER BY amenity_name",
        "question": "List in alphabetic order all different amenities.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: The query requires listing all different amenities. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since the query is only focused on amenities, we only need the 'Dorm_amenity' table.\n\n<3> SQL Generation: Use 'SELECT DISTINCT' to select all different amenities from the 'Dorm_amenity' table and order them alphabetically.\n\nSQL query: SELECT amenity_name FROM dorm_amenity ORDER BY amenity_name",
        "predict": "SELECT amenity_name FROM dorm_amenity ORDER BY amenity_name",
        "hardness": "easy"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT fname ,  lname FROM student WHERE age  <  (SELECT avg(age) FROM student)",
        "question": "Find the first and last name of students whose age is younger than the average age.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to calculate the average age of all students. Secondly, we need to filter students whose age is younger than the average age. Finally, we need to select the first and last name of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the first and last name of students, we only need the 'Student' table.\n\n<3> SQL Generation: Use 'avg' to calculate the average age of all students, and then use 'where' to filter students whose age is younger than the average age. Finally, select the first and last name of these students.\n\nSQL query: SELECT fname ,  lname FROM student WHERE age  <  (SELECT avg(age) FROM student)",
        "predict": "SELECT fname ,  lname FROM student WHERE age  <  (SELECT avg(age) FROM student)",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall'",
        "question": "What are the first names of all students in Smith Hall?",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the dorm with the name 'Smith Hall'. Secondly, we need to find the students who live in that dorm and retrieve their first names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dormid from table 'Dorm' where dorm_name = 'Smith Hall'. In the second step, we need to filter stuid and retrieve first names from table 'Student' based on the dormid found in the first step.\n\n<3> SQL Generation: Use 'where' to find the dorm with the name 'Smith Hall', and then use 'where' to filter students who live in that dorm and retrieve their first names.\n\nSQL query: SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall'",
        "predict": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall'",
        "hardness": "hard"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT avg(T1.age) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.student_capacity  =  (SELECT max(student_capacity) FROM dorm)",
        "question": "Find the average age of students who are living in the dorm with the largest capacity.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the dorm with the largest capacity. Secondly, we need to filter students based on their dorm and calculate the average age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dormid with the largest capacity from table 'Dorm'. In the second step, we need to filter students based on dormid from table 'Lives_in' and calculate the average age from table 'Student'.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select dorm with the largest capacity, and then use 'where' to filter students and calculate the average age.\n\nSQL query: SELECT avg(T1.age) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.student_capacity  =  (SELECT max(student_capacity) FROM dorm)",
        "predict": "SELECT avg(T1.age) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.student_capacity  =  (SELECT max(student_capacity) FROM dorm)",
        "hardness": "extra"
    },
    {
        "db_id": "dorm_1",
        "gold": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "question": "Find the first name and age of students who are living in the dorms that do not have amenity TV Lounge.",
        "fields": "Table Dorm, columns = [*,dormid,dorm_name,student_capacity,gender]\nTable Dorm_amenity, columns = [*,amenid,amenity_name]\nTable Has_amenity, columns = [*,dormid,amenid]\nTable Lives_in, columns = [*,stuid,dormid,room_number]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Has_amenity.amenid = Dorm_amenity.amenid,Has_amenity.dormid = Dorm.dormid,Lives_in.dormid = Dorm.dormid,Lives_in.stuid = Student.StuID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the dorms that do not have the amenity \"TV Lounge\". Secondly, we need to find the students who are living in those dorms and retrieve their first name and age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dormid from table 'Dorm' where amenity_name != \"TV Lounge\". In the second step, we need to filter dormid from table 'Lives_in' and retrieve the corresponding first name and age from table 'Student'.\n\n<3> SQL Generation: Use 'where' to find the dorms that do not have the amenity \"TV Lounge\", and then use 'where' to filter students who are living in those dorms and select their first name and age.\n\nSQL query: SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "predict": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')",
        "hardness": "extra"
    },
    {
        "db_id": "customer_complaints",
        "gold": "SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints)",
        "question": "Find the prices of products which has never received a single complaint.",
        "fields": "Table Complaints, columns = [*,complaint_id,product_id,customer_id,complaint_outcome_code,complaint_status_code,complaint_type_code,date_complaint_raised,date_complaint_closed,staff_id]\nTable Customers, columns = [*,customer_id,customer_type_code,address_line_1,address_line_2,town_city,state,email_address,phone_number]\nTable Products, columns = [*,product_id,parent_product_id,product_category_code,date_product_first_available,date_product_discontinued,product_name,product_description,product_price]\nTable Staff, columns = [*,staff_id,gender,first_name,last_name,email_address,phone_number]\n",
        "foreign_keys": "Foreign_keys = [Complaints.customer_id = Customers.customer_id,Complaints.product_id = Products.product_id,Complaints.staff_id = Staff.staff_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the products that have never received a single complaint. Secondly, we need to select the prices of those products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select product_id from table 'Complaints' and count the number of complaints for each product. In the second step, we need to select product_id and product_price from table 'Products'.\n\n<3> SQL Generation: Use 'group by' and 'having' to find the products that have never received a single complaint, and then select the prices of those products.\n\nSQL query: SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints)",
        "predict": "SELECT product_price FROM products WHERE product_id NOT IN (SELECT product_id FROM complaints)",
        "hardness": "hard"
    },
    {
        "db_id": "workshop_paper",
        "gold": "SELECT Author FROM submission WHERE Submission_ID NOT IN (SELECT Submission_ID FROM acceptance)",
        "question": "List the authors who do not have submission to any workshop.",
        "fields": "Table Acceptance, columns = [*,Submission_ID,Workshop_ID,Result]\nTable submission, columns = [*,Submission_ID,Scores,Author,College]\nTable workshop, columns = [*,Workshop_ID,Date,Venue,Name]\n",
        "foreign_keys": "Foreign_keys = [Acceptance.Workshop_ID = workshop.Workshop_ID,Acceptance.Submission_ID = submission.Submission_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the authors who have submissions to workshops. Secondly, we need to filter out the authors who do not have any submissions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Author from table 'submission' and filter by Workshop_ID. Then, we need to filter out the authors who do not have any submissions from table 'submission'.\n\n<3> SQL Generation: Use 'where' to filter authors who have submissions to workshops, and then use 'not in' to filter out the authors who do not have any submissions.\n\nSQL query: SELECT Author FROM submission WHERE Submission_ID NOT IN (SELECT Submission_ID FROM acceptance)",
        "predict": "SELECT Author FROM submission WHERE Submission_ID NOT IN (SELECT Submission_ID FROM acceptance)",
        "hardness": "hard"
    },
    {
        "db_id": "tracking_share_transactions",
        "gold": "SELECT min(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code  =  \"PUR\" AND share_count  >  50",
        "question": "Show the minimum amount of transactions whose type code is \"PUR\" and whose share count is bigger than 50.",
        "fields": "Table Investors, columns = [*,investor_id,Investor_details]\nTable Lots, columns = [*,lot_id,investor_id,lot_details]\nTable Purchases, columns = [*,purchase_transaction_id,purchase_details]\nTable Ref_Transaction_Types, columns = [*,transaction_type_code,transaction_type_description]\nTable Sales, columns = [*,sales_transaction_id,sales_details]\nTable Transactions, columns = [*,transaction_id,investor_id,transaction_type_code,date_of_transaction,amount_of_transaction,share_count,other_details]\nTable Transactions_Lots, columns = [*,transaction_id,lot_id]\n",
        "foreign_keys": "Foreign_keys = [Lots.investor_id = Investors.investor_id,Transactions.transaction_type_code = Ref_Transaction_Types.transaction_type_code,Transactions.investor_id = Investors.investor_id,Sales.sales_transaction_id = Transactions.transaction_id,Purchases.purchase_transaction_id = Transactions.transaction_id,Transactions_Lots.transaction_id = Transactions.transaction_id,Transactions_Lots.lot_id = Lots.lot_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter transactions with type code \"PUR\" and share count bigger than 50. Secondly, we need to find the minimum amount among these transactions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select amount_of_transaction from table 'Transactions' where transaction_type_code = \"PUR\" and share_count > 50.\n\n<3> SQL Generation: Use 'where' to filter transactions with type code \"PUR\" and share count bigger than 50, and then use 'min' to find the minimum amount among these transactions.\n\nSQL query: SELECT min(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code  =  \"PUR\" AND share_count  >  50",
        "predict": "SELECT min(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code  =  \"PUR\" AND share_count  >  50",
        "hardness": "medium"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "question": "Show the average price range of hotels that have 5 star ratings and allow pets.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter hotels that have 5 star ratings and allow pets. Secondly, we need to calculate the average price range of these hotels.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select price_range from table 'Hotels' where star_rating_code = 5 and pets_allowed_yn = 'Y'.\n\n<3> SQL Generation: Use 'where' to filter hotels that have 5 star ratings and allow pets, and then use 'avg' to calculate the average price range.\n\nSQL query: SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "predict": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "hardness": "medium"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT T1.Name ,  T3.Visit_Date FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Vincent\" OR T2.Tourist_Details  =  \"Vivian\"",
        "question": "For each tourist attraction, return its name and the date when the tourists named Vincent or Vivian visited there.",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the tourists named Vincent or Vivian. Secondly, we need to find the tourist attractions they visited and the corresponding visit dates. Finally, we need to return the name of each tourist attraction and the visit dates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the name from the 'Tourist_Attractions' table, the tourist ID from the 'Visitors' table, and the visit date from the 'Visits' table.\n\n<3> SQL Generation: We need to join the 'Tourist_Attractions', 'Visitors', and 'Visits' tables on the corresponding foreign keys. Then, we filter the rows where the tourist name is either Vincent or Vivian. Finally, we select the name of each tourist attraction and the visit dates.\n\nSQL query: SELECT T1.Name ,  T3.Visit_Date FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Vincent\" OR T2.Tourist_Details  =  \"Vivian\"",
        "predict": "SELECT T1.Name ,  T3.Visit_Date FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  \"Vincent\" OR T2.Tourist_Details  =  \"Vivian\"",
        "hardness": "extra"
    },
    {
        "db_id": "cre_Theme_park",
        "gold": "SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits )",
        "question": "How many tourists did not make any visit?",
        "fields": "Table Features, columns = [*,Feature_ID,Feature_Details]\nTable Hotels, columns = [*,hotel_id,star_rating_code,pets_allowed_yn,price_range,other_hotel_details]\nTable Locations, columns = [*,Location_ID,Location_Name,Address,Other_Details]\nTable Museums, columns = [*,Museum_ID,Museum_Details]\nTable Photos, columns = [*,Photo_ID,Tourist_Attraction_ID,Name,Description,Filename,Other_Details]\nTable Ref_Attraction_Types, columns = [*,Attraction_Type_Code,Attraction_Type_Description]\nTable Ref_Hotel_Star_Ratings, columns = [*,star_rating_code,star_rating_description]\nTable Royal_Family, columns = [*,Royal_Family_ID,Royal_Family_Details]\nTable Shops, columns = [*,Shop_ID,Shop_Details]\nTable Staff, columns = [*,Staff_ID,Tourist_Attraction_ID,Name,Other_Details]\nTable Street_Markets, columns = [*,Market_ID,Market_Details]\nTable Theme_Parks, columns = [*,Theme_Park_ID,Theme_Park_Details]\nTable Tourist_Attraction_Features, columns = [*,Tourist_Attraction_ID,Feature_ID]\nTable Tourist_Attractions, columns = [*,Tourist_Attraction_ID,Attraction_Type_Code,Location_ID,How_to_Get_There,Name,Description,Opening_Hours,Other_Details]\nTable Visitors, columns = [*,Tourist_ID,Tourist_Details]\nTable Visits, columns = [*,Visit_ID,Tourist_Attraction_ID,Tourist_ID,Visit_Date,Visit_Details]\n",
        "foreign_keys": "Foreign_keys = [Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code,Tourist_Attractions.Attraction_Type_Code = Ref_Attraction_Types.Attraction_Type_Code,Tourist_Attractions.Location_ID = Locations.Location_ID,Street_Markets.Market_ID = Tourist_Attractions.Tourist_Attraction_ID,Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID,Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID,Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID,Theme_Parks.Theme_Park_ID = Tourist_Attractions.Tourist_Attraction_ID,Visits.Tourist_ID = Visitors.Tourist_ID,Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Photos.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Staff.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID,Tourist_Attraction_Features.Feature_ID = Features.Feature_ID,Tourist_Attraction_Features.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding tourists who did not make any visit. We need to count the number of tourists who do not have any corresponding records in the 'Visits' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Tourist_ID' column from the 'Visitors' table and filter out the tourists who have corresponding records in the 'Visits' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Visitors' and 'Visits' tables on the 'Tourist_ID' column. Then, we can filter out the rows where the 'Visit_ID' is null (indicating no visit) and count the number of tourists.\n\nSQL query: SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits )",
        "predict": "SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits )",
        "hardness": "extra"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT gtype FROM Video_games WHERE gname  =  \"Call of Destiny\"",
        "question": "What type of game is Call of Destiny?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: We need to find the game type of \"Call of Destiny\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the game type from the \"Video_Games\" table where the game name is \"Call of Destiny\".\n\n<3> SQL Generation: Use 'where' to filter the game name and select the game type.\n\nSQL query: SELECT gtype FROM Video_games WHERE gname  =  \"Call of Destiny\"",
        "predict": "SELECT gtype FROM Video_games WHERE gname  =  \"Call of Destiny\"",
        "hardness": "easy"
    },
    {
        "db_id": "game_1",
        "gold": "SELECT count(*) FROM Video_games WHERE gtype  =  \"Massively multiplayer online game\"",
        "question": "How many video games have type Massively multiplayer online game?",
        "fields": "Table Plays_Games, columns = [*,StuID,GameID,Hours_Played]\nTable SportsInfo, columns = [*,StuID,SportName,HoursPerWeek,GamesPlayed,OnScholarship]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\nTable Video_Games, columns = [*,GameID,GName,GType]\n",
        "foreign_keys": "Foreign_keys = [Plays_Games.StuID = Student.StuID,Plays_Games.GameID = Video_Games.GameID,SportsInfo.StuID = Student.StuID]\n",
        "reasoning": "<1> Decomposition: We need to filter video games based on their type and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Video_Games' table and its 'GType' column, we can directly use this table.\n\n<3> SQL Generation: Use 'where' to filter video games with type 'Massively multiplayer online game' and count them.\n\nSQL query: SELECT count(*) FROM Video_games WHERE gtype  =  \"Massively multiplayer online game\"",
        "predict": "SELECT count(*) FROM Video_games WHERE gtype  =  \"Massively multiplayer online game\"",
        "hardness": "easy"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT date_became_customer FROM customers WHERE customer_id BETWEEN 10 AND 20",
        "question": "Find the \"date became customers\" of the customers whose ID is between 10 and 20.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter customers based on their ID being between 10 and 20. Secondly, we need to select the \"date became customers\" for the selected customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the \"date became customers\" from table 'Customers', we only need this table.\n\n<3> SQL Generation: Use 'where' to filter customers based on their ID being between 10 and 20, and then select the \"date became customers\" for the selected customers.\n\nSQL query: SELECT date_became_customer FROM customers WHERE customer_id BETWEEN 10 AND 20",
        "predict": "SELECT date_became_customer FROM customers WHERE customer_id BETWEEN 10 AND 20",
        "hardness": "easy"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT count(DISTINCT t3.product_id) FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t1.customer_name  =  \"Rodrick Heaney\"",
        "question": "How many types of products have Rodrick Heaney bought in total?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of Rodrick Heaney. Secondly, we need to find the order_id of Rodrick Heaney's orders. Thirdly, we need to find the product_id of the products bought in Rodrick Heaney's orders. Finally, we need to count the number of distinct product types.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_name = 'Rodrick Heaney'. In the second step, we need to select order_id from table 'Customer_Orders' where customer_id = the customer_id found in the first step. In the third step, we need to select product_id from table 'Order_Items' where order_id = the order_id found in the second step. In the final step, we need to count the distinct product types from table 'Products' using the product_id found in the third step.\n\n<3> SQL Generation: Use 'where' to find the customer_id of Rodrick Heaney, and then use 'where' to find the order_id of Rodrick Heaney's orders. Next, use 'where' to find the product_id of the products bought in Rodrick Heaney's orders. Finally, use 'count(distinct)' to count the number of distinct product types.\n\nSQL query: SELECT count(DISTINCT t3.product_id) FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t1.customer_name  =  \"Rodrick Heaney\"",
        "predict": "SELECT count(DISTINCT t3.product_id) FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t1.customer_name  =  \"Rodrick Heaney\"",
        "hardness": "hard"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT count(DISTINCT customer_id) FROM customer_orders WHERE order_status  =  \"Cancelled\"",
        "question": "How many customers have at least one order with status \"Cancelled\"?",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders with status \"Cancelled\". Secondly, we need to count the number of customers who have at least one order with this status.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_id from table 'Customer_Orders' where order_status = \"Cancelled\". Then, we count the distinct customer_ids.\n\n<3> SQL Generation: Use 'where' to filter orders with status \"Cancelled\", and then use 'count' and 'distinct' to count the number of customers.\n\nSQL query: SELECT count(DISTINCT customer_id) FROM customer_orders WHERE order_status  =  \"Cancelled\"",
        "predict": "SELECT count(DISTINCT customer_id) FROM customer_orders WHERE order_status  =  \"Cancelled\"",
        "hardness": "easy"
    },
    {
        "db_id": "customers_and_addresses",
        "gold": "SELECT customer_name FROM customers WHERE payment_method != 'Cash'",
        "question": "What is the name of customers who do not use Cash as payment method.",
        "fields": "Table Addresses, columns = [*,address_id,address_content,city,zip_postcode,state_province_county,country,other_address_details]\nTable Customer_Addresses, columns = [*,customer_id,address_id,date_address_from,address_type,date_address_to]\nTable Customer_Contact_Channels, columns = [*,customer_id,channel_code,active_from_date,active_to_date,contact_number]\nTable Customer_Orders, columns = [*,order_id,customer_id,order_status,order_date,order_details]\nTable Customers, columns = [*,customer_id,payment_method,customer_name,date_became_customer,other_customer_details]\nTable Order_Items, columns = [*,order_id,product_id,order_quantity]\nTable Products, columns = [*,product_id,product_details]\n",
        "foreign_keys": "Foreign_keys = [Customer_Addresses.customer_id = Customers.customer_id,Customer_Addresses.address_id = Addresses.address_id,Customer_Contact_Channels.customer_id = Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Order_Items.order_id = Customer_Orders.order_id,Order_Items.product_id = Products.product_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on customers who do not use Cash as the payment method. We need to select the names of these customers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the customer_name from the Customers table and filter by the payment_method column.\n\n<3> SQL Generation: Use 'where' to filter customers who do not use Cash as the payment method and select their names.\n\nSQL query: SELECT customer_name FROM customers WHERE payment_method != 'Cash'",
        "predict": "SELECT customer_name FROM customers WHERE payment_method != 'Cash'",
        "hardness": "easy"
    },
    {
        "db_id": "roller_coaster",
        "gold": "SELECT Status FROM roller_coaster WHERE LENGTH  >  3300 OR Height  >  100",
        "question": "Show the statuses of roller coasters longer than 3300 or higher than 100.",
        "fields": "Table country, columns = [*,Country_ID,Name,Population,Area,Languages]\nTable roller_coaster, columns = [*,Roller_Coaster_ID,Name,Park,Country_ID,Length,Height,Speed,Opened,Status]\n",
        "foreign_keys": "Foreign_keys = [roller_coaster.Country_ID = country.Country_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter roller coasters based on their length and height. Secondly, we need to show the statuses of the selected roller coasters.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'roller_coaster' table, we only need this table.\n\n<3> SQL Generation: Use 'where' to filter roller coasters based on their length and height, and then select the 'status' column.\n\nSQL query: SELECT Status FROM roller_coaster WHERE LENGTH  >  3300 OR Height  >  100",
        "predict": "SELECT Status FROM roller_coaster WHERE LENGTH  >  3300 OR Height  >  100",
        "hardness": "medium"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "question": "what are the names and classes of the ships that do not have any captain yet?",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding ships that do not have any captain yet. Firstly, we need to identify the ships that have captains. Secondly, we need to filter out the ships that do not have any captain.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Ship_ID from table 'captain' and filter by Ship_ID. Then, we need to select Name and Class from table 'Ship' and filter by Ship_ID.\n\n<3> SQL Generation: Use 'where' to find the Ship_IDs that have captains, and then use 'where' to filter out the ships that do not have any captain. Finally, select the Name and Class of the remaining ships.\n\nSQL query: SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "predict": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "hardness": "extra"
    },
    {
        "db_id": "ship_1",
        "gold": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "question": "Return the names and classes of ships that do not have a captain?",
        "fields": "Table Ship, columns = [*,Ship_ID,Name,Type,Built_Year,Class,Flag]\nTable captain, columns = [*,Captain_ID,Name,Ship_ID,age,Class,Rank]\n",
        "foreign_keys": "Foreign_keys = [captain.Ship_ID = Ship.Ship_ID]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on ships that do not have a captain. Firstly, we need to identify the ships that do not have a captain. Secondly, we need to select the names and classes of those ships.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Ship_ID from table 'captain' and filter by Ship_ID. In the second step, we need to select Name and Class from table 'Ship' and filter by Ship_ID.\n\n<3> SQL Generation: Use 'where' to find the Ship_IDs of ships that do not have a captain, and then use 'where' to select the names and classes of those ships.\n\nSQL query: SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "predict": "SELECT name ,  CLASS FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain)",
        "hardness": "extra"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT count(*) FROM addresses WHERE state_province_county  =  \"Colorado\"",
        "question": "How many cities are there in state \"Colorado\"?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of cities in the state \"Colorado\".\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for cities in a specific state, we need to use the \"Addresses\" table and filter on the \"state_province_county\" column.\n\n<3> SQL Generation: Use the \"where\" clause to filter the rows where the \"state_province_county\" is \"Colorado\", and then use the \"count\" function to count the number of cities.\n\nSQL query: SELECT count(*) FROM addresses WHERE state_province_county  =  \"Colorado\"",
        "predict": "SELECT count(*) FROM addresses WHERE state_province_county  =  \"Colorado\"",
        "hardness": "easy"
    },
    {
        "db_id": "e_government",
        "gold": "SELECT organization_name FROM organizations WHERE organization_name LIKE \"%Party%\"",
        "question": "What are the names of organizations that contain the word \"Party\"?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,town_city,zip_postcode,state_province_county,country]\nTable Forms, columns = [*,form_id,form_type_code,service_id,form_number,form_name,form_description]\nTable Individuals, columns = [*,individual_id,individual_first_name,individual_middle_name,inidividual_phone,individual_email,individual_address,individual_last_name]\nTable Organization_Contact_Individuals, columns = [*,individual_id,organization_id,date_contact_from,date_contact_to]\nTable Organizations, columns = [*,organization_id,date_formed,organization_name,uk_vat_number]\nTable Parties, columns = [*,party_id,payment_method_code,party_phone,party_email]\nTable Party_Addresses, columns = [*,party_id,address_id,date_address_from,address_type_code,date_address_to]\nTable Party_Forms, columns = [*,party_id,form_id,date_completion_started,form_status_code,date_fully_completed]\nTable Party_Services, columns = [*,booking_id,customer_id,service_id,service_datetime,booking_made_date]\nTable Services, columns = [*,service_id,service_type_code,service_name,service_descriptio]\n",
        "foreign_keys": "Foreign_keys = [Forms.service_id = Services.service_id,Organization_Contact_Individuals.individual_id = Individuals.individual_id,Organization_Contact_Individuals.organization_id = Organizations.organization_id,Party_Addresses.party_id = Parties.party_id,Party_Addresses.address_id = Addresses.address_id,Party_Forms.form_id = Forms.form_id,Party_Forms.party_id = Parties.party_id,Party_Services.customer_id = Parties.party_id,Party_Services.service_id = Services.service_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering organizations based on their names containing the word \"Party\". We need to select the names of these organizations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'Organizations' table and the 'organization_name' column.\n\n<3> SQL Generation: Use 'where' to filter organizations whose names contain the word \"Party\" and select their names.\n\nSQL query: SELECT organization_name FROM organizations WHERE organization_name LIKE \"%Party%\"",
        "predict": "SELECT organization_name FROM organizations WHERE organization_name LIKE \"%Party%\"",
        "hardness": "medium"
    },
    {
        "db_id": "school_bus",
        "gold": "SELECT party FROM driver WHERE home_city  =  'Hartford' AND age  >  40",
        "question": "Show the party with drivers from Hartford and drivers older than 40.",
        "fields": "Table driver, columns = [*,Driver_ID,Name,Party,Home_city,Age]\nTable school, columns = [*,School_ID,Grade,School,Location,Type]\nTable school_bus, columns = [*,School_ID,Driver_ID,Years_Working,If_full_time]\n",
        "foreign_keys": "Foreign_keys = [school_bus.Driver_ID = driver.Driver_ID,school_bus.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter drivers based on their home city and age. Secondly, we need to find the party of the selected drivers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Driver_ID from table 'driver' where Home_city = 'Hartford' and Age > 40. In the second step, we need to select Party from table 'driver' based on the Driver_ID obtained in the first step.\n\n<3> SQL Generation: Use 'where' to filter drivers based on their home city and age, and then use 'select' to find the party of the selected drivers.\n\nSQL query: SELECT party FROM driver WHERE home_city  =  'Hartford' AND age  >  40",
        "predict": "SELECT party FROM driver WHERE home_city  =  'Hartford' AND age  >  40",
        "hardness": "medium"
    },
    {
        "db_id": "school_bus",
        "gold": "SELECT name FROM driver WHERE driver_id NOT IN (SELECT driver_id FROM school_bus)",
        "question": "Show the names of the drivers without a school bus.",
        "fields": "Table driver, columns = [*,Driver_ID,Name,Party,Home_city,Age]\nTable school, columns = [*,School_ID,Grade,School,Location,Type]\nTable school_bus, columns = [*,School_ID,Driver_ID,Years_Working,If_full_time]\n",
        "foreign_keys": "Foreign_keys = [school_bus.Driver_ID = driver.Driver_ID,school_bus.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding drivers without a school bus. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'driver' table in this case.\n\n<3> SQL Generation: Use 'where' to filter drivers without a school bus.\n\nSQL query: SELECT name FROM driver WHERE driver_id NOT IN (SELECT driver_id FROM school_bus)",
        "predict": "SELECT name FROM driver WHERE driver_id NOT IN (SELECT driver_id FROM school_bus)",
        "hardness": "hard"
    },
    {
        "db_id": "school_bus",
        "gold": "SELECT school ,  TYPE FROM school WHERE school_id NOT IN (SELECT school_id FROM school_bus)",
        "question": "Show the school name and type for schools without a school bus.",
        "fields": "Table driver, columns = [*,Driver_ID,Name,Party,Home_city,Age]\nTable school, columns = [*,School_ID,Grade,School,Location,Type]\nTable school_bus, columns = [*,School_ID,Driver_ID,Years_Working,If_full_time]\n",
        "foreign_keys": "Foreign_keys = [school_bus.Driver_ID = driver.Driver_ID,school_bus.School_ID = school.School_ID]\n",
        "reasoning": "<1> Decomposition: The query requires finding schools without a school bus. Firstly, we need to identify the schools that have a school bus. Secondly, we need to select the school name and type for schools that do not have a school bus.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'school' and table 'school_bus' have a direct foreign key relationship, we only need these two tables.\n\n<3> SQL Generation: We need to join the 'school' and 'school_bus' tables on the 'School_ID' column. Then, we filter the rows where there is no matching entry in the 'school_bus' table. Finally, we select the school name and type for these schools.\n\nSQL query: SELECT school ,  TYPE FROM school WHERE school_id NOT IN (SELECT school_id FROM school_bus)",
        "predict": "SELECT school ,  TYPE FROM school WHERE school_id NOT IN (SELECT school_id FROM school_bus)",
        "hardness": "extra"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT T3.ssn ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "question": "What are the SSN and names of scientists working on the project with the most hours?",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the project with the most hours. Secondly, we need to find the scientists working on that project and retrieve their SSN and names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the project code with the maximum hours from the 'Projects' table. In the second step, we need to join the 'AssignedTo' and 'Scientists' tables on the project code and scientist SSN, respectively, and retrieve the SSN and names of the scientists.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the project with the most hours, and then join the 'AssignedTo' and 'Scientists' tables on the project code and scientist SSN. Finally, select the SSN and names of the scientists.\n\nSQL query: SELECT T3.ssn ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "predict": "SELECT T3.ssn ,  T3.name FROM assignedto AS T1 JOIN projects AS T2 ON T1.project  =  T2.code JOIN scientists AS T3 ON T1.scientist  =  T3.SSN WHERE T2.hours  =  (SELECT max(hours) FROM projects)",
        "hardness": "extra"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT Name FROM Projects WHERE Code NOT IN (SELECT Project FROM AssignedTo)",
        "question": "Select the project names which are not assigned yet.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: The query requires selecting project names that are not assigned yet. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to select project names, we only need the 'Projects' table.\n\n<3> SQL Generation: Use 'where' to filter projects that are not assigned yet.\n\nSQL query: SELECT Name FROM Projects WHERE Code NOT IN (SELECT Project FROM AssignedTo)",
        "predict": "SELECT Name FROM Projects WHERE Code NOT IN (SELECT Project FROM AssignedTo)",
        "hardness": "hard"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT Name FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "question": "Find the name of scientists who are not assigned to any project.",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: The query requires finding scientists who are not assigned to any project. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the names of scientists from the 'Scientists' table who do not have corresponding entries in the 'AssignedTo' table.\n\n<3> SQL Generation: Use a left join to combine the 'Scientists' and 'AssignedTo' tables on the 'SSN' and 'Scientist' columns, respectively. Then, filter the rows where the 'Project' column is null (indicating that the scientist is not assigned to any project). Finally, select the names of the scientists.\n\nSQL query: SELECT Name FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "predict": "SELECT Name FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "hardness": "hard"
    },
    {
        "db_id": "scientist_1",
        "gold": "SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "question": "How many scientists do not have any projects assigned to them?",
        "fields": "Table AssignedTo, columns = [*,Scientist,Project]\nTable Projects, columns = [*,Code,Name,Hours]\nTable Scientists, columns = [*,SSN,Name]\n",
        "foreign_keys": "Foreign_keys = [AssignedTo.Project = Projects.Code,AssignedTo.Scientist = Scientists.SSN]\n",
        "reasoning": "<1> Decomposition: We need to find scientists who do not have any projects assigned to them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select scientists from the 'Scientists' table and filter out those who have projects assigned to them in the 'AssignedTo' table.\n\n<3> SQL Generation: We can use a left join to combine the 'Scientists' and 'AssignedTo' tables on the 'SSN' column. Then, we can filter out the rows where the 'Project' column is null, indicating that no project is assigned to the scientist. Finally, we can count the number of scientists who meet this condition.\n\nSQL query: SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "predict": "SELECT count(*) FROM scientists WHERE ssn NOT IN (SELECT scientist FROM AssignedTo)",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT DISTINCT Name FROM WINE WHERE YEAR  <  2000 OR YEAR  >  2010",
        "question": "Give the distinct names of wines made before 2000 or after 2010.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines based on their year, selecting wines made before 2000 or after 2010. Secondly, we need to select the distinct names of the filtered wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'Name' column from the 'wine' table, we only need to use the 'wine' table.\n\n<3> SQL Generation: Use 'where' to filter wines based on their year, selecting wines made before 2000 or after 2010. Then, use 'distinct' to select the distinct names of the filtered wines.\n\nSQL query: SELECT DISTINCT Name FROM WINE WHERE YEAR  <  2000 OR YEAR  >  2010",
        "predict": "SELECT DISTINCT Name FROM WINE WHERE YEAR  <  2000 OR YEAR  >  2010",
        "hardness": "medium"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "question": "What are the average prices and cases of wines produced in the year of 2009 and made of Zinfandel grape?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines based on their year and grape. Secondly, we need to calculate the average prices and cases of the selected wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select wines with year = 2009 and grape = 'Zinfandel' from table 'wine'. In the second step, we need to calculate the average prices and cases from table 'wine'.\n\n<3> SQL Generation: Use 'where' to filter wines with year = 2009 and grape = 'Zinfandel', and then use 'avg' to calculate the average prices and cases.\n\nSQL query: SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "predict": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "hardness": "hard"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "question": "Give the average price and case of wines made from Zinfandel grapes in the year 2009.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines based on the grape variety 'Zinfandel' and the year '2009'. Secondly, we need to calculate the average price and case count of the selected wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select price and cases from table 'wine' where grape = 'Zinfandel' and year = 2009.\n\n<3> SQL Generation: Use 'where' to filter wines based on grape and year, and then use 'avg' to calculate the average price and 'sum' to calculate the total cases.\n\nSQL query: SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "predict": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "hardness": "hard"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT Name FROM WINE WHERE YEAR  <  (SELECT min(YEAR) FROM WINE WHERE Winery  =  \"Brander\")",
        "question": "What are the names of wines whose production year are before the year of all wines by Brander winery?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the production year of all wines by Brander winery. Secondly, we need to filter wines whose production year is before the year found in the first step and select their names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select production year from table 'wine' where winery = 'Brander'. In the second step, we need to filter wines based on their production year and select their names from table 'wine'.\n\n<3> SQL Generation: Use 'where' to find the production year of all wines by Brander winery, and then use 'where' to filter wines whose production year is before the year found in the first step and select their names.\n\nSQL query: SELECT Name FROM WINE WHERE YEAR  <  (SELECT min(YEAR) FROM WINE WHERE Winery  =  \"Brander\")",
        "predict": "SELECT Name FROM WINE WHERE YEAR  <  (SELECT min(YEAR) FROM WINE WHERE Winery  =  \"Brander\")",
        "hardness": "hard"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "question": "Find the average price of wines that are not produced from Sonoma county.",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter wines that are not produced from Sonoma county. Secondly, we need to calculate the average price of the selected wines.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'wine' table and the 'appellations' table, we will use these two tables.\n\n<3> SQL Generation: Use 'where' to filter wines that are not produced from Sonoma county, and then use 'avg' to calculate the average price of the selected wines.\n\nSQL query: SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "predict": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "hardness": "extra"
    },
    {
        "db_id": "wine_1",
        "gold": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "question": "What is the average price for wines not produced in Sonoma county?",
        "fields": "Table appellations, columns = [*,No,Appelation,County,State,Area,isAVA]\nTable grapes, columns = [*,ID,Grape,Color]\nTable wine, columns = [*,No,Grape,Winery,Appelation,State,Name,Year,Price,Score,Cases,Drink]\n",
        "foreign_keys": "Foreign_keys = [wine.Appelation = appellations.Appelation,wine.Grape = grapes.Grape]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on wines not produced in Sonoma county. Firstly, we need to identify the wines produced in Sonoma county. Secondly, we need to calculate the average price for wines that are not produced in Sonoma county.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Appelation from table 'appellations' where County = 'Sonoma'. In the second step, we need to filter wines based on their Appelation and calculate the average price.\n\n<3> SQL Generation: Use 'where' to filter wines produced in Sonoma county, and then use 'where' to filter wines that are not produced in Sonoma county and calculate the average price.\n\nSQL query: SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "predict": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "hardness": "extra"
    },
    {
        "db_id": "train_station",
        "gold": "SELECT T2.name FROM train_station AS T1 JOIN train AS T2 ON T1.train_id  =  T2.train_id WHERE T1.station_id NOT IN (SELECT T4.station_id FROM train_station AS T3 JOIN station AS T4 ON T3.station_id  =  T4.station_id WHERE t4.location  =  \"London\")",
        "question": "Find the names of the trains that do not pass any station located in London.",
        "fields": "Table station, columns = [*,Station_ID,Name,Annual_entry_exit,Annual_interchanges,Total_Passengers,Location,Main_Services,Number_of_Platforms]\nTable train, columns = [*,Train_ID,Name,Time,Service]\nTable train_station, columns = [*,Train_ID,Station_ID]\n",
        "foreign_keys": "Foreign_keys = [train_station.Station_ID = station.Station_ID,train_station.Train_ID = train.Train_ID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the stations located in London. Secondly, we need to filter the trains that do not pass any of these stations. Finally, we need to retrieve the names of these trains.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Station_ID from table 'station' where Location = 'London'. We also need to select Train_ID from table 'train_station' and filter by Station_ID.\n\n<3> SQL Generation: Use 'where' to filter stations located in London, and then use 'not in' to filter trains that do not pass any of these stations. Finally, select the names of these trains.\n\nSQL query: SELECT T2.name FROM train_station AS T1 JOIN train AS T2 ON T1.train_id  =  T2.train_id WHERE T1.station_id NOT IN (SELECT T4.station_id FROM train_station AS T3 JOIN station AS T4 ON T3.station_id  =  T4.station_id WHERE t4.location  =  \"London\")",
        "predict": "SELECT T2.name FROM train_station AS T1 JOIN train AS T2 ON T1.train_id  =  T2.train_id WHERE T1.station_id NOT IN (SELECT T4.station_id FROM train_station AS T3 JOIN station AS T4 ON T3.station_id  =  T4.station_id WHERE t4.location  =  \"London\")",
        "hardness": "extra"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT date_joined_staff FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";",
        "question": "When did the staff member with first name as Janessa and last name as Sawayn join the company?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the staff member with first name as Janessa and last name as Sawayn. Secondly, we need to retrieve the date they joined the company.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select date_joined_staff from table 'Staff' where first_name = Janessa and last_name = Sawayn.\n\n<3> SQL Generation: Use 'where' to find the staff member with first name as Janessa and last name as Sawayn, and then select the date they joined the company.\n\nSQL query: SELECT date_joined_staff FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";",
        "predict": "SELECT date_joined_staff FROM Staff WHERE first_name = \"Janessa\" AND last_name = \"Sawayn\";",
        "hardness": "medium"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Rylan\" AND T2.last_name = \"Goodwin\" AND T1.lesson_status_code = \"Completed\";",
        "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with first name 'Rylan' and last name 'Goodwin'. Secondly, we need to filter lessons based on the customer and lesson status code.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where first_name = 'Rylan' and last_name = 'Goodwin'. In the second step, we need to filter lesson_id from table 'Lessons' where customer_id matches the customer found in the first step and lesson_status_code is 'completed'.\n\n<3> SQL Generation: Use 'where' to find the customer with first name 'Rylan' and last name 'Goodwin', and then use 'where' to filter lessons based on the customer and lesson status code. Finally, count the number of lessons that meet these conditions.\n\nSQL query: SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Rylan\" AND T2.last_name = \"Goodwin\" AND T1.lesson_status_code = \"Completed\";",
        "predict": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Rylan\" AND T2.last_name = \"Goodwin\" AND T1.lesson_status_code = \"Completed\";",
        "hardness": "medium"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT count(*) FROM Lessons WHERE lesson_status_code = \"Cancelled\";",
        "question": "How many lessons were in cancelled state?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of lessons in the cancelled state.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the lesson_status_code from the Lessons table.\n\n<3> SQL Generation: Use 'where' to filter lessons with the lesson_status_code = 'cancelled' and count them.\n\nSQL query: SELECT count(*) FROM Lessons WHERE lesson_status_code = \"Cancelled\";",
        "predict": "SELECT count(*) FROM Lessons WHERE lesson_status_code = \"Cancelled\";",
        "hardness": "easy"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT sum(lesson_time) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "question": "How long is the total lesson time taught by staff with first name as Janessa and last name as Sawayn?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the staff with first name 'Janessa' and last name 'Sawayn'. Secondly, we need to calculate the total lesson time taught by these staff.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select staff_id from table 'Staff' where first_name = 'Janessa' and last_name = 'Sawayn'. In the second step, we need to filter lesson_time from table 'Lessons' based on the staff_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the staff with first name 'Janessa' and last name 'Sawayn', and then use 'sum' to calculate the total lesson time taught by these staff.\n\nSQL query: SELECT sum(lesson_time) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "predict": "SELECT sum(lesson_time) FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = \"Janessa\" AND T2.last_name = \"Sawayn\";",
        "hardness": "medium"
    },
    {
        "db_id": "driving_school",
        "gold": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Ray\"",
        "question": "How many lesson does customer with first name Ray took?",
        "fields": "Table Addresses, columns = [*,address_id,line_1_number_building,city,zip_postcode,state_province_county,country]\nTable Customer_Payments, columns = [*,customer_id,datetime_payment,payment_method_code,amount_payment]\nTable Customers, columns = [*,customer_id,customer_address_id,customer_status_code,date_became_customer,date_of_birth,first_name,last_name,amount_outstanding,email_address,phone_number,cell_mobile_phone_number]\nTable Lessons, columns = [*,lesson_id,customer_id,lesson_status_code,staff_id,vehicle_id,lesson_date,lesson_time,price]\nTable Staff, columns = [*,staff_id,staff_address_id,nickname,first_name,middle_name,last_name,date_of_birth,date_joined_staff,date_left_staff]\nTable Vehicles, columns = [*,vehicle_id,vehicle_details]\n",
        "foreign_keys": "Foreign_keys = [Staff.staff_address_id = Addresses.address_id,Customers.customer_address_id = Addresses.address_id,Customer_Payments.customer_id = Customers.customer_id,Lessons.customer_id = Customers.customer_id,Lessons.staff_id = Staff.staff_id,Lessons.vehicle_id = Vehicles.vehicle_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer with first name Ray. Secondly, we need to count the number of lessons taken by that customer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where first_name = 'Ray'. In the second step, we need to count the number of rows in table 'Lessons' where customer_id matches the customer_id found in the first step.\n\n<3> SQL Generation: Use 'where' to find the customer with first name Ray, and then use 'count' to count the number of lessons taken by that customer.\n\nSQL query: SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Ray\"",
        "predict": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = \"Ray\"",
        "hardness": "medium"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT count(*) FROM Faculty WHERE Sex  =  'F' AND Rank  =  \"Professor\"",
        "question": "How many female Professors do we have?",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Decomposition: We need to filter the professors based on their gender.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'Sex' column from the 'Faculty' table.\n\n<3> SQL Generation: Use 'where' to filter the professors based on their gender and count them.\n\nSQL query: SELECT count(*) FROM Faculty WHERE Sex  =  'F' AND Rank  =  \"Professor\"",
        "predict": "SELECT count(*) FROM Faculty WHERE Sex  =  'F' AND Rank  =  \"Professor\"",
        "hardness": "medium"
    },
    {
        "db_id": "activity_1",
        "gold": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  \"Linda\" AND T2.lname  =  \"Smith\"",
        "question": "Who is the advisor of Linda Smith? Give me the first name and last name.",
        "fields": "Table Activity, columns = [*,actid,activity_name]\nTable Faculty, columns = [*,FacID,Lname,Fname,Rank,Sex,Phone,Room,Building]\nTable Faculty_Participates_in, columns = [*,FacID,actid]\nTable Participates_in, columns = [*,stuid,actid]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "foreign_keys": "Foreign_keys = [Participates_in.actid = Activity.actid,Participates_in.stuid = Student.StuID,Faculty_Participates_in.actid = Activity.actid,Faculty_Participates_in.FacID = Faculty.FacID]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the student with the name 'Linda Smith'. Secondly, we need to find the advisor of the student found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Student' where LName = 'Smith' and Fname = 'Linda'. In the second step, we need to select Fname and Lname from table 'Faculty' where FacID is the advisor of the student found in the first step.\n\n<3> SQL Generation: Use 'where' to find the student with the name 'Linda Smith', and then use 'where' to find the advisor of the student and select their first name and last name.\n\nSQL query: SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  \"Linda\" AND T2.lname  =  \"Smith\"",
        "predict": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  \"Linda\" AND T2.lname  =  \"Smith\"",
        "hardness": "extra"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "question": "What is the number of airlines based in Russia?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: We need to filter airlines based on their country, specifically Russia.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airlines' table and the 'country' column.\n\n<3> SQL Generation: Use 'where' to filter airlines based on their country being Russia, and then count the number of rows that meet this condition.\n\nSQL query: SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "predict": "SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "hardness": "easy"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM airports WHERE name LIKE '%International%'",
        "question": "How many airports' names have the word Interanation in them?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on airport names that contain the word \"Interanation\". We need to find the airports with names that match this criteria.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'airports' table and the 'name' column.\n\n<3> SQL Generation: Use the 'LIKE' operator with the '%' wildcard to search for airport names that contain the word \"Interanation\". Then, use the 'COUNT' function to count the number of airports that match this criteria.\n\nSQL query: SELECT count(*) FROM airports WHERE name LIKE '%International%'",
        "predict": "SELECT count(*) FROM airports WHERE name LIKE '%International%'",
        "hardness": "medium"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "question": "In how many cities are there airports in the country of Greenland?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the airports in the country of Greenland. Secondly, we need to count the number of cities where these airports are located.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select apid from table 'airports' where country = 'Greenland'. In the second step, we need to select city from table 'airports' and count the distinct cities.\n\n<3> SQL Generation: Use 'where' to find the airports in the country of Greenland, and then use 'count' and 'distinct' to count the number of cities where these airports are located.\n\nSQL query: SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "predict": "SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "hardness": "easy"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'",
        "question": "What is the number of routes that end at John F Kennedy International Airport?",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: The query requires finding routes that end at John F Kennedy International Airport. We need to filter routes based on their destination airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select routes that have the destination airport ID matching the ID of John F Kennedy International Airport.\n\n<3> SQL Generation: Use 'where' to filter routes based on the destination airport ID matching the ID of John F Kennedy International Airport.\n\nSQL query: SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'",
        "predict": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'",
        "hardness": "medium"
    },
    {
        "db_id": "flight_4",
        "gold": "SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "question": "Find the number of routes from the United States to Canada.",
        "fields": "Table airlines, columns = [*,alid,name,iata,icao,callsign,country,active]\nTable airports, columns = [*,apid,name,city,country,x,y,elevation,iata,icao]\nTable routes, columns = [*,rid,dst_apid,dst_ap,src_apid,src_ap,alid,airline,codeshare]\n",
        "foreign_keys": "Foreign_keys = [routes.alid = airlines.alid,routes.src_apid = airports.apid,routes.dst_apid = airports.apid]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the airports in the United States and Canada. Secondly, we need to filter routes based on their source and destination airports.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select apid from table 'airports' where country = 'United States' or country = 'Canada'. In the second step, we need to filter routes based on src_apid and dst_apid from table 'routes'.\n\n<3> SQL Generation: Use 'where' to filter airports in the United States and Canada, and then use 'where' to filter routes based on their source and destination airports. Finally, count the number of routes that meet these conditions.\n\nSQL query: SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "predict": "SELECT count(*) FROM routes WHERE dst_apid IN (SELECT apid FROM airports WHERE country  =  'Canada') AND src_apid IN (SELECT apid FROM airports WHERE country  =  'United States')",
        "hardness": "extra"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T2.order_id ,  T2.order_status FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "question": "Give me a list of id and status of orders which belong to the customer named \"Jeramie\".",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of the customer named \"Jeramie\". Secondly, we need to filter orders based on their customer_id and select the id and status columns.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_name = \"Jeramie\". In the second step, we need to filter order_id and order_status from table 'Orders' based on the customer_id.\n\n<3> SQL Generation: Use 'where' to find the customer_id of the customer named \"Jeramie\", and then use 'where' to filter orders based on their customer_id and select the id and status columns.\n\nSQL query: SELECT T2.order_id ,  T2.order_status FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "predict": "SELECT T2.order_id ,  T2.order_status FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T2.date_order_placed FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "question": "Find the dates of orders which belong to the customer named \"Jeramie\".",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the customer_id of the customer named \"Jeramie\". Secondly, we need to filter orders based on their customer_id and select the dates of those orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select customer_id from table 'Customers' where customer_name = \"Jeramie\". In the second step, we need to filter order_id and date_order_placed from table 'Orders'.\n\n<3> SQL Generation: Use 'where' to find the customer_id of the customer named \"Jeramie\", and then use 'where' to filter orders based on their customer_id and select the dates of those orders.\n\nSQL query: SELECT T2.date_order_placed FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "predict": "SELECT T2.date_order_placed FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T1.customer_name = \"Jeramie\"",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.date_order_placed >= \"2009-01-01\" AND T2.date_order_placed <= \"2010-01-01\"",
        "question": "Give me the names of customers who have placed orders between 2009-01-01 and 2010-01-01.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders based on their date_order_placed column, selecting only orders placed between 2009-01-01 and 2010-01-01. Secondly, we need to retrieve the names of the customers who placed these orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select customer_name from the Customers table and filter orders based on the date_order_placed column in the Orders table.\n\n<3> SQL Generation: Use 'where' to filter orders placed between 2009-01-01 and 2010-01-01, and then join the Orders and Customers tables on the customer_id column to retrieve the customer names.\n\nSQL query: SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.date_order_placed >= \"2009-01-01\" AND T2.date_order_placed <= \"2010-01-01\"",
        "predict": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id WHERE T2.date_order_placed >= \"2009-01-01\" AND T2.date_order_placed <= \"2010-01-01\"",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT DISTINCT T2.product_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id WHERE T1.date_order_placed >= \"1975-01-01\" AND T1.date_order_placed <= \"1976-01-01\"",
        "question": "Give me a list of distinct product ids from orders placed between 1975-01-01 and 1976-01-01?",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter orders based on the date_order_placed column between 1975-01-01 and 1976-01-01. Secondly, we need to select distinct product_ids from the filtered orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select product_id from the Order_Items table and filter by the order_id from the Orders table.\n\n<3> SQL Generation: Use 'where' to filter orders placed between 1975-01-01 and 1976-01-01, and then use 'distinct' to select unique product_ids from the filtered orders.\n\nSQL query: SELECT DISTINCT T2.product_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id WHERE T1.date_order_placed >= \"1975-01-01\" AND T1.date_order_placed <= \"1976-01-01\"",
        "predict": "SELECT DISTINCT T2.product_id FROM orders AS T1 JOIN order_items AS T2 ON T1.order_id = T2.order_id WHERE T1.date_order_placed >= \"1975-01-01\" AND T1.date_order_placed <= \"1976-01-01\"",
        "hardness": "medium"
    },
    {
        "db_id": "tracking_orders",
        "gold": "SELECT order_id FROM shipments WHERE shipment_date > \"2000-01-01\"",
        "question": "Find the ids of orders which are shipped after 2000-01-01.",
        "fields": "Table Customers, columns = [*,customer_id,customer_name,customer_details]\nTable Invoices, columns = [*,invoice_number,invoice_date,invoice_details]\nTable Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status,order_item_details]\nTable Orders, columns = [*,order_id,customer_id,order_status,date_order_placed,order_details]\nTable Products, columns = [*,product_id,product_name,product_details]\nTable Shipment_Items, columns = [*,shipment_id,order_item_id]\nTable Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date,other_shipment_details]\n",
        "foreign_keys": "Foreign_keys = [Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipments.order_id = Orders.order_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id]\n",
        "reasoning": "<1> Decomposition: The query requires filtering on orders that are shipped after a specific date. Firstly, we need to identify the orders that meet this condition. Secondly, we need to select the order ids of these orders.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select order_id from table 'Orders' and filter by shipment_date from table 'Shipments'.\n\n<3> SQL Generation: Use 'where' to filter orders that are shipped after 2000-01-01 and select the order ids.\n\nSQL query: SELECT order_id FROM shipments WHERE shipment_date > \"2000-01-01\"",
        "predict": "SELECT order_id FROM shipments WHERE shipment_date > \"2000-01-01\"",
        "hardness": "easy"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT count(*) FROM architect WHERE gender  =  'female'",
        "question": "How many architects are female?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: The query requires counting the number of female architects.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'architect' table and the 'gender' column.\n\n<3> SQL Generation: Use 'where' to filter architects with gender = 'female' and count them.\n\nSQL query: SELECT count(*) FROM architect WHERE gender  =  'female'",
        "predict": "SELECT count(*) FROM architect WHERE gender  =  'female'",
        "hardness": "easy"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT name ,  built_year FROM mill WHERE TYPE  =  'Grondzeiler'",
        "question": "What are the names and year of construction for the mills of 'Grondzeiler' type?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter mills based on their type, specifically 'Grondzeiler'. Secondly, we need to select the names and construction years of the filtered mills.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'mill' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter mills of type 'Grondzeiler', and then select the names and construction years of the filtered mills.\n\nSQL query: SELECT name ,  built_year FROM mill WHERE TYPE  =  'Grondzeiler'",
        "predict": "SELECT name ,  built_year FROM mill WHERE TYPE  =  'Grondzeiler'",
        "hardness": "medium"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT LOCATION FROM bridge WHERE name  =  'Kolob Arch' OR name  =  'Rainbow Bridge'",
        "question": "What is the location of the bridge named 'Kolob Arch' or 'Rainbow Bridge'?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the bridges with names 'Kolob Arch' or 'Rainbow Bridge'. Secondly, we need to find the location of these bridges.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are only interested in the location of the bridges, we only need the 'bridge' table.\n\n<3> SQL Generation: Use 'where' to filter bridges with names 'Kolob Arch' or 'Rainbow Bridge' and select their locations.\n\nSQL query: SELECT LOCATION FROM bridge WHERE name  =  'Kolob Arch' OR name  =  'Rainbow Bridge'",
        "predict": "SELECT LOCATION FROM bridge WHERE name  =  'Kolob Arch' OR name  =  'Rainbow Bridge'",
        "hardness": "medium"
    },
    {
        "db_id": "architecture",
        "gold": "SELECT DISTINCT T1.name FROM mill AS T1 JOIN architect AS t2 ON T1.architect_id  =  T2.id JOIN bridge AS T3 ON T3.architect_id  =  T2.id WHERE T3.length_meters  >  80",
        "question": "What are the distinct name of the mills built by the architects who have also built a bridge longer than 80 meters?",
        "fields": "Table architect, columns = [*,id,name,nationality,gender]\nTable bridge, columns = [*,architect_id,id,name,location,length_meters,length_feet]\nTable mill, columns = [*,architect_id,id,location,name,type,built_year,notes]\n",
        "foreign_keys": "Foreign_keys = [bridge.architect_id = architect.id,mill.architect_id = architect.id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to find the architects who have built a bridge longer than 80 meters. Secondly, we need to find the mills built by these architects and select their distinct names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select architect_id from table 'bridge' where length_meters > 80. In the second step, we need to filter architect_id and name from table 'mill' and select distinct names.\n\n<3> SQL Generation: Use 'where' to find the architect_ids of the architects who have built a bridge longer than 80 meters. Then, use 'where' to filter mills built by these architects and select their distinct names.\n\nSQL query: SELECT DISTINCT T1.name FROM mill AS T1 JOIN architect AS t2 ON T1.architect_id  =  T2.id JOIN bridge AS T3 ON T3.architect_id  =  T2.id WHERE T3.length_meters  >  80",
        "predict": "SELECT DISTINCT T1.name FROM mill AS T1 JOIN architect AS t2 ON T1.architect_id  =  T2.id JOIN bridge AS T3 ON T3.architect_id  =  T2.id WHERE T3.length_meters  >  80",
        "hardness": "hard"
    },
    {
        "db_id": "culture_company",
        "gold": "SELECT avg(budget_million) ,  max(budget_million) ,  min(budget_million) FROM movie WHERE YEAR  <  2000",
        "question": "What is the average, maximum, and minimum budget for all movies before 2000.",
        "fields": "Table book_club, columns = [*,book_club_id,Year,Author_or_Editor,Book_Title,Publisher,Category,Result]\nTable culture_company, columns = [*,Company_name,Type,Incorporated_in,Group_Equity_Shareholding,book_club_id,movie_id]\nTable movie, columns = [*,movie_id,Title,Year,Director,Budget_million,Gross_worldwide]\n",
        "foreign_keys": "Foreign_keys = [culture_company.movie_id = movie.movie_id,culture_company.book_club_id = book_club.book_club_id]\n",
        "reasoning": "<1> Decomposition: Firstly, we need to filter movies based on their release year. Secondly, we need to calculate the average, maximum, and minimum budget for the selected movies.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the 'movie' table, we can directly use it.\n\n<3> SQL Generation: Use 'where' to filter movies released before 2000, and then use 'avg', 'max', and 'min' functions to calculate the average, maximum, and minimum budget.\n\nSQL query: SELECT avg(budget_million) ,  max(budget_million) ,  min(budget_million) FROM movie WHERE YEAR  <  2000",
        "predict": "SELECT avg(budget_million) ,  max(budget_million) ,  min(budget_million) FROM movie WHERE YEAR  <  2000",
        "hardness": "medium"
    }
]