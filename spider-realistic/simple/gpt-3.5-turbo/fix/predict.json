[{"db_id": "concert_singer", "gold": "SELECT name ,  country ,  age FROM singer ORDER BY age DESC", "question": "Show name, country, age for all singers from the oldest to the youngest.", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the name, country, and age of all singers, sorted from the oldest to the youngest. We need to select these columns from the 'singer' table and order them by the 'age' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'singer' table for this query.\n\n<3> SQL Generation: We select the 'Name', 'Country', and 'Age' columns from the 'singer' table and order them by the 'Age' column in ascending order.\n\n", "predict": "SELECT Name, Country, Age FROM singer ORDER BY Age ASC"}, {"db_id": "concert_singer", "gold": "SELECT avg(age) ,  min(age) ,  max(age) FROM singer WHERE country  =  'France'", "question": "What is the average, minimum, and maximum age for all French singers?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to filter the French singers from the 'singer' table. Then, we can calculate the average, minimum, and maximum age of these singers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'singer' table for this query.\n\n<3> SQL Generation: We use the 'WHERE' clause to filter the rows where the 'Country' column is 'France'. Then, we use the 'AVG', 'MIN', and 'MAX' functions to calculate the average, minimum, and maximum age of the selected singers.\n\n", "predict": "SELECT AVG(Age), MIN(Age), MAX(Age) FROM singer WHERE Country = 'France'"}, {"db_id": "concert_singer", "gold": "SELECT avg(age) ,  min(age) ,  max(age) FROM singer WHERE country  =  'France'", "question": "What is the average, minimum, and maximum age for all French singers?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to filter the French singers from the 'singer' table. Then, we can calculate the average, minimum, and maximum age of these singers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'singer' table for this query.\n\n<3> SQL Generation: We use the 'WHERE' clause to filter the rows where the 'Country' column is 'France'. Then, we use the 'AVG', 'MIN', and 'MAX' functions to calculate the average, minimum, and maximum age of the selected singers.\n\n", "predict": "SELECT AVG(Age), MIN(Age), MAX(Age) FROM singer WHERE Country = 'France'"}, {"db_id": "concert_singer", "gold": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1", "question": "What are the names and release years for all the songs of the youngest singer?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest singer. Secondly, we need to retrieve the names and release years of all the songs by that singer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the singer with the minimum age from the table 'singer'. In the second step, we need to retrieve the song names and release years from the table 'singer' based on the singer ID.\n\n<3> SQL Generation: Use 'order by' and 'asc' to select the singer with the minimum age, and then use the singer ID to retrieve the song names and release years from the table 'singer'.\n\n", "predict": "\nSELECT Name, Song_release_year \nFROM singer \nWHERE Age = (SELECT MIN(Age) FROM singer)"}, {"db_id": "concert_singer", "gold": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1", "question": "What are the names and release years for all the songs of the youngest singer?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest singer. Secondly, we need to retrieve the names and release years of all the songs by that singer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the singer with the minimum age from the table 'singer'. In the second step, we need to retrieve the song names and release years from the table 'singer' based on the singer ID.\n\n<3> SQL Generation: Use 'order by' and 'asc' to select the singer with the minimum age, and then use the singer ID to retrieve the song names and release years from the table 'singer'.\n\n", "predict": "\nSELECT Name, Song_release_year \nFROM singer \nWHERE Age = (SELECT MIN(Age) FROM singer)"}, {"db_id": "concert_singer", "gold": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)", "question": "What are the number of concerts that occurred in the stadium with space for the most people?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the stadium with the highest capacity. Secondly, we need to filter concerts based on the stadium they occurred in and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the stadium_id with the highest capacity from the 'stadium' table. In the second step, we need to filter the stadium_id from the 'concert' table and count the number of concerts.\n\n<3> SQL Generation: We can use the 'ORDER BY' and 'DESC' keywords to select the stadium with the highest capacity, and then use the 'WHERE' clause to filter the concerts based on the stadium_id and count them.\n\n", "predict": "SELECT COUNT(*) FROM concert WHERE stadium_id = (SELECT stadium_id FROM stadium ORDER BY capacity DESC LIMIT 1)"}, {"db_id": "concert_singer", "gold": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)", "question": "What are the number of concerts that occurred in the stadium with space for the most people?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the stadium with the highest capacity. Secondly, we need to filter concerts based on the stadium they occurred in and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the stadium_id with the highest capacity from the 'stadium' table. In the second step, we need to filter the stadium_id from the 'concert' table and count the number of concerts.\n\n<3> SQL Generation: We can use the 'ORDER BY' and 'DESC' keywords to select the stadium with the highest capacity, and then use the 'WHERE' clause to filter the concerts based on the stadium_id and count them.\n\n", "predict": "\nSELECT COUNT(*) FROM concert WHERE stadium_id = (SELECT stadium_id FROM stadium ORDER BY capacity DESC LIMIT 1)"}, {"db_id": "pets_1", "gold": "SELECT weight FROM pets ORDER BY pet_age LIMIT 1", "question": "How much does the youngest dog weigh?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest dog. Secondly, we need to retrieve its weight.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Has_Pet', 'Pets'].\n\n<3> SQL Generation: We join the 'Has_Pet' and 'Pets' tables on the 'PetID' column. Then, we filter the rows where 'PetType' is 'dog' and find the minimum value of 'pet_age'. Finally, we retrieve the 'weight' column for the row that matches the youngest dog.\n\n", "predict": "SELECT weight FROM Has_Pet AS T1 JOIN Pets AS T2 ON T1.PetID = T2.PetID WHERE T2.PetType = 'dog' AND T2.pet_age = (SELECT MIN(pet_age) FROM Pets WHERE PetType = 'dog')"}, {"db_id": "pets_1", "gold": "SELECT weight FROM pets ORDER BY pet_age LIMIT 1", "question": "How much does the youngest dog weigh?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest dog. Secondly, we need to retrieve its weight.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Has_Pet', 'Pets'].\n\n<3> SQL Generation: We join the 'Has_Pet' and 'Pets' tables on the 'PetID' column. Then, we filter the rows where 'PetType' is 'dog' and find the minimum value of 'pet_age'. Finally, we retrieve the 'weight' column for the row that matches the youngest dog.\n\n", "predict": "SELECT weight FROM Has_Pet AS T1 JOIN Pets AS T2 ON T1.PetID = T2.PetID WHERE T2.PetType = 'dog' AND T2.pet_age = (SELECT MIN(pet_age) FROM Pets WHERE PetType = 'dog')"}, {"db_id": "pets_1", "gold": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1", "question": "What type of pet is the youngest animal, and how much does it weigh?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest animal by selecting the minimum value of 'pet_age' from table 'Pets'. Secondly, we need to identify the type of pet and its weight.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Pets'].\n\n<3> SQL Generation: We select the 'PetType' and 'weight' columns from table 'Pets' where 'pet_age' is equal to the minimum value of 'pet_age' in the table.\n\n", "predict": "SELECT PetType, weight FROM Pets WHERE pet_age = (SELECT MIN(pet_age) FROM Pets)"}, {"db_id": "pets_1", "gold": "SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1", "question": "What type of pet is the youngest animal, and how much does it weigh?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest animal based on its age. Secondly, we need to determine the type of pet and its weight.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Has_Pet', 'Pets'] to find the youngest animal and its type, and table 'Pets' to find its weight.\n\n<3> SQL Generation: We can join the 'Has_Pet' and 'Pets' tables on the 'PetID' column. Then, we can filter the rows to find the animal with the minimum 'pet_age'. Finally, we can select the 'PetType' and 'weight' columns for the youngest animal.\n\n", "predict": "SELECT T2.PetType, T2.weight FROM Has_Pet AS T1 JOIN Pets AS T2 ON T1.PetID = T2.PetID WHERE T2.pet_age = (SELECT MIN(pet_age) FROM Pets)"}, {"db_id": "car_1", "gold": "SELECT Count(*) ,  T2.FullName ,  T2.id FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id GROUP BY T2.id;", "question": "What is the number of car models that are produced by each company and what is the id and full name of each maker?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to count the number of car models produced by each company. Secondly, we need to retrieve the id and full name of each car maker.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. To count the number of car models produced by each company, we need to use tables ['car_makers', 'model_list']. To retrieve the id and full name of each car maker, we need to use table ['car_makers'].\n\n<3> Operation: To count the number of car models produced by each company, we need to perform a 'GROUP BY' operation on the column 'Maker' in table 'model_list'. \n\n<4> SQL Generation: Use 'count' operation to count the number of car models produced by each company, and select the 'Id' and 'FullName' columns from table 'car_makers'.\n\n", "predict": "SELECT car_makers.Id, car_makers.FullName, COUNT(model_list.ModelId) FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker GROUP BY car_makers.Id, car_makers.FullName"}, {"db_id": "car_1", "gold": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;", "question": "What are the names and ids of all nations with at least one car maker?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the nations with at least one car maker. Secondly, we need to retrieve the names and ids of these nations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['countries', 'car_makers'].\n\n<3> SQL Generation: We can use the 'INNER JOIN' operation to join the 'countries' and 'car_makers' tables on the 'CountryId' and 'Id' columns respectively. Then, we can select the 'CountryName' and 'CountryId' columns from the 'countries' table.\n\n", "predict": "SELECT CountryName, CountryId FROM countries INNER JOIN car_makers ON countries.CountryId = car_makers.Country"}, {"db_id": "car_1", "gold": "SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;", "question": "What are the names and ids of all nations with at least one car maker?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the nations with at least one car maker. Secondly, we need to retrieve the names and ids of these nations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['countries', 'car_makers'].\n\n<3> SQL Generation: We can use the 'INNER JOIN' operation to join the 'countries' and 'car_makers' tables on the 'CountryId' and 'Id' columns respectively. Then, we can select the 'CountryName' and 'CountryId' columns from the 'countries' table.\n\n", "predict": "SELECT CountryName, CountryId FROM countries INNER JOIN car_makers ON countries.CountryId = car_makers.Country"}, {"db_id": "car_1", "gold": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;", "question": "What is the car wmodel that is the most fuel efficient?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the car model that is the most fuel efficient. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['car_makers', 'car_names', 'cars_data'].\n\n<3> Operation: Since we are looking for the most fuel efficient car model, we need to find the maximum value of the 'MPG' column in the 'cars_data' table.\n\n<4> SQL Generation: We can use the 'MAX' function to find the maximum value of 'MPG' in the 'cars_data' table. Then, we can join the necessary tables and filter the rows where 'MPG' is equal to the maximum value.\n\n", "predict": "SELECT T2.Model FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId JOIN model_list AS T3 ON T2.Model = T3.Model WHERE T1.MPG = (SELECT MAX(MPG) FROM cars_data)"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;", "question": "In 1980, how many cars were made?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: In this step, we need to filter the cars based on the year they were made, specifically in 1980. Then, we need to count the number of cars that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['cars_data'].\n\n<3> SQL Generation: We filter the rows in the 'cars_data' table where the 'Year' column is equal to 1980. Then, we count the number of rows that meet this condition.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Year = 1980"}, {"db_id": "car_1", "gold": "SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;", "question": "In 1980, how many cars were made?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to filter cars based on their production year. Secondly, we need to count the number of cars that were made in 1980.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['cars_data'] to filter cars based on production year.\n\n<3> SQL Generation: We need to filter the rows where the 'Year' column is equal to 1980, and then count the number of rows that meet this condition.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Year = 1980"}, {"db_id": "flight_2", "gold": "SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  \"USA\"", "question": "What are the airline names and abbreviations for airlines in the USA?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "", "predict": "SELECT Airline, Abbreviation FROM airlines WHERE Country = 'USA'"}, {"db_id": "flight_2", "gold": "SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  \"USA\"", "question": "What are the airline names and abbreviations for airlines in the USA?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "reasoning": "", "predict": "SELECT Airline, Abbreviation FROM airlines WHERE Country = 'USA'"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT name FROM employee ORDER BY age", "question": "List the names of employees and sort from youngest to oldest", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "", "predict": "SELECT Name FROM employee ORDER BY Age ASC"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT name FROM employee ORDER BY age", "question": "List the names of employees and sort from youngest to oldest", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "", "predict": "SELECT Name FROM employee ORDER BY Age ASC"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT manager_name ,  district FROM shop ORDER BY number_products DESC LIMIT 1", "question": "What are the manager name and district of the shop that sells the most merchandise?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the shop that sells the most merchandise. Secondly, we need to find the manager name and district of that shop.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['shop'] to find the shop that sells the most merchandise, and then use the same table to find the manager name and district.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the shop that sells the most merchandise, and then select the manager name and district of that shop.\n\n", "predict": "\nSELECT Manager_name, District \nFROM shop \nWHERE Number_products = (SELECT MAX(Number_products) FROM shop)"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT manager_name ,  district FROM shop ORDER BY number_products DESC LIMIT 1", "question": "What are the manager name and district of the shop that sells the most merchandise?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the shop that sells the most merchandise. Secondly, we need to find the manager name and district of that shop.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['shop'] to find the shop that sells the most merchandise, and then use the same table to find the manager name and district.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the shop that sells the most merchandise, and then select the manager name and district of that shop.\n\n", "predict": "\nSELECT Manager_name, District \nFROM shop \nWHERE Number_products = (SELECT MAX(Number_products) FROM shop)"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT name ,  LOCATION ,  district FROM shop ORDER BY number_products DESC", "question": "Sort all the shops by amount of merchandise in descending order, and return the name, location and district of each shop.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to sort the shops by the amount of merchandise in descending order. Secondly, we need to return the name, location, and district of each shop.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query. We need to use the 'shop' table to get the name, location, and district of each shop, and the 'Number_products' column to sort the shops.\n\n<3> SQL Generation: We will use the 'ORDER BY' clause to sort the shops by the 'Number_products' column in descending order, and then select the 'Name', 'Location', and 'District' columns from the 'shop' table.\n\n", "predict": "SELECT Name, Location, District FROM shop ORDER BY Number_products DESC"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT name ,  LOCATION ,  district FROM shop ORDER BY number_products DESC", "question": "Sort all the shops by amount of merchandise in descending order, and return the name, location and district of each shop.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to sort the shops by the amount of merchandise in descending order. Secondly, we need to return the name, location, and district of each shop.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query. We need to use the table 'shop' to get the name, location, and district, and the table 'shop' to get the amount of merchandise.\n\n<3> SQL Generation: We need to join the 'shop' and 'hiring' tables on the 'Shop_ID' column. Then, we can select the name, location, and district from the 'shop' table and order by the 'Number_products' column in descending order.\n\n", "predict": "SELECT Name, Location, District FROM shop ORDER BY Number_products DESC"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1", "question": "Which employee received the biggest incentive? Give me the employee name.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the employee who received the biggest incentive. Secondly, we need to select the name of the employee.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['employee', 'evaluation'].\n\n<3> SQL Generation: We need to join the 'employee' and 'evaluation' tables on the 'Employee_ID' column. Then, we need to select the employee with the maximum 'Bonus' and retrieve their name.\n\n", "predict": "SELECT Name FROM employee WHERE Employee_ID = (SELECT Employee_ID FROM evaluation ORDER BY Bonus DESC LIMIT 1)"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1", "question": "Which employee received the biggest incentive? Give me the employee name.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the employee who received the biggest incentive. Secondly, we need to retrieve the name of that employee.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['employee', 'evaluation'].\n\n<3> SQL Generation: We can use the 'MAX' function to find the maximum value of the 'Bonus' column in the 'evaluation' table. Then, we can join the 'employee' and 'evaluation' tables on the 'Employee_ID' column and filter the rows where the 'Bonus' column is equal to the maximum value. Finally, we select the 'Name' column from the 'employee' table.\n\n", "predict": "SELECT Name FROM employee JOIN evaluation ON employee.Employee_ID = evaluation.Employee_ID WHERE Bonus = (SELECT MAX(Bonus) FROM evaluation)"}, {"db_id": "course_teach", "gold": "SELECT Name FROM teacher ORDER BY Age ASC", "question": "What are the names of the teachers  from youngest to oldest?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to retrieve the names of the teachers. Secondly, we need to sort the teachers based on their age in ascending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['teacher'] to retrieve the names and ages of the teachers.\n\n<3> SQL Generation: We select the 'Name' column from the 'teacher' table and order the results by the 'Age' column in ascending order.\n\n", "predict": "SELECT Name FROM teacher ORDER BY Age ASC"}, {"db_id": "course_teach", "gold": "SELECT Name FROM teacher ORDER BY Age ASC", "question": "What are the names of the teachers  from youngest to oldest?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to retrieve the names of the teachers. Secondly, we need to sort the teachers based on their age in ascending order.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['teacher'] to retrieve the names and ages of the teachers.\n\n<3> SQL Generation: We select the 'Name' column from the 'teacher' table and order the results by the 'Age' column in ascending order.\n\n", "predict": "SELECT Name FROM teacher ORDER BY Age ASC"}, {"db_id": "museum_visit", "gold": "SELECT name FROM museum WHERE Museum_ID NOT IN (SELECT museum_id FROM visit)", "question": "What is the name of the museum that had no person come yet?", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the museums that had visitors. Secondly, we need to filter out the museums that had no visitors. Finally, we need to select the name of the museum.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['museum', 'visit'].\n\n<3> SQL Generation: We can use a 'LEFT JOIN' operation to combine the 'museum' and 'visit' tables on the 'Museum_ID' column. Then, we filter the rows where the 'visitor_ID' is null, indicating that no visitors have come to the museum. Finally, we select the 'Name' column from the 'museum' table.\n\n", "predict": "SELECT Name FROM museum LEFT JOIN visit ON museum.Museum_ID = visit.Museum_ID WHERE visitor_ID IS NULL"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1", "question": "What is the first name and country code of the oldest player?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the oldest player based on their birth date. Secondly, we need to retrieve the first name and country code of the oldest player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['players'] to retrieve the first name and country code, and we also need to use the 'birth_date' column from this table to find the oldest player.\n\n<3> SQL Generation: We can use the 'MIN' function on the 'birth_date' column to find the oldest player, and then retrieve the corresponding first name and country code.\n\n", "predict": "SELECT first_name, country_code FROM players WHERE birth_date = (SELECT MIN(birth_date) FROM players)"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1", "question": "What is the first name and country code of the oldest player?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the oldest player based on their birth date. Secondly, we need to retrieve the first name and country code of the oldest player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use table 'players' to retrieve the first name and country code of the oldest player.\n\n<3> Operation: We need to find the oldest player, so we should use the 'MIN' operation on the 'birth_date' column in table 'players'.\n\n<4> SQL Generation: Use 'MIN' operation on 'birth_date' column in table 'players' to find the oldest player, and then select the 'first_name' and 'country_code' columns for the oldest player.\n\n", "predict": "SELECT first_name, country_code FROM players WHERE birth_date = (SELECT MIN(birth_date) FROM players)"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  last_name FROM players ORDER BY birth_date", "question": "What are the full names of all players, sorted by age?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the 'players' table to get the full names of the players.\n\n<2> SQL Generation: We need to select the 'first_name' and 'last_name' columns from the 'players' table and order them by the 'birth_date' column in ascending order.\n\n", "predict": "SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM players ORDER BY birth_date ASC"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  last_name FROM players ORDER BY birth_date", "question": "What are the full names of all players, sorted by age?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use the 'players' table to get the full names of the players.\n\n<2> SQL Generation: We need to select the 'first_name' and 'last_name' columns from the 'players' table and order the results by the 'birth_date' column in ascending order.\n\n", "predict": "SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM players ORDER BY birth_date ASC"}, {"db_id": "wta_1", "gold": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1", "question": "What are the names of the winner and loser who played in the longest match?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the longest match by selecting the maximum value of the 'minutes' column from the 'matches' table. Secondly, we need to retrieve the names of the winner and loser who played in that match.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['matches', 'players'] to retrieve the names of the winner and loser.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the match with the longest duration, and then use 'join' to retrieve the names of the winner and loser based on their respective player IDs.\n\n", "predict": "\nSELECT p1.first_name AS winner_first_name, p1.last_name AS winner_last_name, p2.first_name AS loser_first_name, p2.last_name AS loser_last_name\nFROM matches AS m\nJOIN players AS p1 ON m.winner_id = p1.player_id\nJOIN players AS p2 ON m.loser_id = p2.player_id\nWHERE m.minutes = (SELECT MAX(minutes) FROM matches)"}, {"db_id": "wta_1", "gold": "SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1", "question": "What are the names of the winner and loser who played in the longest match?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the longest match by selecting the maximum value of the 'minutes' column from the 'matches' table. Secondly, we need to retrieve the names of the winner and loser who played in that match.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['matches', 'players'] to retrieve the names of the winner and loser.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the match with the longest duration, and then use 'join' to retrieve the names of the winner and loser based on their respective player IDs.\n\n", "predict": "\nSELECT p1.first_name AS winner_first_name, p1.last_name AS winner_last_name, p2.first_name AS loser_first_name, p2.last_name AS loser_last_name\nFROM matches AS m\nJOIN players AS p1 ON m.winner_id = p1.player_id\nJOIN players AS p2 ON m.loser_id = p2.player_id\nWHERE m.minutes = (SELECT MAX(minutes) FROM matches)"}, {"db_id": "wta_1", "gold": "SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3", "question": "What are the names and ranks of the three youngest victors across all matches?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the three youngest victors across all matches. Secondly, we need to retrieve their names and ranks.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['matches', 'players', 'rankings'].\n\n<3> Operation: We need to filter the matches where the player is the winner, calculate their age, and sort them in ascending order. Then, we select the top three records.\n\n<4> SQL Generation: Use 'JOIN' operation to connect the tables based on the foreign key relationships. Use 'WHERE' clause to filter the matches where the player is the winner. Use 'DATEDIFF' function to calculate the age of the players. Use 'ORDER BY' and 'LIMIT' to select the top three youngest victors. Finally, select the names and ranks of the selected players.\n\n", "predict": "\nSELECT T2.first_name, T2.last_name, T3.ranking\nFROM matches AS T1\nJOIN players AS T2 ON T1.winner_id = T2.player_id\nJOIN rankings AS T3 ON T2.player_id = T3.player_id\nWHERE T1.winner_age IS NOT NULL\nORDER BY T1.winner_age ASC\nLIMIT 3"}, {"db_id": "wta_1", "gold": "SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3", "question": "What are the names and ranks of the three youngest victors across all matches?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the three youngest victors across all matches. Secondly, we need to retrieve their names and ranks.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['matches', 'players', 'rankings'].\n\n<3> Operation: We need to filter the matches where the player is the winner, calculate their age, and sort them in ascending order. Then, we select the top three records.\n\n<4> SQL Generation: Use 'JOIN' operation to connect the tables based on the foreign key relationships. Use 'WHERE' clause to filter the matches where the player is the winner. Use 'DATEDIFF' function to calculate the age of the players. Use 'ORDER BY' and 'LIMIT' to select the top three youngest victors. Finally, select the names and ranks of the selected players.\n\n", "predict": "\nSELECT T2.first_name, T2.last_name, T3.ranking\nFROM matches AS T1\nJOIN players AS T2 ON T1.winner_id = T2.player_id\nJOIN rankings AS T3 ON T2.player_id = T3.player_id\nWHERE T1.winner_age IS NOT NULL\nORDER BY T1.winner_age ASC\nLIMIT 3"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1", "question": "Who is the student register earliest? List the first name, middle name and last name.", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires finding the student who registered earliest, so we should apply the 'min' operation to the column 'date_first_registered' in the table 'Students'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since the query only requires information from the 'Students' table, we only need to use the 'Students' table.\n\n<3> SQL Generation: The query requires the first name, middle name, and last name of the student who registered earliest, so we should select these columns from the 'Students' table. We also need to order the result by the 'date_first_registered' column in ascending order and limit the result to 1 row.\n\n", "predict": "SELECT first_name, middle_name, last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1", "question": "What is the first, middle, and last name of the earliest school graduate?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the earliest school graduate. Secondly, we need to retrieve their first, middle, and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Students', 'Transcripts'] to find the earliest school graduate and retrieve their name.\n\n<3> SQL Generation: We can join the 'Students' and 'Transcripts' tables on the 'student_id' column. Then, we can filter the rows where the 'transcript_date' is the earliest. Finally, we can select the 'first_name', 'middle_name', and 'last_name' columns.\n\n", "predict": "SELECT T1.first_name, T1.middle_name, T1.last_name FROM Students AS T1 JOIN Transcripts AS T2 ON T1.student_id = T2.student_id ORDER BY T2.transcript_date ASC LIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1", "question": "What is the first, middle, and last name of the earliest school graduate?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the earliest school graduate. Secondly, we need to retrieve their first, middle, and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Students', 'Transcripts'] to find the earliest school graduate and retrieve their name.\n\n<3> SQL Generation: We can join the 'Students' and 'Transcripts' tables on the 'student_id' column. Then, we can filter the rows where the 'transcript_date' is the earliest. Finally, we can select the 'first_name', 'middle_name', and 'last_name' columns.\n\n", "predict": "\nSELECT T1.first_name, T1.middle_name, T1.last_name \nFROM Students AS T1 \nJOIN Transcripts AS T2 ON T1.student_id = T2.student_id \nWHERE T2.transcript_date = (SELECT MIN(transcript_date) FROM Transcripts)"}, {"db_id": "tvshow", "gold": "SELECT Title FROM Cartoon ORDER BY title", "question": "What are the names of the cartoons sorted alphabetically?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we only need the 'Cartoon' table.\n\n<2> SQL Generation: We need to select the 'Title' column from the 'Cartoon' table and sort it alphabetically.\n\n", "predict": "SELECT Title FROM Cartoon ORDER BY Title ASC"}, {"db_id": "tvshow", "gold": "SELECT Title FROM Cartoon ORDER BY title", "question": "What are the names of the cartoons sorted alphabetically?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we only need the 'Cartoon' table.\n\n<2> SQL Generation: We need to select the 'Title' column from the 'Cartoon' table and sort it alphabetically.\n\n", "predict": "SELECT Title FROM Cartoon ORDER BY Title ASC"}, {"db_id": "tvshow", "gold": "SELECT title ,  Directed_by FROM Cartoon ORDER BY Original_air_date", "question": "What is the name and directors of all the cartoons that are ordered by the time they came out?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the name and directors of all the cartoons, ordered by the time they came out. So, we need to select the 'Title' and 'Directed_by' columns from the 'Cartoon' table and order them by the 'Original_air_date' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Cartoon'].\n\n<3> SQL Generation: We select the 'Title' and 'Directed_by' columns from the 'Cartoon' table and order them by the 'Original_air_date' column.\n\n", "predict": "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date"}, {"db_id": "tvshow", "gold": "SELECT title ,  Directed_by FROM Cartoon ORDER BY Original_air_date", "question": "What is the name and directors of all the cartoons that are ordered by the time they came out?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the name and directors of all the cartoons, ordered by the time they came out. So, we need to select the 'Title' and 'Directed_by' columns from the 'Cartoon' table and order them by the 'Original_air_date' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Cartoon'].\n\n<3> SQL Generation: We select the 'Title' and 'Directed_by' columns from the 'Cartoon' table and order them by the 'Original_air_date' column.\n\n", "predict": "SELECT Title, Directed_by FROM Cartoon ORDER BY Original_air_date"}, {"db_id": "tvshow", "gold": "select production_code ,  channel from cartoon order by original_air_date desc limit 1", "question": "What is the produdction code and channel of the most recent cartoon?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the most recent cartoon based on the 'Original_air_date' column in the 'Cartoon' table. Secondly, we need to select the 'Production_code' and 'Channel' columns for the most recent cartoon.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need to use the 'Cartoon' table for this query.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the most recent cartoon based on the 'Original_air_date' column. Then, select the 'Production_code' and 'Channel' columns for the selected cartoon.\n\n", "predict": "SELECT Production_code, Channel FROM Cartoon ORDER BY Original_air_date DESC LIMIT 1"}, {"db_id": "tvshow", "gold": "select production_code ,  channel from cartoon order by original_air_date desc limit 1", "question": "What is the produdction code and channel of the most recent cartoon?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the most recent cartoon based on the 'Original_air_date' column in the 'Cartoon' table. Secondly, we need to select the 'Production_code' and 'Channel' columns for the most recent cartoon.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need to use the 'Cartoon' table for this query.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the most recent cartoon based on the 'Original_air_date' column. Then, select the 'Production_code' and 'Channel' columns for the selected cartoon.\n\n", "predict": "SELECT Production_code, Channel FROM Cartoon ORDER BY Original_air_date DESC LIMIT 1"}, {"db_id": "poker_player", "gold": "SELECT Earnings FROM poker_player ORDER BY Earnings DESC", "question": "List the mony made by each poker players in descending order.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['people', 'poker_player'].\n\n<2> SQL Generation: We need to select the 'Name' and 'Earnings' columns from the 'people' and 'poker_player' tables, respectively. We also need to join the two tables on the 'People_ID' column. Finally, we need to order the result by 'Earnings' in descending order.\n\n", "predict": "SELECT people.Name, poker_player.Earnings FROM people JOIN poker_player ON people.People_ID = poker_player.People_ID ORDER BY poker_player.Earnings DESC"}, {"db_id": "poker_player", "gold": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1", "question": "Return the money rank of the tallest poker player.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the tallest poker player. Secondly, we need to retrieve the money rank of that player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['people', 'poker_player'].\n\n<3> SQL Generation: We can use a subquery to find the tallest poker player by selecting the 'People_ID' from the 'people' table where the 'Height' is the maximum. Then, we can join the 'poker_player' table with the subquery result on the 'People_ID' column and retrieve the 'Money_Rank' column.\n\n", "predict": "SELECT Money_Rank FROM poker_player JOIN (SELECT People_ID FROM people WHERE Height = (SELECT MAX(Height) FROM people)) AS T ON poker_player.People_ID = T.People_ID"}, {"db_id": "poker_player", "gold": "SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1", "question": "Return the money rank of the tallest poker player.", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the tallest poker player. Secondly, we need to retrieve the money rank of that player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['people', 'poker_player'].\n\n<3> SQL Generation: We can use a subquery to find the tallest poker player by selecting the 'People_ID' from the 'people' table where the 'Height' is the maximum. Then, we can join the 'poker_player' table with the subquery result on the 'People_ID' column and retrieve the 'Money_Rank' column.\n\n", "predict": "SELECT Money_Rank FROM poker_player JOIN (SELECT People_ID FROM people WHERE Height = (SELECT MAX(Height) FROM people)) AS T ON poker_player.People_ID = T.People_ID"}, {"db_id": "world_1", "gold": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1", "question": "Give the name of the nation that uses the greatest amount of languages.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the number of languages used by each nation. Secondly, we need to select the nation with the greatest number of languages.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: We need to perform a 'GROUP BY' operation on the column 'CountryCode' in the 'countrylanguage' table to count the number of languages used by each nation.\n\n<4> SQL Generation: We select the 'Name' column from the 'country' table and join it with the 'countrylanguage' table on the 'Code' column. Then, we group the rows by 'CountryCode' and count the number of languages. Finally, we select the nation with the greatest number of languages using 'ORDER BY' and 'LIMIT'.\n\n", "predict": "\nSELECT Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode GROUP BY CountryCode ORDER BY COUNT(*) DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1", "question": "Give the name of the nation that uses the greatest amount of languages.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the number of languages used by each nation. Secondly, we need to select the nation with the greatest number of languages.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: We need to perform a 'GROUP BY' operation on the column 'CountryCode' in the 'countrylanguage' table to count the number of languages used by each nation.\n\n<4> SQL Generation: We select the 'Name' column from the 'country' table and join it with the 'countrylanguage' table on the 'Code' column. Then, we group the rows by 'CountryCode' and count the number of languages. Finally, we select the nation with the greatest number of languages using 'ORDER BY' and 'LIMIT'.\n\n", "predict": "\nSELECT Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode GROUP BY CountryCode ORDER BY COUNT(*) DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Chinese\"", "question": "How many continents speak Chinese?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the continents where Chinese is spoken. Secondly, we need to count the number of continents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: We need to join the 'country' and 'countrylanguage' tables on the 'Code' column. Then, we filter the rows where 'Language' is 'Chinese' and 'IsOfficial' is 'T'. Finally, we count the number of distinct continents.\n\n", "predict": "SELECT COUNT(DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese' AND T2.IsOfficial = 'T'"}, {"db_id": "world_1", "gold": "SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Chinese\"", "question": "How many continents speak Chinese?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the continents where Chinese is spoken. Secondly, we need to count the number of continents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: We need to join the 'country' and 'countrylanguage' tables on the 'Code' column. Then, we filter the rows where 'Language' is 'Chinese' and 'IsOfficial' is 'T'. Finally, we count the number of distinct continents.\n\n", "predict": "SELECT COUNT(DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese' AND T2.IsOfficial = 'T'"}, {"db_id": "world_1", "gold": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1", "question": "What are the name, population, and life expectancy of the largest Asian country by land?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the largest Asian country by land. Secondly, we need to retrieve the name, population, and life expectancy of that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country'] and ['city'] to find the largest Asian country by land. Then, we need to retrieve the name, population, and life expectancy from the 'country' table.\n\n<3> SQL Generation: We can use the 'WHERE' clause to filter countries by continent ('Asia') and sort them in descending order based on surface area. Then, we can select the top 1 country and retrieve its name, population, and life expectancy.\n\n", "predict": "SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "question": "Give the name, year of independence, and surface area of the country that has the fewest people.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the country with the fewest people. Secondly, we need to select the name, year of independence, and surface area of that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country'] and ['city'] to find the country with the fewest people.\n\n<3> SQL Generation: We can use the 'MIN' function to find the country with the fewest people, and then select the name, year of independence, and surface area of that country.\n\n", "predict": "SELECT T1.Name, T1.IndepYear, T1.SurfaceArea FROM country AS T1 JOIN city AS T2 ON T1.Code = T2.CountryCode GROUP BY T1.Code HAVING COUNT(*) = (SELECT MIN(COUNT(*)) FROM city GROUP BY CountryCode)"}, {"db_id": "world_1", "gold": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "question": "Give the name, year of independence, and surface area of the country that has the fewest people.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the country with the fewest people. Secondly, we need to select the name, year of independence, and surface area of that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['country'] and ['city'] to find the country with the fewest people.\n\n<3> SQL Generation: We can use the 'MIN' function to find the country with the fewest people, and then select the name, year of independence, and surface area of that country.\n\n", "predict": "SELECT T1.Name, T1.IndepYear, T1.SurfaceArea FROM country AS T1 JOIN city AS T2 ON T1.Code = T2.CountryCode GROUP BY T1.Code HAVING COUNT(*) = (SELECT MIN(COUNT(*)) FROM city GROUP BY CountryCode)"}, {"db_id": "world_1", "gold": "SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1", "question": "What are the population, name and leader of the largest country by land?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the largest country by land. Secondly, we need to retrieve the population, name, and leader of that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'country' table to find the largest country by land. Then, we need to retrieve the population, name, and leader from the 'country' table.\n\n<3> SQL Generation: We can use the 'ORDER BY' and 'DESC' keywords to sort the countries by their land area in descending order. Then, we can use the 'LIMIT' keyword to select only the first row, which will be the largest country by land. Finally, we can select the population, name, and leader columns from the 'country' table.\n\n", "predict": "SELECT population, name, headofstate FROM country ORDER BY surfacearea DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "question": "Return the names and surface areas of the 5 largest countries.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires the names and surface areas of the 5 largest countries, so we should select the 'Name' and 'SurfaceArea' columns from the 'country' table. We also need to sort the countries by surface area in descending order and limit the result to the top 5.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'country' table for this query.\n\n<3> SQL generation: We select the 'Name' and 'SurfaceArea' columns from the 'country' table, order the result by 'SurfaceArea' in descending order, and limit the result to 5.\n\n", "predict": "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5"}, {"db_id": "world_1", "gold": "SELECT Name FROM country ORDER BY Population DESC LIMIT 3", "question": "Return the names of the 3 most populated countries.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires the names of the 3 most populated countries, so we should apply the 'order by' operation to the 'Population' column in the 'country' table and sort it in descending order. Then, we can select the top 3 countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'country' table.\n\n<3> SQL generation: The query requires the names of the countries, so we should select the 'Name' column in the 'country' table. We also need to limit the result to the top 3 countries.\n\n", "predict": "SELECT Name FROM country ORDER BY Population DESC LIMIT 3"}, {"db_id": "world_1", "gold": "SELECT Name FROM country ORDER BY Population DESC LIMIT 3", "question": "Return the names of the 3 most populated countries.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires the names of the 3 most populated countries, so we should apply the 'order by' operation to the 'Population' column in the 'country' table and sort it in descending order. Then, we can select the top 3 countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'country' table.\n\n<3> SQL generation: The query requires the names of the countries, so we should select the 'Name' column in the 'country' table. We also need to limit the result to the top 3 countries.\n\n", "predict": "SELECT Name FROM country ORDER BY Population DESC LIMIT 3"}, {"db_id": "world_1", "gold": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3", "question": "Return the names of the 3 countries with the fewest people.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires the names of the 3 countries with the fewest people, so we should sort the countries based on population in ascending order and select the top 3.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['country'].\n\n<3> SQL Generation: We select the 'Name' column from the 'country' table and sort the countries by population in ascending order. Then, we limit the result to the top 3.\n\n", "predict": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3"}, {"db_id": "world_1", "gold": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3", "question": "Return the names of the 3 countries with the fewest people.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "reasoning": "Let's think step by step.\n\n<1> Operation: The query requires the names of the countries with the fewest people, so we should apply the 'order by' operation to the 'Population' column in the 'country' table in ascending order. Then, we select the top 3 rows.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need to use the 'country' table.\n\n<3> SQL Generation: We select the 'Name' column from the 'country' table, order the result by the 'Population' column in ascending order, and limit the result to 3 rows.\n\n", "predict": "SELECT Name FROM country ORDER BY Population ASC LIMIT 3"}, {"db_id": "orchestra", "gold": "SELECT Name FROM conductor ORDER BY Age ASC", "question": "What are the names of conductors, ordered by how old they are?", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the names of conductors, ordered by their age. So, we need to select the 'Name' column from the 'conductor' table and order it by the 'Age' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need information from the 'conductor' table, we only need to use the 'conductor' table.\n\n<3> SQL Generation: We select the 'Name' column from the 'conductor' table and order it by the 'Age' column in descending order.\n\n", "predict": "SELECT Name FROM conductor ORDER BY Age DESC"}, {"db_id": "orchestra", "gold": "SELECT Name FROM conductor ORDER BY Age ASC", "question": "What are the names of conductors, ordered by how old they are?", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the names of conductors, ordered by their age. So, we need to select the 'Name' column from the 'conductor' table and order it by the 'Age' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. Since we only need information from the 'conductor' table, we only need to use the 'conductor' table.\n\n<3> SQL Generation: We need to select the 'Name' column from the 'conductor' table and order it by the 'Age' column in descending order.\n\n", "predict": "SELECT Name FROM conductor ORDER BY Age DESC"}, {"db_id": "orchestra", "gold": "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC", "question": "Return the record companies of orchestras, sorted ascending by the time they have existed.", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the record companies of orchestras, sorted ascending by the time they have existed. So, we need to select the record companies from the 'orchestra' table and sort them based on the 'Year_of_Founded' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need the 'orchestra' table for this query.\n\n<3> SQL Generation: We select the 'Record_Company' column from the 'orchestra' table and order it by the 'Year_of_Founded' column in ascending order.\n\n", "predict": "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded ASC"}, {"db_id": "orchestra", "gold": "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC", "question": "Return the record companies of orchestras, sorted ascending by the time they have existed.", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: The query requires the record companies of orchestras, sorted ascending by the time they have existed. So, we need to select the record companies from the 'orchestra' table and sort them based on the 'Year_of_Founded' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We only need the 'orchestra' table for this query.\n\n<3> SQL Generation: We select the 'Record_Company' column from the 'orchestra' table and order it by the 'Year_of_Founded' column in ascending order.\n\n", "predict": "SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded ASC"}, {"db_id": "network_1", "gold": "SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)", "question": "What is the average grade of students who have friends?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the student IDs of students who have friends. Secondly, we need to calculate the average grade of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Friend', 'Highschooler'] to find the student IDs of students who have friends. Then, we need to use table 'Highschooler' to calculate the average grade.\n\n<3> SQL Generation: We can use a subquery to find the student IDs of students who have friends. Then, we can join this subquery with the 'Highschooler' table to calculate the average grade.\n\n", "predict": "SELECT AVG(grade) FROM Highschooler WHERE ID IN (SELECT student_id FROM Friend)"}, {"db_id": "network_1", "gold": "SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id)", "question": "What is the average grade of students who have friends?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the student IDs of students who have friends. Secondly, we need to calculate the average grade of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Friend', 'Highschooler'] to find the student IDs of students who have friends. Then, we need to use table 'Highschooler' to calculate the average grade.\n\n<3> SQL Generation: We can use a subquery to find the student IDs of students who have friends. Then, we can join this subquery with the 'Highschooler' table to calculate the average grade.\n\n", "predict": "SELECT AVG(grade) FROM Highschooler WHERE ID IN (SELECT student_id FROM Friend)"}, {"db_id": "dog_kennels", "gold": "SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1", "question": "Give me the description of the treatment type that is least expensive.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the treatment type that is least expensive. Secondly, we need to retrieve the description of that treatment type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Treatment_Types', 'Treatments'].\n\n<3> SQL Generation: We can use the 'MIN' function to find the least expensive treatment type based on the 'cost_of_treatment' column in the 'Treatments' table. Then, we can join the 'Treatment_Types' table to retrieve the description of that treatment type.\n\n", "predict": "SELECT Treatment_Types.treatment_type_description FROM Treatment_Types JOIN Treatments ON Treatment_Types.treatment_type_code = Treatments.treatment_type_code WHERE Treatments.cost_of_treatment = (SELECT MIN(cost_of_treatment) FROM Treatments)"}, {"db_id": "dog_kennels", "gold": "SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1", "question": "Give me the description of the treatment type that is least expensive.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the treatment type that is least expensive. Secondly, we need to retrieve the description of that treatment type.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Treatment_Types', 'Treatments'] to find the least expensive treatment type and retrieve its description.\n\n<3> SQL Generation: Use 'order by' and 'asc' to select the treatment type with the least expensive cost, and then retrieve its description.\n\n", "predict": "SELECT treatment_type_description FROM Treatment_Types ORDER BY charge_amount ASC LIMIT 1"}, {"db_id": "dog_kennels", "gold": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "question": "Who owns the youngest dog? Give me his or her last name.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest dog. Secondly, we need to find the owner of that dog and retrieve their last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Dogs', 'Owners'] to find the youngest dog and retrieve the owner's last name.\n\n<3> SQL Generation: We can use the 'MIN' function to find the minimum age of the dogs. Then, we can join the 'Dogs' and 'Owners' tables on the 'owner_id' column to retrieve the last name of the owner of the youngest dog.\n\n", "predict": "SELECT O.last_name FROM Dogs AS D JOIN Owners AS O ON D.owner_id = O.owner_id WHERE D.age = (SELECT MIN(age) FROM Dogs)"}, {"db_id": "dog_kennels", "gold": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "question": "Who owns the youngest dog? Give me his or her last name.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the youngest dog. Secondly, we need to find the owner of that dog and retrieve their last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Dogs', 'Owners'] to find the youngest dog and retrieve the owner's last name.\n\n<3> SQL Generation: We can use the 'MIN' function to find the minimum age of the dogs. Then, we can join the 'Dogs' and 'Owners' tables on the 'owner_id' column to retrieve the last name of the owner.\n\n", "predict": "SELECT O.last_name FROM Dogs AS D JOIN Owners AS O ON D.owner_id = O.owner_id WHERE D.age = (SELECT MIN(age) FROM Dogs)"}, {"db_id": "dog_kennels", "gold": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1", "question": "Show me the price of the most recently performed treatment.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the most recently performed treatment. Secondly, we need to retrieve the price of that treatment.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the treatment_id with the most recent date_of_treatment from the table 'Treatments'. In the second step, we need to retrieve the charge_amount from the table 'Charges' based on the treatment_id.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the treatment_id with the most recent date_of_treatment, and then use 'join' to retrieve the charge_amount based on the treatment_id.\n\n", "predict": "SELECT charge_amount FROM Charges JOIN Treatments ON Charges.charge_id = Treatments.treatment_id ORDER BY Treatments.date_of_treatment DESC LIMIT 1"}, {"db_id": "dog_kennels", "gold": "SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1", "question": "Show me the price of the most recently performed treatment.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the most recently performed treatment. Secondly, we need to retrieve the price of that treatment.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the treatment_id with the most recent date_of_treatment from the table 'Treatments'. In the second step, we need to retrieve the charge_amount from the table 'Charges' based on the treatment_id.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the treatment_id with the most recent date_of_treatment, and then use 'join' to retrieve the charge_amount based on the treatment_id.\n\n", "predict": "SELECT charge_amount FROM Charges JOIN Treatments ON Charges.charge_id = Treatments.treatment_id ORDER BY Treatments.date_of_treatment DESC LIMIT 1"}, {"db_id": "singer", "gold": "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC", "question": "What are the names of singers ordered by ascending wealth?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we only need to use the 'singer' table.\n\n<2> SQL Generation: We need to select the 'Name' column from the 'singer' table and order it by ascending 'Net_Worth_Millions'.\n\n", "predict": "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC"}, {"db_id": "singer", "gold": "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC", "question": "What are the names of singers ordered by ascending wealth?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we only need to use the 'singer' table.\n\n<2> SQL Generation: We need to select the 'Name' column from the 'singer' table and order it by ascending 'Net_Worth_Millions'.\n\n", "predict": "SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC"}, {"db_id": "singer", "gold": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1", "question": "What is the name of the singer with the largest wealth?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "reasoning": "Let's think step by step.\n\n<1> Decomposition: Firstly, we need to find the singer with the largest wealth. Secondly, we need to retrieve the name of that singer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need to use the 'singer' table.\n\n<3> SQL Generation: Use 'order by' and 'desc' to select the singer with the largest wealth, and then retrieve their name.\n\n", "predict": "SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1"}]