[{"db_id": "concert_singer", "gold": "SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1", "question": "What are the names and release years for all the songs of the youngest singer?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "number": 0, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to find the youngest singer. Secondly, we need to retrieve the names and release years of all the songs by that singer.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'Name', 'Song_Name', and 'Song_release_year' columns from the 'singer' table.\n\n<3> SQL Generation: Use 'select' to retrieve the required columns from the 'singer' table. Then, use 'where' to filter for the youngest singer based on their age. Finally, use 'join' to link the 'singer_in_concert' table with the 'concert' table and retrieve the songs performed by the youngest singer.\n\n", "predict": "SELECT singer.Name, singer.Song_Name, singer.Song_release_year \nFROM singer \nJOIN singer_in_concert ON singer.Singer_ID = singer_in_concert.Singer_ID \nJOIN concert ON singer_in_concert.concert_ID = concert.concert_ID \nWHERE singer.Age = (SELECT MIN(Age) FROM singer)"}, {"db_id": "flight_2", "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "question": "Find all airlines that have fewer than 200 flights.", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "number": 120, "hardness": "medium", "reasoning": "<1> Decomposition: We need to find the airlines that have fewer than 200 flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Airline column from the 'airlines' table and count the number of flights for each airline from the 'flights' table.\n\n<3> SQL Generation: Use 'join' to link the 'airlines' and 'flights' tables based on the airport codes. Then, use 'group by' and 'having' to filter the airlines that have fewer than 200 flights.\n\n", "predict": "SELECT airlines.Airline FROM airlines JOIN flights ON flights.Airline = airlines.uid GROUP BY airlines.Airline HAVING COUNT(flights.FlightNo) < 200"}, {"db_id": "flight_2", "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "question": "Which airlines have less than 200 flights?", "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n", "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n", "types": {"airlines.uid": "number", "airlines.Airline": "text", "airlines.Abbreviation": "text", "airlines.Country": "text", "airports.City": "text", "airports.AirportCode": "text", "airports.AirportName": "text", "airports.Country": "text", "airports.CountryAbbrev": "text", "flights.Airline": "number", "flights.FlightNo": "number", "flights.SourceAirport": "text", "flights.DestAirport": "text"}, "number": 121, "hardness": "medium", "reasoning": "<1> Decomposition: We need to find the airlines that have less than 200 flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the Airline column from the 'airlines' table and count the number of flights for each airline from the 'flights' table.\n\n<3> SQL Generation: Use 'join' to link the 'airlines' and 'flights' tables based on the airport codes. Then, use 'group by' and 'having' to filter the airlines that have less than 200 flights.\n\n", "predict": "SELECT airlines.Airline FROM airlines JOIN flights ON flights.Airline = airlines.Airline GROUP BY airlines.Airline HAVING COUNT(flights.FlightNo) < 200"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3", "question": "Show all template type codes with less than three templates.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "number": 148, "hardness": "easy", "reasoning": "<1> Decomposition: We need to find the template type codes that have less than three templates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Template_Type_Code from table 'Ref_Template_Types' and count the number of templates for each template type code from table 'Templates'.\n\n<3> SQL Generation: Use 'group by' and 'having' to count the number of templates for each template type code and filter out the ones with less than three templates.\n\n", "predict": "SELECT Template_Type_Code FROM Ref_Template_Types AS T1 JOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code GROUP BY Template_Type_Code HAVING COUNT(T2.Template_ID) < 3"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2", "question": "What is the document id with 1 to 2 paragraphs?", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "number": 168, "hardness": "easy", "reasoning": "<1> Decomposition: The query requires finding the document ID of documents that have 1 to 2 paragraphs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'Documents' table to get the document ID and the 'Paragraphs' table to count the number of paragraphs for each document.\n\n<3> SQL Generation: We can use a 'join' to join the 'Documents' table with the 'Paragraphs' table on the 'Document_ID' column. Then, we can group the rows by the 'Document_ID' and use the 'HAVING' clause to filter the groups where the count of paragraphs is between 1 and 2. Finally, we can select the 'Document_ID' column from the 'Documents' table.\n\n", "predict": "SELECT Document_ID FROM Documents JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID GROUP BY Documents.Document_ID HAVING COUNT(Paragraphs.Paragraph_ID) BETWEEN 1 AND 2"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2", "question": "Give the ids of documents that have between one and two paragraphs.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "number": 169, "hardness": "easy", "reasoning": "<1> Decomposition: We need to find the documents that have between one and two paragraphs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Document_ID from the 'Documents' table and count the number of paragraphs for each document from the 'Paragraphs' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter the documents based on the count of paragraphs.\n\n", "predict": "SELECT Documents.Document_ID FROM Documents JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID GROUP BY Documents.Document_ID HAVING COUNT(Paragraphs.Paragraph_ID) BETWEEN 1 AND 2"}, {"db_id": "course_teach", "gold": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1", "question": "What is the hometown of the youngest teacher?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "number": 174, "hardness": "medium", "reasoning": "<1> Decomposition: The query requires finding the youngest teacher and retrieving their hometown.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the hometown column from the teacher table and filter by the youngest teacher based on their age.\n\n<3> SQL Generation: Use 'where' to filter the youngest teacher based on their age and select the hometown column.\n\n", "predict": "SELECT hometown FROM teacher WHERE age = (SELECT MIN(age) FROM teacher)"}, {"db_id": "course_teach", "gold": "SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1", "question": "Where is the youngest teacher from?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "number": 175, "hardness": "medium", "reasoning": "<1> Decomposition: We need to find the youngest teacher and their hometown.\n\n<2> Schema Linking: We need to select the hometown column from the teacher table and filter the youngest teacher based on their age.\n\n<3> SQL Generation: Use 'where' to find the youngest teacher and select their hometown.\n\n", "predict": "SELECT hometown FROM teacher WHERE age = (SELECT MIN(age) FROM teacher)"}, {"db_id": "museum_visit", "gold": "SELECT museum_id ,  name FROM museum ORDER BY num_of_staff DESC LIMIT 1", "question": "Find the id and name of the museum that has the most staff members?", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "number": 182, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to find the museum with the most staff members. Secondly, we need to select the museum ID and name of the museum.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Museum_ID and Name from table 'museum' and find the museum with the highest value in the Num_of_Staff column.\n\n<3> SQL Generation: Use 'order by' to sort the museums by the number of staff members in descending order, and then select the top 1 museum ID and name.\n\n", "predict": "SELECT Museum_ID, Name FROM museum ORDER BY Num_of_Staff DESC LIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "question": "What are the names and ids of every course with less than 2 sections?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "number": 213, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to find the courses with less than 2 sections. Secondly, we need to retrieve the names and ids of those courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select course_id from table 'Sections' and count the number of sections for each course. In the second step, we need to filter course_name and course_id from table 'Courses'.\n\n<3> SQL Generation: Use 'group by' and 'having' to find the courses with less than 2 sections, and then select course_name and course_id.\n\n", "predict": "SELECT course_name, course_id FROM Courses \nWHERE course_id IN (SELECT course_id FROM Sections \nGROUP BY course_id \nHAVING COUNT(section_id) < 2)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "number": 216, "hardness": "medium", "reasoning": "<1> Decomposition: The query requires filtering on students who enrolled in 2 degree programs in one semester. Firstly, we need to identify the students who enrolled in 2 degree programs. Secondly, we need to identify the semester in which they enrolled in these degree programs. Finally, we need to retrieve the first, middle, and last names, along with the ids, of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the student ids from the 'Student_Enrolment' table where the count of distinct degree program ids for each student is equal to 2. In the second step, we need to select the semester ids from the 'Student_Enrolment' table where the count of distinct degree program ids for each student is equal to 2. In the final step, we need to retrieve the first, middle, and last names, along with the ids, of the students from the 'Students' table.\n\n<3> SQL Generation: Use 'group by' and 'having' to filter students who enrolled in 2 degree programs. Use 'join' to link the 'Student_Enrolment' table with the 'Students' table to retrieve the first, middle, and last names, along with the ids, of these students.\n\n", "predict": "\nSELECT Students.student_id, Students.first_name, Students.middle_name, Students.last_name\nFROM Students\nJOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id\nGROUP BY Students.student_id, Students.first_name, Students.middle_name, Students.last_name\nHAVING COUNT(DISTINCT Student_Enrolment.degree_program_id) = 2"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1", "question": "What is the first, middle, and last name of the first student to register?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "number": 222, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to find the first student to register. Secondly, we need to retrieve their first, middle, and last name.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the student id and sort the results by the date of first registration. In the second step, we need to retrieve the first, middle, and last name of the student from the 'Students' table.\n\n<3> SQL Generation: Use 'order by' to sort the student ids by the date of first registration in ascending order, and then use 'limit' to retrieve the first student id. Finally, use 'select' to retrieve the first, middle, and last name of the student based on the retrieved student id.\n\n", "predict": "SELECT first_name, middle_name, last_name FROM students ORDER BY date_first_registered ASC LIMIT 1"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1", "question": "What is the earliest date of a transcript release, and what details can you tell me?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "number": 225, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to find the earliest date of a transcript release. Secondly, we need to retrieve the details of the transcript with that earliest release date.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the minimum transcript date from table 'Transcripts'. In the second step, we need to retrieve the details of the transcript with that earliest release date from table 'Transcripts'.\n\n<3> SQL Generation: Use 'min' to find the earliest transcript release date, and then use 'where' to retrieve the details of the transcript with that date.\n\n", "predict": "SELECT * FROM transcripts WHERE transcript_date = (SELECT min(transcript_date) FROM transcripts)"}, {"db_id": "student_transcripts_tracking", "gold": "SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1", "question": "When was the last transcript released?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "number": 226, "hardness": "medium", "reasoning": "<1> Decomposition: We need to find the last transcript released.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the transcript date from the 'Transcripts' table.\n\n<3> SQL Generation: Use 'order by' to sort the transcript dates in descending order and select the first row to get the last transcript released.\n\n", "predict": "SELECT transcript_date FROM transcripts ORDER BY transcript_date DESC LIMIT 1"}, {"db_id": "tvshow", "gold": "SELECT Episode ,  Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;", "question": "What are 3 most highly rated episodes in the TV series table and what were those ratings?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "number": 246, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to find the top 3 episodes with the highest ratings. Secondly, we need to retrieve the ratings of those episodes.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the top 3 episodes based on the rating column from the table 'TV_series'. Then, we need to retrieve the ratings of those episodes.\n\n<3> SQL Generation: Use the 'ORDER BY' clause to sort the episodes by rating in descending order, and then use the 'LIMIT' clause to select the top 3 episodes. Finally, select the episode and rating columns.\n\n", "predict": "SELECT Episode, Rating FROM TV_series ORDER BY Rating DESC LIMIT 3"}, {"db_id": "world_1", "gold": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 338, "hardness": "medium", "reasoning": "<1> Decomposition: The query requires finding the different government forms and their total population for government forms that have an average life expectancy greater than 72.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need the 'country' table for government forms and the 'city' table for population.\n\n<3> SQL Generation: We can use a subquery to calculate the average life expectancy for each government form, and then use a 'having' clause to filter for government forms with an average life expectancy greater than 72. We can join the 'country' and 'city' tables using the 'CountryCode' column and group by the government form. Finally, we can select the government form and sum the population for each group.\n\n", "predict": "\nSELECT country.GovernmentForm, SUM(city.Population) AS total_population\nFROM country\nJOIN city ON country.Code = city.CountryCode\nGROUP BY country.GovernmentForm\nHAVING AVG(country.LifeExpectancy) > 72"}, {"db_id": "world_1", "gold": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72", "question": "What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 339, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to find the different continents. Secondly, we need to calculate the total population and average life expectancy for each continent. Lastly, we need to filter out the continents that have an average life expectancy less than 72.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the continent from table 'country'. Then, we need to join table 'country' with table 'city' on the 'CountryCode' column to calculate the total population. We also need to join table 'country' with table 'countrylanguage' on the 'CountryCode' column to calculate the average life expectancy.\n\n<3> SQL Generation: Use the 'GROUP BY' clause to group the data by continent. Use the 'SUM' function to calculate the total population and the 'AVG' function to calculate the average life expectancy. Use the 'HAVING' clause to filter out the continents with an average life expectancy less than 72.\n\n", "predict": "\nSELECT country.Continent, SUM(city.Population) AS total_population, AVG(country.LifeExpectancy) AS average_life_expectancy\nFROM country\nJOIN city ON country.Code = city.CountryCode\nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode\nGROUP BY country.Continent\nHAVING AVG(country.LifeExpectancy) < 72"}, {"db_id": "real_estate_properties", "gold": "SELECT T2.property_type_description FROM Properties AS T1 JOIN Ref_Property_Types AS T2 ON T1.property_type_code  =  T2.property_type_code GROUP BY T1.property_type_code", "question": "Show the property type descriptions of properties belonging to that code.", "foreign_keys": "Foreign_keys = [Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code,Other_Property_Features.property_id = Properties.property_id,Other_Property_Features.feature_id = Other_Available_Features.feature_id]\n", "tables": "Table Other_Available_Features, columns = [*,feature_id,feature_type_code,feature_name,feature_description]\nTable Other_Property_Features, columns = [*,property_id,feature_id,property_feature_description]\nTable Properties, columns = [*,property_id,property_type_code,date_on_market,date_sold,property_name,property_address,room_count,vendor_requested_price,buyer_offered_price,agreed_selling_price,apt_feature_1,apt_feature_2,apt_feature_3,fld_feature_1,fld_feature_2,fld_feature_3,hse_feature_1,hse_feature_2,hse_feature_3,oth_feature_1,oth_feature_2,oth_feature_3,shp_feature_1,shp_feature_2,shp_feature_3,other_property_details]\nTable Ref_Feature_Types, columns = [*,feature_type_code,feature_type_name]\nTable Ref_Property_Types, columns = [*,property_type_code,property_type_description]\n", "types": {"Ref_Feature_Types.feature_type_code": "text", "Ref_Feature_Types.feature_type_name": "text", "Ref_Property_Types.property_type_code": "text", "Ref_Property_Types.property_type_description": "text", "Other_Available_Features.feature_id": "number", "Other_Available_Features.feature_type_code": "text", "Other_Available_Features.feature_name": "text", "Other_Available_Features.feature_description": "text", "Properties.property_id": "number", "Properties.property_type_code": "text", "Properties.date_on_market": "time", "Properties.date_sold": "time", "Properties.property_name": "text", "Properties.property_address": "text", "Properties.room_count": "number", "Properties.vendor_requested_price": "number", "Properties.buyer_offered_price": "number", "Properties.agreed_selling_price": "number", "Properties.apt_feature_1": "text", "Properties.apt_feature_2": "text", "Properties.apt_feature_3": "text", "Properties.fld_feature_1": "text", "Properties.fld_feature_2": "text", "Properties.fld_feature_3": "text", "Properties.hse_feature_1": "text", "Properties.hse_feature_2": "text", "Properties.hse_feature_3": "text", "Properties.oth_feature_1": "text", "Properties.oth_feature_2": "text", "Properties.oth_feature_3": "text", "Properties.shp_feature_1": "text", "Properties.shp_feature_2": "text", "Properties.shp_feature_3": "text", "Properties.other_property_details": "text", "Other_Property_Features.property_id": "number", "Other_Property_Features.feature_id": "number", "Other_Property_Features.property_feature_description": "text"}, "number": 405, "hardness": "medium", "reasoning": "<1> Decomposition: The query requires showing the property type descriptions of properties belonging to a specific code.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the property_type_description from the table 'Ref_Property_Types' where the property_type_code matches the specified code.\n\n<3> SQL Generation: Use 'where' to filter the rows in the 'Ref_Property_Types' table based on the specified code, and then select the property_type_description.\n\n", "predict": "SELECT property_type_description FROM Ref_Property_Types WHERE property_type_code = [specified code]"}]