[
    {
        "db_id": "concert_singer",
        "gold": "SELECT country FROM singer WHERE age  >  40 INTERSECT SELECT country FROM singer WHERE age  <  30",
        "question": "Show countries where a singer above age 40 and a singer below 30 are from.",
        "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n",
        "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n",
        "types": {
            "stadium.Stadium_ID": "number",
            "stadium.Location": "text",
            "stadium.Name": "text",
            "stadium.Capacity": "number",
            "stadium.Highest": "number",
            "stadium.Lowest": "number",
            "stadium.Average": "number",
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Country": "text",
            "singer.Song_Name": "text",
            "singer.Song_release_year": "text",
            "singer.Age": "number",
            "singer.Is_male": "others",
            "concert.concert_ID": "number",
            "concert.concert_Name": "text",
            "concert.Theme": "text",
            "concert.Stadium_ID": "text",
            "concert.Year": "text",
            "singer_in_concert.concert_ID": "number",
            "singer_in_concert.Singer_ID": "text"
        },
        "number": 0,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the countries where singers above age 40 are from; 2. what are the countries where singers below 30 are from.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['singer']. To complete the second subproblem, we also need to use tables ['singer'].\n\n<3> Operation: Use 'where' to filter using column 'Age' in table 'singer'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Country FROM singer WHERE Age > 40 INTERSECT SELECT Country FROM singer WHERE Age < 30"
    },
    {
        "db_id": "concert_singer",
        "gold": "SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014",
        "question": "Show names for all stadiums except for stadiums having a concert in year 2014.",
        "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n",
        "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n",
        "types": {
            "stadium.Stadium_ID": "number",
            "stadium.Location": "text",
            "stadium.Name": "text",
            "stadium.Capacity": "number",
            "stadium.Highest": "number",
            "stadium.Lowest": "number",
            "stadium.Average": "number",
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Country": "text",
            "singer.Song_Name": "text",
            "singer.Song_release_year": "text",
            "singer.Age": "number",
            "singer.Is_male": "others",
            "concert.concert_ID": "number",
            "concert.concert_Name": "text",
            "concert.Theme": "text",
            "concert.Stadium_ID": "text",
            "concert.Year": "text",
            "singer_in_concert.concert_ID": "number",
            "singer_in_concert.Singer_ID": "text"
        },
        "number": 1,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes exclusion logic, so we can decompose the question into two subproblems: 1. what are the stadiums that have a concert in year 2014; 2. what are the names of all stadiums.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['concert']. To complete the second subproblem, we need to use tables ['stadium'].\n\n<3> Operation: Use 'where' to filter using column 'Year' in table 'concert'.\n\n<4> SQL Generation: Use 'except' operation to exclude the stadiums from the first subproblem from the second subproblem to form the final SQL statement.\n\n",
        "predict": "SELECT Name FROM stadium EXCEPT SELECT stadium.Name FROM stadium JOIN concert ON stadium.Stadium_ID = concert.Stadium_ID WHERE concert.Year = 2014"
    },
    {
        "db_id": "concert_singer",
        "gold": "SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",
        "question": "Find the name and location of the stadiums which some concerts happened in the years of both 2014 and 2015.",
        "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n",
        "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n",
        "types": {
            "stadium.Stadium_ID": "number",
            "stadium.Location": "text",
            "stadium.Name": "text",
            "stadium.Capacity": "number",
            "stadium.Highest": "number",
            "stadium.Lowest": "number",
            "stadium.Average": "number",
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Country": "text",
            "singer.Song_Name": "text",
            "singer.Song_release_year": "text",
            "singer.Age": "number",
            "singer.Is_male": "others",
            "concert.concert_ID": "number",
            "concert.concert_Name": "text",
            "concert.Theme": "text",
            "concert.Stadium_ID": "text",
            "concert.Year": "text",
            "singer_in_concert.concert_ID": "number",
            "singer_in_concert.Singer_ID": "text"
        },
        "number": 2,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the stadiums where concerts happened in 2014; 2. what are the stadiums where concerts happened in 2015.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['concert', 'stadium']. To complete the second subproblem, we also need to use tables ['concert', 'stadium'].\n\n<3> Operation: Use 'where' to filter using column 'Year' in table 'concert'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Name, Location FROM stadium WHERE Stadium_ID IN (SELECT Stadium_ID FROM concert WHERE Year = 2014) INTERSECT SELECT Name, Location FROM stadium WHERE Stadium_ID IN (SELECT Stadium_ID FROM concert WHERE Year = 2015)"
    },
    {
        "db_id": "concert_singer",
        "gold": "SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",
        "question": "What are the names and locations of the stadiums that had concerts that occurred in both 2014 and 2015?",
        "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n",
        "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n",
        "types": {
            "stadium.Stadium_ID": "number",
            "stadium.Location": "text",
            "stadium.Name": "text",
            "stadium.Capacity": "number",
            "stadium.Highest": "number",
            "stadium.Lowest": "number",
            "stadium.Average": "number",
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Country": "text",
            "singer.Song_Name": "text",
            "singer.Song_release_year": "text",
            "singer.Age": "number",
            "singer.Is_male": "others",
            "concert.concert_ID": "number",
            "concert.concert_Name": "text",
            "concert.Theme": "text",
            "concert.Stadium_ID": "text",
            "concert.Year": "text",
            "singer_in_concert.concert_ID": "number",
            "singer_in_concert.Singer_ID": "text"
        },
        "number": 3,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the names and locations of the stadiums that had concerts in 2014; 2. what are the names and locations of the stadiums that had concerts in 2015.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['concert', 'stadium']. To complete the second subproblem, we also need to use tables ['concert', 'stadium'].\n\n<3> Operation: Use 'where' to filter using column 'Year' in table 'concert'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Name, Location FROM stadium WHERE Stadium_ID IN (SELECT Stadium_ID FROM concert WHERE Year = 2014) INTERSECT SELECT Name, Location FROM stadium WHERE Stadium_ID IN (SELECT Stadium_ID FROM concert WHERE Year = 2015)"
    },
    {
        "db_id": "pets_1",
        "gold": "select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'cat' intersect select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'dog'",
        "question": "Find the first name of students who have both cat and dog pets .",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 5,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the intersection set logic, so we can decompose the question into two subproblems: 1. what are the student ids who have a cat pet; 2. what are the student ids who have a dog pet. Then we can find the intersection of these two sets to get the student ids who have both cat and dog pets. Finally, we can retrieve the first names of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Has_Pet', 'Pets', 'Student']. To complete the second subproblem, we also need to use tables ['Has_Pet', 'Pets', 'Student'].\n\n<3> Operation: Use 'join' operation to connect the tables based on the foreign key relationships. Then use 'where' to filter using column 'PetType' in table 'Pets' to find the student ids who have a cat pet or a dog pet.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement. Then use 'join' operation to retrieve the first names of the students.\n\n",
        "predict": "SELECT Student.Fname FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'cat' INTERSECT SELECT Student.Fname FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'dog'"
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' INTERSECT SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog'",
        "question": "What are the students' first names who have both cats and dogs as pets?",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 6,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the first names of students who have cats as pets; 2. what are the first names of students who have dogs as pets.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Student', 'Has_Pet', 'Pets']. To complete the second subproblem, we need to use tables ['Student', 'Has_Pet', 'Pets'].\n\n<3> Operation: Use 'inner join' to connect the tables 'Student', 'Has_Pet', and 'Pets' using the foreign key relationships. Then, use 'where' to filter the rows where the pet type is 'cat' for the first subproblem and 'dog' for the second subproblem.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Student.Fname FROM Student INNER JOIN Has_Pet ON Student.StuID = Has_Pet.StuID INNER JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'cat' INTERSECT SELECT Student.Fname FROM Student INNER JOIN Has_Pet ON Student.StuID = Has_Pet.StuID INNER JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'dog'"
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'",
        "question": "Find the id of students who do not have a cat pet.",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 9,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes negation logic, so we can decompose the question into two subproblems: 1. what are the ids of students who have a cat pet; 2. what are all the student ids. Then we can find the difference between the two sets to get the final result.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Has_Pet', 'Pets']. To complete the second subproblem, we need to use tables ['Student'].\n\n<3> Operation: Use 'where' to filter using column 'PetType' in table 'Pets'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.StuID FROM Student AS T1 EXCEPT SELECT T1.StuID FROM Has_Pet AS T1 INNER JOIN Pets AS T2 ON T1.PetID = T2.PetID WHERE T2.PetType = \"cat\""
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'",
        "question": "What are the ids of the students who do not own cats as pets?",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 10,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes exclusion logic, so we can decompose the question into two subproblems: 1. what are the ids of the students who own pets; 2. what are the ids of the students who own cats as pets.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Student', 'Has_Pet']. To complete the second subproblem, we also need to use tables ['Student', 'Has_Pet', 'Pets'].\n\n<3> Operation: Use 'where' to filter using column 'PetType' in table 'Pets'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT StuID FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet WHERE PetID IN (SELECT PetID FROM Pets WHERE PetType = \"cat\"))"
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
        "question": "Find all airlines that have flights from both airports 'APG' and 'CVO'.",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 18,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the intersection set logic, so we can decompose the question into two subproblems: 1. find all airlines that have flights from airport 'APG'; 2. find all airlines that have flights from airport 'CVO'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['airlines', 'flights', 'airports'].\n\n<3> Operation: Use 'where' to filter using column 'SourceAirport' in table 'flights' and column 'AirportCode' in table 'airports'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Airline FROM airlines WHERE EXISTS (SELECT * FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode WHERE airports.AirportCode = 'APG' AND airlines.uid = flights.Airline) INTERSECT SELECT Airline FROM airlines WHERE EXISTS (SELECT * FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode WHERE airports.AirportCode = 'CVO' AND airlines.uid = flights.Airline)"
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
        "question": "Which airlines have departing flights from both APG and CVO airports?",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 19,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the airlines that have departing flights from APG airport; 2. what are the airlines that have departing flights from CVO airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['airlines', 'flights', 'airports']. To complete the second subproblem, we also need to use tables ['airlines', 'flights', 'airports'].\n\n<3> Operation: Use 'where' to filter using column 'SourceAirport' in table 'flights'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT DISTINCT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline JOIN airports AS T3 ON T2.SourceAirport = T3.AirportCode WHERE T3.AirportName = \"APG\" INTERSECT SELECT DISTINCT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline JOIN airports AS T3 ON T2.SourceAirport = T3.AirportCode WHERE T3.AirportName = \"CVO\""
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
        "question": "Find all airlines that have flights from airport 'CVO' but not from 'APG'.",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 20,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes set difference logic, so we can decompose the question into two subproblems: 1. find all airlines that have flights from airport 'CVO'; 2. find all airlines that have flights from airport 'APG'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['airlines', 'airports', 'flights'].\n\n<3> Operation: Use 'where' to filter using column 'SourceAirport' in table 'flights'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT DISTINCT airlines.Airline FROM airlines JOIN flights ON airlines.Airline = flights.Airline WHERE flights.SourceAirport = 'CVO' EXCEPT SELECT DISTINCT airlines.Airline FROM airlines JOIN flights ON airlines.Airline = flights.Airline WHERE flights.SourceAirport = 'APG'"
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
        "question": "Which airlines have departures from CVO but not from APG airports?",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 21,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes set difference logic, so we can decompose the question into two subproblems: 1. what are the airlines that have departures from CVO airports; 2. what are the airlines that have departures from APG airports.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['flights', 'airports', 'airlines']. To complete the second subproblem, we need to use tables ['flights', 'airports', 'airlines'] in the same reason.\n\n<3> Operation: Use 'where' to filter using column 'AirportCode' in table 'airports'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT DISTINCT T3.Airline FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode JOIN airlines AS T3 ON T1.Airline = T3.uid WHERE T2.AirportCode = \"CVO\" EXCEPT SELECT DISTINCT T3.Airline FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode JOIN airlines AS T3 ON T1.Airline = T3.uid WHERE T2.AirportCode = \"APG\""
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)",
        "question": "Find the name of airports which do not have any flight in and out.",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 22,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the absence of flights in and out of airports, so we can decompose the question into the subproblem of finding airports that do not have any flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the subproblem, we need to use tables ['airports', 'flights'].\n\n<3> Operation: Use 'left join' and 'where' to filter out airports that do not have any flights.\n\n<4> SQL Generation: Use 'is null' to check if the joined column from the 'flights' table is null, indicating the absence of flights. Combine the 'left join' and 'where' operations to form the final SQL statement.\n\n",
        "predict": "SELECT AirportName FROM airports LEFT JOIN flights ON airports.AirportCode = flights.SourceAirport OR airports.AirportCode = flights.DestAirport WHERE flights.FlightNo IS NULL"
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)",
        "question": "Which airports do not have departing or arriving flights?",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 23,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the absence of flights, so we can decompose the question into two subproblems: 1. which airports have departing flights; 2. which airports have arriving flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['airports', 'flights']. To complete the second subproblem, we need to use tables ['airports', 'flights'] in the same reason.\n\n<3> Operation: Use 'where' to filter using columns 'SourceAirport' and 'DestAirport' in table 'flights'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems and use 'not exists' to find the airports that do not have departing or arriving flights.\n\n",
        "predict": "SELECT * FROM airports WHERE NOT EXISTS (SELECT * FROM flights WHERE airports.AirportCode = flights.SourceAirport) UNION SELECT * FROM airports WHERE NOT EXISTS (SELECT * FROM flights WHERE airports.AirportCode = flights.DestAirport)"
    },
    {
        "db_id": "employee_hire_evaluation",
        "gold": "SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000",
        "question": "Which district has both stores with less than 3000 products and stores with more than 10000 products?",
        "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n",
        "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n",
        "types": {
            "employee.Employee_ID": "number",
            "employee.Name": "text",
            "employee.Age": "number",
            "employee.City": "text",
            "shop.Shop_ID": "number",
            "shop.Name": "text",
            "shop.Location": "text",
            "shop.District": "text",
            "shop.Number_products": "number",
            "shop.Manager_name": "text",
            "hiring.Shop_ID": "number",
            "hiring.Employee_ID": "number",
            "hiring.Start_from": "text",
            "hiring.Is_full_time": "others",
            "evaluation.Employee_ID": "text",
            "evaluation.Year_awarded": "text",
            "evaluation.Bonus": "number"
        },
        "number": 27,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the intersection of two sets, so we can decompose the question into two subproblems: 1. which districts have stores with less than 3000 products; 2. which districts have stores with more than 10000 products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['shop']. To complete the second subproblem, we also need to use tables ['shop'].\n\n<3> Operation: Use 'where' to filter using column 'Number_products' in table 'shop'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT district FROM shop WHERE Number_products < 3000 INTERSECT SELECT district FROM shop WHERE Number_products > 10000"
    },
    {
        "db_id": "employee_hire_evaluation",
        "gold": "SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000",
        "question": "Find the districts in which there are both shops selling less than 3000 products and shops selling more than 10000 products.",
        "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n",
        "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n",
        "types": {
            "employee.Employee_ID": "number",
            "employee.Name": "text",
            "employee.Age": "number",
            "employee.City": "text",
            "shop.Shop_ID": "number",
            "shop.Name": "text",
            "shop.Location": "text",
            "shop.District": "text",
            "shop.Number_products": "number",
            "shop.Manager_name": "text",
            "hiring.Shop_ID": "number",
            "hiring.Employee_ID": "number",
            "hiring.Start_from": "text",
            "hiring.Is_full_time": "others",
            "evaluation.Employee_ID": "text",
            "evaluation.Year_awarded": "text",
            "evaluation.Bonus": "number"
        },
        "number": 28,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. find the districts in which there are shops selling less than 3000 products; 2. find the districts in which there are shops selling more than 10000 products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['shop']. To complete the second subproblem, we also need to use tables ['shop'].\n\n<3> Operation: Use 'where' to filter using column 'Number_products' in table 'shop'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT district FROM shop WHERE Number_products < 3000 INTERSECT SELECT district FROM shop WHERE Number_products > 10000"
    },
    {
        "db_id": "cre_Doc_Template_Mgt",
        "gold": "SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'",
        "question": "What are the ids of documents that contain the paragraph text 'Brazil' and 'Ireland'?",
        "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n",
        "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n",
        "types": {
            "Ref_Template_Types.Template_Type_Code": "text",
            "Ref_Template_Types.Template_Type_Description": "text",
            "Templates.Template_ID": "number",
            "Templates.Version_Number": "number",
            "Templates.Template_Type_Code": "text",
            "Templates.Date_Effective_From": "time",
            "Templates.Date_Effective_To": "time",
            "Templates.Template_Details": "text",
            "Documents.Document_ID": "number",
            "Documents.Template_ID": "number",
            "Documents.Document_Name": "text",
            "Documents.Document_Description": "text",
            "Documents.Other_Details": "text",
            "Paragraphs.Paragraph_ID": "number",
            "Paragraphs.Document_ID": "number",
            "Paragraphs.Paragraph_Text": "text",
            "Paragraphs.Other_Details": "text"
        },
        "number": 31,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the ids of documents that contain the paragraph text 'Brazil'; 2. what are the ids of documents that contain the paragraph text 'Ireland'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Documents', 'Paragraphs'].\n\n<3> Operation: Use 'where' to filter using column 'Paragraph_Text' in table 'Paragraphs' for both subproblems.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Brazil' INTERSECT SELECT Document_ID FROM Paragraphs WHERE Paragraph_Text = 'Ireland'"
    },
    {
        "db_id": "museum_visit",
        "gold": "SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  <  2009 INTERSECT SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  >  2011",
        "question": "What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?",
        "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n",
        "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n",
        "types": {
            "museum.Museum_ID": "number",
            "museum.Name": "text",
            "museum.Num_of_Staff": "number",
            "museum.Open_Year": "text",
            "visitor.ID": "number",
            "visitor.Name": "text",
            "visitor.Level_of_membership": "number",
            "visitor.Age": "number",
            "visit.Museum_ID": "number",
            "visit.visitor_ID": "text",
            "visit.Num_of_Ticket": "number",
            "visit.Total_spent": "number"
        },
        "number": 35,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the museums opened before 2009; 2. what are the museums opened after 2011.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['museum']. To complete the second subproblem, we need to use table ['museum'].\n\n<3> Operation: Use 'where' to filter using column 'Open_Year' in table 'museum'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT visitor.Name FROM visitor JOIN visit ON visitor.ID = visit.visitor_ID JOIN museum ON visit.Museum_ID = museum.Museum_ID WHERE museum.Open_Year < 2009 INTERSECT SELECT visitor.Name FROM visitor JOIN visit ON visitor.ID = visit.visitor_ID JOIN museum ON visit.Museum_ID = museum.Museum_ID WHERE museum.Open_Year > 2011"
    },
    {
        "db_id": "wta_1",
        "gold": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
        "question": "List the names of all winners who played in both 2013 and 2016.",
        "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n",
        "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n",
        "types": {
            "players.player_id": "number",
            "players.first_name": "text",
            "players.last_name": "text",
            "players.hand": "text",
            "players.birth_date": "time",
            "players.country_code": "text",
            "matches.best_of": "number",
            "matches.draw_size": "number",
            "matches.loser_age": "number",
            "matches.loser_entry": "text",
            "matches.loser_hand": "text",
            "matches.loser_ht": "number",
            "matches.loser_id": "number",
            "matches.loser_ioc": "text",
            "matches.loser_name": "text",
            "matches.loser_rank": "number",
            "matches.loser_rank_points": "number",
            "matches.loser_seed": "number",
            "matches.match_num": "number",
            "matches.minutes": "number",
            "matches.round": "text",
            "matches.score": "text",
            "matches.surface": "text",
            "matches.tourney_date": "time",
            "matches.tourney_id": "text",
            "matches.tourney_level": "text",
            "matches.tourney_name": "text",
            "matches.winner_age": "number",
            "matches.winner_entry": "text",
            "matches.winner_hand": "text",
            "matches.winner_ht": "number",
            "matches.winner_id": "number",
            "matches.winner_ioc": "text",
            "matches.winner_name": "text",
            "matches.winner_rank": "number",
            "matches.winner_rank_points": "number",
            "matches.winner_seed": "number",
            "matches.year": "number",
            "rankings.ranking_date": "time",
            "rankings.ranking": "number",
            "rankings.player_id": "number",
            "rankings.ranking_points": "number",
            "rankings.tours": "number"
        },
        "number": 36,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. who are the winners who played in 2013; 2. who are the winners who played in 2016.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['matches', 'players']. To complete the second subproblem, we need to use tables ['matches', 'players'].\n\n<3> Operation: Since we want to find the winners who played in both 2013 and 2016, we need to perform an 'INTERSECT' operation on the subqueries.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT DISTINCT T1.winner_name FROM matches AS T1 JOIN players AS T2 ON T1.winner_id = T2.player_id WHERE T1.year = 2013 INTERSECT SELECT DISTINCT T1.winner_name FROM matches AS T1 JOIN players AS T2 ON T1.winner_id = T2.player_id WHERE T1.year = 2016"
    },
    {
        "db_id": "wta_1",
        "gold": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
        "question": "What are the names of players who won in both 2013 and 2016?",
        "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n",
        "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n",
        "types": {
            "players.player_id": "number",
            "players.first_name": "text",
            "players.last_name": "text",
            "players.hand": "text",
            "players.birth_date": "time",
            "players.country_code": "text",
            "matches.best_of": "number",
            "matches.draw_size": "number",
            "matches.loser_age": "number",
            "matches.loser_entry": "text",
            "matches.loser_hand": "text",
            "matches.loser_ht": "number",
            "matches.loser_id": "number",
            "matches.loser_ioc": "text",
            "matches.loser_name": "text",
            "matches.loser_rank": "number",
            "matches.loser_rank_points": "number",
            "matches.loser_seed": "number",
            "matches.match_num": "number",
            "matches.minutes": "number",
            "matches.round": "text",
            "matches.score": "text",
            "matches.surface": "text",
            "matches.tourney_date": "time",
            "matches.tourney_id": "text",
            "matches.tourney_level": "text",
            "matches.tourney_name": "text",
            "matches.winner_age": "number",
            "matches.winner_entry": "text",
            "matches.winner_hand": "text",
            "matches.winner_ht": "number",
            "matches.winner_id": "number",
            "matches.winner_ioc": "text",
            "matches.winner_name": "text",
            "matches.winner_rank": "number",
            "matches.winner_rank_points": "number",
            "matches.winner_seed": "number",
            "matches.year": "number",
            "rankings.ranking_date": "time",
            "rankings.ranking": "number",
            "rankings.player_id": "number",
            "rankings.ranking_points": "number",
            "rankings.tours": "number"
        },
        "number": 37,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of players who won in 2013; 2. what are the names of players who won in 2016.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['matches', 'players']. To complete the second subproblem, we need to use tables ['matches', 'players'].\n\n<3> Operation: For both subproblems, we need to filter the matches table based on the year and the winner_id column. We can use the 'where' clause for this operation.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.first_name, T1.last_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.year = 2013 INTERSECT SELECT T1.first_name, T1.last_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.year = 2016"
    },
    {
        "db_id": "wta_1",
        "gold": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
        "question": "What are the country code and first name of the players who won in both tourney WTA Championships and Australian Open?",
        "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n",
        "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n",
        "types": {
            "players.player_id": "number",
            "players.first_name": "text",
            "players.last_name": "text",
            "players.hand": "text",
            "players.birth_date": "time",
            "players.country_code": "text",
            "matches.best_of": "number",
            "matches.draw_size": "number",
            "matches.loser_age": "number",
            "matches.loser_entry": "text",
            "matches.loser_hand": "text",
            "matches.loser_ht": "number",
            "matches.loser_id": "number",
            "matches.loser_ioc": "text",
            "matches.loser_name": "text",
            "matches.loser_rank": "number",
            "matches.loser_rank_points": "number",
            "matches.loser_seed": "number",
            "matches.match_num": "number",
            "matches.minutes": "number",
            "matches.round": "text",
            "matches.score": "text",
            "matches.surface": "text",
            "matches.tourney_date": "time",
            "matches.tourney_id": "text",
            "matches.tourney_level": "text",
            "matches.tourney_name": "text",
            "matches.winner_age": "number",
            "matches.winner_entry": "text",
            "matches.winner_hand": "text",
            "matches.winner_ht": "number",
            "matches.winner_id": "number",
            "matches.winner_ioc": "text",
            "matches.winner_name": "text",
            "matches.winner_rank": "number",
            "matches.winner_rank_points": "number",
            "matches.winner_seed": "number",
            "matches.year": "number",
            "rankings.ranking_date": "time",
            "rankings.ranking": "number",
            "rankings.player_id": "number",
            "rankings.ranking_points": "number",
            "rankings.tours": "number"
        },
        "number": 38,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the country code and first name of the players who won in tourney WTA Championships; 2. what are the country code and first name of the players who won in Australian Open.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['matches', 'players']. To complete the second subproblem, we need to use tables ['matches', 'players'].\n\n<3> Operation: For both subproblems, we need to filter the matches based on the tourney name and then retrieve the country code and first name of the players who won.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.country_code, T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'WTA Championships' INTERSECT SELECT T1.country_code, T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'Australian Open'"
    },
    {
        "db_id": "wta_1",
        "gold": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
        "question": "What are the first names and country codes for players who won both the WTA Championships and the Australian Open?",
        "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n",
        "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n",
        "types": {
            "players.player_id": "number",
            "players.first_name": "text",
            "players.last_name": "text",
            "players.hand": "text",
            "players.birth_date": "time",
            "players.country_code": "text",
            "matches.best_of": "number",
            "matches.draw_size": "number",
            "matches.loser_age": "number",
            "matches.loser_entry": "text",
            "matches.loser_hand": "text",
            "matches.loser_ht": "number",
            "matches.loser_id": "number",
            "matches.loser_ioc": "text",
            "matches.loser_name": "text",
            "matches.loser_rank": "number",
            "matches.loser_rank_points": "number",
            "matches.loser_seed": "number",
            "matches.match_num": "number",
            "matches.minutes": "number",
            "matches.round": "text",
            "matches.score": "text",
            "matches.surface": "text",
            "matches.tourney_date": "time",
            "matches.tourney_id": "text",
            "matches.tourney_level": "text",
            "matches.tourney_name": "text",
            "matches.winner_age": "number",
            "matches.winner_entry": "text",
            "matches.winner_hand": "text",
            "matches.winner_ht": "number",
            "matches.winner_id": "number",
            "matches.winner_ioc": "text",
            "matches.winner_name": "text",
            "matches.winner_rank": "number",
            "matches.winner_rank_points": "number",
            "matches.winner_seed": "number",
            "matches.year": "number",
            "rankings.ranking_date": "time",
            "rankings.ranking": "number",
            "rankings.player_id": "number",
            "rankings.ranking_points": "number",
            "rankings.tours": "number"
        },
        "number": 39,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the first names and country codes for players who won the WTA Championships; 2. what are the first names and country codes for players who won the Australian Open.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['matches', 'players']. To complete the second subproblem, we need to use tables ['matches', 'players'].\n\n<3> Operation: For both subproblems, we need to filter the matches table to include only the rows where the tournament name is 'WTA Championships' or 'Australian Open'. Then, we need to perform a 'GROUP BY' operation on the column 'winner_id' and filter by performing 'HAVING COUNT()' on the column 'match_num' to ensure that the player has won both tournaments.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.first_name, T1.country_code FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'WTA Championships' GROUP BY T1.player_id HAVING COUNT(T2.match_num) > 0 INTERSECT SELECT T1.first_name, T1.country_code FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'Australian Open' GROUP BY T1.player_id HAVING COUNT(T2.match_num) > 0"
    },
    {
        "db_id": "student_transcripts_tracking",
        "gold": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
        "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.",
        "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n",
        "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n",
        "types": {
            "Addresses.address_id": "number",
            "Addresses.line_1": "text",
            "Addresses.line_2": "text",
            "Addresses.line_3": "text",
            "Addresses.city": "text",
            "Addresses.zip_postcode": "text",
            "Addresses.state_province_county": "text",
            "Addresses.country": "text",
            "Addresses.other_address_details": "text",
            "Courses.course_id": "number",
            "Courses.course_name": "text",
            "Courses.course_description": "text",
            "Courses.other_details": "text",
            "Departments.department_id": "number",
            "Departments.department_name": "text",
            "Departments.department_description": "text",
            "Departments.other_details": "text",
            "Degree_Programs.degree_program_id": "number",
            "Degree_Programs.department_id": "number",
            "Degree_Programs.degree_summary_name": "text",
            "Degree_Programs.degree_summary_description": "text",
            "Degree_Programs.other_details": "text",
            "Sections.section_id": "number",
            "Sections.course_id": "number",
            "Sections.section_name": "text",
            "Sections.section_description": "text",
            "Sections.other_details": "text",
            "Semesters.semester_id": "number",
            "Semesters.semester_name": "text",
            "Semesters.semester_description": "text",
            "Semesters.other_details": "text",
            "Students.student_id": "number",
            "Students.current_address_id": "number",
            "Students.permanent_address_id": "number",
            "Students.first_name": "text",
            "Students.middle_name": "text",
            "Students.last_name": "text",
            "Students.cell_mobile_number": "text",
            "Students.email_address": "text",
            "Students.ssn": "text",
            "Students.date_first_registered": "time",
            "Students.date_left": "time",
            "Students.other_student_details": "text",
            "Student_Enrolment.student_enrolment_id": "number",
            "Student_Enrolment.degree_program_id": "number",
            "Student_Enrolment.semester_id": "number",
            "Student_Enrolment.student_id": "number",
            "Student_Enrolment.other_details": "text",
            "Student_Enrolment_Courses.student_course_id": "number",
            "Student_Enrolment_Courses.course_id": "number",
            "Student_Enrolment_Courses.student_enrolment_id": "number",
            "Transcripts.transcript_id": "number",
            "Transcripts.transcript_date": "time",
            "Transcripts.other_details": "text",
            "Transcript_Contents.student_course_id": "number",
            "Transcript_Contents.transcript_id": "number"
        },
        "number": 41,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes filtering logic, so we can decompose the question into two subproblems: 1. find the student ids of students who currently live in the state of North Carolina; 2. find the last names of students who have not registered in any degree program.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Students', 'Addresses']. To complete the second subproblem, we need to use tables ['Students', 'Student_Enrolment', 'Degree_Programs'].\n\n<3> Operation: For the first subproblem, we need to filter using column 'state_province_county' in table 'Addresses'. For the second subproblem, we need to filter using column 'degree_program_id' in table 'Student_Enrolment' and check if it is null.\n\n<4> SQL Generation: Use 'inner join' operation to connect the queries of subproblems and form the final SQL statement.\n\n",
        "predict": "SELECT T1.last_name FROM Students AS T1 INNER JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = \"North Carolina\" AND T1.student_id NOT IN (SELECT T3.student_id FROM Student_Enrolment AS T3 WHERE T3.degree_program_id IS NOT NULL)"
    },
    {
        "db_id": "student_transcripts_tracking",
        "gold": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
        "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?",
        "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n",
        "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n",
        "types": {
            "Addresses.address_id": "number",
            "Addresses.line_1": "text",
            "Addresses.line_2": "text",
            "Addresses.line_3": "text",
            "Addresses.city": "text",
            "Addresses.zip_postcode": "text",
            "Addresses.state_province_county": "text",
            "Addresses.country": "text",
            "Addresses.other_address_details": "text",
            "Courses.course_id": "number",
            "Courses.course_name": "text",
            "Courses.course_description": "text",
            "Courses.other_details": "text",
            "Departments.department_id": "number",
            "Departments.department_name": "text",
            "Departments.department_description": "text",
            "Departments.other_details": "text",
            "Degree_Programs.degree_program_id": "number",
            "Degree_Programs.department_id": "number",
            "Degree_Programs.degree_summary_name": "text",
            "Degree_Programs.degree_summary_description": "text",
            "Degree_Programs.other_details": "text",
            "Sections.section_id": "number",
            "Sections.course_id": "number",
            "Sections.section_name": "text",
            "Sections.section_description": "text",
            "Sections.other_details": "text",
            "Semesters.semester_id": "number",
            "Semesters.semester_name": "text",
            "Semesters.semester_description": "text",
            "Semesters.other_details": "text",
            "Students.student_id": "number",
            "Students.current_address_id": "number",
            "Students.permanent_address_id": "number",
            "Students.first_name": "text",
            "Students.middle_name": "text",
            "Students.last_name": "text",
            "Students.cell_mobile_number": "text",
            "Students.email_address": "text",
            "Students.ssn": "text",
            "Students.date_first_registered": "time",
            "Students.date_left": "time",
            "Students.other_student_details": "text",
            "Student_Enrolment.student_enrolment_id": "number",
            "Student_Enrolment.degree_program_id": "number",
            "Student_Enrolment.semester_id": "number",
            "Student_Enrolment.student_id": "number",
            "Student_Enrolment.other_details": "text",
            "Student_Enrolment_Courses.student_course_id": "number",
            "Student_Enrolment_Courses.course_id": "number",
            "Student_Enrolment_Courses.student_enrolment_id": "number",
            "Transcripts.transcript_id": "number",
            "Transcripts.transcript_date": "time",
            "Transcripts.other_details": "text",
            "Transcript_Contents.student_course_id": "number",
            "Transcript_Contents.transcript_id": "number"
        },
        "number": 42,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the last names of the students who live in North Carolina; 2. what are the last names of the students who have not registered in any degree programs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables 'Students' and 'Addresses'. To complete the second subproblem, we need to use tables 'Students' and 'Student_Enrolment'.\n\n<3> Operation: Since we need to find students who have not registered in any degree programs, we can use a 'LEFT JOIN' operation between the 'Students' and 'Student_Enrolment' tables, and filter out the students who have a non-null value in the 'degree_program_id' column.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = \"North Carolina\" INTERSECT SELECT T1.last_name FROM Students AS T1 LEFT JOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id WHERE T2.degree_program_id IS NULL"
    },
    {
        "db_id": "student_transcripts_tracking",
        "gold": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
        "question": "Find the semester when both Master students and Bachelor students got enrolled in.",
        "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n",
        "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n",
        "types": {
            "Addresses.address_id": "number",
            "Addresses.line_1": "text",
            "Addresses.line_2": "text",
            "Addresses.line_3": "text",
            "Addresses.city": "text",
            "Addresses.zip_postcode": "text",
            "Addresses.state_province_county": "text",
            "Addresses.country": "text",
            "Addresses.other_address_details": "text",
            "Courses.course_id": "number",
            "Courses.course_name": "text",
            "Courses.course_description": "text",
            "Courses.other_details": "text",
            "Departments.department_id": "number",
            "Departments.department_name": "text",
            "Departments.department_description": "text",
            "Departments.other_details": "text",
            "Degree_Programs.degree_program_id": "number",
            "Degree_Programs.department_id": "number",
            "Degree_Programs.degree_summary_name": "text",
            "Degree_Programs.degree_summary_description": "text",
            "Degree_Programs.other_details": "text",
            "Sections.section_id": "number",
            "Sections.course_id": "number",
            "Sections.section_name": "text",
            "Sections.section_description": "text",
            "Sections.other_details": "text",
            "Semesters.semester_id": "number",
            "Semesters.semester_name": "text",
            "Semesters.semester_description": "text",
            "Semesters.other_details": "text",
            "Students.student_id": "number",
            "Students.current_address_id": "number",
            "Students.permanent_address_id": "number",
            "Students.first_name": "text",
            "Students.middle_name": "text",
            "Students.last_name": "text",
            "Students.cell_mobile_number": "text",
            "Students.email_address": "text",
            "Students.ssn": "text",
            "Students.date_first_registered": "time",
            "Students.date_left": "time",
            "Students.other_student_details": "text",
            "Student_Enrolment.student_enrolment_id": "number",
            "Student_Enrolment.degree_program_id": "number",
            "Student_Enrolment.semester_id": "number",
            "Student_Enrolment.student_id": "number",
            "Student_Enrolment.other_details": "text",
            "Student_Enrolment_Courses.student_course_id": "number",
            "Student_Enrolment_Courses.course_id": "number",
            "Student_Enrolment_Courses.student_enrolment_id": "number",
            "Transcripts.transcript_id": "number",
            "Transcripts.transcript_date": "time",
            "Transcripts.other_details": "text",
            "Transcript_Contents.student_course_id": "number",
            "Transcript_Contents.transcript_id": "number"
        },
        "number": 43,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the intersection of two sets, so we can decompose the question into two subproblems: 1. find the semesters when Master students got enrolled; 2. find the semesters when Bachelor students got enrolled.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Student_Enrolment', 'Degree_Programs', 'Departments', 'Semesters']. To complete the second subproblem, we need to use tables ['Student_Enrolment', 'Degree_Programs', 'Departments', 'Semesters'].\n\n<3> Operation: Use 'where' to filter using column 'degree_summary_name' in table 'Degree_Programs' for the first subproblem. For the second subproblem, use 'where' to filter using column 'degree_summary_name' in table 'Degree_Programs'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT semester_name FROM Semesters WHERE semester_id IN (SELECT semester_id FROM Student_Enrolment WHERE degree_program_id IN (SELECT degree_program_id FROM Degree_Programs WHERE degree_summary_name = 'Master')) INTERSECT SELECT semester_name FROM Semesters WHERE semester_id IN (SELECT semester_id FROM Student_Enrolment WHERE degree_program_id IN (SELECT degree_program_id FROM Degree_Programs WHERE degree_summary_name = 'Bachelor'))"
    },
    {
        "db_id": "student_transcripts_tracking",
        "gold": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
        "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?",
        "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n",
        "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n",
        "types": {
            "Addresses.address_id": "number",
            "Addresses.line_1": "text",
            "Addresses.line_2": "text",
            "Addresses.line_3": "text",
            "Addresses.city": "text",
            "Addresses.zip_postcode": "text",
            "Addresses.state_province_county": "text",
            "Addresses.country": "text",
            "Addresses.other_address_details": "text",
            "Courses.course_id": "number",
            "Courses.course_name": "text",
            "Courses.course_description": "text",
            "Courses.other_details": "text",
            "Departments.department_id": "number",
            "Departments.department_name": "text",
            "Departments.department_description": "text",
            "Departments.other_details": "text",
            "Degree_Programs.degree_program_id": "number",
            "Degree_Programs.department_id": "number",
            "Degree_Programs.degree_summary_name": "text",
            "Degree_Programs.degree_summary_description": "text",
            "Degree_Programs.other_details": "text",
            "Sections.section_id": "number",
            "Sections.course_id": "number",
            "Sections.section_name": "text",
            "Sections.section_description": "text",
            "Sections.other_details": "text",
            "Semesters.semester_id": "number",
            "Semesters.semester_name": "text",
            "Semesters.semester_description": "text",
            "Semesters.other_details": "text",
            "Students.student_id": "number",
            "Students.current_address_id": "number",
            "Students.permanent_address_id": "number",
            "Students.first_name": "text",
            "Students.middle_name": "text",
            "Students.last_name": "text",
            "Students.cell_mobile_number": "text",
            "Students.email_address": "text",
            "Students.ssn": "text",
            "Students.date_first_registered": "time",
            "Students.date_left": "time",
            "Students.other_student_details": "text",
            "Student_Enrolment.student_enrolment_id": "number",
            "Student_Enrolment.degree_program_id": "number",
            "Student_Enrolment.semester_id": "number",
            "Student_Enrolment.student_id": "number",
            "Student_Enrolment.other_details": "text",
            "Student_Enrolment_Courses.student_course_id": "number",
            "Student_Enrolment_Courses.course_id": "number",
            "Student_Enrolment_Courses.student_enrolment_id": "number",
            "Transcripts.transcript_id": "number",
            "Transcripts.transcript_date": "time",
            "Transcripts.other_details": "text",
            "Transcript_Contents.student_course_id": "number",
            "Transcript_Contents.transcript_id": "number"
        },
        "number": 44,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what is the id of the semester that had Masters students enrolled; 2. what is the id of the semester that had Bachelors students enrolled.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Semesters', 'Student_Enrolment', 'Degree_Programs']. To complete the second subproblem, we need to use tables ['Semesters', 'Student_Enrolment', 'Degree_Programs'].\n\n<3> Operation: Use 'where' to filter using column 'degree_summary_name' in table 'Degree_Programs' to find Masters students and Bachelors students respectively.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  \"Masters\" INTERSECT SELECT T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  \"Bachelors\""
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "question": "which countries' tv channels are not playing any cartoon written by Todd Casey?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 46,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes negation logic, so we can decompose the question into two subproblems: 1. what are the countries that have TV channels playing cartoons; 2. what are the countries that have TV channels playing cartoons written by Todd Casey.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['TV_Channel', 'Cartoon']. To complete the second subproblem, we also need to use tables ['TV_Channel', 'Cartoon'].\n\n<3> Operation: Use 'where' to filter using column 'Written_by' in table 'Cartoon'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id  =  T2.Channel EXCEPT SELECT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id  =  T2.Channel WHERE T2.Written_by  =  \"Todd Casey\""
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "question": "What are the countries that are not playing cartoons written by Todd Casey?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 47,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes negation logic, so we can decompose the question into two subproblems: 1. what are the countries that are playing cartoons; 2. what are the countries that are playing cartoons written by Todd Casey.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['TV_Channel', 'Cartoon']. To complete the second subproblem, we need to use tables ['TV_Channel', 'Cartoon'].\n\n<3> Operation: Use 'where' to filter using column 'Written_by' in table 'Cartoon'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT DISTINCT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id  =  T2.Channel EXCEPT SELECT DISTINCT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id  =  T2.Channel WHERE T2.Written_by  =  \"Todd Casey\""
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",
        "question": "What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 48,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the series names and countries of TV channels playing cartoons directed by Ben Jones; 2. what are the series names and countries of TV channels playing cartoons directed by Michael Chang.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Cartoon', 'TV_Channel']. To complete the second subproblem, we also need to use tables ['Cartoon', 'TV_Channel'].\n\n<3> Operation: Use 'where' to filter out the cartoons directed by Ben Jones and cartoons directed by Michael Chang.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT series_name, Country FROM TV_Channel WHERE id IN (SELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones') INTERSECT SELECT series_name, Country FROM TV_Channel WHERE id IN (SELECT Channel FROM Cartoon WHERE Directed_by = 'Michael Chang')"
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
        "question": "find the id of tv channels that do not play any cartoon directed by Ben Jones.",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 49,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes exclusion logic, so we can decompose the question into two subproblems: 1. find the cartoons directed by Ben Jones; 2. find the TV channels that do not play any of the cartoons directed by Ben Jones.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Cartoon', 'TV_Channel'].\n\n<3> Operation: Use 'where' to filter using column 'Directed_by' in table 'Cartoon'.\n\n<4> SQL Generation: Use 'not exists' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.id FROM TV_Channel AS T1 WHERE NOT EXISTS (SELECT * FROM Cartoon AS T2 WHERE T2.Directed_by = 'Ben Jones' AND T2.Channel = T1.id)"
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
        "question": "What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 50,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes exclusion logic, so we can decompose the question into two subproblems: 1. what are the ids of the TV channels that have cartoons directed by Ben Jones; 2. what are all the TV channel ids. Then we can exclude the TV channels from the second subproblem that are present in the first subproblem.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Cartoon', 'TV_Channel']. To complete the second subproblem, we need to use table ['TV_Channel'].\n\n<3> Operation: For the first subproblem, we need to perform a 'JOIN' operation on the columns 'Channel' in tables 'Cartoon' and 'TV_Channel', and filter by 'Directed_by = \"Ben Jones\"'. For the second subproblem, we need to select all the ids from the table 'TV_Channel'.\n\n<4> SQL Generation: Use 'NOT IN' operation to exclude the TV channels from the second subproblem that are present in the first subproblem, and form the final SQL statement.\n\n",
        "predict": "SELECT id FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE Directed_by = \"Ben Jones\")"
    },
    {
        "db_id": "voter_1",
        "gold": "SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Tabatha Gehling' INTERSECT SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Kelly Clauss'",
        "question": "List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'.",
        "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n",
        "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n",
        "types": {
            "AREA_CODE_STATE.area_code": "number",
            "AREA_CODE_STATE.state": "text",
            "CONTESTANTS.contestant_number": "number",
            "CONTESTANTS.contestant_name": "text",
            "VOTES.vote_id": "number",
            "VOTES.phone_number": "number",
            "VOTES.state": "text",
            "VOTES.contestant_number": "number",
            "VOTES.created": "time"
        },
        "number": 54,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the area codes in which voters voted for the contestant 'Tabatha Gehling'; 2. what are the area codes in which voters voted for the contestant 'Kelly Clauss'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['VOTES', 'CONTESTANTS', 'AREA_CODE_STATE']. To complete the second subproblem, we also need to use tables ['VOTES', 'CONTESTANTS', 'AREA_CODE_STATE'].\n\n<3> Operation: Use 'where' to filter using column 'contestant_name' in table 'CONTESTANTS'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT area_code FROM AREA_CODE_STATE WHERE state IN (SELECT state FROM VOTES JOIN CONTESTANTS ON VOTES.contestant_number = CONTESTANTS.contestant_number WHERE CONTESTANTS.contestant_name = 'Tabatha Gehling') INTERSECT SELECT area_code FROM AREA_CODE_STATE WHERE state IN (SELECT state FROM VOTES JOIN CONTESTANTS ON VOTES.contestant_number = CONTESTANTS.contestant_number WHERE CONTESTANTS.contestant_name = 'Kelly Clauss')"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\")",
        "question": "How many countries speak both English and Dutch?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 55,
        "hardness": "easy",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the intersection of two sets, so we can decompose the question into two subproblems: 1. what are the countries that speak English; 2. what are the countries that speak Dutch.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT COUNT(*) FROM (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' INTERSECT SELECT CountryCode FROM countrylanguage WHERE Language = 'Dutch') AS T"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\")",
        "question": "What is the number of nations that use English and Dutch?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 56,
        "hardness": "easy",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the intersection of two sets, so we can decompose the question into two subproblems: 1. what are the nations that use English; 2. what are the nations that use Dutch.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT COUNT(*) FROM country AS C JOIN countrylanguage AS CL ON C.Code = CL.CountryCode WHERE CL.Language = \"English\" INTERSECT SELECT COUNT(*) FROM country AS C JOIN countrylanguage AS CL ON C.Code = CL.CountryCode WHERE CL.Language = \"Dutch\""
    },
    {
        "db_id": "world_1",
        "gold": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\"",
        "question": "What are the names of nations speak both English and French?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 57,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the names of nations that speak English; 2. what are the names of nations that speak French.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English') INTERSECT SELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'French')"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\"",
        "question": "Give the names of nations that speak both English and French.",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 58,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of nations that speak English; 2. what are the names of nations that speak French.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT C1.Name FROM country AS C1 JOIN countrylanguage AS CL1 ON C1.Code = CL1.CountryCode WHERE CL1.Language = \"English\" INTERSECT SELECT C2.Name FROM country AS C2 JOIN countrylanguage AS CL2 ON C2.Code = CL2.CountryCode WHERE CL2.Language = \"French\""
    },
    {
        "db_id": "world_1",
        "gold": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
        "question": "What are the names of nations where both English and French are official languages?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 59,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the names of nations where English is an official language; 2. what are the names of nations where French is an official language.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' and 'IsOfficial' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T') INTERSECT SELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'French' AND IsOfficial = 'T')"
    },
    {
        "db_id": "world_1",
        "gold": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  \"english\" and isofficial  =  \"t\" union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  \"dutch\" and isofficial  =  \"t\"",
        "question": "What are the countries where either English or Dutch is the official language ?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 62,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the logical OR operation, so we can decompose the question into two subproblems: 1. what are the countries where English is the official language; 2. what are the countries where Dutch is the official language.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'IsOfficial' in table 'countrylanguage' and column 'Language' in table 'country'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT C1.Name FROM country AS C1 JOIN countrylanguage AS CL1 ON C1.Code  =  CL1.CountryCode WHERE CL1.Language  =  \"English\" AND CL1.IsOfficial  =  \"T\" UNION SELECT C2.Name FROM country AS C2 JOIN countrylanguage AS CL2 ON C2.Code  =  CL2.CountryCode WHERE CL2.Language  =  \"Dutch\" AND CL2.IsOfficial  =  \"T\""
    },
    {
        "db_id": "world_1",
        "gold": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND IsOfficial  =  \"T\" UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\" AND IsOfficial  =  \"T\"",
        "question": "Which countries have either English or Dutch as an official language?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 63,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the union set logic, so we can decompose the question into two subproblems: 1. what are the countries that have English as an official language; 2. what are the countries that have Dutch as an official language.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'IsOfficial' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "\nSELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T')\nUNION\nSELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'Dutch' AND IsOfficial = 'T')"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 64,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes negation logic, so we can decompose the question into two subproblems: 1. what are the codes of the countries that speak English; 2. what are the codes of the countries whose government forms are Republic.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use table 'country'.\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage' and column 'GovernmentForm' in table 'country'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT C1.Code FROM country AS C1 WHERE C1.Code NOT IN (SELECT CL.CountryCode FROM countrylanguage AS CL WHERE CL.Language = \"English\") EXCEPT SELECT C2.Code FROM country AS C2 WHERE C2.GovernmentForm = \"Republic\""
    },
    {
        "db_id": "world_1",
        "gold": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "question": "Return the codes of countries that do not speak English and do not have Republics for governments.",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 65,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes exclusion logic, so we can decompose the question into two subproblems: 1. return the codes of countries that do not speak English; 2. return the codes of countries that do not have Republics for governments.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage' and column 'GovernmentForm' in table 'country'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English') EXCEPT SELECT Code FROM country WHERE GovernmentForm = 'Republic'"
    },
    {
        "db_id": "orchestra",
        "gold": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
        "question": "Show the record companies shared by orchestras founded before 2003 and after 2003.",
        "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n",
        "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n",
        "types": {
            "conductor.Conductor_ID": "number",
            "conductor.Name": "text",
            "conductor.Age": "number",
            "conductor.Nationality": "text",
            "conductor.Year_of_Work": "number",
            "orchestra.Orchestra_ID": "number",
            "orchestra.Orchestra": "text",
            "orchestra.Conductor_ID": "number",
            "orchestra.Record_Company": "text",
            "orchestra.Year_of_Founded": "number",
            "orchestra.Major_Record_Format": "text",
            "performance.Performance_ID": "number",
            "performance.Orchestra_ID": "number",
            "performance.Type": "text",
            "performance.Date": "text",
            "performance.Official_ratings_(millions)": "number",
            "performance.Weekly_rank": "text",
            "performance.Share": "text",
            "show.Show_ID": "number",
            "show.Performance_ID": "number",
            "show.If_first_show": "others",
            "show.Result": "text",
            "show.Attendance": "number"
        },
        "number": 67,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the record companies of orchestras founded before 2003; 2. what are the record companies of orchestras founded after 2003.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['orchestra']. To complete the second subproblem, we also need to use tables ['orchestra'].\n\n<3> Operation: Use 'where' to filter using column 'Year_of_Founded' in table 'orchestra'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
    },
    {
        "db_id": "orchestra",
        "gold": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
        "question": "What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?",
        "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n",
        "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n",
        "types": {
            "conductor.Conductor_ID": "number",
            "conductor.Name": "text",
            "conductor.Age": "number",
            "conductor.Nationality": "text",
            "conductor.Year_of_Work": "number",
            "orchestra.Orchestra_ID": "number",
            "orchestra.Orchestra": "text",
            "orchestra.Conductor_ID": "number",
            "orchestra.Record_Company": "text",
            "orchestra.Year_of_Founded": "number",
            "orchestra.Major_Record_Format": "text",
            "performance.Performance_ID": "number",
            "performance.Orchestra_ID": "number",
            "performance.Type": "text",
            "performance.Date": "text",
            "performance.Official_ratings_(millions)": "number",
            "performance.Weekly_rank": "text",
            "performance.Share": "text",
            "show.Show_ID": "number",
            "show.Performance_ID": "number",
            "show.If_first_show": "others",
            "show.Result": "text",
            "show.Attendance": "number"
        },
        "number": 68,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the record companies used by orchestras founded before 2003; 2. what are the record companies used by orchestras founded after 2003.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['orchestra']. To complete the second subproblem, we also need to use tables ['orchestra'].\n\n<3> Operation: Use 'where' to filter using column 'Year_of_Founded' in table 'orchestra'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003"
    },
    {
        "db_id": "singer",
        "gold": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955",
        "question": "Show the citizenship shared by singers with birth year before 1945 and after 1955.",
        "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n",
        "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n",
        "types": {
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Birth_Year": "number",
            "singer.Net_Worth_Millions": "number",
            "singer.Citizenship": "text",
            "song.Song_ID": "number",
            "song.Title": "text",
            "song.Singer_ID": "number",
            "song.Sales": "number",
            "song.Highest_Position": "number"
        },
        "number": 91,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. singers with birth year before 1945; 2. singers with birth year after 1955.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['singer']. To complete the second subproblem, we also need to use table ['singer'].\n\n<3> Operation: Since we need to find the citizenship shared by singers, we can perform a 'GROUP BY' operation on the column 'Citizenship' and filter by the birth year conditions.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Citizenship FROM singer WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year > 1955"
    },
    {
        "db_id": "singer",
        "gold": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955",
        "question": "What are the citizenships that are shared by singers with a birth year before 1945 and after 1955?",
        "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n",
        "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n",
        "types": {
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Birth_Year": "number",
            "singer.Net_Worth_Millions": "number",
            "singer.Citizenship": "text",
            "song.Song_ID": "number",
            "song.Title": "text",
            "song.Singer_ID": "number",
            "song.Sales": "number",
            "song.Highest_Position": "number"
        },
        "number": 92,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes set intersection logic, so we can decompose the question into two subproblems: 1. what are the citizenships of singers with a birth year before 1945; 2. what are the citizenships of singers with a birth year after 1955.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'singer'. To complete the second subproblem, we also need to use table 'singer'.\n\n<3> Operation: Use 'where' to filter using column 'Birth_Year' in table 'singer'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT citizenship FROM singer WHERE Birth_Year < 1945 INTERSECT SELECT citizenship FROM singer WHERE Birth_Year > 1955"
    },
    {
        "db_id": "real_estate_properties",
        "gold": "SELECT property_name FROM Properties WHERE property_type_code  =  \"House\" UNION SELECT property_name FROM Properties WHERE property_type_code  =  \"Apartment\" AND room_count  >  1",
        "question": "What are the names of properties that are either houses or apartments with more than 1 room?",
        "foreign_keys": "Foreign_keys = [Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code,Other_Property_Features.property_id = Properties.property_id,Other_Property_Features.feature_id = Other_Available_Features.feature_id]\n",
        "tables": "Table Other_Available_Features, columns = [*,feature_id,feature_type_code,feature_name,feature_description]\nTable Other_Property_Features, columns = [*,property_id,feature_id,property_feature_description]\nTable Properties, columns = [*,property_id,property_type_code,date_on_market,date_sold,property_name,property_address,room_count,vendor_requested_price,buyer_offered_price,agreed_selling_price,apt_feature_1,apt_feature_2,apt_feature_3,fld_feature_1,fld_feature_2,fld_feature_3,hse_feature_1,hse_feature_2,hse_feature_3,oth_feature_1,oth_feature_2,oth_feature_3,shp_feature_1,shp_feature_2,shp_feature_3,other_property_details]\nTable Ref_Feature_Types, columns = [*,feature_type_code,feature_type_name]\nTable Ref_Property_Types, columns = [*,property_type_code,property_type_description]\n",
        "types": {
            "Ref_Feature_Types.feature_type_code": "text",
            "Ref_Feature_Types.feature_type_name": "text",
            "Ref_Property_Types.property_type_code": "text",
            "Ref_Property_Types.property_type_description": "text",
            "Other_Available_Features.feature_id": "number",
            "Other_Available_Features.feature_type_code": "text",
            "Other_Available_Features.feature_name": "text",
            "Other_Available_Features.feature_description": "text",
            "Properties.property_id": "number",
            "Properties.property_type_code": "text",
            "Properties.date_on_market": "time",
            "Properties.date_sold": "time",
            "Properties.property_name": "text",
            "Properties.property_address": "text",
            "Properties.room_count": "number",
            "Properties.vendor_requested_price": "number",
            "Properties.buyer_offered_price": "number",
            "Properties.agreed_selling_price": "number",
            "Properties.apt_feature_1": "text",
            "Properties.apt_feature_2": "text",
            "Properties.apt_feature_3": "text",
            "Properties.fld_feature_1": "text",
            "Properties.fld_feature_2": "text",
            "Properties.fld_feature_3": "text",
            "Properties.hse_feature_1": "text",
            "Properties.hse_feature_2": "text",
            "Properties.hse_feature_3": "text",
            "Properties.oth_feature_1": "text",
            "Properties.oth_feature_2": "text",
            "Properties.oth_feature_3": "text",
            "Properties.shp_feature_1": "text",
            "Properties.shp_feature_2": "text",
            "Properties.shp_feature_3": "text",
            "Properties.other_property_details": "text",
            "Other_Property_Features.property_id": "number",
            "Other_Property_Features.feature_id": "number",
            "Other_Property_Features.property_feature_description": "text"
        },
        "number": 93,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union set logic, so we can decompose the question into two subproblems: 1. what are the names of houses with more than 1 room; 2. what are the names of apartments with more than 1 room.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Properties', 'Ref_Property_Types']. To complete the second subproblem, we need to use tables ['Properties', 'Ref_Property_Types'].\n\n<3> Operation: Use 'where' to filter out the houses and apartments with more than 1 room.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "\nSELECT property_name FROM Properties \nWHERE property_type_code = (SELECT property_type_code FROM Ref_Property_Types WHERE property_type_description = 'house') \nAND room_count > 1\nUNION\nSELECT property_name FROM Properties \nWHERE property_type_code = (SELECT property_type_code FROM Ref_Property_Types WHERE property_type_description = 'apartment') \nAND room_count > 1"
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",
        "question": "Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query requires finding the series name and country of the TV channel that is playing cartoons directed by Ben Jones and Michael Chang.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we need to use tables ['Cartoon', 'TV_Channel'].\n\n<3> Operation: Use 'join' operation to connect the tables based on the foreign key relationships and 'where' to filter out the cartoons directed by Ben Jones and Michael Chang.\n\n<4> SQL Generation: Use 'select' to retrieve the series name and country columns from the TV_Channel table.\n\n",
        "predict": "SELECT TV_Channel.series_name, TV_Channel.Country FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE Cartoon.Directed_by IN ('Ben Jones', 'Michael Chang')"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
        "question": "Give the names of countries with English and French as official languages.",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of countries with English as an official language; 2. what are the names of countries with French as an official language.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: For both subproblems, we need to perform a 'JOIN' operation on the column 'Code' in the 'country' table and the column 'CountryCode' in the 'countrylanguage' table. Then, we need to filter the results by selecting only the rows where the column 'Language' is equal to 'English' for the first subproblem and 'French' for the second subproblem.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'French'"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "question": "What are the country codes for countries that do not speak English?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes negation logic, so we can decompose the question into two subproblems: 1. what are the country codes for countries that speak English; 2. what are the country codes for all countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we need to use table 'country'.\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Code FROM country EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = \"English\""
    },
    {
        "db_id": "world_1",
        "gold": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "question": "Return the country codes for countries that do not speak English.",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query asks for the country codes of countries that do not speak English.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'not in' operation to exclude the country codes where the language is English.\n\n",
        "predict": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = \"English\")"
    }
]