[{"db_id": "car_1", "gold": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "question": "Which countries in europe have at least 3 car manufacturers?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 30, "hardness": "extra", "reasoning": "<1> Operation: The query requires the countries in Europe that have at least 3 car manufacturers. So we should apply the 'count' operation to the 'Id' column in the 'car_makers' table, and find the countries with a count of at least 3. Since the unit to which the car manufacturers being counted in the query belong is the country, we should apply the 'group by' operation to the 'Country' column in the 'car_makers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['car_makers', 'countries', 'continents'].\n\n<3> SQL Generation: The query requires the countries in Europe that have at least 3 car manufacturers, so we should select the 'CountryName' column from the 'countries' table. We also need to join the 'car_makers' table with the 'countries' table and the 'continents' table to ensure that we are only considering countries in Europe.\n\n", "predict": "SELECT CountryName FROM car_makers \nJOIN countries ON car_makers.Country = countries.CountryId \nJOIN continents ON countries.Continent = continents.ContId \nGROUP BY Country \nHAVING COUNT(*) >= 3 \nAND continents.Continent = 'Europe'"}, {"db_id": "car_1", "gold": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "question": "What are the names of all European countries with at least 3 manufacturers?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 31, "hardness": "extra", "reasoning": "<1> Operation: The query requires the names of all European countries with at least 3 manufacturers, so we should apply the 'count' operation to the 'Id' column in the 'car_makers' table, and find the countries with a count of at least 3. Since the unit to which the manufacturers being counted in the query belong is the country, we should apply the 'group by' operation to the 'Country' column in the 'car_makers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['car_makers', 'countries', 'continents'].\n\n<3> SQL Generation: The query requires the names of all European countries with at least 3 manufacturers, so we should select the 'CountryName' column in the 'countries' table. We also need to join the 'car_makers' table with the 'countries' table and the 'continents' table to ensure that we are only considering European countries. Finally, we should apply the 'count' operation to the 'Id' column in the 'car_makers' table and filter the result to only include countries with a count of at least 3.\n\n", "predict": "SELECT CountryName FROM car_makers JOIN countries ON car_makers.Country = countries.CountryId JOIN continents ON countries.Continent = continents.ContId WHERE continents.Continent = 'Europe' GROUP BY countries.CountryName HAVING COUNT(car_makers.Id) >= 3"}, {"db_id": "car_1", "gold": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 41, "hardness": "extra", "reasoning": "<1> Operation: The query requires finding the model with the largest horsepower among cars with 4 cylinders. So, we should filter the cars based on the 'Cylinders' column in the 'cars_data' table, selecting only the rows where 'Cylinders' equals 4. Then, we should find the model with the largest 'Horsepower' among these filtered rows.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables 'cars_data' and 'car_names'.\n\n<3> SQL Generation: The query requires finding the model with the largest horsepower among cars with 4 cylinders. So, we should select the 'Model' column in the 'car_names' table and the 'Horsepower' column in the 'cars_data' table. We also need to filter the rows where 'Cylinders' equals 4 in the 'cars_data' table. Finally, we should order the result by 'Horsepower' in descending order and limit the result to 1 row.\n\n", "predict": "SELECT car_names.Model FROM car_names JOIN cars_data ON car_names.MakeId = cars_data.Id WHERE cars_data.Cylinders = 4 ORDER BY cars_data.Horsepower DESC LIMIT 1"}, {"db_id": "car_1", "gold": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 42, "hardness": "extra", "reasoning": "<1> Operation: The query requires finding the model with the most horsepower among all 4 cylinder cars. So we should filter the cars based on the 'Cylinders' column and select the model with the maximum value in the 'Horsepower' column.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables 'cars_data', 'car_names', 'model_list', and 'car_makers'.\n\n<3> SQL Generation: The query requires finding the model with the most horsepower among all 4 cylinder cars, so we should select the 'Model' column in the 'model_list' table and the 'Horsepower' column in the 'cars_data' table. We also need to filter the cars based on the 'Cylinders' column in the 'cars_data' table.\n\n", "predict": "SELECT model_list.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId JOIN model_list ON car_names.Model = model_list.Model JOIN car_makers ON model_list.Maker = car_makers.Id WHERE cars_data.Cylinders = 4 ORDER BY cars_data.Horsepower DESC LIMIT 1"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1", "question": "Which cities do more than one employee under age 30 come from?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "number": 58, "hardness": "medium", "reasoning": "<1> Operation: The query requires cities where more than one employee under the age of 30 comes from. So we should apply the 'count' operation to the 'Employee_ID' column in the 'employee' table, with the condition that the 'Age' column is less than 30. Then we need to filter the result to only include cities with a count greater than 1.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['employee'].\n\n<3> SQL Generation: The query requires cities where more than one employee under the age of 30 comes from, so we should select the 'City' column in the 'employee' table. We need to apply the 'count' operation to the 'Employee_ID' column and group the result by the 'City' column. Then we need to filter the result to only include cities with a count greater than 1 and the 'Age' column less than 30.\n\n", "predict": "SELECT City FROM employee WHERE Age < 30 GROUP BY City HAVING COUNT(Employee_ID) > 1"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1", "question": "Find the cities that have more than one employee under age 30.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "number": 59, "hardness": "medium", "reasoning": "<1> Operation: The query requires finding the cities that have more than one employee under age 30. So we should apply the 'count' operation to the 'City' column in the 'employee' table, filtering for employees under age 30, and find the cities with a count greater than 1. Since the unit to which the employees being counted in the query belong is the city, we should apply the 'group by' operation to the 'City' column in the 'employee' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need to use the 'employee' table in this case.\n\n<3> SQL Generation: The query requires finding the cities that have more than one employee under age 30, so we should select the 'City' column from the 'employee' table, filter for employees under age 30, group by 'City', and count the number of employees in each city. Finally, we should filter for cities with a count greater than 1.\n\n", "predict": "SELECT City FROM employee WHERE Age < 30 GROUP BY City HAVING COUNT(*) > 1"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  \"Asia\" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1", "question": "What is the language that is used by the largest number of Asian nations?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 181, "hardness": "extra", "reasoning": "<1> Operation: The query requires the language that is used by the largest number of Asian nations, so we should apply the 'count' operation to the 'CountryCode' column in the 'countrylanguage' table and find the language with the highest count. Since we are looking for Asian nations, we should filter for countries in the 'country' table that have 'Continent' equal to 'Asia'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: The query requires the language that is used by the largest number of Asian nations, so we should select the 'Language' column in the 'countrylanguage' table. We also need to filter for countries in Asia and order the result by the count in descending order.\n\n", "predict": "SELECT Language FROM countrylanguage WHERE CountryCode IN (SELECT Code FROM country WHERE Continent = 'Asia') GROUP BY Language ORDER BY COUNT(*) DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District", "question": "Find the number of cities in each district whose population is greater than the average population of cities?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 184, "hardness": "extra", "reasoning": "<1> Operation: The query requires finding the number of cities in each district whose population is greater than the average population of cities. We should apply the 'count' operation to the 'ID' column in the 'city' table, and filter the cities based on the population condition. We also need to calculate the average population of cities.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'city' table for counting the cities and filtering based on population, and the 'country' table for calculating the average population.\n\n<3> SQL Generation: The query requires finding the number of cities in each district whose population is greater than the average population of cities. We should select the 'District' column and apply the 'count' operation to the 'ID' column in the 'city' table. We also need to calculate the average population of cities using the 'AVG' function and filter the cities based on the population condition.\n\n", "predict": "SELECT District, COUNT(ID) FROM city WHERE Population > (SELECT AVG(Population) FROM city) GROUP BY District"}, {"db_id": "world_1", "gold": "SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District", "question": "How many cities in each district have a population that is above the average population across all cities?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 185, "hardness": "extra", "reasoning": "<1> Operation: The query requires counting the number of cities in each district that have a population above the average population across all cities. We need to apply the 'count' operation to the 'city' table and filter the cities based on the population condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['city'] and ['country'].\n\n<3> SQL Generation: The query requires counting the number of cities in each district that have a population above the average population across all cities. We should select the 'District' column and apply the 'count' operation to the 'ID' column in the 'city' table. We also need to filter the cities based on the population condition, which involves calculating the average population across all cities. To achieve this, we can use a subquery to calculate the average population and then compare it with the 'Population' column in the 'city' table.\n\n", "predict": "SELECT District, COUNT(ID) FROM city WHERE Population > (SELECT AVG(Population) FROM city) GROUP BY District"}, {"db_id": "world_1", "gold": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode", "question": "What is the total number of countries where Spanish is spoken by the largest percentage of people?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 192, "hardness": "extra", "reasoning": "<1> Operation: The query requires the total number of countries where Spanish is spoken by the largest percentage of people, so we should apply the 'max' operation to the 'Percentage' column in the 'countrylanguage' table. Since the unit to which the percentages being compared in the query belong is the country, we do not need to apply any grouping or sorting operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: The query requires the total number of countries where Spanish is spoken by the largest percentage of people, so we should count the number of countries where the 'Percentage' column in the 'countrylanguage' table is equal to the maximum percentage for Spanish. We also need to filter for the 'Language' column in the 'countrylanguage' table to be equal to 'Spanish'.\n\n", "predict": "SELECT COUNT(*) FROM countrylanguage WHERE Language = 'Spanish' AND Percentage = (SELECT MAX(Percentage) FROM countrylanguage WHERE Language = 'Spanish')"}, {"db_id": "world_1", "gold": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 193, "hardness": "medium", "reasoning": "<1> Operation: The query requires the codes of countries where Spanish is spoken by the largest percentage of people, so we should apply the 'max' operation to the 'Percentage' column in the 'countrylanguage' table. Since we are interested in the countries where Spanish is spoken, we should filter the rows where the 'Language' column is equal to 'Spanish'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: The query requires the codes of countries where Spanish is spoken by the largest percentage of people, so we should select the 'Code' column in the 'country' table. We also need to join the 'country' and 'countrylanguage' tables on the 'CountryCode' column.\n\n", "predict": "SELECT country.Code FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language = 'Spanish' GROUP BY country.Code ORDER BY MAX(countrylanguage.Percentage) DESC LIMIT 1"}, {"db_id": "network_1", "gold": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2", "question": "What are the names of high schoolers who have a grade of over 5 and have 2 or more friends?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "number": 228, "hardness": "hard", "reasoning": "<1> Operation: The query requires the names of high schoolers who have a grade of over 5 and have 2 or more friends. So we should apply the 'filter' operation to the 'grade' column in the 'Highschooler' table to select high schoolers with a grade over 5. Then we should apply the 'group by' operation to the 'name' column in the 'Highschooler' table and the 'count' operation to the 'friend_id' column in the 'Friend' table to find high schoolers with 2 or more friends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Highschooler', 'Friend'].\n\n<3> SQL Generation: The query requires the names of high schoolers who have a grade of over 5 and have 2 or more friends, so we should select the 'name' column in the 'Highschooler' table. We should also join the 'Friend' table with the 'Highschooler' table on the 'ID' column to link the high schoolers with their friends. Then we should apply the 'filter' operation to the 'grade' column in the 'Highschooler' table to select high schoolers with a grade over 5. Finally, we should apply the 'group by' operation to the 'name' column in the 'Highschooler' table and the 'count' operation to the 'friend_id' column in the 'Friend' table, and set the condition that the count should be greater than or equal to 2.\n\n", "predict": "SELECT name FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id WHERE grade > 5 GROUP BY name HAVING COUNT(friend_id) >= 2"}]