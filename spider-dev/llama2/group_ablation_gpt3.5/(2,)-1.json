[{"db_id": "pets_1", "gold": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog'", "question": "What are the first names of every student who has a cat or dog as a pet?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "number": 4, "hardness": "extra", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the logical OR operation, so we can decompose the question into two subproblems: 1. what are the first names of students who have a cat as a pet; 2. what are the first names of students who have a dog as a pet.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Has_Pet', 'Student', 'Pets']. To complete the second subproblem, we need to use tables ['Has_Pet', 'Student', 'Pets'].\n\n<3> Operation: Use 'join' operation to connect the tables based on the foreign key relationships. Use 'where' to filter using column 'PetType' in table 'Pets'.\n\n<4> SQL Generation: Use 'union' operation to combine the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT DISTINCT Student.Fname FROM Has_Pet JOIN Student ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'cat' UNION SELECT DISTINCT Student.Fname FROM Has_Pet JOIN Student ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'dog'"}, {"db_id": "pets_1", "gold": "SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')", "question": "Find the major and age of students who do not have a cat pet.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "number": 7, "hardness": "extra", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes exclusion logic, so we can decompose the question into two subproblems: 1. what are the StuIDs of students who have a cat pet; 2. what are the major and age of students who do not have the StuIDs obtained from the first subproblem.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Has_Pet', 'Pets']. To complete the second subproblem, we also need to use tables ['Student'].\n\n<3> Operation: Use 'where' to filter using column 'PetType' in table 'Pets'.\n\n<4> SQL Generation: Use 'not in' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT Major, Age FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE PetType = \"cat\")"}, {"db_id": "pets_1", "gold": "SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')", "question": "What major is every student who does not own a cat as a pet, and also how old are they?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "number": 8, "hardness": "extra", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes negation logic, so we can decompose the question into two subproblems: 1. what are the students who own a cat as a pet; 2. what are the students who do not own a cat as a pet.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Student', 'Has_Pet', 'Pets']. To complete the second subproblem, we also need to use tables ['Student', 'Has_Pet', 'Pets'].\n\n<3> Operation: Use 'where' to filter using column 'PetType' in table 'Pets'.\n\n<4> SQL Generation: Use 'not exists' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT S.Major, S.Age FROM Student AS S WHERE NOT EXISTS (SELECT * FROM Has_Pet AS HP JOIN Pets AS P ON HP.PetID = P.PetID WHERE HP.StuID = S.StuID AND P.PetType = \"cat\")"}, {"db_id": "pets_1", "gold": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')", "question": "Find the first name and age of students who have a dog but do not have a cat as a pet.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "number": 11, "hardness": "extra", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the presence of a dog and the absence of a cat, so we can decompose the question into two subproblems: 1. what are the students who have a dog; 2. what are the students who do not have a cat.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Student', 'Has_Pet', 'Pets'].\n\n<3> Operation: Use 'where' to filter using column 'PetType' in table 'Pets'.\n\n<4> SQL Generation: Use 'intersect' and 'except' operations to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT T1.Fname, T1.Age FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T2.PetID = T3.PetID WHERE T3.PetType = \"dog\" INTERSECT SELECT T1.Fname, T1.Age FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T2.PetID = T3.PetID WHERE T3.PetType != \"cat\""}, {"db_id": "pets_1", "gold": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')", "question": "What is the first name of every student who has a dog but does not have a cat?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "number": 12, "hardness": "extra", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the presence of a dog and the absence of a cat, so we can decompose the question into two subproblems: 1. what are the student IDs who have a dog; 2. what are the student IDs who have a cat.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Student', 'Has_Pet', 'Pets'].\n\n<3> Operation: Use 'where' to filter using column 'PetType' in table 'Pets'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT Fname FROM Student WHERE StuID IN (SELECT StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE PetType = \"dog\") EXCEPT SELECT Fname FROM Student WHERE StuID IN (SELECT StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE PetType = \"cat\")"}, {"db_id": "car_1", "gold": "SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500;", "question": "What are the different models created by either the car maker General Motors or weighed more than 3500?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 13, "hardness": "extra", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes either/or logic, so we can decompose the question into two subproblems: 1. what are the models created by the car maker General Motors; 2. what are the models that weigh more than 3500.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['car_makers', 'model_list', 'car_names']. To complete the second subproblem, we need to use table 'cars_data'.\n\n<3> Operation: Use 'where' to filter using column 'Maker' in table 'car_makers' for the first subproblem. Use 'where' to filter using column 'Weight' in table 'cars_data' for the second subproblem.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT T1.Model FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id  =  T2.Maker JOIN car_names AS T3 ON T2.Model  =  T3.Model WHERE T1.Maker  =  \"General Motors\" UNION SELECT T4.Model FROM cars_data AS T4 WHERE T4.Weight > 3500"}, {"db_id": "car_1", "gold": "select distinct year from cars_data where weight between 3000 and 4000;", "question": "What are the different years in which there were cars produced that weighed less than 4000 and also cars that weighted more than 3000 ?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 14, "hardness": "easy", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the intersection logic, so we can decompose the question into two subproblems: 1. what are the years in which there were cars produced that weighed less than 4000; 2. what are the years in which there were cars produced that weighed more than 3000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['cars_data']. To complete the second subproblem, we also need to use tables ['cars_data'].\n\n<3> Operation: Use 'where' to filter using column 'Weight' in table 'cars_data'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT DISTINCT Year FROM cars_data WHERE Weight < 4000 INTERSECT SELECT DISTINCT Year FROM cars_data WHERE Weight > 3000"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)", "question": "Find the names of employees who never won any award in the evaluation.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "number": 24, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes negation logic, so we can decompose the question into two subproblems: 1. what are the Employee_IDs of employees who won awards in the evaluation; 2. what are the names of employees who do not have Employee_IDs in the result of the first subproblem.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['evaluation']. To complete the second subproblem, we need to use tables ['employee'].\n\n<3> Operation: Use 'not in' to filter the names of employees who do not have Employee_IDs in the result of the first subproblem.\n\n<4> SQL Generation: Use 'not in' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)", "question": "What are the names of the employees who never received any evaluation?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "number": 25, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the absence of evaluations, so we can decompose the question into one subproblem: what are the names of the employees who have no corresponding records in the evaluation table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the subproblem, we need to use tables ['employee', 'evaluation'].\n\n<3> Operation: Use 'left join' to combine the employee table with the evaluation table, and filter the rows where the evaluation.Employee_ID is null.\n\n<4> SQL Generation: Use 'select' to retrieve the names of the employees who have no corresponding records in the evaluation table.\n\n", "predict": "SELECT employee.Name FROM employee LEFT JOIN evaluation ON employee.Employee_ID = evaluation.Employee_ID WHERE evaluation.Employee_ID IS NULL"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)", "question": "Find the name of the shops that do not hire any employee.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "number": 26, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the absence of a relationship, so we can decompose the question into finding the shops that have no corresponding records in the 'hiring' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To find the shops that do not hire any employee, we need to use tables ['shop', 'hiring'].\n\n<3> Operation: Use 'left join' to combine the 'shop' table with the 'hiring' table, and then filter the rows where the 'Employee_ID' is null.\n\n<4> SQL Generation: Use the 'left join' operation and the 'is null' condition to form the final SQL statement.\n\n", "predict": "SELECT shop.Name FROM shop LEFT JOIN hiring ON shop.Shop_ID = hiring.Shop_ID WHERE hiring.Employee_ID IS NULL"}, {"db_id": "course_teach", "gold": "SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33", "question": "What are the names of the teachers who are aged either 32 or 33?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "number": 32, "hardness": "medium", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union set logic, so we can decompose the question into two subproblems: 1. what are the names of the teachers who are aged 32; 2. what are the names of the teachers who are aged 33.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use table 'teacher'.\n\n<3> Operation: Use 'where' to filter using column 'Age' in table 'teacher'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT Name FROM teacher WHERE Age = 32 UNION SELECT Name FROM teacher WHERE Age = 33"}, {"db_id": "course_teach", "gold": "SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)", "question": "List the names of teachers who have not been arranged to teach courses.", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "number": 33, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query asks for the names of teachers who have not been arranged to teach courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we need to use table ['teacher'] and table ['course_arrange'].\n\n<3> Operation: We need to perform a 'LEFT JOIN' operation on the 'teacher' table and the 'course_arrange' table, and filter the rows where the 'Teacher_ID' in the 'course_arrange' table is NULL.\n\n<4> SQL Generation: Use the 'SELECT' statement to select the 'Name' column from the 'teacher' table, and apply the 'LEFT JOIN' operation and the 'IS NULL' condition to filter the rows.\n\n", "predict": "SELECT Name FROM teacher LEFT JOIN course_arrange ON teacher.Teacher_ID = course_arrange.Teacher_ID WHERE course_arrange.Teacher_ID IS NULL"}, {"db_id": "course_teach", "gold": "SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)", "question": "What are the names of the teachers whose courses have not been arranged?", "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n", "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n", "types": {"course.Course_ID": "number", "course.Staring_Date": "text", "course.Course": "text", "teacher.Teacher_ID": "number", "teacher.Name": "text", "teacher.Age": "text", "teacher.Hometown": "text", "course_arrange.Course_ID": "number", "course_arrange.Teacher_ID": "number", "course_arrange.Grade": "number"}, "number": 34, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query asks for the names of the teachers whose courses have not been arranged. We can decompose the question into two subproblems: 1. what are the course IDs that have been arranged; 2. what are the names of the teachers whose courses have not been arranged.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['course_arrange']. To complete the second subproblem, we need to use table ['teacher'].\n\n<3> Operation: For the first subproblem, we need to perform a 'SELECT' operation on the column 'Course_ID' in the table 'course_arrange'. For the second subproblem, we need to perform a 'SELECT' operation on the column 'Name' in the table 'teacher' and filter by performing a 'NOT IN' operation on the column 'Teacher_ID' using the result from the first subproblem.\n\n<4> SQL Generation: Use the 'NOT IN' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT Name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)"}, {"db_id": "wta_1", "gold": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'", "question": "How many different winners both participated in the WTA Championships and were left handed?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "number": 40, "hardness": "medium", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. who are the winners that participated in the WTA Championships; 2. who are the winners that are left-handed.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['matches', 'players']. To complete the second subproblem, we need to use tables ['matches', 'players'].\n\n<3> Operation: Use 'where' to filter using column 'tourney_name' in table 'matches' for the first subproblem. Use 'where' to filter using column 'hand' in table 'players' for the second subproblem.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT COUNT(DISTINCT T1.winner_id) FROM matches AS T1 JOIN players AS T2 ON T1.winner_id = T2.player_id WHERE T1.tourney_name = 'WTA Championships' INTERSECT SELECT T3.winner_id FROM matches AS T3 JOIN players AS T4 ON T3.winner_id = T4.player_id WHERE T4.hand = 'Left'"}, {"db_id": "student_transcripts_tracking", "gold": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?", "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n", "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n", "types": {"Addresses.address_id": "number", "Addresses.line_1": "text", "Addresses.line_2": "text", "Addresses.line_3": "text", "Addresses.city": "text", "Addresses.zip_postcode": "text", "Addresses.state_province_county": "text", "Addresses.country": "text", "Addresses.other_address_details": "text", "Courses.course_id": "number", "Courses.course_name": "text", "Courses.course_description": "text", "Courses.other_details": "text", "Departments.department_id": "number", "Departments.department_name": "text", "Departments.department_description": "text", "Departments.other_details": "text", "Degree_Programs.degree_program_id": "number", "Degree_Programs.department_id": "number", "Degree_Programs.degree_summary_name": "text", "Degree_Programs.degree_summary_description": "text", "Degree_Programs.other_details": "text", "Sections.section_id": "number", "Sections.course_id": "number", "Sections.section_name": "text", "Sections.section_description": "text", "Sections.other_details": "text", "Semesters.semester_id": "number", "Semesters.semester_name": "text", "Semesters.semester_description": "text", "Semesters.other_details": "text", "Students.student_id": "number", "Students.current_address_id": "number", "Students.permanent_address_id": "number", "Students.first_name": "text", "Students.middle_name": "text", "Students.last_name": "text", "Students.cell_mobile_number": "text", "Students.email_address": "text", "Students.ssn": "text", "Students.date_first_registered": "time", "Students.date_left": "time", "Students.other_student_details": "text", "Student_Enrolment.student_enrolment_id": "number", "Student_Enrolment.degree_program_id": "number", "Student_Enrolment.semester_id": "number", "Student_Enrolment.student_id": "number", "Student_Enrolment.other_details": "text", "Student_Enrolment_Courses.student_course_id": "number", "Student_Enrolment_Courses.course_id": "number", "Student_Enrolment_Courses.student_enrolment_id": "number", "Transcripts.transcript_id": "number", "Transcripts.transcript_date": "time", "Transcripts.other_details": "text", "Transcript_Contents.student_course_id": "number", "Transcript_Contents.transcript_id": "number"}, "number": 45, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes filtering based on two conditions: 1. students who live in Haiti permanently; 2. students who have the cell phone number 09700166582.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Students', 'Addresses']. To complete the second subproblem, we only need to use the 'Students' table.\n\n<3> Operation: Use 'where' to filter using columns 'country' and 'cell_mobile_number' in table 'Students'.\n\n<4> SQL Generation: Use 'or' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT first_name FROM Students WHERE country = \"Haiti\" OR cell_mobile_number = \"09700166582\""}, {"db_id": "tvshow", "gold": "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')", "question": "find the package option of the tv channel that do not have any cartoon directed by Ben Jones.", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "number": 51, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes negation logic, so we can decompose the question into two subproblems: 1. find the TV channels that have cartoons directed by Ben Jones; 2. find the TV channels that do not have any cartoons directed by Ben Jones.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Cartoon', 'TV_Channel'].\n\n<3> Operation: Use 'where' to filter using column 'Directed_by' in table 'Cartoon'.\n\n<4> SQL Generation: Use 'not exists' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT T1.Package_Option FROM TV_Channel AS T1 WHERE NOT EXISTS (SELECT * FROM Cartoon AS T2 WHERE T2.Directed_by = 'Ben Jones' AND T2.Channel = T1.id)"}, {"db_id": "tvshow", "gold": "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')", "question": "What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?", "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n", "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n", "types": {"TV_Channel.id": "text", "TV_Channel.series_name": "text", "TV_Channel.Country": "text", "TV_Channel.Language": "text", "TV_Channel.Content": "text", "TV_Channel.Pixel_aspect_ratio_PAR": "text", "TV_Channel.Hight_definition_TV": "text", "TV_Channel.Pay_per_view_PPV": "text", "TV_Channel.Package_Option": "text", "TV_series.id": "number", "TV_series.Episode": "text", "TV_series.Air_Date": "text", "TV_series.Rating": "text", "TV_series.Share": "number", "TV_series.18_49_Rating_Share": "text", "TV_series.Viewers_m": "text", "TV_series.Weekly_Rank": "number", "TV_series.Channel": "text", "Cartoon.id": "number", "Cartoon.Title": "text", "Cartoon.Directed_by": "text", "Cartoon.Written_by": "text", "Cartoon.Original_air_date": "text", "Cartoon.Production_code": "number", "Cartoon.Channel": "text"}, "number": 52, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes negation logic, so we can decompose the question into two subproblems: 1. what are the ids of cartoons directed by Ben Jones; 2. what are the ids of tv channels that are not playing any cartoons directed by Ben Jones.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Cartoon']. To complete the second subproblem, we need to use tables ['TV_Channel', 'Cartoon'].\n\n<3> Operation: Use 'where' to filter using column 'Directed_by' in table 'Cartoon'.\n\n<4> SQL Generation: Use 'not exists' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT T1.Package_Option FROM TV_Channel AS T1 WHERE NOT EXISTS (SELECT * FROM Cartoon AS T2 WHERE T2.Directed_by = \"Ben Jones\" AND T2.Channel = T1.id)"}, {"db_id": "poker_player", "gold": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)", "question": "What are the names of people who do not play poker?", "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n", "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n", "types": {"poker_player.Poker_Player_ID": "number", "poker_player.People_ID": "number", "poker_player.Final_Table_Made": "number", "poker_player.Best_Finish": "number", "poker_player.Money_Rank": "number", "poker_player.Earnings": "number", "people.People_ID": "number", "people.Nationality": "text", "people.Name": "text", "people.Birth_Date": "text", "people.Height": "number"}, "number": 53, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes negation logic, so we can decompose the question into two subproblems: 1. what are the People_IDs of people who play poker; 2. what are the names of people who do not have People_IDs in the set obtained from the first subproblem.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['people', 'poker_player']. To complete the second subproblem, we only need to use the 'people' table.\n\n<3> Operation: Use 'where' to filter using column 'Poker_Player_ID' in table 'poker_player'.\n\n<4> SQL Generation: Use 'not in' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)"}, {"db_id": "world_1", "gold": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"", "question": "What are the regions that use English or Dutch?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 60, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the regions that use English; 2. what are the regions that use Dutch.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we need to use tables ['country', 'countrylanguage'] in the same reason.\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" UNION SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"Dutch\""}, {"db_id": "world_1", "gold": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"", "question": "Which regions speak Dutch or English?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 61, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. which regions speak Dutch; 2. which regions speak English.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT DISTINCT country.Region FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language = \"Dutch\" UNION SELECT DISTINCT country.Region FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language = \"English\""}, {"db_id": "orchestra", "gold": "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)", "question": "What are the orchestras that do not have any performances?", "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n", "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n", "types": {"conductor.Conductor_ID": "number", "conductor.Name": "text", "conductor.Age": "number", "conductor.Nationality": "text", "conductor.Year_of_Work": "number", "orchestra.Orchestra_ID": "number", "orchestra.Orchestra": "text", "orchestra.Conductor_ID": "number", "orchestra.Record_Company": "text", "orchestra.Year_of_Founded": "number", "orchestra.Major_Record_Format": "text", "performance.Performance_ID": "number", "performance.Orchestra_ID": "number", "performance.Type": "text", "performance.Date": "text", "performance.Official_ratings_(millions)": "number", "performance.Weekly_rank": "text", "performance.Share": "text", "show.Show_ID": "number", "show.Performance_ID": "number", "show.If_first_show": "others", "show.Result": "text", "show.Attendance": "number"}, "number": 66, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the absence of performances, so we can decompose the question into a subproblem: what are the orchestras that do not have any performances.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the subproblem, we need to use tables ['orchestra', 'performance'].\n\n<3> Operation: Use 'left join' to combine the 'orchestra' table with the 'performance' table, and filter the rows where the 'Performance_ID' is null.\n\n<4> SQL Generation: Use 'where' to filter the rows where the 'Performance_ID' is null.\n\n", "predict": "SELECT Orchestra FROM orchestra LEFT JOIN performance ON orchestra.Orchestra_ID = performance.Orchestra_ID WHERE performance.Performance_ID IS NULL"}, {"db_id": "dog_kennels", "gold": "SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin'", "question": "List the emails of the professionals who live in the state of Hawaii or the state of Wisconsin.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "number": 87, "hardness": "medium", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union set logic, so we can decompose the question into two subproblems: 1. what are the emails of professionals who live in the state of Hawaii; 2. what are the emails of professionals who live in the state of Wisconsin.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use the 'Professionals' table.\n\n<3> Operation: Use 'where' to filter using the 'state' column in the 'Professionals' table.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT email_address FROM Professionals WHERE state = 'Hawaii' UNION SELECT email_address FROM Professionals WHERE state = 'Wisconsin'"}, {"db_id": "dog_kennels", "gold": "SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin'", "question": "What are the emails of the professionals living in either the state of Hawaii or the state of Wisconsin?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "number": 88, "hardness": "medium", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union set logic, so we can decompose the question into two subproblems: 1. what are the emails of the professionals living in the state of Hawaii; 2. what are the emails of the professionals living in the state of Wisconsin.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Professionals', 'Owners']. To complete the second subproblem, we also need to use tables ['Professionals', 'Owners'].\n\n<3> Operation: Use 'where' to filter using column 'state' in table 'Owners'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n", "predict": "SELECT email_address FROM professionals JOIN owners ON professionals.owner_id = owners.owner_id WHERE owners.state = 'Hawaii' UNION SELECT email_address FROM professionals JOIN owners ON professionals.owner_id = owners.owner_id WHERE owners.state = 'Wisconsin'"}, {"db_id": "singer", "gold": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)", "question": "List the name of singers that do not have any song.", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "number": 89, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query asks for the names of singers who do not have any songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we need to use table ['singer'] and table ['song'].\n\n<3> Operation: We need to perform a 'LEFT JOIN' operation on the tables 'singer' and 'song' using the foreign key 'Singer_ID'. Then, we need to filter the result by selecting the rows where the 'Song_ID' is NULL.\n\n<4> SQL Generation: Use the 'SELECT' statement to retrieve the 'Name' column from the 'singer' table and apply the 'LEFT JOIN' and 'IS NULL' conditions to filter the result.\n\n", "predict": "SELECT Name FROM singer LEFT JOIN song ON singer.Singer_ID = song.Singer_ID WHERE song.Song_ID IS NULL"}, {"db_id": "singer", "gold": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)", "question": "What is the sname of every sing that does not have any song?", "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n", "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n", "types": {"singer.Singer_ID": "number", "singer.Name": "text", "singer.Birth_Year": "number", "singer.Net_Worth_Millions": "number", "singer.Citizenship": "text", "song.Song_ID": "number", "song.Title": "text", "song.Singer_ID": "number", "song.Sales": "number", "song.Highest_Position": "number"}, "number": 90, "hardness": "hard", "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query asks for the name of every singer who does not have any songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the query, we need to use table ['singer'] and table ['song'].\n\n<3> Operation: We need to perform a 'LEFT JOIN' operation on the column 'Singer_ID' to connect the 'singer' table with the 'song' table. Then, we need to filter the result by selecting the rows where the 'Song_ID' is NULL, indicating that the singer does not have any songs.\n\n<4> SQL Generation: Use the 'SELECT' statement to retrieve the 'Name' column from the 'singer' table, and apply the 'LEFT JOIN' and 'IS NULL' conditions to filter the result.\n\n", "predict": "SELECT Name FROM singer LEFT JOIN song ON singer.Singer_ID = song.Singer_ID WHERE song.Song_ID IS NULL"}]