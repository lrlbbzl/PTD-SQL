[{"db_id": "concert_singer", "gold": "SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014", "question": "What are the names of all stadiums that did not have a concert in 2014?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "number": 13, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to find the concert_IDs of all concerts that took place in 2014. Secondly, we need to find the Stadium_IDs of all stadiums. Finally, we need to find the names of all stadiums that do not have a concert in 2014.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select concert_ID from table 'concert' where Year = 2014. In the second step, we need to select Stadium_ID from table 'stadium'. In the final step, we need to select Name from table 'stadium' where Stadium_ID does not match any of the Stadium_IDs found in the first step.\n\n<3> SQL Generation: Use 'where' to find the concert_IDs of all concerts that took place in 2014. Then, use 'where not in' to find the Stadium_IDs of all stadiums that did not have a concert in 2014. Finally, use 'where' to find the names of all stadiums that do not have a concert in 2014.\n\n", "predict": "SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert WHERE Year = 2014)"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'", "question": "Show the document id with paragraph text 'Brazil' and 'Ireland'.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "number": 170, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to filter the paragraphs with text 'Brazil' from table 'Paragraphs'. Secondly, we need to filter the paragraphs with text 'Ireland' from the same table. Finally, we need to find the document IDs that have both of these paragraphs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need to filter the 'Paragraphs' table, we only need this table.\n\n<3> SQL Generation: We filter the rows where 'Paragraph_Text' is 'Brazil' and 'Paragraph_Text' is 'Ireland'. Then, we select the 'Document_ID' column from the filtered rows.\n\n", "predict": "SELECT document_id FROM paragraphs WHERE paragraph_text = 'Brazil' AND paragraph_text = 'Ireland'"}, {"db_id": "battle_death", "gold": "SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'Lettice' INTERSECT SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'HMS Atalanta'", "question": "List the name and date the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta'", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "number": 204, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to find the battle that has lost the ship named 'Lettice'. Secondly, we need to find the battle that has lost the ship named 'HMS Atalanta'. Finally, we need to retrieve the name and date of the battles found in the previous steps.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use the 'ship' table to find the battles, and then use the 'battle' table to retrieve the name and date of the battles.\n\n<3> SQL Generation: Use 'select' to retrieve the name and date columns from the 'battle' table. Then, use 'join' to link the 'ship' table with the 'battle' table based on the lost_in_battle foreign key relationship. Finally, use 'where' to filter the battles based on the ship names.\n\n", "predict": "SELECT battle.name, battle.date FROM battle JOIN ship ON battle.id = ship.lost_in_battle WHERE ship.name = 'Lettice' OR ship.name = 'HMS Atalanta'"}, {"db_id": "battle_death", "gold": "SELECT name ,  RESULT ,  bulgarian_commander FROM battle EXCEPT SELECT T1.name ,  T1.result ,  T1.bulgarian_commander FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.location  =  'English Channel'", "question": "Show names, results and bulgarian commanders of the battles with no ships lost in the 'English Channel'.", "foreign_keys": "Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]\n", "tables": "Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]\nTable death, columns = [*,caused_by_ship_id,id,note,killed,injured]\nTable ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]\n", "types": {"battle.id": "number", "battle.name": "text", "battle.date": "text", "battle.bulgarian_commander": "text", "battle.latin_commander": "text", "battle.result": "text", "ship.lost_in_battle": "number", "ship.id": "number", "ship.name": "text", "ship.tonnage": "text", "ship.ship_type": "text", "ship.location": "text", "ship.disposition_of_ship": "text", "death.caused_by_ship_id": "number", "death.id": "number", "death.note": "text", "death.killed": "number", "death.injured": "number"}, "number": 205, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to find the battles with no ships lost in the 'English Channel'. Secondly, we need to select the names, results, and bulgarian commanders of these battles.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the battles from the \"battle\" table where no ships were lost in the 'English Channel'. In the second step, we need to select the names, results, and bulgarian commanders from the \"battle\" table.\n\n<3> SQL Generation: Use 'where' to filter the battles with no ships lost in the 'English Channel', and then select the names, results, and bulgarian commanders from the filtered battles.\n\n", "predict": "SELECT name, result, bulgarian_commander FROM battle WHERE id NOT IN (SELECT lost_in_battle FROM ship WHERE location = 'English Channel')"}]