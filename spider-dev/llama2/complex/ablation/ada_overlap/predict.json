[
    {
        "db_id": "concert_singer",
        "gold": "SELECT country FROM singer WHERE age  >  40 INTERSECT SELECT country FROM singer WHERE age  <  30",
        "question": "Show countries where a singer above age 40 and a singer below 30 are from.",
        "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n",
        "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n",
        "types": {
            "stadium.Stadium_ID": "number",
            "stadium.Location": "text",
            "stadium.Name": "text",
            "stadium.Capacity": "number",
            "stadium.Highest": "number",
            "stadium.Lowest": "number",
            "stadium.Average": "number",
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Country": "text",
            "singer.Song_Name": "text",
            "singer.Song_release_year": "text",
            "singer.Age": "number",
            "singer.Is_male": "others",
            "concert.concert_ID": "number",
            "concert.concert_Name": "text",
            "concert.Theme": "text",
            "concert.Stadium_ID": "text",
            "concert.Year": "text",
            "singer_in_concert.concert_ID": "number",
            "singer_in_concert.Singer_ID": "text"
        },
        "number": 0,
        "hardness": "hard",
        "reasoning": "<1> Operation: The query requires the code of the document type that is most common, so we should apply the 'count' operation to the 'Document_Type_Code' column in the 'Documents' table and find the document type code with the highest count. Since the unit to which the document types being counted in the query belong is the document, we should apply the 'group by' operation to the 'Document_Type_Code' column in the 'Documents' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['Documents'].\n\n<3> SQL Generation: The query requires the code of the document type that is most common, so we should select the 'Document_Type_Code' column in the 'Documents' table.\n\n",
        "predict": "SELECT Document_Type_Code FROM Documents GROUP BY Document_Type_Code ORDER BY COUNT(*) DESC LIMIT 1"
    },
    {
        "db_id": "concert_singer",
        "gold": "SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014",
        "question": "Show names for all stadiums except for stadiums having a concert in year 2014.",
        "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n",
        "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n",
        "types": {
            "stadium.Stadium_ID": "number",
            "stadium.Location": "text",
            "stadium.Name": "text",
            "stadium.Capacity": "number",
            "stadium.Highest": "number",
            "stadium.Lowest": "number",
            "stadium.Average": "number",
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Country": "text",
            "singer.Song_Name": "text",
            "singer.Song_release_year": "text",
            "singer.Age": "number",
            "singer.Is_male": "others",
            "concert.concert_ID": "number",
            "concert.concert_Name": "text",
            "concert.Theme": "text",
            "concert.Stadium_ID": "text",
            "concert.Year": "text",
            "singer_in_concert.concert_ID": "number",
            "singer_in_concert.Singer_ID": "text"
        },
        "number": 1,
        "hardness": "hard",
        "reasoning": "<1> Operation: The query requires the poll resource associated with the most candidates, so we should apply the 'count' operation to the 'Candidate_ID' column in the 'candidate' table and find the poll resource with the highest count. Since the unit to which the candidates being counted in the query belong is the poll resource, we should apply the 'group by' operation to the 'Poll_Source' column in the 'candidate' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['candidate'].\n\n<3> SQL Generation: The query requires the poll resource associated with the most candidates, so we should select the 'Poll_Source' column in the 'candidate' table.\n\n",
        "predict": "SELECT Poll_Source FROM candidate GROUP BY Poll_Source ORDER BY COUNT(*) DESC LIMIT 1"
    },
    {
        "db_id": "concert_singer",
        "gold": "SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",
        "question": "Find the name and location of the stadiums which some concerts happened in the years of both 2014 and 2015.",
        "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n",
        "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n",
        "types": {
            "stadium.Stadium_ID": "number",
            "stadium.Location": "text",
            "stadium.Name": "text",
            "stadium.Capacity": "number",
            "stadium.Highest": "number",
            "stadium.Lowest": "number",
            "stadium.Average": "number",
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Country": "text",
            "singer.Song_Name": "text",
            "singer.Song_release_year": "text",
            "singer.Age": "number",
            "singer.Is_male": "others",
            "concert.concert_ID": "number",
            "concert.concert_Name": "text",
            "concert.Theme": "text",
            "concert.Stadium_ID": "text",
            "concert.Year": "text",
            "singer_in_concert.concert_ID": "number",
            "singer_in_concert.Singer_ID": "text"
        },
        "number": 2,
        "hardness": "extra",
        "reasoning": "<1> Operation: The query requires the poll resource associated with the most candidates, so we should apply the 'count' operation to the 'Candidate_ID' column in the 'candidate' table and find the poll resource with the highest count. Since the unit to which the candidates being counted in the query belong is the poll resource, we should apply the 'group by' operation to the 'Poll_Source' column in the 'candidate' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['candidate'].\n\n<3> SQL Generation: The query requires the poll resource associated with the most candidates, so we should select the 'Poll_Source' column in the 'candidate' table.\n\n",
        "predict": "SELECT Poll_Source FROM candidate GROUP BY Poll_Source ORDER BY COUNT(*) DESC LIMIT 1"
    },
    {
        "db_id": "concert_singer",
        "gold": "SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",
        "question": "What are the names and locations of the stadiums that had concerts that occurred in both 2014 and 2015?",
        "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n",
        "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n",
        "types": {
            "stadium.Stadium_ID": "number",
            "stadium.Location": "text",
            "stadium.Name": "text",
            "stadium.Capacity": "number",
            "stadium.Highest": "number",
            "stadium.Lowest": "number",
            "stadium.Average": "number",
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Country": "text",
            "singer.Song_Name": "text",
            "singer.Song_release_year": "text",
            "singer.Age": "number",
            "singer.Is_male": "others",
            "concert.concert_ID": "number",
            "concert.concert_Name": "text",
            "concert.Theme": "text",
            "concert.Stadium_ID": "text",
            "concert.Year": "text",
            "singer_in_concert.concert_ID": "number",
            "singer_in_concert.Singer_ID": "text"
        },
        "number": 3,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names and locations of the stadiums that had concerts in 2014; 2. what are the names and locations of the stadiums that had concerts in 2015.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['concert', 'stadium']. To complete the second subproblem, we also need to use tables ['concert', 'stadium'].\n\n<3> Operation: Use 'where' to filter using the column 'Year' in the 'concert' table.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.Name, T1.Location FROM stadium AS T1 JOIN concert AS T2 ON T1.Stadium_ID = T2.Stadium_ID WHERE T2.Year = 2014 INTERSECT SELECT T1.Name, T1.Location FROM stadium AS T1 JOIN concert AS T2 ON T1.Stadium_ID = T2.Stadium_ID WHERE T2.Year = 2015"
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog'",
        "question": "What are the first names of every student who has a cat or dog as a pet?",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 4,
        "hardness": "extra",
        "reasoning": "<1> Decomposition: Firstly, we need to find the first names of all students who have a cat as a pet. Secondly, we need to find the first names of all students who have a dog as a pet. Finally, we need to combine the results to get the first names of students who have either a cat or a dog as a pet.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first names from the 'Student' table and filter based on the 'PetType' column in the 'Pets' table.\n\n<3> Operation: Use 'where' to filter the students who have a cat or a dog as a pet.\n\n<4> SQL Generation: Use 'union' operation to combine the queries for students who have a cat and students who have a dog to get the final result.\n\n",
        "predict": "\nSELECT Fname FROM Student \nWHERE StuID IN (SELECT StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE PetType = 'cat')\nUNION\nSELECT Fname FROM Student \nWHERE StuID IN (SELECT StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE PetType = 'dog')"
    },
    {
        "db_id": "pets_1",
        "gold": "select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'cat' intersect select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'dog'",
        "question": "Find the first name of students who have both cat and dog pets .",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 5,
        "hardness": "extra",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who have both cat and dog pets. Secondly, we need to retrieve their first names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to join the tables 'Has_Pet', 'Pets', and 'Student' to find the students who have both cat and dog pets.\n\n<3> SQL Generation: Use 'where' to filter the students who have both cat and dog pets and select their first names.\n\n",
        "predict": "\nSELECT T1.Fname \nFROM Student AS T1 \nJOIN Has_Pet AS T2 ON T1.StuID = T2.StuID \nJOIN Pets AS T3 ON T2.PetID = T3.PetID \nWHERE T3.PetType IN ('cat', 'dog') \nGROUP BY T1.StuID \nHAVING COUNT(DISTINCT T3.PetType) = 2"
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' INTERSECT SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog'",
        "question": "What are the students' first names who have both cats and dogs as pets?",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 6,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the students' first names who have cats as pets; 2. what are the students' first names who have dogs as pets.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Student', 'Has_Pet', 'Pets']. To complete the second subproblem, we also need to use tables ['Student', 'Has_Pet', 'Pets'].\n\n<3> Operation: Use 'where' to filter using column 'PetType' in table 'Pets'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.Fname FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T2.PetID = T3.PetID WHERE T3.PetType = \"cat\" INTERSECT SELECT T1.Fname FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T2.PetID = T3.PetID WHERE T3.PetType = \"dog\""
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "question": "Find the major and age of students who do not have a cat pet.",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 7,
        "hardness": "extra",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who do not have a cat pet and retrieve their major and age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to filter StuID from table 'Has_Pet' where PetType != \"cat\" and then retrieve the corresponding major and age from table 'Student'.\n\n<3> SQL Generation: Use 'where' to find the students who do not have a cat pet and then select their major and age.\n\n",
        "predict": "SELECT T1.Major, T1.Age FROM Student AS T1 WHERE T1.StuID NOT IN (SELECT T2.StuID FROM Has_Pet AS T2 JOIN Pets AS T3 ON T2.PetID = T3.PetID WHERE T3.PetType = 'cat')"
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "question": "What major is every student who does not own a cat as a pet, and also how old are they?",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 8,
        "hardness": "extra",
        "reasoning": "SELECT T1.Major, T1.Age FROM Student AS T1 WHERE T1.StuID NOT IN (SELECT T2.StuID FROM Has_Pet AS T2 JOIN Pets AS T3 ON T2.PetID = T3.PetID WHERE T3.PetType = 'Cat'",
        "predict": "Major, T1.Age FROM Student AS T1 WHERE T1.StuID NOT IN (SELECT T2.StuID FROM Has_Pet AS T2 JOIN Pets AS T3 ON T2.PetID = T3.PetID WHERE T3.PetType = 'Cat')"
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'",
        "question": "Find the id of students who do not have a cat pet.",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 9,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of all students; 2. what are the ids of students who have a cat pet.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Student'. To complete the second subproblem, we need to use tables ['Student', 'Has_Pet', 'Pets'].\n\n<3> Operation: Use 'where' to filter using column 'PetType' in table 'Pets'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT StuID FROM Student EXCEPT SELECT t1.StuID FROM Student AS t1 JOIN Has_Pet AS t2 ON t1.StuID = t2.StuID JOIN Pets AS t3 ON t2.PetID = t3.PetID WHERE t3.PetType = 'cat'"
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'",
        "question": "What are the ids of the students who do not own cats as pets?",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 10,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we break down the query into two subproblems: 1. what are the ids of all students; 2. what are the ids of students who own cats as pets.\n\n<2> Schema Linking: We need to use tables ['Student', 'Has_Pet', 'Pets'] to solve this query.\n\n<3> Operation: Use 'where' to filter out students who own cats as pets by checking the 'PetType' column in the 'Pets' table.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT StuID FROM Student EXCEPT SELECT T1.StuID FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID = T2.StuID JOIN Pets AS T3 ON T2.PetID = T3.PetID WHERE T3.PetType = 'Cat'"
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "question": "Find the first name and age of students who have a dog but do not have a cat as a pet.",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 11,
        "hardness": "extra",
        "reasoning": "<1> Decomposition: Firstly, we need to find the students who have a dog as a pet. Secondly, we need to filter out students who have a cat as a pet and retrieve their first name and age.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Has_Pet' where PetType = \"dog\". In the second step, we need to filter out StuID from table 'Has_Pet' where PetType = \"cat\" and retrieve the corresponding first name and age from table 'Student'.\n\n<3> SQL Generation: Use 'where' to find the students who have a dog as a pet, and then use 'where not exists' to filter out students who have a cat as a pet and select their first name and age.\n\n",
        "predict": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T2.petid IN (SELECT T3.petid FROM pets AS T3 WHERE T3.pettype  =  'dog') AND NOT EXISTS (SELECT 1 FROM has_pet AS T4 JOIN pets AS T5 ON T4.petid  =  T5.petid WHERE T5.pettype  =  'cat' AND T4.stuid  =  T1.stuid)"
    },
    {
        "db_id": "pets_1",
        "gold": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",
        "question": "What is the first name of every student who has a dog but does not have a cat?",
        "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n",
        "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n",
        "types": {
            "Student.StuID": "number",
            "Student.LName": "text",
            "Student.Fname": "text",
            "Student.Age": "number",
            "Student.Sex": "text",
            "Student.Major": "number",
            "Student.Advisor": "number",
            "Student.city_code": "text",
            "Has_Pet.StuID": "number",
            "Has_Pet.PetID": "number",
            "Pets.PetID": "number",
            "Pets.PetType": "text",
            "Pets.pet_age": "number",
            "Pets.weight": "number"
        },
        "number": 12,
        "hardness": "extra",
        "reasoning": "SELECT Fname FROM Student WHERE StuID IN (SELECT StuID FROM Has_Pet WHERE PetID IN (SELECT PetID FROM Pets WHERE PetType = 'dog') AND StuID NOT IN (SELECT StuID FROM Has_Pet WHERE PetID IN (SELECT PetID FROM Pets WHERE PetType = 'cat'))",
        "predict": "me FROM Student WHERE StuID IN (SELECT StuID FROM Has_Pet WHERE PetID IN (SELECT PetID FROM Pets WHERE PetType = 'dog') AND StuID NOT IN (SELECT StuID FROM Has_Pet WHERE PetID IN (SELECT PetID FROM Pets WHERE PetType = 'cat')))"
    },
    {
        "db_id": "car_1",
        "gold": "SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500;",
        "question": "What are the different models created by either the car maker General Motors or weighed more than 3500?",
        "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n",
        "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n",
        "types": {
            "continents.ContId": "number",
            "continents.Continent": "text",
            "countries.CountryId": "number",
            "countries.CountryName": "text",
            "countries.Continent": "number",
            "car_makers.Id": "number",
            "car_makers.Maker": "text",
            "car_makers.FullName": "text",
            "car_makers.Country": "text",
            "model_list.ModelId": "number",
            "model_list.Maker": "number",
            "model_list.Model": "text",
            "car_names.MakeId": "number",
            "car_names.Model": "text",
            "car_names.Make": "text",
            "cars_data.Id": "number",
            "cars_data.MPG": "text",
            "cars_data.Cylinders": "number",
            "cars_data.Edispl": "number",
            "cars_data.Horsepower": "text",
            "cars_data.Weight": "number",
            "cars_data.Accelerate": "number",
            "cars_data.Year": "number"
        },
        "number": 13,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the different models created by the car maker General Motors; 2. what are the different models that weighed more than 3500.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['car_makers', 'model_list', 'car_names']. To complete the second subproblem, we need to use tables ['cars_data', 'car_names'].\n\n<3> Operation: For the first subproblem, we need to filter using the column 'Maker' in table 'car_makers'. For the second subproblem, we need to filter using the column 'Weight' in table 'cars_data'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Model FROM model_list WHERE Maker  =  'General Motors' UNION SELECT Model FROM car_names JOIN cars_data ON car_names.MakeId  =  cars_data.Id WHERE Weight  >  3500"
    },
    {
        "db_id": "car_1",
        "gold": "select distinct year from cars_data where weight between 3000 and 4000;",
        "question": "What are the different years in which there were cars produced that weighed less than 4000 and also cars that weighted more than 3000 ?",
        "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n",
        "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n",
        "types": {
            "continents.ContId": "number",
            "continents.Continent": "text",
            "countries.CountryId": "number",
            "countries.CountryName": "text",
            "countries.Continent": "number",
            "car_makers.Id": "number",
            "car_makers.Maker": "text",
            "car_makers.FullName": "text",
            "car_makers.Country": "text",
            "model_list.ModelId": "number",
            "model_list.Maker": "number",
            "model_list.Model": "text",
            "car_names.MakeId": "number",
            "car_names.Model": "text",
            "car_names.Make": "text",
            "cars_data.Id": "number",
            "cars_data.MPG": "text",
            "cars_data.Cylinders": "number",
            "cars_data.Edispl": "number",
            "cars_data.Horsepower": "text",
            "cars_data.Weight": "number",
            "cars_data.Accelerate": "number",
            "cars_data.Year": "number"
        },
        "number": 14,
        "hardness": "easy",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the intersection logic, so we can decompose the question into two subproblems: 1. what are the different years in which there were cars produced that weighed less than 4000; 2. what are the different years in which there were cars produced that weighed more than 3000.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['cars_data'].\n\n<3> Operation: For both subproblems, we need to filter the data based on the weight criteria and then retrieve the distinct years.\n\n<4> SQL Generation: Use 'INTERSECT' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "\n(SELECT DISTINCT Year FROM cars_data WHERE Weight < 4000)\nINTERSECT\n(SELECT DISTINCT Year FROM cars_data WHERE Weight > 3000)"
    },
    {
        "db_id": "car_1",
        "gold": "SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country;",
        "question": "What are the name of the countries where there is not a single car maker?",
        "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n",
        "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n",
        "types": {
            "continents.ContId": "number",
            "continents.Continent": "text",
            "countries.CountryId": "number",
            "countries.CountryName": "text",
            "countries.Continent": "number",
            "car_makers.Id": "number",
            "car_makers.Maker": "text",
            "car_makers.FullName": "text",
            "car_makers.Country": "text",
            "model_list.ModelId": "number",
            "model_list.Maker": "number",
            "model_list.Model": "text",
            "car_names.MakeId": "number",
            "car_names.Model": "text",
            "car_names.Make": "text",
            "cars_data.Id": "number",
            "cars_data.MPG": "text",
            "cars_data.Cylinders": "number",
            "cars_data.Edispl": "number",
            "cars_data.Horsepower": "text",
            "cars_data.Weight": "number",
            "cars_data.Accelerate": "number",
            "cars_data.Year": "number"
        },
        "number": 15,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: We need to find the countries where there is no car maker present.\n\n<2> Schema Linking: We will need to use the 'countries' table to get the list of countries and the 'car_makers' table to check if there are any car makers present in each country.\n\n<3> SQL Generation: We will use a subquery to check if there are any car makers present in each country and then filter out the countries where there are no car makers.\n\n",
        "predict": "SELECT CountryName FROM countries WHERE CountryId NOT IN (SELECT DISTINCT Country FROM car_makers)"
    },
    {
        "db_id": "car_1",
        "gold": "SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.countryId HAVING count(*)  >  3 UNION SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country JOIN MODEL_LIST AS T3 ON T2.Id  =  T3.Maker WHERE T3.Model  =  'fiat';",
        "question": "What are the id and names of the countries which have more than 3 car makers or produce the 'fiat' model?",
        "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n",
        "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n",
        "types": {
            "continents.ContId": "number",
            "continents.Continent": "text",
            "countries.CountryId": "number",
            "countries.CountryName": "text",
            "countries.Continent": "number",
            "car_makers.Id": "number",
            "car_makers.Maker": "text",
            "car_makers.FullName": "text",
            "car_makers.Country": "text",
            "model_list.ModelId": "number",
            "model_list.Maker": "number",
            "model_list.Model": "text",
            "car_names.MakeId": "number",
            "car_names.Model": "text",
            "car_names.Make": "text",
            "cars_data.Id": "number",
            "cars_data.MPG": "text",
            "cars_data.Cylinders": "number",
            "cars_data.Edispl": "number",
            "cars_data.Horsepower": "text",
            "cars_data.Weight": "number",
            "cars_data.Accelerate": "number",
            "cars_data.Year": "number"
        },
        "number": 16,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we decompose the query into two subproblems: 1. countries with more than 3 car makers; 2. countries that produce the 'fiat' model.\n\n<2> Schema Linking: Based on the requirements of the query and foreign key relationships, we need to use tables ['countries', 'car_makers', 'model_list', 'car_names'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'CountryId' in the 'car_makers' table and filter by performing 'HAVING COUNT()' to find countries with more than 3 car makers. For the second subproblem, we need to use 'JOIN' operations to link the tables and filter by the 'Model' column to find countries that produce the 'fiat' model.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "\nSELECT T1.CountryId, T1.CountryName \nFROM countries AS T1 \nJOIN car_makers AS T2 ON T1.CountryId = T2.Country \nGROUP BY T1.CountryId \nHAVING COUNT(T2.Id) > 3 \nUNION \nSELECT T1.CountryId, T1.CountryName \nFROM countries AS T1 \nJOIN car_makers AS T2 ON T1.CountryId = T2.Country \nJOIN model_list AS T3 ON T2.Id = T3.Maker \nJOIN car_names AS T4 ON T3.Model = T4.Model \nWHERE T4.Model = 'fiat'"
    },
    {
        "db_id": "car_1",
        "gold": "select t1.countryid ,  t1.countryname from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  3 union select t1.countryid ,  t1.countryname from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country join model_list as t3 on t2.id  =  t3.maker where t3.model  =  'fiat';",
        "question": "What are the ids and names of all countries that either have more than 3 car makers or produce fiat model ?",
        "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n",
        "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n",
        "types": {
            "continents.ContId": "number",
            "continents.Continent": "text",
            "countries.CountryId": "number",
            "countries.CountryName": "text",
            "countries.Continent": "number",
            "car_makers.Id": "number",
            "car_makers.Maker": "text",
            "car_makers.FullName": "text",
            "car_makers.Country": "text",
            "model_list.ModelId": "number",
            "model_list.Maker": "number",
            "model_list.Model": "text",
            "car_names.MakeId": "number",
            "car_names.Model": "text",
            "car_names.Make": "text",
            "cars_data.Id": "number",
            "cars_data.MPG": "text",
            "cars_data.Cylinders": "number",
            "cars_data.Edispl": "number",
            "cars_data.Horsepower": "text",
            "cars_data.Weight": "number",
            "cars_data.Accelerate": "number",
            "cars_data.Year": "number"
        },
        "number": 17,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the ids and names of all countries that have more than 3 car makers; 2. what are the ids and names of all countries that produce the Fiat model.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['car_makers', 'countries']. To complete the second subproblem, we need to use tables ['car_names', 'model_list', 'car_makers', 'countries'].\n\n<3> Operation: For the first subproblem, we need to perform a 'GROUP BY' operation on the column 'Country' in the 'car_makers' table and filter by performing 'HAVING COUNT()' on the column 'Id'. For the second subproblem, we need to use 'LIKE' to filter using the model name 'Fiat' on the column 'Model'.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "\nSELECT T1.CountryId, T1.CountryName \nFROM countries AS T1 \nJOIN car_makers AS T2 ON T1.CountryId = T2.Country \nGROUP BY T1.CountryId \nHAVING COUNT(T2.Id) > 3 \nUNION \nSELECT T1.CountryId, T1.CountryName \nFROM countries AS T1 \nJOIN car_makers AS T2 ON T1.CountryId = T2.Country \nJOIN model_list AS T3 ON T2.Id = T3.Maker \nJOIN car_names AS T4 ON T3.Model = T4.Model \nWHERE T4.Make = 'Fiat'"
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
        "question": "Find all airlines that have flights from both airports 'APG' and 'CVO'.",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 18,
        "hardness": "extra",
        "reasoning": "<1> Decomposition: The query requires finding airlines that have flights from both airports 'APG' and 'CVO'. We can decompose this into two subproblems: 1. Find airlines that have flights from airport 'APG'; 2. Find airlines that have flights from airport 'CVO'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['flights', 'airports']. To complete the second subproblem, we also need to use tables ['flights', 'airports'].\n\n<3> Operation: Use 'where' to filter flights based on the source airports being 'APG' and 'CVO'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "\nSELECT Airline \nFROM flights \nWHERE SourceAirport = 'APG' \nINTERSECT \nSELECT Airline \nFROM flights \nWHERE SourceAirport = 'CVO'"
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\"",
        "question": "Which airlines have departing flights from both APG and CVO airports?",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 19,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the airlines that have departing flights from APG airport; 2. what are the airlines that have departing flights from CVO airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['airlines', 'airports', 'flights']. To complete the second subproblem, we also need to use tables ['airlines', 'airports', 'flights'].\n\n<3> Operation: Use 'where' to filter using column 'SourceAirport' in table 'flights'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Airline FROM flights WHERE SourceAirport = 'APG' INTERSECT SELECT Airline FROM flights WHERE SourceAirport = 'CVO'"
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
        "question": "Find all airlines that have flights from airport 'CVO' but not from 'APG'.",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 20,
        "hardness": "extra",
        "reasoning": "<1> Decomposition: Firstly, we need to find the airlines that have flights from airport 'CVO'. Secondly, we need to find the airlines that do not have flights from airport 'APG'. Finally, we need to find the intersection of these two sets to get the final result.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To find the airlines with flights from airport 'CVO', we need to use tables ['flights', 'airports', 'airlines']. To find the airlines without flights from airport 'APG', we also need to use the same set of tables.\n\n<3> SQL Generation: Use 'where' to filter for flights from airport 'CVO' and 'APG', then use 'except' operation to find the airlines that have flights from 'CVO' but not from 'APG'.\n\n",
        "predict": "\nSELECT DISTINCT a1.Airline \nFROM airlines a1 \nJOIN flights f1 ON a1.uid = f1.Airline \nJOIN airports ap1 ON f1.SourceAirport = ap1.AirportCode \nWHERE ap1.AirportCode = 'CVO' \nEXCEPT \nSELECT DISTINCT a2.Airline \nFROM airlines a2 \nJOIN flights f2 ON a2.uid = f2.Airline \nJOIN airports ap2 ON f2.SourceAirport = ap2.AirportCode \nWHERE ap2.AirportCode = 'APG'"
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"CVO\" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  \"APG\"",
        "question": "Which airlines have departures from CVO but not from APG airports?",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 21,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes set difference logic, so we can decompose the question into two subproblems: 1. what are the airlines that have departures from CVO airport; 2. what are the airlines that have departures from APG airport.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['flights', 'airports', 'airlines']. To complete the second subproblem, we need to use tables ['flights', 'airports', 'airlines'].\n\n<3> Operation: Use 'where' to filter using column 'SourceAirport' in table 'flights'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT DISTINCT T1.Airline FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'CVO' EXCEPT SELECT DISTINCT T1.Airline FROM flights AS T1 JOIN airports AS T2 ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'APG'"
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)",
        "question": "Find the name of airports which do not have any flight in and out.",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 22,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: Firstly, we need to find the airports that do not have any flight in or out. Secondly, we need to retrieve the names of those airports.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select AirportCode from the 'airports' table where the AirportCode does not appear in either the SourceAirport or DestAirport columns of the 'flights' table.\n\n<3> SQL Generation: Use 'where' to find the airports that do not have any flight in or out, and then select their AirportName.\n\n",
        "predict": "SELECT AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights)"
    },
    {
        "db_id": "flight_2",
        "gold": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)",
        "question": "Which airports do not have departing or arriving flights?",
        "foreign_keys": "Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]\n",
        "tables": "Table airlines, columns = [*,uid,Airline,Abbreviation,Country]\nTable airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]\nTable flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]\n",
        "types": {
            "airlines.uid": "number",
            "airlines.Airline": "text",
            "airlines.Abbreviation": "text",
            "airlines.Country": "text",
            "airports.City": "text",
            "airports.AirportCode": "text",
            "airports.AirportName": "text",
            "airports.Country": "text",
            "airports.CountryAbbrev": "text",
            "flights.Airline": "number",
            "flights.FlightNo": "number",
            "flights.SourceAirport": "text",
            "flights.DestAirport": "text"
        },
        "number": 23,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: Firstly, we need to find the airports that do not have any departing or arriving flights.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select AirportCode from table 'airports' and filter the airports that do not have any departing or arriving flights from table 'flights'.\n\n<3> SQL Generation: Use 'where' to filter the airports that do not have any departing or arriving flights.\n\n",
        "predict": "SELECT AirportCode, AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights) AND AirportCode NOT IN (SELECT DestAirport FROM flights)"
    },
    {
        "db_id": "employee_hire_evaluation",
        "gold": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)",
        "question": "Find the names of employees who never won any award in the evaluation.",
        "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n",
        "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n",
        "types": {
            "employee.Employee_ID": "number",
            "employee.Name": "text",
            "employee.Age": "number",
            "employee.City": "text",
            "shop.Shop_ID": "number",
            "shop.Name": "text",
            "shop.Location": "text",
            "shop.District": "text",
            "shop.Number_products": "number",
            "shop.Manager_name": "text",
            "hiring.Shop_ID": "number",
            "hiring.Employee_ID": "number",
            "hiring.Start_from": "text",
            "hiring.Is_full_time": "others",
            "evaluation.Employee_ID": "text",
            "evaluation.Year_awarded": "text",
            "evaluation.Bonus": "number"
        },
        "number": 24,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all employees; 2. what are the names of employees who won awards in the evaluation.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['employee']. To complete the second subproblem, we need to use tables ['employee', 'evaluation'].\n\n<3> Operation: Use 'where' to filter using column 'Year_awarded' in table 'evaluation'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Name FROM employee EXCEPT SELECT t1.Name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID = t2.Employee_ID"
    },
    {
        "db_id": "employee_hire_evaluation",
        "gold": "SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation)",
        "question": "What are the names of the employees who never received any evaluation?",
        "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n",
        "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n",
        "types": {
            "employee.Employee_ID": "number",
            "employee.Name": "text",
            "employee.Age": "number",
            "employee.City": "text",
            "shop.Shop_ID": "number",
            "shop.Name": "text",
            "shop.Location": "text",
            "shop.District": "text",
            "shop.Number_products": "number",
            "shop.Manager_name": "text",
            "hiring.Shop_ID": "number",
            "hiring.Employee_ID": "number",
            "hiring.Start_from": "text",
            "hiring.Is_full_time": "others",
            "evaluation.Employee_ID": "text",
            "evaluation.Year_awarded": "text",
            "evaluation.Bonus": "number"
        },
        "number": 25,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes the absence of a certain condition, so we can decompose the question into finding employees who do not have any evaluations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To find employees who never received any evaluation, we need to use tables ['employee', 'evaluation'].\n\n<3> Operation: Use 'where' to filter out employees who have no entries in the 'evaluation' table.\n\n<4> SQL Generation: Use 'not exists' operation to find employees who do not have any entries in the 'evaluation' table.\n\n",
        "predict": "SELECT Name FROM employee WHERE NOT EXISTS (SELECT * FROM evaluation WHERE employee.Employee_ID = evaluation.Employee_ID)"
    },
    {
        "db_id": "employee_hire_evaluation",
        "gold": "SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)",
        "question": "Find the name of the shops that do not hire any employee.",
        "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n",
        "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n",
        "types": {
            "employee.Employee_ID": "number",
            "employee.Name": "text",
            "employee.Age": "number",
            "employee.City": "text",
            "shop.Shop_ID": "number",
            "shop.Name": "text",
            "shop.Location": "text",
            "shop.District": "text",
            "shop.Number_products": "number",
            "shop.Manager_name": "text",
            "hiring.Shop_ID": "number",
            "hiring.Employee_ID": "number",
            "hiring.Start_from": "text",
            "hiring.Is_full_time": "others",
            "evaluation.Employee_ID": "text",
            "evaluation.Year_awarded": "text",
            "evaluation.Bonus": "number"
        },
        "number": 26,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: Firstly, we need to find the shops that do not hire any employee. Secondly, we need to select the name of those shops.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are only interested in the name of the shops, we only need the 'shop' table.\n\n<3> SQL Generation: Use 'where' to filter the shops that do not hire any employee, and then select the name from the 'shop' table.\n\n",
        "predict": "SELECT Name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)"
    },
    {
        "db_id": "employee_hire_evaluation",
        "gold": "SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000",
        "question": "Which district has both stores with less than 3000 products and stores with more than 10000 products?",
        "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n",
        "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n",
        "types": {
            "employee.Employee_ID": "number",
            "employee.Name": "text",
            "employee.Age": "number",
            "employee.City": "text",
            "shop.Shop_ID": "number",
            "shop.Name": "text",
            "shop.Location": "text",
            "shop.District": "text",
            "shop.Number_products": "number",
            "shop.Manager_name": "text",
            "hiring.Shop_ID": "number",
            "hiring.Employee_ID": "number",
            "hiring.Start_from": "text",
            "hiring.Is_full_time": "others",
            "evaluation.Employee_ID": "text",
            "evaluation.Year_awarded": "text",
            "evaluation.Bonus": "number"
        },
        "number": 27,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the districts that have stores with less than 3000 products; 2. what are the districts that have stores with more than 10000 products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['shop']. To complete the second subproblem, we also need to use tables ['shop'].\n\n<3> Operation: Use 'where' to filter using column 'Number_products' in table 'shop'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.District FROM shop AS T1 WHERE T1.Number_products < 3000 INTERSECT SELECT T1.District FROM shop AS T1 WHERE T1.Number_products > 10000"
    },
    {
        "db_id": "employee_hire_evaluation",
        "gold": "SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000",
        "question": "Find the districts in which there are both shops selling less than 3000 products and shops selling more than 10000 products.",
        "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n",
        "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n",
        "types": {
            "employee.Employee_ID": "number",
            "employee.Name": "text",
            "employee.Age": "number",
            "employee.City": "text",
            "shop.Shop_ID": "number",
            "shop.Name": "text",
            "shop.Location": "text",
            "shop.District": "text",
            "shop.Number_products": "number",
            "shop.Manager_name": "text",
            "hiring.Shop_ID": "number",
            "hiring.Employee_ID": "number",
            "hiring.Start_from": "text",
            "hiring.Is_full_time": "others",
            "evaluation.Employee_ID": "text",
            "evaluation.Year_awarded": "text",
            "evaluation.Bonus": "number"
        },
        "number": 28,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the districts with shops selling less than 3000 products; 2. what are the districts with shops selling more than 10000 products.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['shop']. To complete the second subproblem, we also need to use tables ['shop'].\n\n<3> Operation: Use 'where' to filter using column 'Number_products' in table 'shop'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT District FROM shop WHERE Number_products < 3000 INTERSECT SELECT District FROM shop WHERE Number_products > 10000"
    },
    {
        "db_id": "cre_Doc_Template_Mgt",
        "gold": "SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents",
        "question": "Show ids for all templates not used by any document.",
        "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n",
        "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n",
        "types": {
            "Ref_Template_Types.Template_Type_Code": "text",
            "Ref_Template_Types.Template_Type_Description": "text",
            "Templates.Template_ID": "number",
            "Templates.Version_Number": "number",
            "Templates.Template_Type_Code": "text",
            "Templates.Date_Effective_From": "time",
            "Templates.Date_Effective_To": "time",
            "Templates.Template_Details": "text",
            "Documents.Document_ID": "number",
            "Documents.Template_ID": "number",
            "Documents.Document_Name": "text",
            "Documents.Document_Description": "text",
            "Documents.Other_Details": "text",
            "Paragraphs.Paragraph_ID": "number",
            "Paragraphs.Document_ID": "number",
            "Paragraphs.Paragraph_Text": "text",
            "Paragraphs.Other_Details": "text"
        },
        "number": 29,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of templates used by documents; 2. what are the ids of all templates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Templates', 'Documents']. To complete the second subproblem, we only need to use the table 'Templates'.\n\n<3> Operation: Use 'where' to filter out the templates used by documents.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Template_ID FROM Templates EXCEPT SELECT T1.Template_ID FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID  =  T2.Template_ID"
    },
    {
        "db_id": "cre_Doc_Template_Mgt",
        "gold": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id",
        "question": "Show all template type codes that are not used by any document.",
        "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n",
        "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n",
        "types": {
            "Ref_Template_Types.Template_Type_Code": "text",
            "Ref_Template_Types.Template_Type_Description": "text",
            "Templates.Template_ID": "number",
            "Templates.Version_Number": "number",
            "Templates.Template_Type_Code": "text",
            "Templates.Date_Effective_From": "time",
            "Templates.Date_Effective_To": "time",
            "Templates.Template_Details": "text",
            "Documents.Document_ID": "number",
            "Documents.Template_ID": "number",
            "Documents.Document_Name": "text",
            "Documents.Document_Description": "text",
            "Documents.Other_Details": "text",
            "Paragraphs.Paragraph_ID": "number",
            "Paragraphs.Document_ID": "number",
            "Paragraphs.Paragraph_Text": "text",
            "Paragraphs.Other_Details": "text"
        },
        "number": 30,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the template type codes of all templates; 2. what are the template type codes that are used by documents.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Templates']. To complete the second subproblem, we need to use tables ['Templates', 'Documents'].\n\n<3> Operation: Use 'where' to filter using column 'Template_ID' in table 'Documents'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Template_Type_Code FROM Templates EXCEPT SELECT T1.Template_Type_Code FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID  =  T2.Template_ID"
    },
    {
        "db_id": "cre_Doc_Template_Mgt",
        "gold": "SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland'",
        "question": "What are the ids of documents that contain the paragraph text 'Brazil' and 'Ireland'?",
        "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n",
        "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n",
        "types": {
            "Ref_Template_Types.Template_Type_Code": "text",
            "Ref_Template_Types.Template_Type_Description": "text",
            "Templates.Template_ID": "number",
            "Templates.Version_Number": "number",
            "Templates.Template_Type_Code": "text",
            "Templates.Date_Effective_From": "time",
            "Templates.Date_Effective_To": "time",
            "Templates.Template_Details": "text",
            "Documents.Document_ID": "number",
            "Documents.Template_ID": "number",
            "Documents.Document_Name": "text",
            "Documents.Document_Description": "text",
            "Documents.Other_Details": "text",
            "Paragraphs.Paragraph_ID": "number",
            "Paragraphs.Document_ID": "number",
            "Paragraphs.Paragraph_Text": "text",
            "Paragraphs.Other_Details": "text"
        },
        "number": 31,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the ids of documents that contain the paragraph text 'Brazil'; 2. what are the ids of documents that contain the paragraph text 'Ireland'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables 'Documents' and 'Paragraphs'. To complete the second subproblem, we also need to use tables 'Documents' and 'Paragraphs'.\n\n<3> Operation: Use 'where' to filter using column 'Paragraph_Text' in table 'Paragraphs'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.Document_ID FROM Documents AS T1 JOIN Paragraphs AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Paragraph_Text = 'Brazil' INTERSECT SELECT T1.Document_ID FROM Documents AS T1 JOIN Paragraphs AS T2 ON T1.Document_ID = T2.Document_ID WHERE T2.Paragraph_Text = 'Ireland'"
    },
    {
        "db_id": "course_teach",
        "gold": "SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33",
        "question": "What are the names of the teachers who are aged either 32 or 33?",
        "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n",
        "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n",
        "types": {
            "course.Course_ID": "number",
            "course.Staring_Date": "text",
            "course.Course": "text",
            "teacher.Teacher_ID": "number",
            "teacher.Name": "text",
            "teacher.Age": "text",
            "teacher.Hometown": "text",
            "course_arrange.Course_ID": "number",
            "course_arrange.Teacher_ID": "number",
            "course_arrange.Grade": "number"
        },
        "number": 32,
        "hardness": "medium",
        "reasoning": "<1> Decomposition: The query requires finding the names of teachers who are aged either 32 or 33.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the query requirements and the foreign key relationships. We need to select the 'Name' column from the 'teacher' table where the 'Age' is either 32 or 33.\n\n<3> SQL Generation: Use the 'where' clause to filter teachers with the age of 32 or 33.\n\n",
        "predict": "SELECT Name FROM teacher WHERE Age IN (32, 33)"
    },
    {
        "db_id": "course_teach",
        "gold": "SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)",
        "question": "List the names of teachers who have not been arranged to teach courses.",
        "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n",
        "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n",
        "types": {
            "course.Course_ID": "number",
            "course.Staring_Date": "text",
            "course.Course": "text",
            "teacher.Teacher_ID": "number",
            "teacher.Name": "text",
            "teacher.Age": "text",
            "teacher.Hometown": "text",
            "course_arrange.Course_ID": "number",
            "course_arrange.Teacher_ID": "number",
            "course_arrange.Grade": "number"
        },
        "number": 33,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: The query requires finding teachers who have not been arranged to teach courses.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the query requirements and the foreign key relationships. We need to select the names of teachers from the 'teacher' table who have not been arranged to teach courses.\n\n<3> SQL Generation: We can use a left join to combine the 'teacher' table with the 'course_arrange' table on the 'Teacher_ID' column. Then, we can filter the rows where the 'Course_ID' is null, indicating that the teacher has not been arranged to teach any courses.\n\n",
        "predict": "SELECT Name FROM teacher WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM course_arrange)"
    },
    {
        "db_id": "course_teach",
        "gold": "SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)",
        "question": "What are the names of the teachers whose courses have not been arranged?",
        "foreign_keys": "Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]\n",
        "tables": "Table course, columns = [*,Course_ID,Staring_Date,Course]\nTable course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]\nTable teacher, columns = [*,Teacher_ID,Name,Age,Hometown]\n",
        "types": {
            "course.Course_ID": "number",
            "course.Staring_Date": "text",
            "course.Course": "text",
            "teacher.Teacher_ID": "number",
            "teacher.Name": "text",
            "teacher.Age": "text",
            "teacher.Hometown": "text",
            "course_arrange.Course_ID": "number",
            "course_arrange.Teacher_ID": "number",
            "course_arrange.Grade": "number"
        },
        "number": 34,
        "hardness": "hard",
        "reasoning": "<1> Operation: The query requires the names of teachers whose courses have not been arranged, so we should find the teachers whose courses do not have corresponding entries in the 'course_arrange' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['teacher', 'course_arrange'].\n\n<3> SQL Generation: Use 'except' operation to find the names of teachers whose courses have not been arranged.\n\n",
        "predict": "SELECT Name FROM teacher EXCEPT SELECT T2.Name FROM teacher AS T1 LEFT JOIN course_arrange AS T2 ON T1.Teacher_ID = T2.Teacher_ID"
    },
    {
        "db_id": "museum_visit",
        "gold": "SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  <  2009 INTERSECT SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  >  2011",
        "question": "What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?",
        "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n",
        "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n",
        "types": {
            "museum.Museum_ID": "number",
            "museum.Name": "text",
            "museum.Num_of_Staff": "number",
            "museum.Open_Year": "text",
            "visitor.ID": "number",
            "visitor.Name": "text",
            "visitor.Level_of_membership": "number",
            "visitor.Age": "number",
            "visit.Museum_ID": "number",
            "visit.visitor_ID": "text",
            "visit.Num_of_Ticket": "number",
            "visit.Total_spent": "number"
        },
        "number": 35,
        "hardness": "extra",
        "reasoning": "<1> Operation: The query requires the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011. We need to filter the museums based on their opening years and find the visitors who visited both types of museums.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['museum', 'visit', 'visitor'].\n\n<3> SQL Generation: The query requires the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011. We should select the 'Name' column from the 'visitor' table and filter the museums based on their opening years.\n\n",
        "predict": "\nSELECT T3.Name \nFROM visitor AS T3 \nJOIN visit AS T2 ON T3.ID = T2.visitor_ID \nJOIN museum AS T1 ON T2.Museum_ID = T1.Museum_ID \nWHERE T1.Open_Year < 2009 \nAND T1.Open_Year > 2011 \nGROUP BY T3.Name"
    },
    {
        "db_id": "wta_1",
        "gold": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
        "question": "List the names of all winners who played in both 2013 and 2016.",
        "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n",
        "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n",
        "types": {
            "players.player_id": "number",
            "players.first_name": "text",
            "players.last_name": "text",
            "players.hand": "text",
            "players.birth_date": "time",
            "players.country_code": "text",
            "matches.best_of": "number",
            "matches.draw_size": "number",
            "matches.loser_age": "number",
            "matches.loser_entry": "text",
            "matches.loser_hand": "text",
            "matches.loser_ht": "number",
            "matches.loser_id": "number",
            "matches.loser_ioc": "text",
            "matches.loser_name": "text",
            "matches.loser_rank": "number",
            "matches.loser_rank_points": "number",
            "matches.loser_seed": "number",
            "matches.match_num": "number",
            "matches.minutes": "number",
            "matches.round": "text",
            "matches.score": "text",
            "matches.surface": "text",
            "matches.tourney_date": "time",
            "matches.tourney_id": "text",
            "matches.tourney_level": "text",
            "matches.tourney_name": "text",
            "matches.winner_age": "number",
            "matches.winner_entry": "text",
            "matches.winner_hand": "text",
            "matches.winner_ht": "number",
            "matches.winner_id": "number",
            "matches.winner_ioc": "text",
            "matches.winner_name": "text",
            "matches.winner_rank": "number",
            "matches.winner_rank_points": "number",
            "matches.winner_seed": "number",
            "matches.year": "number",
            "rankings.ranking_date": "time",
            "rankings.ranking": "number",
            "rankings.player_id": "number",
            "rankings.ranking_points": "number",
            "rankings.tours": "number"
        },
        "number": 36,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of winners who played in 2013; 2. what are the names of winners who played in 2016.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['matches', 'players']. To complete the second subproblem, we also need to use tables ['matches', 'players'].\n\n<3> Operation: Use 'where' to filter using column 'year' in table 'matches'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.first_name, T1.last_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.year = 2013 INTERSECT SELECT T1.first_name, T1.last_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.year = 2016"
    },
    {
        "db_id": "wta_1",
        "gold": "SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016",
        "question": "What are the names of players who won in both 2013 and 2016?",
        "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n",
        "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n",
        "types": {
            "players.player_id": "number",
            "players.first_name": "text",
            "players.last_name": "text",
            "players.hand": "text",
            "players.birth_date": "time",
            "players.country_code": "text",
            "matches.best_of": "number",
            "matches.draw_size": "number",
            "matches.loser_age": "number",
            "matches.loser_entry": "text",
            "matches.loser_hand": "text",
            "matches.loser_ht": "number",
            "matches.loser_id": "number",
            "matches.loser_ioc": "text",
            "matches.loser_name": "text",
            "matches.loser_rank": "number",
            "matches.loser_rank_points": "number",
            "matches.loser_seed": "number",
            "matches.match_num": "number",
            "matches.minutes": "number",
            "matches.round": "text",
            "matches.score": "text",
            "matches.surface": "text",
            "matches.tourney_date": "time",
            "matches.tourney_id": "text",
            "matches.tourney_level": "text",
            "matches.tourney_name": "text",
            "matches.winner_age": "number",
            "matches.winner_entry": "text",
            "matches.winner_hand": "text",
            "matches.winner_ht": "number",
            "matches.winner_id": "number",
            "matches.winner_ioc": "text",
            "matches.winner_name": "text",
            "matches.winner_rank": "number",
            "matches.winner_rank_points": "number",
            "matches.winner_seed": "number",
            "matches.year": "number",
            "rankings.ranking_date": "time",
            "rankings.ranking": "number",
            "rankings.player_id": "number",
            "rankings.ranking_points": "number",
            "rankings.tours": "number"
        },
        "number": 37,
        "hardness": "hard",
        "reasoning": "SELECT DISTINCT T1.first_name, T1.last_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.year = 2013 AND T1.player_id IN (SELECT winner_id FROM matches WHERE year = 2016",
        "predict": "TINCT T1.first_name, T1.last_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.year = 2013 AND T1.player_id IN (SELECT winner_id FROM matches WHERE year = 2016)"
    },
    {
        "db_id": "wta_1",
        "gold": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
        "question": "What are the country code and first name of the players who won in both tourney WTA Championships and Australian Open?",
        "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n",
        "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n",
        "types": {
            "players.player_id": "number",
            "players.first_name": "text",
            "players.last_name": "text",
            "players.hand": "text",
            "players.birth_date": "time",
            "players.country_code": "text",
            "matches.best_of": "number",
            "matches.draw_size": "number",
            "matches.loser_age": "number",
            "matches.loser_entry": "text",
            "matches.loser_hand": "text",
            "matches.loser_ht": "number",
            "matches.loser_id": "number",
            "matches.loser_ioc": "text",
            "matches.loser_name": "text",
            "matches.loser_rank": "number",
            "matches.loser_rank_points": "number",
            "matches.loser_seed": "number",
            "matches.match_num": "number",
            "matches.minutes": "number",
            "matches.round": "text",
            "matches.score": "text",
            "matches.surface": "text",
            "matches.tourney_date": "time",
            "matches.tourney_id": "text",
            "matches.tourney_level": "text",
            "matches.tourney_name": "text",
            "matches.winner_age": "number",
            "matches.winner_entry": "text",
            "matches.winner_hand": "text",
            "matches.winner_ht": "number",
            "matches.winner_id": "number",
            "matches.winner_ioc": "text",
            "matches.winner_name": "text",
            "matches.winner_rank": "number",
            "matches.winner_rank_points": "number",
            "matches.winner_seed": "number",
            "matches.year": "number",
            "rankings.ranking_date": "time",
            "rankings.ranking": "number",
            "rankings.player_id": "number",
            "rankings.ranking_points": "number",
            "rankings.tours": "number"
        },
        "number": 38,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we decompose the query into two subproblems: 1. What are the country code and first name of the players who won in the tourney WTA Championships; 2. What are the country code and first name of the players who won in the Australian Open.\n\n<2> Schema Linking: We need to use tables ['players', 'matches'] to find the players who won in each tournament.\n\n<3> Operation: Use 'where' to filter using column 'tourney_name' in table 'matches'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.country_code, T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.tourney_name = \"WTA Championships\" INTERSECT SELECT T1.country_code, T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id = T2.winner_id WHERE T2.tourney_name = \"Australian Open\""
    },
    {
        "db_id": "wta_1",
        "gold": "SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",
        "question": "What are the first names and country codes for players who won both the WTA Championships and the Australian Open?",
        "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n",
        "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n",
        "types": {
            "players.player_id": "number",
            "players.first_name": "text",
            "players.last_name": "text",
            "players.hand": "text",
            "players.birth_date": "time",
            "players.country_code": "text",
            "matches.best_of": "number",
            "matches.draw_size": "number",
            "matches.loser_age": "number",
            "matches.loser_entry": "text",
            "matches.loser_hand": "text",
            "matches.loser_ht": "number",
            "matches.loser_id": "number",
            "matches.loser_ioc": "text",
            "matches.loser_name": "text",
            "matches.loser_rank": "number",
            "matches.loser_rank_points": "number",
            "matches.loser_seed": "number",
            "matches.match_num": "number",
            "matches.minutes": "number",
            "matches.round": "text",
            "matches.score": "text",
            "matches.surface": "text",
            "matches.tourney_date": "time",
            "matches.tourney_id": "text",
            "matches.tourney_level": "text",
            "matches.tourney_name": "text",
            "matches.winner_age": "number",
            "matches.winner_entry": "text",
            "matches.winner_hand": "text",
            "matches.winner_ht": "number",
            "matches.winner_id": "number",
            "matches.winner_ioc": "text",
            "matches.winner_name": "text",
            "matches.winner_rank": "number",
            "matches.winner_rank_points": "number",
            "matches.winner_seed": "number",
            "matches.year": "number",
            "rankings.ranking_date": "time",
            "rankings.ranking": "number",
            "rankings.player_id": "number",
            "rankings.ranking_points": "number",
            "rankings.tours": "number"
        },
        "number": 39,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection set logic, so we can decompose the question into two subproblems: 1. what are the first names and country codes for players who won the WTA Championships; 2. what are the first names and country codes for players who won the Australian Open.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['players', 'matches']. To complete the second subproblem, we also need to use tables ['players', 'matches'].\n\n<3> Operation: Use 'where' to filter using column 'tourney_name' in table 'matches'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "\nSELECT T1.first_name, T1.country_code \nFROM players AS T1 \nJOIN matches AS T2 ON T1.player_id = T2.winner_id \nWHERE T2.tourney_name = 'WTA Championships'\nINTERSECT\nSELECT T1.first_name, T1.country_code \nFROM players AS T1 \nJOIN matches AS T2 ON T1.player_id = T2.winner_id \nWHERE T2.tourney_name = 'Australian Open'"
    },
    {
        "db_id": "wta_1",
        "gold": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'",
        "question": "How many different winners both participated in the WTA Championships and were left handed?",
        "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n",
        "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n",
        "types": {
            "players.player_id": "number",
            "players.first_name": "text",
            "players.last_name": "text",
            "players.hand": "text",
            "players.birth_date": "time",
            "players.country_code": "text",
            "matches.best_of": "number",
            "matches.draw_size": "number",
            "matches.loser_age": "number",
            "matches.loser_entry": "text",
            "matches.loser_hand": "text",
            "matches.loser_ht": "number",
            "matches.loser_id": "number",
            "matches.loser_ioc": "text",
            "matches.loser_name": "text",
            "matches.loser_rank": "number",
            "matches.loser_rank_points": "number",
            "matches.loser_seed": "number",
            "matches.match_num": "number",
            "matches.minutes": "number",
            "matches.round": "text",
            "matches.score": "text",
            "matches.surface": "text",
            "matches.tourney_date": "time",
            "matches.tourney_id": "text",
            "matches.tourney_level": "text",
            "matches.tourney_name": "text",
            "matches.winner_age": "number",
            "matches.winner_entry": "text",
            "matches.winner_hand": "text",
            "matches.winner_ht": "number",
            "matches.winner_id": "number",
            "matches.winner_ioc": "text",
            "matches.winner_name": "text",
            "matches.winner_rank": "number",
            "matches.winner_rank_points": "number",
            "matches.winner_seed": "number",
            "matches.year": "number",
            "rankings.ranking_date": "time",
            "rankings.ranking": "number",
            "rankings.player_id": "number",
            "rankings.ranking_points": "number",
            "rankings.tours": "number"
        },
        "number": 40,
        "hardness": "medium",
        "reasoning": "<1> Operation: The query requires counting the number of different winners who participated in the WTA Championships and were left-handed. We need to filter for players who participated in the WTA Championships and were left-handed, then count the distinct winners.\n\n<2> Schema Linking: We need to use tables ['matches', 'players'] based on the query requirements and foreign key relationships.\n\n<3> SQL Generation: We should select the distinct 'winner_id' from the 'matches' table where the 'winner_hand' is left-handed and the 'tourney_name' is WTA Championships. Then, we count the number of distinct winners.\n\n",
        "predict": "\nSELECT COUNT(DISTINCT m.winner_id) \nFROM matches m \nJOIN players p ON m.winner_id = p.player_id \nWHERE m.tourney_name = 'WTA Championships' AND p.hand = 'L'"
    },
    {
        "db_id": "student_transcripts_tracking",
        "gold": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
        "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.",
        "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n",
        "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n",
        "types": {
            "Addresses.address_id": "number",
            "Addresses.line_1": "text",
            "Addresses.line_2": "text",
            "Addresses.line_3": "text",
            "Addresses.city": "text",
            "Addresses.zip_postcode": "text",
            "Addresses.state_province_county": "text",
            "Addresses.country": "text",
            "Addresses.other_address_details": "text",
            "Courses.course_id": "number",
            "Courses.course_name": "text",
            "Courses.course_description": "text",
            "Courses.other_details": "text",
            "Departments.department_id": "number",
            "Departments.department_name": "text",
            "Departments.department_description": "text",
            "Departments.other_details": "text",
            "Degree_Programs.degree_program_id": "number",
            "Degree_Programs.department_id": "number",
            "Degree_Programs.degree_summary_name": "text",
            "Degree_Programs.degree_summary_description": "text",
            "Degree_Programs.other_details": "text",
            "Sections.section_id": "number",
            "Sections.course_id": "number",
            "Sections.section_name": "text",
            "Sections.section_description": "text",
            "Sections.other_details": "text",
            "Semesters.semester_id": "number",
            "Semesters.semester_name": "text",
            "Semesters.semester_description": "text",
            "Semesters.other_details": "text",
            "Students.student_id": "number",
            "Students.current_address_id": "number",
            "Students.permanent_address_id": "number",
            "Students.first_name": "text",
            "Students.middle_name": "text",
            "Students.last_name": "text",
            "Students.cell_mobile_number": "text",
            "Students.email_address": "text",
            "Students.ssn": "text",
            "Students.date_first_registered": "time",
            "Students.date_left": "time",
            "Students.other_student_details": "text",
            "Student_Enrolment.student_enrolment_id": "number",
            "Student_Enrolment.degree_program_id": "number",
            "Student_Enrolment.semester_id": "number",
            "Student_Enrolment.student_id": "number",
            "Student_Enrolment.other_details": "text",
            "Student_Enrolment_Courses.student_course_id": "number",
            "Student_Enrolment_Courses.course_id": "number",
            "Student_Enrolment_Courses.student_enrolment_id": "number",
            "Transcripts.transcript_id": "number",
            "Transcripts.transcript_date": "time",
            "Transcripts.other_details": "text",
            "Transcript_Contents.student_course_id": "number",
            "Transcript_Contents.transcript_id": "number"
        },
        "number": 41,
        "hardness": "extra",
        "reasoning": "<1> Operation: The query requires finding the last name of students who currently live in the state of North Carolina but have not registered in any degree program. We need to filter out students based on their current address in North Carolina and then check if they are registered in any degree program.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Students', 'Addresses', 'Degree_Programs', 'Departments'].\n\n<3> SQL Generation: We should select the last name of students from the 'Students' table, filter out students who currently live in the state of North Carolina, and then check if they are registered in any degree program.\n\n",
        "predict": "\nSELECT last_name \nFROM Students \nJOIN Addresses ON Students.current_address_id = Addresses.address_id \nLEFT JOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id \nWHERE Addresses.state_province_county = 'North Carolina' \nAND Student_Enrolment.degree_program_id IS NULL"
    },
    {
        "db_id": "student_transcripts_tracking",
        "gold": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id",
        "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?",
        "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n",
        "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n",
        "types": {
            "Addresses.address_id": "number",
            "Addresses.line_1": "text",
            "Addresses.line_2": "text",
            "Addresses.line_3": "text",
            "Addresses.city": "text",
            "Addresses.zip_postcode": "text",
            "Addresses.state_province_county": "text",
            "Addresses.country": "text",
            "Addresses.other_address_details": "text",
            "Courses.course_id": "number",
            "Courses.course_name": "text",
            "Courses.course_description": "text",
            "Courses.other_details": "text",
            "Departments.department_id": "number",
            "Departments.department_name": "text",
            "Departments.department_description": "text",
            "Departments.other_details": "text",
            "Degree_Programs.degree_program_id": "number",
            "Degree_Programs.department_id": "number",
            "Degree_Programs.degree_summary_name": "text",
            "Degree_Programs.degree_summary_description": "text",
            "Degree_Programs.other_details": "text",
            "Sections.section_id": "number",
            "Sections.course_id": "number",
            "Sections.section_name": "text",
            "Sections.section_description": "text",
            "Sections.other_details": "text",
            "Semesters.semester_id": "number",
            "Semesters.semester_name": "text",
            "Semesters.semester_description": "text",
            "Semesters.other_details": "text",
            "Students.student_id": "number",
            "Students.current_address_id": "number",
            "Students.permanent_address_id": "number",
            "Students.first_name": "text",
            "Students.middle_name": "text",
            "Students.last_name": "text",
            "Students.cell_mobile_number": "text",
            "Students.email_address": "text",
            "Students.ssn": "text",
            "Students.date_first_registered": "time",
            "Students.date_left": "time",
            "Students.other_student_details": "text",
            "Student_Enrolment.student_enrolment_id": "number",
            "Student_Enrolment.degree_program_id": "number",
            "Student_Enrolment.semester_id": "number",
            "Student_Enrolment.student_id": "number",
            "Student_Enrolment.other_details": "text",
            "Student_Enrolment_Courses.student_course_id": "number",
            "Student_Enrolment_Courses.course_id": "number",
            "Student_Enrolment_Courses.student_enrolment_id": "number",
            "Transcripts.transcript_id": "number",
            "Transcripts.transcript_date": "time",
            "Transcripts.other_details": "text",
            "Transcript_Contents.student_course_id": "number",
            "Transcript_Contents.transcript_id": "number"
        },
        "number": 42,
        "hardness": "extra",
        "reasoning": "<1> Operation: The query requires the last name of the students who live in North Carolina but have not registered in any degree programs. We need to filter out the students who live in North Carolina and have not registered in any degree programs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Students', 'Addresses', 'Student_Enrolment', 'Degree_Programs'].\n\n<3> SQL Generation: The query requires the last name of the students who live in North Carolina but have not registered in any degree programs. We should select the 'last_name' column from the 'Students' table and filter out the students who live in North Carolina and have not registered in any degree programs.\n\n",
        "predict": "\nSELECT last_name \nFROM Students \nJOIN Addresses ON Students.current_address_id = Addresses.address_id \nLEFT JOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id \nLEFT JOIN Degree_Programs ON Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id \nWHERE Addresses.state_province_county = 'North Carolina' AND Degree_Programs.degree_program_id IS NULL"
    },
    {
        "db_id": "student_transcripts_tracking",
        "gold": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
        "question": "Find the semester when both Master students and Bachelor students got enrolled in.",
        "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n",
        "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n",
        "types": {
            "Addresses.address_id": "number",
            "Addresses.line_1": "text",
            "Addresses.line_2": "text",
            "Addresses.line_3": "text",
            "Addresses.city": "text",
            "Addresses.zip_postcode": "text",
            "Addresses.state_province_county": "text",
            "Addresses.country": "text",
            "Addresses.other_address_details": "text",
            "Courses.course_id": "number",
            "Courses.course_name": "text",
            "Courses.course_description": "text",
            "Courses.other_details": "text",
            "Departments.department_id": "number",
            "Departments.department_name": "text",
            "Departments.department_description": "text",
            "Departments.other_details": "text",
            "Degree_Programs.degree_program_id": "number",
            "Degree_Programs.department_id": "number",
            "Degree_Programs.degree_summary_name": "text",
            "Degree_Programs.degree_summary_description": "text",
            "Degree_Programs.other_details": "text",
            "Sections.section_id": "number",
            "Sections.course_id": "number",
            "Sections.section_name": "text",
            "Sections.section_description": "text",
            "Sections.other_details": "text",
            "Semesters.semester_id": "number",
            "Semesters.semester_name": "text",
            "Semesters.semester_description": "text",
            "Semesters.other_details": "text",
            "Students.student_id": "number",
            "Students.current_address_id": "number",
            "Students.permanent_address_id": "number",
            "Students.first_name": "text",
            "Students.middle_name": "text",
            "Students.last_name": "text",
            "Students.cell_mobile_number": "text",
            "Students.email_address": "text",
            "Students.ssn": "text",
            "Students.date_first_registered": "time",
            "Students.date_left": "time",
            "Students.other_student_details": "text",
            "Student_Enrolment.student_enrolment_id": "number",
            "Student_Enrolment.degree_program_id": "number",
            "Student_Enrolment.semester_id": "number",
            "Student_Enrolment.student_id": "number",
            "Student_Enrolment.other_details": "text",
            "Student_Enrolment_Courses.student_course_id": "number",
            "Student_Enrolment_Courses.course_id": "number",
            "Student_Enrolment_Courses.student_enrolment_id": "number",
            "Transcripts.transcript_id": "number",
            "Transcripts.transcript_date": "time",
            "Transcripts.other_details": "text",
            "Transcript_Contents.student_course_id": "number",
            "Transcript_Contents.transcript_id": "number"
        },
        "number": 43,
        "hardness": "extra",
        "reasoning": "<1> Operation: The query requires finding the semester when both Master students and Bachelor students got enrolled in. To achieve this, we need to identify the semester where students from both Master and Bachelor degree programs are enrolled. We should apply the 'group by' operation to the 'semester_id' column in the 'Student_Enrolment' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Student_Enrolment', 'Degree_Programs'].\n\n<3> SQL Generation: The query requires finding the semester when both Master students and Bachelor students got enrolled in, so we should select the 'semester_id' column in the 'Student_Enrolment' table and filter the results based on the degree program. We can achieve this by using a subquery to filter the semester IDs where both Master and Bachelor students are enrolled.\n\n",
        "predict": "\nSELECT semester_id \nFROM Student_Enrolment \nWHERE degree_program_id IN \n    (SELECT degree_program_id \n     FROM Degree_Programs \n     WHERE degree_summary_name IN ('Master', 'Bachelor')) \nGROUP BY semester_id \nHAVING COUNT(DISTINCT degree_program_id) = 2"
    },
    {
        "db_id": "student_transcripts_tracking",
        "gold": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'",
        "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?",
        "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n",
        "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n",
        "types": {
            "Addresses.address_id": "number",
            "Addresses.line_1": "text",
            "Addresses.line_2": "text",
            "Addresses.line_3": "text",
            "Addresses.city": "text",
            "Addresses.zip_postcode": "text",
            "Addresses.state_province_county": "text",
            "Addresses.country": "text",
            "Addresses.other_address_details": "text",
            "Courses.course_id": "number",
            "Courses.course_name": "text",
            "Courses.course_description": "text",
            "Courses.other_details": "text",
            "Departments.department_id": "number",
            "Departments.department_name": "text",
            "Departments.department_description": "text",
            "Departments.other_details": "text",
            "Degree_Programs.degree_program_id": "number",
            "Degree_Programs.department_id": "number",
            "Degree_Programs.degree_summary_name": "text",
            "Degree_Programs.degree_summary_description": "text",
            "Degree_Programs.other_details": "text",
            "Sections.section_id": "number",
            "Sections.course_id": "number",
            "Sections.section_name": "text",
            "Sections.section_description": "text",
            "Sections.other_details": "text",
            "Semesters.semester_id": "number",
            "Semesters.semester_name": "text",
            "Semesters.semester_description": "text",
            "Semesters.other_details": "text",
            "Students.student_id": "number",
            "Students.current_address_id": "number",
            "Students.permanent_address_id": "number",
            "Students.first_name": "text",
            "Students.middle_name": "text",
            "Students.last_name": "text",
            "Students.cell_mobile_number": "text",
            "Students.email_address": "text",
            "Students.ssn": "text",
            "Students.date_first_registered": "time",
            "Students.date_left": "time",
            "Students.other_student_details": "text",
            "Student_Enrolment.student_enrolment_id": "number",
            "Student_Enrolment.degree_program_id": "number",
            "Student_Enrolment.semester_id": "number",
            "Student_Enrolment.student_id": "number",
            "Student_Enrolment.other_details": "text",
            "Student_Enrolment_Courses.student_course_id": "number",
            "Student_Enrolment_Courses.course_id": "number",
            "Student_Enrolment_Courses.student_enrolment_id": "number",
            "Transcripts.transcript_id": "number",
            "Transcripts.transcript_date": "time",
            "Transcripts.other_details": "text",
            "Transcript_Contents.student_course_id": "number",
            "Transcript_Contents.transcript_id": "number"
        },
        "number": 44,
        "hardness": "extra",
        "reasoning": "<1> Operation: The query requires finding the semester that had both Masters and Bachelors students enrolled. To achieve this, we need to identify the semester_id where students enrolled in both Masters and Bachelors degree programs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Semesters', 'Student_Enrolment', 'Degree_Programs'] to find the semester_id where both Masters and Bachelors students are enrolled.\n\n<3> SQL Generation: The query requires finding the semester_id where both Masters and Bachelors students are enrolled. We need to join the 'Semesters', 'Student_Enrolment', and 'Degree_Programs' tables to filter the semester_id where students are enrolled in both Masters and Bachelors degree programs.\n\n",
        "predict": "\nSELECT semester_id \nFROM Student_Enrolment \nWHERE degree_program_id IN \n    (SELECT degree_program_id \n     FROM Degree_Programs \n     WHERE degree_summary_name IN ('Masters', 'Bachelors')) \nGROUP BY semester_id \nHAVING COUNT(DISTINCT degree_program_id) = 2"
    },
    {
        "db_id": "student_transcripts_tracking",
        "gold": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'",
        "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?",
        "foreign_keys": "Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]\n",
        "tables": "Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]\nTable Courses, columns = [*,course_id,course_name,course_description,other_details]\nTable Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]\nTable Departments, columns = [*,department_id,department_name,department_description,other_details]\nTable Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]\nTable Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]\nTable Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]\nTable Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]\nTable Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]\nTable Transcript_Contents, columns = [*,student_course_id,transcript_id]\nTable Transcripts, columns = [*,transcript_id,transcript_date,other_details]\n",
        "types": {
            "Addresses.address_id": "number",
            "Addresses.line_1": "text",
            "Addresses.line_2": "text",
            "Addresses.line_3": "text",
            "Addresses.city": "text",
            "Addresses.zip_postcode": "text",
            "Addresses.state_province_county": "text",
            "Addresses.country": "text",
            "Addresses.other_address_details": "text",
            "Courses.course_id": "number",
            "Courses.course_name": "text",
            "Courses.course_description": "text",
            "Courses.other_details": "text",
            "Departments.department_id": "number",
            "Departments.department_name": "text",
            "Departments.department_description": "text",
            "Departments.other_details": "text",
            "Degree_Programs.degree_program_id": "number",
            "Degree_Programs.department_id": "number",
            "Degree_Programs.degree_summary_name": "text",
            "Degree_Programs.degree_summary_description": "text",
            "Degree_Programs.other_details": "text",
            "Sections.section_id": "number",
            "Sections.course_id": "number",
            "Sections.section_name": "text",
            "Sections.section_description": "text",
            "Sections.other_details": "text",
            "Semesters.semester_id": "number",
            "Semesters.semester_name": "text",
            "Semesters.semester_description": "text",
            "Semesters.other_details": "text",
            "Students.student_id": "number",
            "Students.current_address_id": "number",
            "Students.permanent_address_id": "number",
            "Students.first_name": "text",
            "Students.middle_name": "text",
            "Students.last_name": "text",
            "Students.cell_mobile_number": "text",
            "Students.email_address": "text",
            "Students.ssn": "text",
            "Students.date_first_registered": "time",
            "Students.date_left": "time",
            "Students.other_student_details": "text",
            "Student_Enrolment.student_enrolment_id": "number",
            "Student_Enrolment.degree_program_id": "number",
            "Student_Enrolment.semester_id": "number",
            "Student_Enrolment.student_id": "number",
            "Student_Enrolment.other_details": "text",
            "Student_Enrolment_Courses.student_course_id": "number",
            "Student_Enrolment_Courses.course_id": "number",
            "Student_Enrolment_Courses.student_enrolment_id": "number",
            "Transcripts.transcript_id": "number",
            "Transcripts.transcript_date": "time",
            "Transcripts.other_details": "text",
            "Transcript_Contents.student_course_id": "number",
            "Transcript_Contents.transcript_id": "number"
        },
        "number": 45,
        "hardness": "hard",
        "reasoning": "SELECT first_name FROM Students WHERE permanent_address_id IN (SELECT address_id FROM Addresses WHERE country = 'Haiti') OR cell_mobile_number = '09700166582",
        "predict": "st_name FROM Students WHERE permanent_address_id IN (SELECT address_id FROM Addresses WHERE country = 'Haiti') OR cell_mobile_number = '09700166582'"
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "question": "which countries' tv channels are not playing any cartoon written by Todd Casey?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 46,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we break down the query into smaller parts. We need to find the countries whose TV channels are not playing any cartoon written by Todd Casey.\n\n<2> Schema Linking: Identify the tables and columns needed for the query. We will need to use the 'TV_Channel' table to get the list of countries and the 'Cartoon' table to check if any cartoon is written by Todd Casey.\n\n<3> Operation: Use 'where' to filter out the TV channels that are playing cartoons written by Todd Casey.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT DISTINCT Country FROM TV_Channel EXCEPT SELECT T1.Country FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Written_by = 'Todd Casey'"
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey'",
        "question": "What are the countries that are not playing cartoons written by Todd Casey?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 47,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: Firstly, we need to filter cartoons written by Todd Casey. Secondly, we need to find the countries that are not playing these cartoons.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Cartoon', 'TV_Channel'].\n\n<3> SQL Generation: Use 'where' to filter cartoons written by Todd Casey, and then use 'distinct' to find the unique countries that are not playing these cartoons.\n\n",
        "predict": "SELECT DISTINCT TV_Channel.Country FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE Cartoon.Written_by = \"Todd Casey\""
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",
        "question": "What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 48,
        "hardness": "extra",
        "reasoning": "SELECT T2.series_name, T2.Country FROM Cartoon AS T1 JOIN TV_Channel AS T2 ON T1.Channel = T2.id WHERE T1.Directed_by = 'Ben Jones' OR T1.Directed_by = 'Michael Chang",
        "predict": "series_name, T2.Country FROM Cartoon AS T1 JOIN TV_Channel AS T2 ON T1.Channel = T2.id WHERE T1.Directed_by = 'Ben Jones' OR T1.Directed_by = 'Michael Chang'"
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
        "question": "find the id of tv channels that do not play any cartoon directed by Ben Jones.",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 49,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of all TV channels; 2. what are the ids of TV channels that play cartoons directed by Ben Jones.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['TV_Channel']. To complete the second subproblem, we need to use tables ['TV_Channel', 'Cartoon'].\n\n<3> Operation: Use 'where' to filter using column 'Directed_by' in table 'Cartoon'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT id FROM TV_Channel EXCEPT SELECT T1.id FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Directed_by = 'Ben Jones'"
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
        "question": "What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 50,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: Firstly, we need to find the TV channels that do not have any cartoons directed by Ben Jones. Secondly, we need to retrieve the ids of those TV channels.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select id from table 'TV_Channel' where there are no corresponding entries in table 'Cartoon' directed by Ben Jones. \n\n<3> SQL Generation: Use 'where' and 'not exists' to find the TV channels that do not have any cartoons directed by Ben Jones, and then select the ids of those TV channels.\n\n",
        "predict": "SELECT id FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones')"
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')",
        "question": "find the package option of the tv channel that do not have any cartoon directed by Ben Jones.",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 51,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the package options of all TV channels; 2. what are the package options of TV channels that have cartoons directed by Ben Jones.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['TV_Channel']. To complete the second subproblem, we need to use tables ['TV_Channel', 'Cartoon'].\n\n<3> Operation: Use 'where' to filter using column 'Directed_by' in table 'Cartoon'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Package_Option FROM TV_Channel EXCEPT SELECT t1.Package_Option FROM TV_Channel AS t1 JOIN Cartoon AS t2 ON t1.id  =  t2.Channel WHERE t2.Directed_by = 'Ben Jones'"
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')",
        "question": "What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "number": 52,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the package options of all TV channels; 2. what are the package options of TV channels that are playing cartoons directed by Ben Jones.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'TV_Channel'. To complete the second subproblem, we need to use tables ['TV_Channel', 'Cartoon'].\n\n<3> Operation: Use 'where' to filter using column 'Directed_by' in table 'Cartoon'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Package_Option FROM TV_Channel EXCEPT SELECT T1.Package_Option FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id  =  T2.Channel WHERE T2.Directed_by  =  \"Ben Jones\""
    },
    {
        "db_id": "poker_player",
        "gold": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player)",
        "question": "What are the names of people who do not play poker?",
        "foreign_keys": "Foreign_keys = [poker_player.People_ID = people.People_ID]\n",
        "tables": "Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]\nTable poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]\n",
        "types": {
            "poker_player.Poker_Player_ID": "number",
            "poker_player.People_ID": "number",
            "poker_player.Final_Table_Made": "number",
            "poker_player.Best_Finish": "number",
            "poker_player.Money_Rank": "number",
            "poker_player.Earnings": "number",
            "people.People_ID": "number",
            "people.Nationality": "text",
            "people.Name": "text",
            "people.Birth_Date": "text",
            "people.Height": "number"
        },
        "number": 53,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all people; 2. what are the names of people who play poker.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['people']. To complete the second subproblem, we need to use tables ['people', 'poker_player'].\n\n<3> Operation: Use 'where' to filter using column 'People_ID' in table 'poker_player'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Name FROM people EXCEPT SELECT t1.Name FROM people AS t1 JOIN poker_player AS t2 ON t1.People_ID = t2.People_ID"
    },
    {
        "db_id": "voter_1",
        "gold": "SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Tabatha Gehling' INTERSECT SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Kelly Clauss'",
        "question": "List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'.",
        "foreign_keys": "Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]\n",
        "tables": "Table AREA_CODE_STATE, columns = [*,area_code,state]\nTable CONTESTANTS, columns = [*,contestant_number,contestant_name]\nTable VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]\n",
        "types": {
            "AREA_CODE_STATE.area_code": "number",
            "AREA_CODE_STATE.state": "text",
            "CONTESTANTS.contestant_number": "number",
            "CONTESTANTS.contestant_name": "text",
            "VOTES.vote_id": "number",
            "VOTES.phone_number": "number",
            "VOTES.state": "text",
            "VOTES.contestant_number": "number",
            "VOTES.created": "time"
        },
        "number": 54,
        "hardness": "extra",
        "reasoning": "<1> Operation: The query requires listing the area codes in which voters voted for both the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'. To achieve this, we need to identify the area codes where both contestants received votes. We should apply the 'group by' operation to the 'state' column in the 'AREA_CODE_STATE' table and filter the results based on the contestants 'Tabatha Gehling' and 'Kelly Clauss'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['AREA_CODE_STATE', 'CONTESTANTS', 'VOTES'].\n\n<3> SQL Generation: The query requires listing the area codes in which voters voted for both the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss', so we should select the 'area_code' column in the 'AREA_CODE_STATE' table.\n\n",
        "predict": "\nSELECT area_code \nFROM AREA_CODE_STATE \nWHERE state IN (\n    SELECT state \n    FROM VOTES \n    JOIN CONTESTANTS ON VOTES.contestant_number = CONTESTANTS.contestant_number \n    WHERE contestant_name = 'Tabatha Gehling' \n    INTERSECT \n    SELECT state \n    FROM VOTES \n    JOIN CONTESTANTS ON VOTES.contestant_number = CONTESTANTS.contestant_number \n    WHERE contestant_name = 'Kelly Clauss'\n)"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\")",
        "question": "How many countries speak both English and Dutch?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 55,
        "hardness": "easy",
        "reasoning": "<1> Operation: The query requires finding the number of countries that speak both English and Dutch. To achieve this, we need to filter the 'countrylanguage' table for countries where both English and Dutch are spoken. We can achieve this by applying the 'group by' operation on the 'CountryCode' column and counting the occurrences where both English and Dutch are spoken.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use the 'countrylanguage' table twice, once for English and once for Dutch.\n\n<3> SQL Generation: The query requires finding the number of countries that speak both English and Dutch. We should select the 'CountryCode' column from the 'countrylanguage' table, filter for rows where the language is English or Dutch, group by 'CountryCode', and count the occurrences.\n\nSQL query:\nSELECT COUNT(*) \nFROM (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language IN ('English', 'Dutch') \n    GROUP BY CountryCode \n    HAVING COUNT(DISTINCT Language) = 2\n) AS T",
        "predict": "ion: The query requires finding the number of countries that speak both English and Dutch. To achieve this, we need to filter the 'countrylanguage' table for countries where both English and Dutch are spoken. We can achieve this by applying the 'group by' operation on the 'CountryCode' column and counting the occurrences where both English and Dutch are spoken.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use the 'countrylanguage' table twice, once for English and once for Dutch.\n\n<3> SQL Generation: The query requires finding the number of countries that speak both English and Dutch. We should select the 'CountryCode' column from the 'countrylanguage' table, filter for rows where the language is English or Dutch, group by 'CountryCode', and count the occurrences.\n\nSQL query:\nSELECT COUNT(*) \nFROM (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language IN ('English', 'Dutch') \n    GROUP BY CountryCode \n    HAVING COUNT(DISTINCT Language) = 2\n) AS T1"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\")",
        "question": "What is the number of nations that use English and Dutch?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 56,
        "hardness": "easy",
        "reasoning": "<1> Operation: The query requires the number of nations that use English and Dutch, so we should filter the 'Language' column in the 'countrylanguage' table for both 'English' and 'Dutch' languages. Since we are looking for nations that use both languages, we should apply the 'group by' operation to the 'CountryCode' column in the 'countrylanguage' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['countrylanguage'].\n\n<3> SQL Generation: The query requires the number of nations that use English and Dutch, so we should count the distinct 'CountryCode' values in the 'countrylanguage' table where the 'Language' is either 'English' or 'Dutch'.\n\n",
        "predict": "SELECT COUNT(DISTINCT CountryCode) FROM countrylanguage WHERE Language IN ('English', 'Dutch') GROUP BY CountryCode HAVING COUNT(DISTINCT Language) = 2"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\"",
        "question": "What are the names of nations speak both English and French?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 57,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of nations that speak English; 2. what are the names of nations that speak French.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"French\""
    },
    {
        "db_id": "world_1",
        "gold": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\"",
        "question": "Give the names of nations that speak both English and French.",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 58,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of nations that speak English; 2. what are the names of nations that speak French.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"French\""
    },
    {
        "db_id": "world_1",
        "gold": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
        "question": "What are the names of nations where both English and French are official languages?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 59,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of nations where English is an official language; 2. what are the names of nations where French is an official language.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' and 'IsOfficial' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"English\" AND T2.IsOfficial = \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = \"French\" AND T2.IsOfficial = \"T\""
    },
    {
        "db_id": "world_1",
        "gold": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"",
        "question": "What are the regions that use English or Dutch?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 60,
        "hardness": "hard",
        "reasoning": "<1> Operation: The query requires identifying the regions that use English or Dutch, so we should filter the regions based on the languages spoken in those regions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['country', 'countrylanguage'] to link the countries with the languages spoken in those countries.\n\n<3> SQL Generation: The query requires identifying the regions that use English or Dutch, so we should select the 'Region' column in the 'country' table based on the languages 'English' and 'Dutch' in the 'countrylanguage' table.\n\n",
        "predict": "SELECT DISTINCT Region FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language IN ('English', 'Dutch'))"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"",
        "question": "Which regions speak Dutch or English?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 61,
        "hardness": "hard",
        "reasoning": "<1> Operation: The query requires the regions where Dutch or English is spoken, so we should filter the 'Language' column in the 'countrylanguage' table for 'Dutch' or 'English'. Since we are interested in regions, we should consider the 'Region' column in the 'country' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: The query requires the regions where Dutch or English is spoken, so we should select the 'Region' column in the 'country' table. We also need to join the 'country' table with the 'countrylanguage' table on the 'CountryCode' column.\n\n",
        "predict": "SELECT DISTINCT c.Region FROM country AS c JOIN countrylanguage AS cl ON c.Code = cl.CountryCode WHERE cl.Language = 'Dutch' OR cl.Language = 'English'"
    },
    {
        "db_id": "world_1",
        "gold": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  \"english\" and isofficial  =  \"t\" union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  \"dutch\" and isofficial  =  \"t\"",
        "question": "What are the countries where either English or Dutch is the official language ?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 62,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the countries where English is the official language; 2. what are the countries where Dutch is the official language.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: For both subproblems, we need to filter using the column 'Language' and 'IsOfficial' in the 'countrylanguage' table.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T') UNION SELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'Dutch' AND IsOfficial = 'T')"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND IsOfficial  =  \"T\" UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"Dutch\" AND IsOfficial  =  \"T\"",
        "question": "Which countries have either English or Dutch as an official language?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 63,
        "hardness": "extra",
        "reasoning": "<1> Decomposition: In this step, we need to find countries that have either English or Dutch as an official language. This can be decomposed into two subproblems: 1. Find countries where English is an official language; 2. Find countries where Dutch is an official language.\n\n<2> Schema Linking: Based on the decomposition, we need to use tables ['country', 'countrylanguage'] to find the countries with English or Dutch as official languages.\n\n<3> Operation: We need to filter the rows where the language is either English or Dutch and is marked as official in the 'IsOfficial' column.\n\n<4> SQL Generation: Use 'union' operation to combine the queries for both subproblems to get the final result.\n\n",
        "predict": "\nSELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T')\nUNION\nSELECT Name FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'Dutch' AND IsOfficial = 'T')"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 64,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: Firstly, we need to filter countries based on not speaking English and having a government form other than Republic. Secondly, we need to select the country codes for the filtered countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need information about countries, we should consider tables ['country', 'countrylanguage'].\n\n<3> SQL Generation: Use 'where' to filter countries based on not speaking English and having a government form other than Republic, and then select the country codes for the filtered countries.\n\n",
        "predict": "\nSELECT c.Code \nFROM country AS c \nJOIN countrylanguage AS cl ON c.Code = cl.CountryCode \nWHERE cl.Language != 'English' AND c.GovernmentForm != 'Republic'"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT Code FROM country WHERE GovernmentForm != \"Republic\" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "question": "Return the codes of countries that do not speak English and do not have Republics for governments.",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "number": 65,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: The query requires filtering on countries that do not speak English and do not have Republics for governments. Firstly, we need to identify the countries that do not speak English. Secondly, we need to identify the countries that do not have Republics for governments. Finally, we need to select the codes of the countries that satisfy both conditions.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to consider information from the 'country' and 'countrylanguage' tables.\n\n<3> SQL Generation: Use 'where' to filter countries that do not speak English and do not have Republics for governments, and then select the codes of those countries.\n\n",
        "predict": "\nSELECT Code \nFROM country \nWHERE Code NOT IN \n    (SELECT CountryCode \n     FROM countrylanguage \n     WHERE Language = 'English') \nAND GovernmentForm != 'Republic'"
    },
    {
        "db_id": "orchestra",
        "gold": "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)",
        "question": "What are the orchestras that do not have any performances?",
        "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n",
        "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n",
        "types": {
            "conductor.Conductor_ID": "number",
            "conductor.Name": "text",
            "conductor.Age": "number",
            "conductor.Nationality": "text",
            "conductor.Year_of_Work": "number",
            "orchestra.Orchestra_ID": "number",
            "orchestra.Orchestra": "text",
            "orchestra.Conductor_ID": "number",
            "orchestra.Record_Company": "text",
            "orchestra.Year_of_Founded": "number",
            "orchestra.Major_Record_Format": "text",
            "performance.Performance_ID": "number",
            "performance.Orchestra_ID": "number",
            "performance.Type": "text",
            "performance.Date": "text",
            "performance.Official_ratings_(millions)": "number",
            "performance.Weekly_rank": "text",
            "performance.Share": "text",
            "show.Show_ID": "number",
            "show.Performance_ID": "number",
            "show.If_first_show": "others",
            "show.Result": "text",
            "show.Attendance": "number"
        },
        "number": 66,
        "hardness": "hard",
        "reasoning": "SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance",
        "predict": "hestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance)"
    },
    {
        "db_id": "orchestra",
        "gold": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
        "question": "Show the record companies shared by orchestras founded before 2003 and after 2003.",
        "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n",
        "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n",
        "types": {
            "conductor.Conductor_ID": "number",
            "conductor.Name": "text",
            "conductor.Age": "number",
            "conductor.Nationality": "text",
            "conductor.Year_of_Work": "number",
            "orchestra.Orchestra_ID": "number",
            "orchestra.Orchestra": "text",
            "orchestra.Conductor_ID": "number",
            "orchestra.Record_Company": "text",
            "orchestra.Year_of_Founded": "number",
            "orchestra.Major_Record_Format": "text",
            "performance.Performance_ID": "number",
            "performance.Orchestra_ID": "number",
            "performance.Type": "text",
            "performance.Date": "text",
            "performance.Official_ratings_(millions)": "number",
            "performance.Weekly_rank": "text",
            "performance.Share": "text",
            "show.Show_ID": "number",
            "show.Performance_ID": "number",
            "show.If_first_show": "others",
            "show.Result": "text",
            "show.Attendance": "number"
        },
        "number": 67,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: The query requires finding the record companies shared by orchestras founded before and after 2003. We can decompose this into two subproblems: 1. record companies of orchestras founded before 2003; 2. record companies of orchestras founded after 2003.\n\n<2> Schema Linking: We need to use the tables 'orchestra' and 'performance' to find the record companies associated with orchestras. \n\n<3> Operation: We will use the 'where' clause to filter orchestras based on their year of founding.\n\n<4> SQL Generation: We will use the 'intersect' operation to combine the results of the two subproblems.\n\n",
        "predict": "\nSELECT Record_Company \nFROM orchestra \nWHERE Year_of_Founded < 2003 \nINTERSECT \nSELECT Record_Company \nFROM orchestra \nWHERE Year_of_Founded > 2003"
    },
    {
        "db_id": "orchestra",
        "gold": "SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003",
        "question": "What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?",
        "foreign_keys": "Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]\n",
        "tables": "Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]\nTable orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]\nTable performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]\nTable show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]\n",
        "types": {
            "conductor.Conductor_ID": "number",
            "conductor.Name": "text",
            "conductor.Age": "number",
            "conductor.Nationality": "text",
            "conductor.Year_of_Work": "number",
            "orchestra.Orchestra_ID": "number",
            "orchestra.Orchestra": "text",
            "orchestra.Conductor_ID": "number",
            "orchestra.Record_Company": "text",
            "orchestra.Year_of_Founded": "number",
            "orchestra.Major_Record_Format": "text",
            "performance.Performance_ID": "number",
            "performance.Orchestra_ID": "number",
            "performance.Type": "text",
            "performance.Date": "text",
            "performance.Official_ratings_(millions)": "number",
            "performance.Weekly_rank": "text",
            "performance.Share": "text",
            "show.Show_ID": "number",
            "show.Performance_ID": "number",
            "show.If_first_show": "others",
            "show.Result": "text",
            "show.Attendance": "number"
        },
        "number": 68,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we need to decompose the query into two subproblems: 1. record companies used by orchestras founded before 2003; 2. record companies used by orchestras founded after 2003.\n\n<2> Schema Linking: We will use tables ['orchestra', 'performance', 'show'] to find the record companies used by orchestras founded before and after 2003.\n\n<3> Operation: Use 'where' to filter orchestras based on the year of founding.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT DISTINCT Record_Company FROM orchestra AS o1 JOIN show AS s1 ON o1.Orchestra_ID = s1.Orchestra_ID JOIN performance AS p1 ON o1.Orchestra_ID = p1.Orchestra_ID WHERE o1.Year_of_Founded < 2003 INTERSECT SELECT DISTINCT Record_Company FROM orchestra AS o2 JOIN show AS s2 ON o2.Orchestra_ID = s2.Orchestra_ID JOIN performance AS p2 ON o2.Orchestra_ID = p2.Orchestra_ID WHERE o2.Year_of_Founded > 2003"
    },
    {
        "db_id": "network_1",
        "gold": "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend",
        "question": "Show ids of all students who do not have any friends.",
        "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n",
        "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n",
        "types": {
            "Highschooler.ID": "number",
            "Highschooler.name": "text",
            "Highschooler.grade": "number",
            "Friend.student_id": "number",
            "Friend.friend_id": "number",
            "Likes.student_id": "number",
            "Likes.liked_id": "number"
        },
        "number": 69,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of all students; 2. what are the ids of students who have friends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Highschooler'. To complete the second subproblem, we need to use tables ['Highschooler', 'Friend'].\n\n<3> Operation: Use 'where' to filter using column 'friend_id' in table 'Friend'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT ID FROM Highschooler EXCEPT SELECT t1.ID FROM Highschooler AS t1 JOIN Friend AS t2 ON t1.ID  =  t2.friend_id"
    },
    {
        "db_id": "network_1",
        "gold": "SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend",
        "question": "What are the ids of high school students who do not have friends?",
        "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n",
        "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n",
        "types": {
            "Highschooler.ID": "number",
            "Highschooler.name": "text",
            "Highschooler.grade": "number",
            "Friend.student_id": "number",
            "Friend.friend_id": "number",
            "Likes.student_id": "number",
            "Likes.liked_id": "number"
        },
        "number": 70,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the ids of all high school students; 2. what are the ids of high school students who have friends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table 'Highschooler'. To complete the second subproblem, we need to use tables ['Highschooler', 'Friend'].\n\n<3> Operation: Use 'where' to filter using column 'friend_id' in table 'Friend'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT ID FROM Highschooler EXCEPT SELECT t1.ID FROM Highschooler AS t1 JOIN Friend AS t2 ON t1.ID = t2.friend_id"
    },
    {
        "db_id": "network_1",
        "gold": "SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id",
        "question": "Show names of all high school students who do not have any friends.",
        "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n",
        "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n",
        "types": {
            "Highschooler.ID": "number",
            "Highschooler.name": "text",
            "Highschooler.grade": "number",
            "Friend.student_id": "number",
            "Friend.friend_id": "number",
            "Likes.student_id": "number",
            "Likes.liked_id": "number"
        },
        "number": 71,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of all high school students; 2. what are the names of high school students who have friends.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Highschooler']. To complete the second subproblem, we need to use tables ['Highschooler', 'Friend'].\n\n<3> Operation: Use 'where' to filter using column 'student_id' in table 'Friend'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT name FROM Highschooler EXCEPT SELECT T1.name FROM Highschooler AS T1 JOIN Friend AS T2 ON T1.ID = T2.student_id"
    },
    {
        "db_id": "network_1",
        "gold": "SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id",
        "question": "What are the names of students who have no friends?",
        "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n",
        "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n",
        "types": {
            "Highschooler.ID": "number",
            "Highschooler.name": "text",
            "Highschooler.grade": "number",
            "Friend.student_id": "number",
            "Friend.friend_id": "number",
            "Likes.student_id": "number",
            "Likes.liked_id": "number"
        },
        "number": 72,
        "hardness": "hard",
        "reasoning": "SELECT name FROM Highschooler WHERE ID NOT IN (SELECT DISTINCT student_id FROM Friend",
        "predict": "e FROM Highschooler WHERE ID NOT IN (SELECT DISTINCT student_id FROM Friend)"
    },
    {
        "db_id": "network_1",
        "gold": "SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes",
        "question": "Show the ids of high schoolers who have friends and are also liked by someone else.",
        "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n",
        "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n",
        "types": {
            "Highschooler.ID": "number",
            "Highschooler.name": "text",
            "Highschooler.grade": "number",
            "Friend.student_id": "number",
            "Friend.friend_id": "number",
            "Likes.student_id": "number",
            "Likes.liked_id": "number"
        },
        "number": 73,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: Firstly, we need to find the high schoolers who have friends. Secondly, we need to find the high schoolers who are liked by someone else. Finally, we need to find the intersection of these two sets to get the high schoolers who have friends and are also liked by someone else.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select student_id from table 'Friend' to find high schoolers who have friends. In the second step, we need to select student_id from table 'Likes' to find high schoolers who are liked by someone else.\n\n<3> SQL Generation: Use 'where' to find the student_ids of high schoolers who have friends and are also liked by someone else. Then, select their IDs.\n\n",
        "predict": "SELECT DISTINCT H1.ID FROM Highschooler AS H1 WHERE H1.ID IN (SELECT F1.student_id FROM Friend AS F1) AND H1.ID IN (SELECT L1.student_id FROM Likes AS L1)"
    },
    {
        "db_id": "network_1",
        "gold": "SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes",
        "question": "What are the ids of students who both have friends and are liked?",
        "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n",
        "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n",
        "types": {
            "Highschooler.ID": "number",
            "Highschooler.name": "text",
            "Highschooler.grade": "number",
            "Friend.student_id": "number",
            "Friend.friend_id": "number",
            "Likes.student_id": "number",
            "Likes.liked_id": "number"
        },
        "number": 74,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the ids of students who have friends; 2. what are the ids of students who are liked.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Friend', 'Highschooler']. To complete the second subproblem, we also need to use tables ['Likes', 'Highschooler'].\n\n<3> Operation: Use 'where' to filter using columns 'friend_id' and 'liked_id' in tables 'Friend' and 'Likes'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.ID FROM Highschooler AS T1 JOIN Friend AS T2 ON T1.ID = T2.student_id INTERSECT SELECT T1.ID FROM Highschooler AS T1 JOIN Likes AS T2 ON T1.ID = T2.student_id"
    },
    {
        "db_id": "network_1",
        "gold": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id",
        "question": "Show name of all students who have some friends and also are liked by someone else.",
        "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n",
        "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n",
        "types": {
            "Highschooler.ID": "number",
            "Highschooler.name": "text",
            "Highschooler.grade": "number",
            "Friend.student_id": "number",
            "Friend.friend_id": "number",
            "Likes.student_id": "number",
            "Likes.liked_id": "number"
        },
        "number": 75,
        "hardness": "hard",
        "reasoning": "<1> Operation: The query requires the names of students who have friends and are liked by someone else. We need to find the student IDs who have friends and are liked by someone else.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['Friend', 'Likes', 'Highschooler'].\n\n<3> SQL Generation: We need to select the names of students who have friends and are liked by someone else. We can achieve this by joining the 'Friend' table with the 'Likes' table on the 'student_id' column and 'liked_id' column, and then joining the result with the 'Highschooler' table to get the names of the students.\n\n",
        "predict": "SELECT DISTINCT H1.name FROM Highschooler AS H1 JOIN Friend AS F ON H1.ID = F.student_id JOIN Likes AS L ON H1.ID = L.student_id"
    },
    {
        "db_id": "network_1",
        "gold": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id",
        "question": "What are the names of high schoolers who both have friends and are liked?",
        "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n",
        "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n",
        "types": {
            "Highschooler.ID": "number",
            "Highschooler.name": "text",
            "Highschooler.grade": "number",
            "Friend.student_id": "number",
            "Friend.friend_id": "number",
            "Likes.student_id": "number",
            "Likes.liked_id": "number"
        },
        "number": 76,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of high schoolers who have friends; 2. what are the names of high schoolers who are liked.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Highschooler', 'Friend']. To complete the second subproblem, we also need to use tables ['Highschooler', 'Likes'].\n\n<3> Operation: Use 'where' to filter using columns 'student_id' and 'friend_id' in table 'Friend', and columns 'student_id' and 'liked_id' in table 'Likes'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.name FROM Highschooler AS T1 JOIN Friend AS T2 ON T1.ID  =  T2.student_id INTERSECT SELECT T1.name FROM Highschooler AS T1 JOIN Likes AS T2 ON T1.ID  =  T2.student_id"
    },
    {
        "db_id": "dog_kennels",
        "gold": "SELECT state FROM Owners INTERSECT SELECT state FROM Professionals",
        "question": "Which states have both owners and professionals living there?",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 77,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. which states have owners living there; 2. which states have professionals living there.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Owners']. To complete the second subproblem, we need to use tables ['Professionals'].\n\n<3> Operation: Use 'distinct' to get unique states from the 'state' column in the respective tables.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT state FROM Owners INTERSECT SELECT state FROM Professionals"
    },
    {
        "db_id": "dog_kennels",
        "gold": "SELECT state FROM Owners INTERSECT SELECT state FROM Professionals",
        "question": "Find the states where both owners and professionals live.",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 78,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the states where owners live; 2. what are the states where professionals live.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['Owners', 'Professionals'].\n\n<3> Operation: Use 'group by' to group the states based on the 'state' column in both 'Owners' and 'Professionals' tables.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT state FROM Owners GROUP BY state INTERSECT SELECT state FROM Professionals GROUP BY state"
    },
    {
        "db_id": "dog_kennels",
        "gold": "SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2",
        "question": "Which professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 79,
        "hardness": "extra",
        "reasoning": "<1> Operation: The query requires professionals who either live in the state of Indiana or have done treatment on more than 2 treatments. We need to apply the 'count' operation to the 'professional_id' column in the 'Treatments' table and filter by the count being greater than 2. We also need to filter by the state of Indiana in the 'state' column of the 'Professionals' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. We need to use tables ['Professionals', 'Treatments'].\n\n<3> SQL Generation: The query requires the professional id, last name, and cell phone of the professionals who meet the criteria. We should select the 'professional_id', 'last_name', and 'cell_number' columns in the 'Professionals' table.\n\n",
        "predict": "SELECT professional_id, last_name, cell_number FROM Professionals WHERE state = 'Indiana' OR professional_id IN (SELECT professional_id FROM Treatments GROUP BY professional_id HAVING COUNT(*) > 2)"
    },
    {
        "db_id": "dog_kennels",
        "gold": "SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2",
        "question": "Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed more than two treatments.",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 80,
        "hardness": "extra",
        "reasoning": "<1> Decomposition: We need to filter professionals based on two conditions - either they live in the state of Indiana or have performed more than two treatments. Then, we need to retrieve their id, last name, and cell phone.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select professional_id, last_name, and cell_number from table 'Professionals' and filter by the state of residence and the number of treatments performed.\n\n<3> SQL Generation: Use 'where' to filter professionals who live in Indiana or have performed more than two treatments, and then select their id, last name, and cell phone.\n\n",
        "predict": "SELECT professional_id, last_name, cell_number FROM Professionals WHERE state = 'Indiana' OR professional_id IN (SELECT professional_id FROM Treatments GROUP BY professional_id HAVING COUNT(*) > 2)"
    },
    {
        "db_id": "dog_kennels",
        "gold": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )",
        "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 81,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the dogs that have not cost their owner more than 1000 for treatment. Secondly, we need to list the names of these dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for dogs and their treatments, we need to select the 'dog_id' from the 'Treatments' table. Then, we need to select the 'name' of these dogs from the 'Dogs' table.\n\n<3> SQL Generation: Use 'where' to filter the treatments that cost less than or equal to 1000, and then use 'where' to find the dogs that have not cost their owner more than 1000 for treatment and list their names.\n\n",
        "predict": "SELECT D.name FROM Dogs AS D JOIN Treatments AS T ON D.dog_id = T.dog_id WHERE T.cost_of_treatment <= 1000"
    },
    {
        "db_id": "dog_kennels",
        "gold": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )",
        "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 82,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the names of the dogs; 2. for which the owner has not spent more than 1000 for treatment.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Dogs']. To complete the second subproblem, we need to use tables ['Dogs', 'Treatments'].\n\n<3> Operation: For the second subproblem, we need to perform a 'GROUP BY' operation on the column 'dog_id' in table 'Treatments' and filter by performing 'HAVING SUM()' on the column 'cost_of_treatment'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT name FROM Dogs EXCEPT SELECT T1.name FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id = T2.dog_id GROUP BY T2.dog_id HAVING SUM(cost_of_treatment) > 1000"
    },
    {
        "db_id": "dog_kennels",
        "gold": "SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs",
        "question": "Which first names are used for professionals or owners but are not used as dog names?",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 83,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the first names used for professionals or owners; 2. what are the first names used as dog names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Owners', 'Professionals']. To complete the second subproblem, we need to use tables ['Dogs'].\n\n<3> Operation: Use 'select' to retrieve the first names from the respective tables.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT first_name FROM Owners UNION SELECT first_name FROM Professionals EXCEPT SELECT name FROM Dogs"
    },
    {
        "db_id": "dog_kennels",
        "gold": "SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs",
        "question": "Find the first names that are used for professionals or owners but are not used as dog names.",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 84,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what are the first names used for professionals or owners; 2. what are the first names used as dog names.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Owners', 'Professionals']. To complete the second subproblem, we need to use tables ['Dogs'].\n\n<3> Operation: Use 'union' operation to combine the queries of subproblems and then use 'except' operation to find the difference set.\n\n<4> SQL Generation: Use 'union' operation to combine the queries of subproblems and then use 'except' operation to find the difference set.\n\n",
        "predict": "\n(SELECT first_name FROM Owners)\nUNION\n(SELECT first_name FROM Professionals)\nEXCEPT\n(SELECT name FROM Dogs)"
    },
    {
        "db_id": "dog_kennels",
        "gold": "SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",
        "question": "Which professional did not operate any treatment on dogs? List the professional's id, role and email.",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 85,
        "hardness": "extra",
        "reasoning": "SELECT professional_id, role_code, email_address FROM Professionals WHERE professional_id NOT IN (SELECT professional_id FROM Treatments",
        "predict": "fessional_id, role_code, email_address FROM Professionals WHERE professional_id NOT IN (SELECT professional_id FROM Treatments)"
    },
    {
        "db_id": "dog_kennels",
        "gold": "SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",
        "question": "Give me the id, role and email of the professionals who did not perform any treatment on dogs.",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 86,
        "hardness": "extra",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes difference set logic, so we can decompose the question into two subproblems: 1. what is the id, role, and email of all professionals; 2. what is the id, role, and email of professionals who have performed treatments on dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use table ['Professionals']. To complete the second subproblem, we need to use tables ['Professionals', 'Treatments'].\n\n<3> Operation: Use 'where' to filter using column 'professional_id' in table 'Treatments'.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT professional_id, role_code, email_address FROM professionals EXCEPT SELECT T1.professional_id, T1.role_code, T1.email_address FROM professionals AS T1 JOIN treatments AS T2 ON T1.professional_id = T2.professional_id"
    },
    {
        "db_id": "dog_kennels",
        "gold": "SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin'",
        "question": "List the emails of the professionals who live in the state of Hawaii or the state of Wisconsin.",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 87,
        "hardness": "medium",
        "reasoning": "<1> Decomposition: Firstly, we need to identify the emails of the professionals who live in the state of Hawaii. Secondly, we need to identify the emails of the professionals who live in the state of Wisconsin. Finally, we need to combine the results of these two queries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the 'email_address' column from the 'Professionals' table and filter based on the 'state' column from the 'Professionals' table.\n\n<3> SQL Generation: Use 'where' to filter the emails of the professionals who live in the state of Hawaii and the state of Wisconsin, and then use 'union' to combine the results.\n\n",
        "predict": "\nSELECT email_address FROM professionals WHERE state = \"Hawaii\"\nUNION\nSELECT email_address FROM professionals WHERE state = \"Wisconsin\""
    },
    {
        "db_id": "dog_kennels",
        "gold": "SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin'",
        "question": "What are the emails of the professionals living in either the state of Hawaii or the state of Wisconsin?",
        "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n",
        "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n",
        "types": {
            "Breeds.breed_code": "text",
            "Breeds.breed_name": "text",
            "Charges.charge_id": "number",
            "Charges.charge_type": "text",
            "Charges.charge_amount": "number",
            "Sizes.size_code": "text",
            "Sizes.size_description": "text",
            "Treatment_Types.treatment_type_code": "text",
            "Treatment_Types.treatment_type_description": "text",
            "Owners.owner_id": "number",
            "Owners.first_name": "text",
            "Owners.last_name": "text",
            "Owners.street": "text",
            "Owners.city": "text",
            "Owners.state": "text",
            "Owners.zip_code": "text",
            "Owners.email_address": "text",
            "Owners.home_phone": "text",
            "Owners.cell_number": "text",
            "Dogs.dog_id": "number",
            "Dogs.owner_id": "number",
            "Dogs.abandoned_yn": "text",
            "Dogs.breed_code": "text",
            "Dogs.size_code": "text",
            "Dogs.name": "text",
            "Dogs.age": "text",
            "Dogs.date_of_birth": "time",
            "Dogs.gender": "text",
            "Dogs.weight": "text",
            "Dogs.date_arrived": "time",
            "Dogs.date_adopted": "time",
            "Dogs.date_departed": "time",
            "Professionals.professional_id": "number",
            "Professionals.role_code": "text",
            "Professionals.first_name": "text",
            "Professionals.street": "text",
            "Professionals.city": "text",
            "Professionals.state": "text",
            "Professionals.zip_code": "text",
            "Professionals.last_name": "text",
            "Professionals.email_address": "text",
            "Professionals.home_phone": "text",
            "Professionals.cell_number": "text",
            "Treatments.treatment_id": "number",
            "Treatments.dog_id": "number",
            "Treatments.professional_id": "number",
            "Treatments.treatment_type_code": "text",
            "Treatments.date_of_treatment": "time",
            "Treatments.cost_of_treatment": "number"
        },
        "number": 88,
        "hardness": "medium",
        "reasoning": "<1> Operation: The query requires filtering the emails of professionals based on the states they live in, so we should filter the 'state' column in the 'Professionals' table to include only the states of Hawaii and Wisconsin.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. In this question, we only need to use table 'Professionals'.\n\n<3> SQL Generation: The query requires the emails of professionals living in either the state of Hawaii or the state of Wisconsin, so we should select the 'email_address' column in the 'Professionals' table and filter based on the 'state' column.\n\n",
        "predict": "SELECT email_address FROM Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin'"
    },
    {
        "db_id": "singer",
        "gold": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)",
        "question": "List the name of singers that do not have any song.",
        "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n",
        "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n",
        "types": {
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Birth_Year": "number",
            "singer.Net_Worth_Millions": "number",
            "singer.Citizenship": "text",
            "song.Song_ID": "number",
            "song.Title": "text",
            "song.Singer_ID": "number",
            "song.Sales": "number",
            "song.Highest_Position": "number"
        },
        "number": 89,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: The query requires finding singers that do not have any songs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We only need the 'singer' table for this query.\n\n<3> SQL Generation: Use 'where' to filter singers that do not have any songs.\n\n",
        "predict": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)"
    },
    {
        "db_id": "singer",
        "gold": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)",
        "question": "What is the sname of every sing that does not have any song?",
        "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n",
        "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n",
        "types": {
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Birth_Year": "number",
            "singer.Net_Worth_Millions": "number",
            "singer.Citizenship": "text",
            "song.Song_ID": "number",
            "song.Title": "text",
            "song.Singer_ID": "number",
            "song.Sales": "number",
            "song.Highest_Position": "number"
        },
        "number": 90,
        "hardness": "hard",
        "reasoning": "<1> Decomposition: Firstly, we need to find the singers that do not have any songs. Secondly, we need to retrieve the names of those singers.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Singer_ID from table 'singer' where there are no corresponding entries in table 'song'. Then, we need to retrieve the names of those singers from table 'singer'.\n\n<3> SQL Generation: Use 'where' and 'not exists' to find the singers that do not have any songs, and then select the names of those singers.\n\n",
        "predict": "SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song)"
    },
    {
        "db_id": "singer",
        "gold": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955",
        "question": "Show the citizenship shared by singers with birth year before 1945 and after 1955.",
        "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n",
        "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n",
        "types": {
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Birth_Year": "number",
            "singer.Net_Worth_Millions": "number",
            "singer.Citizenship": "text",
            "song.Song_ID": "number",
            "song.Title": "text",
            "song.Singer_ID": "number",
            "song.Sales": "number",
            "song.Highest_Position": "number"
        },
        "number": 91,
        "hardness": "hard",
        "reasoning": "SELECT Citizenship FROM singer WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year > 195",
        "predict": "izenship FROM singer WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year > 1955"
    },
    {
        "db_id": "singer",
        "gold": "SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955",
        "question": "What are the citizenships that are shared by singers with a birth year before 1945 and after 1955?",
        "foreign_keys": "Foreign_keys = [song.Singer_ID = singer.Singer_ID]\n",
        "tables": "Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]\nTable song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]\n",
        "types": {
            "singer.Singer_ID": "number",
            "singer.Name": "text",
            "singer.Birth_Year": "number",
            "singer.Net_Worth_Millions": "number",
            "singer.Citizenship": "text",
            "song.Song_ID": "number",
            "song.Title": "text",
            "song.Singer_ID": "number",
            "song.Sales": "number",
            "song.Highest_Position": "number"
        },
        "number": 92,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the citizenships of singers with a birth year before 1945; 2. what are the citizenships of singers with a birth year after 1955.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete both subproblems, we need to use tables ['singer'].\n\n<3> Operation: Use 'where' to filter using the 'Birth_Year' column in table 'singer'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Citizenship FROM singer WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year > 1955"
    },
    {
        "db_id": "real_estate_properties",
        "gold": "SELECT property_name FROM Properties WHERE property_type_code  =  \"House\" UNION SELECT property_name FROM Properties WHERE property_type_code  =  \"Apartment\" AND room_count  >  1",
        "question": "What are the names of properties that are either houses or apartments with more than 1 room?",
        "foreign_keys": "Foreign_keys = [Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code,Other_Property_Features.property_id = Properties.property_id,Other_Property_Features.feature_id = Other_Available_Features.feature_id]\n",
        "tables": "Table Other_Available_Features, columns = [*,feature_id,feature_type_code,feature_name,feature_description]\nTable Other_Property_Features, columns = [*,property_id,feature_id,property_feature_description]\nTable Properties, columns = [*,property_id,property_type_code,date_on_market,date_sold,property_name,property_address,room_count,vendor_requested_price,buyer_offered_price,agreed_selling_price,apt_feature_1,apt_feature_2,apt_feature_3,fld_feature_1,fld_feature_2,fld_feature_3,hse_feature_1,hse_feature_2,hse_feature_3,oth_feature_1,oth_feature_2,oth_feature_3,shp_feature_1,shp_feature_2,shp_feature_3,other_property_details]\nTable Ref_Feature_Types, columns = [*,feature_type_code,feature_type_name]\nTable Ref_Property_Types, columns = [*,property_type_code,property_type_description]\n",
        "types": {
            "Ref_Feature_Types.feature_type_code": "text",
            "Ref_Feature_Types.feature_type_name": "text",
            "Ref_Property_Types.property_type_code": "text",
            "Ref_Property_Types.property_type_description": "text",
            "Other_Available_Features.feature_id": "number",
            "Other_Available_Features.feature_type_code": "text",
            "Other_Available_Features.feature_name": "text",
            "Other_Available_Features.feature_description": "text",
            "Properties.property_id": "number",
            "Properties.property_type_code": "text",
            "Properties.date_on_market": "time",
            "Properties.date_sold": "time",
            "Properties.property_name": "text",
            "Properties.property_address": "text",
            "Properties.room_count": "number",
            "Properties.vendor_requested_price": "number",
            "Properties.buyer_offered_price": "number",
            "Properties.agreed_selling_price": "number",
            "Properties.apt_feature_1": "text",
            "Properties.apt_feature_2": "text",
            "Properties.apt_feature_3": "text",
            "Properties.fld_feature_1": "text",
            "Properties.fld_feature_2": "text",
            "Properties.fld_feature_3": "text",
            "Properties.hse_feature_1": "text",
            "Properties.hse_feature_2": "text",
            "Properties.hse_feature_3": "text",
            "Properties.oth_feature_1": "text",
            "Properties.oth_feature_2": "text",
            "Properties.oth_feature_3": "text",
            "Properties.shp_feature_1": "text",
            "Properties.shp_feature_2": "text",
            "Properties.shp_feature_3": "text",
            "Properties.other_property_details": "text",
            "Other_Property_Features.property_id": "number",
            "Other_Property_Features.feature_id": "number",
            "Other_Property_Features.property_feature_description": "text"
        },
        "number": 93,
        "hardness": "hard",
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes union logic, so we can decompose the question into two subproblems: 1. what are the names of houses with more than 1 room; 2. what are the names of apartments with more than 1 room.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Properties', 'Ref_Property_Types']. To complete the second subproblem, we need to use tables ['Properties', 'Ref_Property_Types'].\n\n<3> Operation: For both subproblems, we need to filter using the column 'room_count' in the 'Properties' table and the 'property_type_description' in the 'Ref_Property_Types' table to identify houses and apartments.\n\n<4> SQL Generation: Use 'union' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "\nSELECT property_name \nFROM Properties \nJOIN Ref_Property_Types ON Properties.property_type_code = Ref_Property_Types.property_type_code \nWHERE property_type_description = 'House' AND room_count > 1 \nUNION \nSELECT property_name \nFROM Properties \nJOIN Ref_Property_Types ON Properties.property_type_code = Ref_Property_Types.property_type_code \nWHERE property_type_description = 'Apartment' AND room_count > 1"
    },
    {
        "db_id": "car_1",
        "gold": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;",
        "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .",
        "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n",
        "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n",
        "types": {
            "continents.ContId": "number",
            "continents.Continent": "text",
            "countries.CountryId": "number",
            "countries.CountryName": "text",
            "countries.Continent": "number",
            "car_makers.Id": "number",
            "car_makers.Maker": "text",
            "car_makers.FullName": "text",
            "car_makers.Country": "text",
            "model_list.ModelId": "number",
            "model_list.Maker": "number",
            "model_list.Model": "text",
            "car_names.MakeId": "number",
            "car_names.Model": "text",
            "car_names.Make": "text",
            "cars_data.Id": "number",
            "cars_data.MPG": "text",
            "cars_data.Cylinders": "number",
            "cars_data.Edispl": "number",
            "cars_data.Horsepower": "text",
            "cars_data.Weight": "number",
            "cars_data.Accelerate": "number",
            "cars_data.Year": "number"
        },
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. which car makers produce at least 2 models; 2. which car makers have more than 3 models.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['car_makers', 'model_list']. To complete the second subproblem, we need to use tables ['car_makers', 'model_list'].\n\n<3> Operation: For both subproblems, we need to perform a 'GROUP BY' operation on the column 'Maker' and filter by performing 'HAVING COUNT()' on the respective columns ('ModelId' for the first subproblem and 'ModelId' for the second subproblem).\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.Id, T1.Maker FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker GROUP BY T1.Id HAVING COUNT(T2.ModelId) >= 2 INTERSECT SELECT T1.Id, T1.Maker FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker GROUP BY T1.Id HAVING COUNT(T2.ModelId) > 3"
    },
    {
        "db_id": "car_1",
        "gold": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;",
        "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?",
        "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n",
        "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n",
        "types": {
            "continents.ContId": "number",
            "continents.Continent": "text",
            "countries.CountryId": "number",
            "countries.CountryName": "text",
            "countries.Continent": "number",
            "car_makers.Id": "number",
            "car_makers.Maker": "text",
            "car_makers.FullName": "text",
            "car_makers.Country": "text",
            "model_list.ModelId": "number",
            "model_list.Maker": "number",
            "model_list.Model": "text",
            "car_names.MakeId": "number",
            "car_names.Model": "text",
            "car_names.Make": "text",
            "cars_data.Id": "number",
            "cars_data.MPG": "text",
            "cars_data.Cylinders": "number",
            "cars_data.Edispl": "number",
            "cars_data.Horsepower": "text",
            "cars_data.Weight": "number",
            "cars_data.Accelerate": "number",
            "cars_data.Year": "number"
        },
        "reasoning": "<1> Decomposition: We need to find car makers that produce at least 2 models and make more than 3 cars. This can be broken down into two subproblems: 1. Find car makers that produce at least 2 models; 2. Find car makers that make more than 3 cars.\n\n<2> Schema Linking: We need to use tables ['car_makers', 'model_list', 'car_names'] to find car makers that produce at least 2 models and ['car_makers', 'cars_data'] to find car makers that make more than 3 cars.\n\n<3> SQL Generation: Use 'group by' and 'having' to find car makers that produce at least 2 models and make more than 3 cars, then combine the results using 'intersect'.\n\n",
        "predict": "\n(SELECT Id, Maker FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker GROUP BY Id HAVING COUNT(DISTINCT ModelId) >= 2)\nINTERSECT\n(SELECT Id, Maker FROM car_makers JOIN car_names ON car_makers.Id = car_names.Make JOIN cars_data ON car_names.MakeId = cars_data.Id GROUP BY Id HAVING COUNT(*) > 3)"
    },
    {
        "db_id": "cre_Doc_Template_Mgt",
        "gold": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id",
        "question": "What are the codes of template types that are not used for any document?",
        "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n",
        "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n",
        "types": {
            "Ref_Template_Types.Template_Type_Code": "text",
            "Ref_Template_Types.Template_Type_Description": "text",
            "Templates.Template_ID": "number",
            "Templates.Version_Number": "number",
            "Templates.Template_Type_Code": "text",
            "Templates.Date_Effective_From": "time",
            "Templates.Date_Effective_To": "time",
            "Templates.Template_Details": "text",
            "Documents.Document_ID": "number",
            "Documents.Template_ID": "number",
            "Documents.Document_Name": "text",
            "Documents.Document_Description": "text",
            "Documents.Other_Details": "text",
            "Paragraphs.Paragraph_ID": "number",
            "Paragraphs.Document_ID": "number",
            "Paragraphs.Paragraph_Text": "text",
            "Paragraphs.Other_Details": "text"
        },
        "reasoning": "<1> Decomposition: The query can be decomposed into two subproblems: 1. What are all the template types available? 2. What are the template types that are not used for any document?\n\n<2> Schema Linking: Based on the decomposition, we need to use tables ['Ref_Template_Types', 'Templates', 'Documents'].\n\n<3> Operation: Use 'where' to filter out template types that are used for any document.\n\n<4> SQL Generation: Use 'except' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT Template_Type_Code FROM Ref_Template_Types EXCEPT SELECT T1.Template_Type_Code FROM Ref_Template_Types AS T1 JOIN Templates AS T2 ON T1.Template_Type_Code = T2.Template_Type_Code JOIN Documents AS T3 ON T2.Template_ID = T3.Template_ID"
    },
    {
        "db_id": "tvshow",
        "gold": "SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",
        "question": "Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?",
        "foreign_keys": "Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]\n",
        "tables": "Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]\nTable TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]\nTable TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]\n",
        "types": {
            "TV_Channel.id": "text",
            "TV_Channel.series_name": "text",
            "TV_Channel.Country": "text",
            "TV_Channel.Language": "text",
            "TV_Channel.Content": "text",
            "TV_Channel.Pixel_aspect_ratio_PAR": "text",
            "TV_Channel.Hight_definition_TV": "text",
            "TV_Channel.Pay_per_view_PPV": "text",
            "TV_Channel.Package_Option": "text",
            "TV_series.id": "number",
            "TV_series.Episode": "text",
            "TV_series.Air_Date": "text",
            "TV_series.Rating": "text",
            "TV_series.Share": "number",
            "TV_series.18_49_Rating_Share": "text",
            "TV_series.Viewers_m": "text",
            "TV_series.Weekly_Rank": "number",
            "TV_series.Channel": "text",
            "Cartoon.id": "number",
            "Cartoon.Title": "text",
            "Cartoon.Directed_by": "text",
            "Cartoon.Written_by": "text",
            "Cartoon.Original_air_date": "text",
            "Cartoon.Production_code": "number",
            "Cartoon.Channel": "text"
        },
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes filtering based on specific directors, so we can decompose the question into two subproblems: 1. what are the series names and countries of TV channels playing cartoons directed by Ben Jones; 2. what are the series names and countries of TV channels playing cartoons directed by Michael Chang.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['Cartoon', 'TV_Channel', 'TV_series']. To complete the second subproblem, we also need to use tables ['Cartoon', 'TV_Channel', 'TV_series'].\n\n<3> Operation: Use 'where' to filter using column 'Directed_by' in table 'Cartoon'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "\nSELECT T3.series_name, T2.Country \nFROM Cartoon AS T1 \nJOIN TV_Channel AS T2 ON T1.Channel = T2.id \nJOIN TV_series AS T3 ON T2.id = T3.Channel \nWHERE T1.Directed_by = \"Ben Jones\" \nINTERSECT \nSELECT T3.series_name, T2.Country \nFROM Cartoon AS T1 \nJOIN TV_Channel AS T2 ON T1.Channel = T2.id \nJOIN TV_series AS T3 ON T2.id = T3.Channel \nWHERE T1.Directed_by = \"Michael Chang\""
    },
    {
        "db_id": "world_1",
        "gold": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" AND T2.IsOfficial  =  \"T\" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"French\" AND T2.IsOfficial  =  \"T\"",
        "question": "Give the names of countries with English and French as official languages.",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "reasoning": "<1> Question Decomposition: In this step, we contemplate how to decompose the query. The query emphasizes intersection logic, so we can decompose the question into two subproblems: 1. what are the names of countries with English as an official language; 2. what are the names of countries with French as an official language.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the requirements of the query and the foreign key relationships. To complete the first subproblem, we need to use tables ['country', 'countrylanguage']. To complete the second subproblem, we also need to use tables ['country', 'countrylanguage'].\n\n<3> Operation: Use 'where' to filter using column 'Language' and 'IsOfficial' in table 'countrylanguage'.\n\n<4> SQL Generation: Use 'intersect' operation to connect the queries of subproblems to form the final SQL statement.\n\n",
        "predict": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "question": "What are the country codes for countries that do not speak English?",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "reasoning": "<1> Decomposition: We need to filter countries based on whether they speak English or not, and then select the country codes for the filtered countries.\n\n<2> Schema Linking: We only need information from the 'country' table for this query.\n\n<3> Operation: Use 'where' to filter countries based on the language not being English.\n\n<4> SQL Generation: Select the 'Code' column from the 'country' table where the language is not English.\n\n",
        "predict": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')"
    },
    {
        "db_id": "world_1",
        "gold": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  \"English\"",
        "question": "Return the country codes for countries that do not speak English.",
        "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n",
        "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n",
        "types": {
            "city.ID": "number",
            "city.Name": "text",
            "city.CountryCode": "text",
            "city.District": "text",
            "city.Population": "number",
            "sqlite_sequence.name": "text",
            "sqlite_sequence.seq": "text",
            "country.Code": "text",
            "country.Name": "text",
            "country.Continent": "text",
            "country.Region": "text",
            "country.SurfaceArea": "number",
            "country.IndepYear": "number",
            "country.Population": "number",
            "country.LifeExpectancy": "number",
            "country.GNP": "number",
            "country.GNPOld": "number",
            "country.LocalName": "text",
            "country.GovernmentForm": "text",
            "country.HeadOfState": "text",
            "country.Capital": "number",
            "country.Code2": "text",
            "countrylanguage.CountryCode": "text",
            "countrylanguage.Language": "text",
            "countrylanguage.IsOfficial": "text",
            "countrylanguage.Percentage": "number"
        },
        "reasoning": "<1> Decomposition: The query requires filtering on countries that do not speak English. Firstly, we need to identify the country codes for countries that do not have English as an official language.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'country' table and 'countrylanguage' table, we should consider these two tables.\n\n<3> SQL Generation: Use 'where' to filter countries based on not speaking English, and then select the country codes for those countries.\n\n",
        "predict": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')"
    }
]