[{"db_id": "pets_1", "gold": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid", "question": "Find the first name and age of students who have a pet.", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "number": 27, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to identify the students who have a pet. Secondly, we need to select the first name and age of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select StuID from table 'Has_Pet'. In the second step, we need to filter students based on their StuID and select their first name and age from table 'Student'.\n\n<3> SQL Generation: Use 'where' to filter students who have a pet, and then select their first name and age.\n\n", "predict": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid"}, {"db_id": "pets_1", "gold": "SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid", "question": "What are the different first names and ages of the students who do have pets?", "foreign_keys": "Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]\n", "tables": "Table Has_Pet, columns = [*,StuID,PetID]\nTable Pets, columns = [*,PetID,PetType,pet_age,weight]\nTable Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]\n", "types": {"Student.StuID": "number", "Student.LName": "text", "Student.Fname": "text", "Student.Age": "number", "Student.Sex": "text", "Student.Major": "number", "Student.Advisor": "number", "Student.city_code": "text", "Has_Pet.StuID": "number", "Has_Pet.PetID": "number", "Pets.PetID": "number", "Pets.PetType": "text", "Pets.pet_age": "number", "Pets.weight": "number"}, "number": 28, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to find the students who have pets. Secondly, we need to select the first names and ages of these students.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the first names and ages from the 'Student' table and filter by the students who have pets from the 'Has_Pet' table.\n\n<3> SQL Generation: Use 'where' to filter students who have pets and select their first names and ages.\n\n", "predict": "SELECT DISTINCT T1.Fname ,  T1.Age FROM Student AS T1 JOIN Has_Pet AS T2 ON T1.StuID  =  T2.StuID"}, {"db_id": "cre_Doc_Template_Mgt", "gold": "SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID", "question": "Return the different descriptions for templates that have been used in a document.", "foreign_keys": "Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]\n", "tables": "Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]\nTable Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]\nTable Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]\nTable Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]\n", "types": {"Ref_Template_Types.Template_Type_Code": "text", "Ref_Template_Types.Template_Type_Description": "text", "Templates.Template_ID": "number", "Templates.Version_Number": "number", "Templates.Template_Type_Code": "text", "Templates.Date_Effective_From": "time", "Templates.Date_Effective_To": "time", "Templates.Template_Details": "text", "Documents.Document_ID": "number", "Documents.Template_ID": "number", "Documents.Document_Name": "text", "Documents.Document_Description": "text", "Documents.Other_Details": "text", "Paragraphs.Paragraph_ID": "number", "Paragraphs.Document_ID": "number", "Paragraphs.Paragraph_Text": "text", "Paragraphs.Other_Details": "text"}, "number": 157, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to identify the templates that have been used in a document. Secondly, we need to filter the descriptions of those templates.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Template_ID from table 'Documents'. In the second step, we need to filter the descriptions from table 'Templates' and 'Ref_Template_Types'.\n\n<3> SQL Generation: Use 'where' to filter templates that have been used in a document, and then select the different descriptions from those templates.\n\n", "predict": "SELECT DISTINCT Template_Type_Description FROM Ref_Template_Types WHERE Template_Type_Code IN (SELECT Template_Type_Code FROM Templates WHERE Template_ID IN (SELECT Template_ID FROM Documents))"}, {"db_id": "dog_kennels", "gold": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "question": "Find the arriving date and the departing date of the dogs that received a treatment.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "number": 380, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to find the dogs that received a treatment. Secondly, we need to select the arriving date and the departing date of those dogs.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select dog_id from table 'Treatments'. In the second step, we need to select date_arrived and date_departed from table 'Dogs' for the selected dogs.\n\n<3> SQL Generation: Use 'where' to filter the dogs that received a treatment, and then select the arriving date and the departing date from the 'Dogs' table.\n\n", "predict": "SELECT date_arrived ,  date_departed FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)"}, {"db_id": "dog_kennels", "gold": "SELECT count(DISTINCT professional_id) FROM Treatments", "question": "How many professionals have performed any treatment to dogs?", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "number": 382, "hardness": "easy", "reasoning": "<1> Decomposition: Firstly, we need to find the professionals who have performed any treatment to dogs. Secondly, we need to count the number of professionals found in the first step.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we are looking for professionals who have performed any treatment to dogs, we only need the 'Professionals' and 'Treatments' tables.\n\n<3> SQL Generation: Use 'inner join' to combine the 'Professionals' table with the 'Treatments' table on the 'professional_id' column. Then, count the distinct 'professional_id' from the result.\n\n", "predict": "SELECT COUNT(DISTINCT professional_id) FROM Treatments"}, {"db_id": "dog_kennels", "gold": "SELECT count(DISTINCT professional_id) FROM Treatments", "question": "Find the number of professionals who have ever treated dogs.", "foreign_keys": "Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]\n", "tables": "Table Breeds, columns = [*,breed_code,breed_name]\nTable Charges, columns = [*,charge_id,charge_type,charge_amount]\nTable Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]\nTable Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]\nTable Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]\nTable Sizes, columns = [*,size_code,size_description]\nTable Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]\nTable Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]\n", "types": {"Breeds.breed_code": "text", "Breeds.breed_name": "text", "Charges.charge_id": "number", "Charges.charge_type": "text", "Charges.charge_amount": "number", "Sizes.size_code": "text", "Sizes.size_description": "text", "Treatment_Types.treatment_type_code": "text", "Treatment_Types.treatment_type_description": "text", "Owners.owner_id": "number", "Owners.first_name": "text", "Owners.last_name": "text", "Owners.street": "text", "Owners.city": "text", "Owners.state": "text", "Owners.zip_code": "text", "Owners.email_address": "text", "Owners.home_phone": "text", "Owners.cell_number": "text", "Dogs.dog_id": "number", "Dogs.owner_id": "number", "Dogs.abandoned_yn": "text", "Dogs.breed_code": "text", "Dogs.size_code": "text", "Dogs.name": "text", "Dogs.age": "text", "Dogs.date_of_birth": "time", "Dogs.gender": "text", "Dogs.weight": "text", "Dogs.date_arrived": "time", "Dogs.date_adopted": "time", "Dogs.date_departed": "time", "Professionals.professional_id": "number", "Professionals.role_code": "text", "Professionals.first_name": "text", "Professionals.street": "text", "Professionals.city": "text", "Professionals.state": "text", "Professionals.zip_code": "text", "Professionals.last_name": "text", "Professionals.email_address": "text", "Professionals.home_phone": "text", "Professionals.cell_number": "text", "Treatments.treatment_id": "number", "Treatments.dog_id": "number", "Treatments.professional_id": "number", "Treatments.treatment_type_code": "text", "Treatments.date_of_treatment": "time", "Treatments.cost_of_treatment": "number"}, "number": 383, "hardness": "easy", "reasoning": "<1> Decomposition: We need to find the professionals who have ever treated dogs and count them.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the professional_id from the 'Treatments' table.\n\n<3> SQL Generation: Use 'distinct' to find unique professionals who have treated dogs, and then use 'count' to count them.\n\n", "predict": "SELECT COUNT(DISTINCT professional_id) FROM Treatments"}]