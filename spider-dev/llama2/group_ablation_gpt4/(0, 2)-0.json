[{"db_id": "car_1", "gold": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "question": "Which countries in europe have at least 3 car manufacturers?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 30, "hardness": "extra", "reasoning": "<1> Operation: The query requires the countries in Europe that have at least 3 car manufacturers, so we should apply the 'count' operation to the 'Id' column in the 'car_makers' table, and filter for countries with a count greater than or equal to 3. Since the unit to which the car manufacturers being counted in the query belong is the country, we should apply the 'group by' operation to the 'Country' column in the 'car_makers' table. We also need to filter for countries in Europe.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to use tables ['car_makers', 'countries', 'continents'].\n\n<3> SQL Generation: The query requires the countries in Europe that have at least 3 car manufacturers, so we should select the 'CountryName' column in the 'countries' table and count the 'Id' column in the 'car_makers' table. We also need to filter for countries with a count greater than or equal to 3 and countries in Europe.\n\n", "predict": "SELECT countries.CountryName FROM car_makers JOIN countries ON car_makers.Country = countries.CountryId JOIN continents ON countries.Continent = continents.ContId WHERE continents.Continent = 'Europe' GROUP BY countries.CountryName HAVING COUNT(car_makers.Id) >= 3"}, {"db_id": "car_1", "gold": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "question": "What are the names of all European countries with at least 3 manufacturers?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 31, "hardness": "extra", "reasoning": "<1> Operation: The query requires the names of all European countries with at least 3 manufacturers, so we should apply the 'count' operation to the 'Id' column in the 'car_makers' table, and filter the count to be greater than or equal to 3. Since the unit to which the manufacturers being counted in the query belong is the country, we should apply the 'group by' operation to the 'Country' column in the 'car_makers' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'car_makers' and 'countries', and between 'countries' and 'continents', we need to use tables ['car_makers', 'countries', 'continents'].\n\n<3> SQL Generation: The query requires the names of all European countries with at least 3 manufacturers, so we should select the 'CountryName' column in the 'countries' table. We also need to filter the result to only include countries with a count greater than or equal to 3 and countries that are in Europe.\n\n", "predict": "SELECT T2.CountryName FROM car_makers AS T1 JOIN countries AS T2 ON T1.Country = T2.CountryId JOIN continents AS T3 ON T2.Continent = T3.ContId WHERE T3.Continent = 'Europe' GROUP BY T2.CountryName HAVING COUNT(T1.Id) >= 3"}, {"db_id": "car_1", "gold": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 41, "hardness": "extra", "reasoning": "<1> Operation: The query requires the model of the car with 4 cylinders that has the largest horsepower, so we should apply the 'max' operation to the 'Horsepower' column in the 'cars_data' table. Since the unit to which the horsepower being compared in the query belong is the car model, we do not need to apply any grouping or sorting operations. We also need to filter the cars with 4 cylinders in the 'cars_data' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connections between table 'cars_data', 'car_names', and 'model_list', we need to use tables ['cars_data', 'car_names', 'model_list'].\n\n<3> SQL Generation: The query requires the model of the car with 4 cylinders that has the largest horsepower, so we should select the 'Model' column in the 'model_list' table and the 'Horsepower' column in the 'cars_data' table.\n\n", "predict": "SELECT Model FROM model_list WHERE ModelId = (SELECT Model FROM car_names WHERE MakeId = (SELECT Id FROM cars_data WHERE Cylinders = 4 ORDER BY Horsepower DESC LIMIT 1))"}, {"db_id": "car_1", "gold": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 42, "hardness": "extra", "reasoning": "<1> Operation: The query requires the model of the 4 cylinder car with the most horsepower, so we should apply the 'max' operation to the 'Horsepower' column in the 'cars_data' table for the rows where 'Cylinders' equals 4. Since the unit to which the horsepower being compared in the query belong is the model, we do not need to apply any grouping or sorting operations.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'cars_data' and 'car_names', we need to use tables ['cars_data', 'car_names'].\n\n<3> SQL Generation: The query requires the model of the 4 cylinder car with the most horsepower, so we should select the 'Model' column in the 'car_names' table.\n\n", "predict": "SELECT Model FROM car_names WHERE MakeId = (SELECT Id FROM cars_data WHERE Cylinders = 4 ORDER BY Horsepower DESC LIMIT 1)"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1", "question": "Which cities do more than one employee under age 30 come from?", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "number": 58, "hardness": "medium", "reasoning": "<1> Operation: The query requires the cities from which more than one employee under age 30 come, so we should apply the 'count' operation to the 'City' column in the 'employee' table, and find the cities with a count greater than 1. We also need to filter the employees under age 30.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['employee'].\n\n<3> SQL Generation: The query requires the cities from which more than one employee under age 30 come, so we should select the 'City' column in the 'employee' table. We also need to filter the employees under age 30.\n\n", "predict": "SELECT City FROM employee WHERE Age < 30 GROUP BY City HAVING COUNT(*) > 1"}, {"db_id": "employee_hire_evaluation", "gold": "SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1", "question": "Find the cities that have more than one employee under age 30.", "foreign_keys": "Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]\n", "tables": "Table employee, columns = [*,Employee_ID,Name,Age,City]\nTable evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]\nTable hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]\nTable shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]\n", "types": {"employee.Employee_ID": "number", "employee.Name": "text", "employee.Age": "number", "employee.City": "text", "shop.Shop_ID": "number", "shop.Name": "text", "shop.Location": "text", "shop.District": "text", "shop.Number_products": "number", "shop.Manager_name": "text", "hiring.Shop_ID": "number", "hiring.Employee_ID": "number", "hiring.Start_from": "text", "hiring.Is_full_time": "others", "evaluation.Employee_ID": "text", "evaluation.Year_awarded": "text", "evaluation.Bonus": "number"}, "number": 59, "hardness": "medium", "reasoning": "<1> Operation: The query requires the cities that have more than one employee under age 30, so we should apply the 'count' operation to the 'Employee_ID' column in the 'employee' table, and find the cities with a count greater than 1. Since the unit to which the employees being counted in the query belong is the city, we should apply the 'group by' operation to the 'City' column in the 'employee' table. We also need to filter the employees under age 30.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['employee'].\n\n<3> SQL Generation: The query requires the cities that have more than one employee under age 30, so we should select the 'City' column in the 'employee' table. We also need to filter the employees under age 30.\n\n", "predict": "SELECT City FROM employee WHERE Age < 30 GROUP BY City HAVING COUNT(*) > 1"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  \"Asia\" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1", "question": "What is the language that is used by the largest number of Asian nations?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 181, "hardness": "extra", "reasoning": "<1> Operation: The query requires the language that is used by the largest number of Asian nations, so we should apply the 'count' operation to the 'CountryCode' column in the 'countrylanguage' table and find the language with the highest count. Since the unit to which the countries being counted in the query belong is the language, we should apply the 'group by' operation to the 'Language' column in the 'countrylanguage' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Due to the direct foreign key connection between table 'countrylanguage' and 'country', we need to use tables ['countrylanguage', 'country'].\n\n<3> SQL Generation: The query requires the language that is used by the largest number of Asian nations, so we should select the 'Language' column in the 'countrylanguage' table.\n\n", "predict": "SELECT Language FROM countrylanguage WHERE CountryCode IN (SELECT Code FROM country WHERE Continent = 'Asia') GROUP BY Language ORDER BY COUNT(*) DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District", "question": "Find the number of cities in each district whose population is greater than the average population of cities?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 184, "hardness": "extra", "reasoning": "<1> Operation: The query requires the number of cities in each district whose population is greater than the average population of cities. So we should apply the 'count' operation to the 'ID' column in the 'city' table, and filter the cities whose 'Population' is greater than the average population of cities. Since the unit to which the cities being counted in the query belong is the district, we should apply the 'group by' operation to the 'District' column in the 'city' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['city'].\n\n<3> SQL Generation: The query requires the number of cities in each district whose population is greater than the average population of cities, so we should select the 'District' column in the 'city' table and count the 'ID' column in the 'city' table.\n\n", "predict": "SELECT District, COUNT(ID) FROM city WHERE Population > (SELECT AVG(Population) FROM city) GROUP BY District"}, {"db_id": "world_1", "gold": "SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District", "question": "How many cities in each district have a population that is above the average population across all cities?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 185, "hardness": "extra", "reasoning": "<1> Operation: The query requires the number of cities in each district that have a population above the average population across all cities. This involves two operations: first, we need to calculate the average population across all cities, and then we need to count the number of cities in each district that have a population above this average. Since the unit to which the cities being counted in the query belong is the district, we should apply the 'group by' operation to the 'District' column in the 'city' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['city'].\n\n<3> SQL Generation: The query requires the number of cities in each district that have a population above the average population across all cities, so we should select the 'District' column in the 'city' table and count the 'ID' column in the 'city' table where the 'Population' column in the 'city' table is greater than the average population across all cities.\n\n", "predict": "SELECT District, COUNT(ID) FROM city WHERE Population > (SELECT AVG(Population) FROM city) GROUP BY District"}, {"db_id": "world_1", "gold": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode", "question": "What is the total number of countries where Spanish is spoken by the largest percentage of people?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 192, "hardness": "extra", "reasoning": "<1> Operation: The query requires the total number of countries where Spanish is spoken by the largest percentage of people, so we should apply the 'max' operation to the 'Percentage' column in the 'countrylanguage' table and filter the 'Language' column in the 'countrylanguage' table to be 'Spanish'. Since the unit to which the percentage being calculated in the query belongs is the country, we should apply the 'group by' operation to the 'CountryCode' column in the 'countrylanguage' table.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['countrylanguage'].\n\n<3> SQL Generation: The query requires the total number of countries where Spanish is spoken by the largest percentage of people, so we should select the 'CountryCode' column in the 'countrylanguage' table and count the number of unique 'CountryCode'.\n\n", "predict": "SELECT COUNT(*) FROM (SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' GROUP BY CountryCode HAVING Percentage = MAX(Percentage))"}, {"db_id": "world_1", "gold": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 193, "hardness": "medium", "reasoning": "<1> Operation: The query requires the codes of countries where Spanish is spoken by the largest percentage of people, so we should apply the 'max' operation to the 'Percentage' column in the 'countrylanguage' table, and find the country code with the highest percentage. Since the unit to which the percentage being calculated in the query belongs is the country code, we should apply the 'group by' operation to the 'CountryCode' column in the 'countrylanguage' table. Also, we need to filter out the rows where the 'Language' column in the 'countrylanguage' table is not 'Spanish'.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we only need to use table ['countrylanguage'].\n\n<3> SQL Generation: The query requires the codes of countries where Spanish is spoken by the largest percentage of people, so we should select the 'CountryCode' column in the 'countrylanguage' table. We also need to filter out the rows where the 'Language' column in the 'countrylanguage' table is not 'Spanish'.\n\n", "predict": "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' GROUP BY CountryCode ORDER BY MAX(Percentage) DESC"}, {"db_id": "network_1", "gold": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2", "question": "What are the names of high schoolers who have a grade of over 5 and have 2 or more friends?", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "number": 228, "hardness": "hard", "reasoning": "<1> Operation: The query requires the names of high schoolers who have a grade of over 5 and have 2 or more friends. So we should apply the 'count' operation to the 'Friend' table for the 'student_id' column, and filter the count to be greater than or equal to 2. We also need to filter the 'Highschooler' table for the 'grade' column to be greater than 5.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In this question, we need to use tables ['Friend', 'Highschooler'].\n\n<3> SQL Generation: The query requires the names of high schoolers who have a grade of over 5 and have 2 or more friends, so we should select the 'name' column in the 'Highschooler' table. We also need to filter the 'grade' column to be greater than 5 and the count of 'student_id' in the 'Friend' table to be greater than or equal to 2.\n\n", "predict": "SELECT name FROM Highschooler WHERE grade > 5 AND ID IN (SELECT student_id FROM Friend GROUP BY student_id HAVING COUNT(*) >= 2)"}]