[{"db_id": "concert_singer", "gold": "SELECT T2.name ,  T2.capacity FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  >=  2014 GROUP BY T2.stadium_id ORDER BY count(*) DESC LIMIT 1", "question": "Show the stadium name and capacity with most number of concerts in year 2014 or after.", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "number": 9, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to filter concerts that happened in year 2014 or after. Secondly, we need to count the number of concerts for each stadium. Lastly, we need to find the stadium with the most number of concerts and display its name and capacity.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select concert_ID from table 'concert' where Year >= 2014. In the second step, we need to count the number of concerts for each stadium from table 'concert' and join it with table 'stadium' to get the stadium name and capacity.\n\n<3> SQL Generation: Use 'where' to filter concerts that happened in year 2014 or after, and then use 'group by' to count the number of concerts for each stadium. Use 'order by' and 'limit' to find the stadium with the most number of concerts.\n\n", "predict": "SELECT T2.name, T2.capacity FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id = T2.stadium_id WHERE T1.year >= 2014 GROUP BY T2.stadium_id ORDER BY COUNT(*) DESC LIMIT 1"}, {"db_id": "concert_singer", "gold": "select t2.name ,  t2.capacity from concert as t1 join stadium as t2 on t1.stadium_id  =  t2.stadium_id where t1.year  >  2013 group by t2.stadium_id order by count(*) desc limit 1", "question": "What is the name and capacity of the stadium with the most concerts after 2013 ?", "foreign_keys": "Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]\n", "tables": "Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]\nTable singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]\nTable singer_in_concert, columns = [*,concert_ID,Singer_ID]\nTable stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]\n", "types": {"stadium.Stadium_ID": "number", "stadium.Location": "text", "stadium.Name": "text", "stadium.Capacity": "number", "stadium.Highest": "number", "stadium.Lowest": "number", "stadium.Average": "number", "singer.Singer_ID": "number", "singer.Name": "text", "singer.Country": "text", "singer.Song_Name": "text", "singer.Song_release_year": "text", "singer.Age": "number", "singer.Is_male": "others", "concert.concert_ID": "number", "concert.concert_Name": "text", "concert.Theme": "text", "concert.Stadium_ID": "text", "concert.Year": "text", "singer_in_concert.concert_ID": "number", "singer_in_concert.Singer_ID": "text"}, "number": 10, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to find the concerts after 2013. Secondly, we need to count the number of concerts for each stadium. Finally, we need to find the stadium with the most concerts and retrieve its name and capacity.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select concert_ID from table 'concert' where Year > 2013. In the second step, we need to count the number of concerts for each Stadium_ID from table 'concert'. In the final step, we need to select the name and capacity from table 'stadium' based on the Stadium_ID with the most concerts.\n\n<3> SQL Generation: Use 'where' to find the concerts after 2013, and then use 'group by' and 'order by' to count the number of concerts for each stadium and find the stadium with the most concerts. Finally, use 'select' to retrieve the name and capacity of that stadium.\n\n", "predict": "SELECT T1.Name ,  T1.Capacity FROM stadium AS T1 JOIN (SELECT Stadium_ID FROM concert WHERE Year > 2013 GROUP BY Stadium_ID ORDER BY COUNT(*) DESC LIMIT 1) AS T2 ON T1.Stadium_ID  =  T2.Stadium_ID"}, {"db_id": "car_1", "gold": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 55, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to find the car models with 3 cylinders. Secondly, we need to calculate the maximum horsepower of these car models. Finally, we need to retrieve the make of these car models.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'cars_data' where Cylinders = 3. In the second step, we need to select the maximum Horsepower from table 'cars_data' where Id is from the first step. In the final step, we need to select Make from table 'car_names' where MakeId is from the first step.\n\n<3> SQL Generation: Use 'where' to find the car models with 3 cylinders, and then use 'where' to filter the horsepower of these car models and calculate the maximum value. Finally, use 'where' to filter the make of these car models.\n\n", "predict": "SELECT max(T1.Horsepower) ,  T2.Make FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Cylinders  =  3"}, {"db_id": "car_1", "gold": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "question": "What is the largest amount of horsepower for the models with 3 cylinders and what make is it?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 56, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to find the models with 3 cylinders. Secondly, we need to identify the model with the largest amount of horsepower among these models. Finally, we need to retrieve the make of this model and the largest amount of horsepower.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'cars_data' where Cylinders = 3. In the second step, we need to filter the models with 3 cylinders and retrieve the Id with the maximum Horsepower. In the final step, we need to select the Make from table 'car_names' and the maximum Horsepower from table 'cars_data' based on the Id obtained in the second step.\n\n<3> SQL Generation: Use 'where' to find the models with 3 cylinders, and then use 'order by' and 'limit' to find the model with the largest amount of horsepower. Finally, use 'select' to retrieve the make of this model and the largest amount of horsepower.\n\n", "predict": "SELECT T1.Make ,  MAX(T2.Horsepower) FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  3 ORDER BY T2.Horsepower DESC LIMIT 1"}, {"db_id": "car_1", "gold": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "question": "For model volvo, how many cylinders does the car with the least accelerate have?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 68, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to find the car with the model \"volvo\". Secondly, we need to find the car with the least accelerate among these cars. Lastly, we need to find the number of cylinders this car has.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Id from table 'model_list' where Model = \"volvo\". In the second step, we need to select Id from table 'cars_data' where Accelerate is the minimum and Id is in the list of Ids obtained in the first step. In the last step, we need to select Cylinders from table 'cars_data' where Id is the one obtained in the second step.\n\n<3> SQL Generation: Use 'where' to find the car with the model \"volvo\", and then use 'where' and 'min' to find the car with the least accelerate, and finally use 'where' to find the number of cylinders this car has.\n\n", "predict": "SELECT T1.cylinders FROM cars_data AS T1 JOIN car_names AS T2 ON T1.id = T2.makeid JOIN model_list AS T3 ON T2.model = T3.model WHERE T3.model = \"volvo\" AND T1.accelerate = (SELECT min(accelerate) FROM cars_data AS T4 JOIN car_names AS T5 ON T4.id = T5.makeid JOIN model_list AS T6 ON T5.model = T6.model WHERE T6.model = \"volvo\")"}, {"db_id": "car_1", "gold": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 69, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to find the Volvo model. Secondly, we need to find the version with the least accelerate. Lastly, we need to find the number of cylinders that version has.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select ModelId from table 'model_list' where Maker = 'Volvo'. In the second step, we need to select Id from table 'car_names' where Model = ModelId obtained in the first step. Then, we need to select the row with the minimum Accelerate from table 'cars_data' where Id = Id obtained in the second step. In the last step, we need to select Cylinders from the row obtained in the second step.\n\n<3> SQL Generation: Use 'where' to find the Volvo model, and then use 'where' to find the version with the least accelerate, and then select the number of cylinders that version has.\n\n", "predict": "SELECT T3.Cylinders FROM model_list AS T1 JOIN car_names AS T2 ON T1.ModelId = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T1.Maker = 'Volvo' ORDER BY T3.Accelerate ASC LIMIT 1"}, {"db_id": "car_1", "gold": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "question": "How many cars have a larger accelerate than the car with the largest horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 70, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to find the car with the largest horsepower. Secondly, we need to find the accelerate of that car. Finally, we need to count the number of cars with a larger accelerate than that.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we need to compare the 'accelerate' and 'horsepower' columns of the 'cars_data' table, we only need the 'cars_data' table.\n\n<3> SQL Generation: Use 'max' to find the car with the largest horsepower, and then use 'where' to filter cars with a larger accelerate.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Accelerate > (SELECT Accelerate FROM cars_data WHERE Horsepower = (SELECT max(Horsepower) FROM cars_data))"}, {"db_id": "car_1", "gold": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "foreign_keys": "Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]\n", "tables": "Table car_makers, columns = [*,Id,Maker,FullName,Country]\nTable car_names, columns = [*,MakeId,Model,Make]\nTable cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]\nTable continents, columns = [*,ContId,Continent]\nTable countries, columns = [*,CountryId,CountryName,Continent]\nTable model_list, columns = [*,ModelId,Maker,Model]\n", "types": {"continents.ContId": "number", "continents.Continent": "text", "countries.CountryId": "number", "countries.CountryName": "text", "countries.Continent": "number", "car_makers.Id": "number", "car_makers.Maker": "text", "car_makers.FullName": "text", "car_makers.Country": "text", "model_list.ModelId": "number", "model_list.Maker": "number", "model_list.Model": "text", "car_names.MakeId": "number", "car_names.Model": "text", "car_names.Make": "text", "cars_data.Id": "number", "cars_data.MPG": "text", "cars_data.Cylinders": "number", "cars_data.Edispl": "number", "cars_data.Horsepower": "text", "cars_data.Weight": "number", "cars_data.Accelerate": "number", "cars_data.Year": "number"}, "number": 71, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to find the car with the most horsepower. Secondly, we need to count the number of cars with an accelerate greater than the one of the car with the most horsepower.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select the maximum horsepower from the 'cars_data' table. In the second step, we need to count the number of cars from the 'cars_data' table where the accelerate is greater than the one of the car with the most horsepower.\n\n<3> SQL Generation: Use 'max' to find the car with the most horsepower, and then use 'count' to count the number of cars with an accelerate greater than the one of the car with the most horsepower.\n\n", "predict": "SELECT count(*) FROM cars_data WHERE Accelerate > (SELECT max(Horsepower) FROM cars_data)"}, {"db_id": "museum_visit", "gold": "SELECT name FROM visitor WHERE Level_of_membership  >  4 ORDER BY Level_of_membership DESC", "question": "Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low.", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "number": 179, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to filter visitors whose membership level is higher than 4. Secondly, we need to select their names. Lastly, we need to order the results by the level from high to low.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Name, Level_of_membership from table 'visitor' where Level_of_membership is higher than 4.\n\n<3> SQL Generation: Use 'where' to filter visitors whose membership level is higher than 4, and then select their names. Finally, use 'order by' to sort the results by the level from high to low.\n\n", "predict": "SELECT Name FROM visitor WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC"}, {"db_id": "museum_visit", "gold": "SELECT name ,  Level_of_membership FROM visitor WHERE Level_of_membership  >  4 ORDER BY age DESC", "question": "Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young.", "foreign_keys": "Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]\n", "tables": "Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]\nTable visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]\nTable visitor, columns = [*,ID,Name,Level_of_membership,Age]\n", "types": {"museum.Museum_ID": "number", "museum.Name": "text", "museum.Num_of_Staff": "number", "museum.Open_Year": "text", "visitor.ID": "number", "visitor.Name": "text", "visitor.Level_of_membership": "number", "visitor.Age": "number", "visit.Museum_ID": "number", "visit.visitor_ID": "text", "visit.Num_of_Ticket": "number", "visit.Total_spent": "number"}, "number": 181, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to filter visitors whose membership level is higher than 4. Secondly, we need to select their name and membership level. Finally, we need to sort the result by age from old to young.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select name, level_of_membership, and age from table 'visitor' where level_of_membership is higher than 4.\n\n<3> SQL Generation: Use 'where' to filter visitors whose membership level is higher than 4, and then select their name and membership level. Finally, use 'order by' to sort the result by age from old to young.\n\n", "predict": "SELECT name ,  level_of_membership FROM visitor WHERE level_of_membership > 4 ORDER BY age DESC;"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "question": "List the first and last name of all players who are left / L hand in the order of birth date.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "number": 193, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to filter players based on their hand. Secondly, we need to select the first name and last name of the filtered players. Lastly, we need to order the result by birth date.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select first_name, last_name, and birth_date from table 'players' and filter by hand.\n\n<3> SQL Generation: Use 'where' to filter players based on their hand, and then select their first name and last name. Finally, use 'order by' to sort the result by birth date.\n\n", "predict": "SELECT first_name , last_name FROM players WHERE hand = 'L' ORDER BY birth_date;"}, {"db_id": "wta_1", "gold": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "question": "What are the full names of all left handed players, in order of birth date?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "number": 194, "hardness": "medium", "reasoning": "<1> Decomposition: Firstly, we need to filter players who are left-handed. Secondly, we need to retrieve the full names of these players. Lastly, we need to order the results by birth date.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select first_name, last_name, and birth_date from the 'players' table where hand = 'left'.\n\n<3> SQL Generation: Use 'where' to filter left-handed players, and then use 'concat' to combine first_name and last_name into full names. Lastly, use 'order by' to sort the results by birth date.\n\n", "predict": "SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM players WHERE hand = 'left' ORDER BY birth_date"}, {"db_id": "wta_1", "gold": "SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1", "question": "Find the name of the winner who has the highest rank points and participated in the Australian Open tourney.", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "number": 195, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to filter the matches where the tourney_name is \"Australian Open\". Secondly, we need to find the winner_id from these matches. Thirdly, we need to find the player with the highest rank points among these winners. Lastly, we need to retrieve the name of this player.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select winner_id from table 'matches' where tourney_name = \"Australian Open\". In the second step, we need to select player_id and ranking_points from table 'rankings' where player_id is in the winner_ids from the first step. In the third step, we need to find the player_id with the highest ranking_points. In the last step, we need to select first_name and last_name from table 'players' where player_id is the one found in the third step.\n\n<3> SQL Generation: Use 'where' to filter matches where the tourney_name is \"Australian Open\" and select the winner_id. Then, use 'where' to filter players in table 'rankings' where player_id is in the winner_ids from the first step and select the player_id with the highest ranking_points. Lastly, select the first_name and last_name of the player with the highest ranking_points.\n\n", "predict": "SELECT T1.first_name ,  T1.last_name FROM players AS T1 WHERE T1.player_id  =  (SELECT T2.player_id FROM rankings AS T2 WHERE T2.player_id IN (SELECT T3.winner_id FROM matches AS T3 WHERE T3.tourney_name  =  'Australian Open') ORDER BY T2.ranking_points DESC LIMIT 1)"}, {"db_id": "wta_1", "gold": "SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1", "question": "What is the name of the winner with the most rank points who participated in the Australian Open tournament?", "foreign_keys": "Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]\n", "tables": "Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]\nTable players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]\nTable rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]\n", "types": {"players.player_id": "number", "players.first_name": "text", "players.last_name": "text", "players.hand": "text", "players.birth_date": "time", "players.country_code": "text", "matches.best_of": "number", "matches.draw_size": "number", "matches.loser_age": "number", "matches.loser_entry": "text", "matches.loser_hand": "text", "matches.loser_ht": "number", "matches.loser_id": "number", "matches.loser_ioc": "text", "matches.loser_name": "text", "matches.loser_rank": "number", "matches.loser_rank_points": "number", "matches.loser_seed": "number", "matches.match_num": "number", "matches.minutes": "number", "matches.round": "text", "matches.score": "text", "matches.surface": "text", "matches.tourney_date": "time", "matches.tourney_id": "text", "matches.tourney_level": "text", "matches.tourney_name": "text", "matches.winner_age": "number", "matches.winner_entry": "text", "matches.winner_hand": "text", "matches.winner_ht": "number", "matches.winner_id": "number", "matches.winner_ioc": "text", "matches.winner_name": "text", "matches.winner_rank": "number", "matches.winner_rank_points": "number", "matches.winner_seed": "number", "matches.year": "number", "rankings.ranking_date": "time", "rankings.ranking": "number", "rankings.player_id": "number", "rankings.ranking_points": "number", "rankings.tours": "number"}, "number": 196, "hardness": "hard", "reasoning": "<1> Decomposition: We need to find the winner with the most rank points who participated in the Australian Open tournament. \n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select the winner_name from the matches table, the ranking_points from the rankings table, and filter by the tourney_name from the matches table.\n\n<3> SQL Generation: We can use the MAX function to find the maximum ranking points and then select the winner_name of the player with that score who participated in the Australian Open tournament.\n\n", "predict": "SELECT winner_name FROM matches JOIN rankings ON matches.winner_id = rankings.player_id WHERE tourney_name = 'Australian Open' ORDER BY ranking_points DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1", "question": "Which language is the most popular in Aruba?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 285, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to find the country code corresponding to 'Aruba' from the 'country' table. Secondly, we need to find the language with the highest percentage in the 'countrylanguage' table corresponding to that country code.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select 'Code' from the 'country' table where 'Name' = 'Aruba', and then select 'Language' from the 'countrylanguage' table where 'CountryCode' = 'Code' and 'Percentage' is the highest.\n\n<3> SQL Generation: Use 'where' to find the country code corresponding to 'Aruba', and then use 'where' and 'order by' to find the language with the highest percentage corresponding to that country code.\n\n", "predict": "SELECT Language FROM countrylanguage WHERE CountryCode = (SELECT Code FROM country WHERE Name = 'Aruba') ORDER BY Percentage DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  \"Aruba\" ORDER BY Percentage DESC LIMIT 1", "question": "What language is predominantly spoken in Aruba?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 286, "hardness": "extra", "reasoning": "<1> Decomposition: The query requires finding the language predominantly spoken in Aruba. Firstly, we need to identify the country code for Aruba. Secondly, we need to find the language that is predominantly spoken in Aruba.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Code from table 'country' where Name = 'Aruba'. In the second step, we need to select Language from table 'countrylanguage' and filter by CountryCode.\n\n<3> SQL Generation: Use 'where' to filter the country named 'Aruba' and select its country code. Then, use this country code to filter the languages spoken in Aruba and select the language with the highest percentage.\n\n", "predict": "SELECT Language FROM countrylanguage WHERE CountryCode = (SELECT Code FROM country WHERE Name = \"Aruba\") ORDER BY Percentage DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy LIMIT 1", "question": "What is the name of country that has the shortest life expectancy in Asia?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 293, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to find the country with the shortest life expectancy in the 'country' table where the continent is 'Asia'. Secondly, we need to retrieve the name of that country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select 'Name' and 'LifeExpectancy' from the 'country' table where 'Continent' is 'Asia'.\n\n<3> SQL Generation: Use 'where' to filter countries in Asia, and then use 'order by' and 'limit' to find the country with the shortest life expectancy. Finally, select the name of that country.\n\n", "predict": "SELECT Name FROM country WHERE Continent = 'Asia' ORDER BY LifeExpectancy ASC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy LIMIT 1", "question": "Give the name of the country in Asia with the lowest life expectancy.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 294, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to filter countries in the continent of Asia. Secondly, we need to find the country with the lowest life expectancy among these countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need the name of the country and the life expectancy, we only need the 'country' table.\n\n<3> SQL Generation: Use 'where' to filter countries in the continent of Asia, and then use 'order by' and 'limit' to find the country with the lowest life expectancy.\n\n", "predict": "SELECT Name FROM country WHERE Continent  =  \"Asia\" ORDER BY LifeExpectancy ASC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  \"Asia\" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1", "question": "Which language is the most popular on the Asian continent?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 312, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to filter countries that are in the Asian continent. Secondly, we need to find the language that has the highest percentage among the filtered countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Code from table 'country' where Continent = 'Asia'. In the second step, we need to select Language from table 'countrylanguage' and filter by CountryCode, then order by Percentage in descending order.\n\n<3> SQL Generation: Use 'where' to filter countries that are in the Asian continent, and then use 'where' to filter languages by CountryCode. Finally, use 'order by' and 'desc' to select the language with the highest percentage.\n\n", "predict": "SELECT Language FROM countrylanguage WHERE CountryCode IN (SELECT Code FROM country WHERE Continent = 'Asia') ORDER BY Percentage DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  \"Republic\" GROUP BY T2.Language HAVING COUNT(*)  =  1", "question": "Which languages are spoken by only one country in republic governments?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 313, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to filter countries with republic governments. Secondly, we need to find the languages spoken by these countries. Finally, we need to filter out the languages that are spoken by only one country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Code from table 'country' where GovernmentForm = 'Republic'. In the second step, we need to join table 'countrylanguage' on the 'CountryCode' column, and then select Language. In the final step, we need to filter out the languages that are spoken by only one country.\n\n<3> SQL Generation: Use 'where' to filter countries with republic governments, join 'countrylanguage' table on the corresponding column, select Language, and then filter out the languages that are spoken by only one country.\n\n", "predict": "SELECT T1.Language FROM countrylanguage AS T1 JOIN country AS T2 ON T1.CountryCode  =  T2.Code WHERE T2.GovernmentForm  =  'Republic' GROUP BY T1.Language HAVING COUNT(DISTINCT T1.CountryCode) = 1"}, {"db_id": "world_1", "gold": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  \"Republic\" GROUP BY T2.Language HAVING COUNT(*)  =  1", "question": "What languages are only used by a single country with a republic government?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 314, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to filter countries based on their government form being a republic. Secondly, we need to select the languages used by these countries. Lastly, we need to filter these languages based on their usage by only a single country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select Language from table 'countrylanguage' for the filtered countries and then filter these languages based on their usage by only a single country.\n\n<3> SQL Generation: Use 'where' to filter countries with a republic government, and then select Language from table 'countrylanguage' for the filtered countries. Lastly, filter these languages based on their usage by only a single country.\n\n", "predict": "SELECT T1.Language FROM countrylanguage AS T1 JOIN country AS T2 ON T1.CountryCode = T2.Code WHERE T2.GovernmentForm = 'Republic' GROUP BY T1.Language HAVING COUNT(DISTINCT T1.CountryCode) = 1"}, {"db_id": "world_1", "gold": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  \"English\" ORDER BY T1.Population DESC LIMIT 1", "question": "Find the city with the largest population that uses English.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 315, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to find the countries that use English. Secondly, we need to find the cities in these countries. Finally, we need to find the city with the largest population among these cities.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. In the first step, we need to select Code from table 'countrylanguage' where Language = \"English\". In the second step, we need to select Name from table 'city' where CountryCode matches the Code found in the first step. In the final step, we need to select the city with the largest population.\n\n<3> SQL Generation: Use 'where' to find the Code of the countries that use English, and then use 'where' to find the cities in these countries. Finally, use 'order by' and 'limit' to find the city with the largest population.\n\n", "predict": "SELECT t1.Name FROM city AS t1 JOIN countrylanguage AS t2 ON t1.CountryCode  =  t2.CountryCode WHERE t2.Language  =  \"English\" ORDER BY t1.Population DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  \"English\" ORDER BY T1.Population DESC LIMIT 1", "question": "What is the most populace city that speaks English?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 316, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to filter cities where English is spoken. Secondly, we need to find the city with the highest population among the filtered cities.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select 'Name' from the 'city' table, filter by 'Language' from the 'countrylanguage' table, and order by 'Population' from the 'city' table.\n\n<3> SQL Generation: Use 'where' to filter cities where English is spoken, and then use 'order by' and 'desc' to select the city with the highest population. Finally, select the name of that city.\n\n", "predict": "SELECT city.Name FROM city JOIN countrylanguage ON city.CountryCode = countrylanguage.CountryCode WHERE countrylanguage.Language = 'English' ORDER BY city.Population DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  \"Asia\" ORDER BY SurfaceArea DESC LIMIT 1", "question": "What are the name, population, and life expectancy of the largest Asian country by land?", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 317, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to filter countries based on their continent being \"Asia\". Secondly, we need to find the country with the largest surface area. Finally, we need to select the name, population, and life expectancy for the selected country.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since we only need information from the 'country' table, we only need to consider that table.\n\n<3> SQL Generation: Use 'where' to filter countries based on their continent being \"Asia\", and then use 'order by' and 'limit' to find the country with the largest surface area. Finally, select the name, population, and life expectancy for the selected country.\n\n", "predict": "SELECT name ,  population ,  lifeexpectancy FROM country WHERE continent = 'Asia' ORDER BY surfacearea DESC LIMIT 1"}, {"db_id": "world_1", "gold": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode", "question": "Count the number of countries for which Spanish is the predominantly spoken language.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 348, "hardness": "extra", "reasoning": "<1> Decomposition: Firstly, we need to filter countries where Spanish is the predominantly spoken language. Secondly, we need to count the number of countries that meet this condition.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select CountryCode from table 'countrylanguage' where Language = \"Spanish\" and IsOfficial = \"T\". Then, we need to count the number of unique CountryCode in the 'country' table.\n\n<3> SQL Generation: Use 'where' to filter countries where Spanish is the predominantly spoken language in the table 'countrylanguage'. Then, use 'count' to calculate the number of unique CountryCode in the 'country' table.\n\n", "predict": "SELECT COUNT(DISTINCT Code) FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' AND IsOfficial = 'T')"}, {"db_id": "world_1", "gold": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  \"Spanish\" GROUP BY CountryCode", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "foreign_keys": "Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]\n", "tables": "Table city, columns = [*,ID,Name,CountryCode,District,Population]\nTable country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]\nTable countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]\nTable sqlite_sequence, columns = [*,name,seq]\n", "types": {"city.ID": "number", "city.Name": "text", "city.CountryCode": "text", "city.District": "text", "city.Population": "number", "sqlite_sequence.name": "text", "sqlite_sequence.seq": "text", "country.Code": "text", "country.Name": "text", "country.Continent": "text", "country.Region": "text", "country.SurfaceArea": "number", "country.IndepYear": "number", "country.Population": "number", "country.LifeExpectancy": "number", "country.GNP": "number", "country.GNPOld": "number", "country.LocalName": "text", "country.GovernmentForm": "text", "country.HeadOfState": "text", "country.Capital": "number", "country.Code2": "text", "countrylanguage.CountryCode": "text", "countrylanguage.Language": "text", "countrylanguage.IsOfficial": "text", "countrylanguage.Percentage": "number"}, "number": 349, "hardness": "medium", "reasoning": "<1> Decomposition: The query requires filtering on column 'Language', so we should apply the 'where' to column 'Language' and then return the codes of selected countries.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. Since table 'countrylanguage' has columns 'Language' and 'CountryCode', we only need table 'countrylanguage'.\n\n<3> SQL Generation: Directly write the sql using 'where'.\n\n", "predict": "SELECT CountryCode FROM countrylanguage WHERE Language =  'Spanish'"}, {"db_id": "network_1", "gold": "SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2", "question": "Show the names of students who have a grade higher than 5 and have at least 2 friends.", "foreign_keys": "Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]\n", "tables": "Table Friend, columns = [*,student_id,friend_id]\nTable Highschooler, columns = [*,ID,name,grade]\nTable Likes, columns = [*,student_id,liked_id]\n", "types": {"Highschooler.ID": "number", "Highschooler.name": "text", "Highschooler.grade": "number", "Friend.student_id": "number", "Friend.friend_id": "number", "Likes.student_id": "number", "Likes.liked_id": "number"}, "number": 370, "hardness": "hard", "reasoning": "<1> Decomposition: Firstly, we need to filter students based on their grade. Secondly, we need to count the number of friends each student has and filter based on this count.\n\n<2> Schema Linking: In this step, we identify the tables and columns that should be used based on the first step and the foreign key relationships. We need to select name from table 'Highschooler' and filter based on grade. We also need to count the number of friends from table 'Friend'.\n\n<3> SQL Generation: Use 'where' to filter students based on their grade, and then use 'having' to filter students who have at least 2 friends.\n\n", "predict": "SELECT T1.name FROM Highschooler AS T1 JOIN Friend AS T2 ON T1.ID = T2.student_id WHERE T1.grade > 5 GROUP BY T1.name HAVING COUNT(T2.friend_id) >= 2"}]